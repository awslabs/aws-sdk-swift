// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension CORSRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedHeaders = "AllowedHeader"
        case allowedMethods = "AllowedMethod"
        case allowedOrigins = "AllowedOrigin"
        case exposeHeaders = "ExposeHeader"
        case maxAgeSeconds = "MaxAgeSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: Key("xmlns"))
        }
        if let allowedHeaders = allowedHeaders {
            if allowedHeaders.isEmpty {
                var allowedHeadersContainer = container.nestedUnkeyedContainer(forKey: Key("AllowedHeader"))
                try allowedHeadersContainer.encodeNil()
            } else {
                for allowedheader0 in allowedHeaders {
                    var allowedHeadersContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("AllowedHeader"))
                    try allowedHeadersContainer0.encode(allowedheader0, forKey: Key(""))
                }
            }
        }
        if let allowedMethods = allowedMethods {
            if allowedMethods.isEmpty {
                var allowedMethodsContainer = container.nestedUnkeyedContainer(forKey: Key("AllowedMethod"))
                try allowedMethodsContainer.encodeNil()
            } else {
                for allowedmethod0 in allowedMethods {
                    var allowedMethodsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("AllowedMethod"))
                    try allowedMethodsContainer0.encode(allowedmethod0, forKey: Key(""))
                }
            }
        }
        if let allowedOrigins = allowedOrigins {
            if allowedOrigins.isEmpty {
                var allowedOriginsContainer = container.nestedUnkeyedContainer(forKey: Key("AllowedOrigin"))
                try allowedOriginsContainer.encodeNil()
            } else {
                for allowedorigin0 in allowedOrigins {
                    var allowedOriginsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("AllowedOrigin"))
                    try allowedOriginsContainer0.encode(allowedorigin0, forKey: Key(""))
                }
            }
        }
        if let exposeHeaders = exposeHeaders {
            if exposeHeaders.isEmpty {
                var exposeHeadersContainer = container.nestedUnkeyedContainer(forKey: Key("ExposeHeader"))
                try exposeHeadersContainer.encodeNil()
            } else {
                for exposeheader0 in exposeHeaders {
                    var exposeHeadersContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExposeHeader"))
                    try exposeHeadersContainer0.encode(exposeheader0, forKey: Key(""))
                }
            }
        }
        if maxAgeSeconds != 0 {
            try container.encode(maxAgeSeconds, forKey: Key("maxAgeSeconds"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.allowedHeaders) {
            let allowedHeadersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .allowedHeaders)
            if allowedHeadersWrappedContainer != nil {
                let allowedHeadersContainer = try containerValues.decodeIfPresent([String].self, forKey: .allowedHeaders)
                var allowedHeadersBuffer:[String]? = nil
                if let allowedHeadersContainer = allowedHeadersContainer {
                    allowedHeadersBuffer = [String]()
                    for stringContainer0 in allowedHeadersContainer {
                        allowedHeadersBuffer?.append(stringContainer0)
                    }
                }
                allowedHeaders = allowedHeadersBuffer
            } else {
                allowedHeaders = []
            }
        } else {
            allowedHeaders = nil
        }
        if containerValues.contains(.allowedMethods) {
            let allowedMethodsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .allowedMethods)
            if allowedMethodsWrappedContainer != nil {
                let allowedMethodsContainer = try containerValues.decodeIfPresent([String].self, forKey: .allowedMethods)
                var allowedMethodsBuffer:[String]? = nil
                if let allowedMethodsContainer = allowedMethodsContainer {
                    allowedMethodsBuffer = [String]()
                    for stringContainer0 in allowedMethodsContainer {
                        allowedMethodsBuffer?.append(stringContainer0)
                    }
                }
                allowedMethods = allowedMethodsBuffer
            } else {
                allowedMethods = []
            }
        } else {
            allowedMethods = nil
        }
        if containerValues.contains(.allowedOrigins) {
            let allowedOriginsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .allowedOrigins)
            if allowedOriginsWrappedContainer != nil {
                let allowedOriginsContainer = try containerValues.decodeIfPresent([String].self, forKey: .allowedOrigins)
                var allowedOriginsBuffer:[String]? = nil
                if let allowedOriginsContainer = allowedOriginsContainer {
                    allowedOriginsBuffer = [String]()
                    for stringContainer0 in allowedOriginsContainer {
                        allowedOriginsBuffer?.append(stringContainer0)
                    }
                }
                allowedOrigins = allowedOriginsBuffer
            } else {
                allowedOrigins = []
            }
        } else {
            allowedOrigins = nil
        }
        if containerValues.contains(.exposeHeaders) {
            let exposeHeadersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .exposeHeaders)
            if exposeHeadersWrappedContainer != nil {
                let exposeHeadersContainer = try containerValues.decodeIfPresent([String].self, forKey: .exposeHeaders)
                var exposeHeadersBuffer:[String]? = nil
                if let exposeHeadersContainer = exposeHeadersContainer {
                    exposeHeadersBuffer = [String]()
                    for stringContainer0 in exposeHeadersContainer {
                        exposeHeadersBuffer?.append(stringContainer0)
                    }
                }
                exposeHeaders = exposeHeadersBuffer
            } else {
                exposeHeaders = []
            }
        } else {
            exposeHeaders = nil
        }
        let maxAgeSecondsDecoded = try containerValues.decode(Int.self, forKey: .maxAgeSeconds)
        maxAgeSeconds = maxAgeSecondsDecoded
    }
}
