// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

public struct CreateMultipartUploadInput: Equatable {
    /**
     <p>The canned ACL to apply to the object.</p>
              <p>This action is not supported by Amazon S3 on Outposts.</p>
     */
    public let aCL: ObjectCannedACL?
    /**
     <p>The name of the bucket to which to initiate the upload</p>
              <p>When using this API with an access point, you must direct requests to the access point hostname. The access point hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.s3-accesspoint.<i>Region</i>.amazonaws.com. When using this operation with an access point through the AWS SDKs, you provide the access point ARN in place of the bucket name. For more information about access point ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/using-access-points.html">Using Access Points</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
              <p>When using this API with Amazon S3 on Outposts, you must direct requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the form <i>AccessPointName</i>-<i>AccountId</i>.<i>outpostID</i>.s3-outposts.<i>Region</i>.amazonaws.com. When using this operation using S3 on Outposts through the AWS SDKs, you provide the Outposts bucket ARN in place of the bucket name. For more information about S3 on Outposts ARNs, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/S3onOutposts.html">Using S3 on Outposts</a> in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
     */
    public let bucket: String?
    /**
     <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code> causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS.</p>
              <p>Specifying this header with an object operation doesnâ€™t affect bucket-level settings for S3 Bucket Key.</p>
     */
    public let bucketKeyEnabled: Bool
    /// <p>Specifies caching behavior along the request/reply chain.</p>
    public let cacheControl: String?
    /// <p>Specifies presentational information for the object.</p>
    public let contentDisposition: String?
    /**
     <p>Specifies what content encodings have been applied to the object and thus what decoding
              mechanisms must be applied to obtain the media-type referenced by the Content-Type header
              field.</p>
     */
    public let contentEncoding: String?
    /// <p>The language the content is in.</p>
    public let contentLanguage: String?
    /// <p>A standard MIME type describing the format of the object data.</p>
    public let contentType: String?
    /// <p>The account id of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP <code>403 (Access Denied)</code> error.</p>
    public let expectedBucketOwner: String?
    /// <p>The date and time at which the object is no longer cacheable.</p>
    public let expires: Date?
    /**
     <p>Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the
           object.</p>
              <p>This action is not supported by Amazon S3 on Outposts.</p>
     */
    public let grantFullControl: String?
    /**
     <p>Allows grantee to read the object data and its
           metadata.</p>
              <p>This action is not supported by Amazon S3 on Outposts.</p>
     */
    public let grantRead: String?
    /**
     <p>Allows grantee to read the object ACL.</p>
              <p>This action is not supported by Amazon S3 on Outposts.</p>
     */
    public let grantReadACP: String?
    /**
     <p>Allows grantee to write the ACL for the applicable
           object.</p>
              <p>This action is not supported by Amazon S3 on Outposts.</p>
     */
    public let grantWriteACP: String?
    /// <p>Object key for which the multipart upload is to be initiated.</p>
    public let key: String?
    /// <p>A map of metadata to store with the object in S3.</p>
    public let metadata: [String:String]?
    /// <p>Specifies whether you want to apply a Legal Hold to the uploaded object.</p>
    public let objectLockLegalHoldStatus: ObjectLockLegalHoldStatus?
    /// <p>Specifies the Object Lock mode that you want to apply to the uploaded object.</p>
    public let objectLockMode: ObjectLockMode?
    /// <p>Specifies the date and time when you want the Object Lock to expire.</p>
    public let objectLockRetainUntilDate: Date?
    /**
     <p>Confirms that the requester knows that they will be charged for the request. Bucket
              owners need not specify this parameter in their requests. For information about downloading
              objects from requester pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in
                 Requestor Pays Buckets</a> in the <i>Amazon S3 Developer Guide</i>.</p>
     */
    public let requestPayer: RequestPayer?
    /**
     <p>Specifies the algorithm to use to when encrypting the object (for example,
              AES256).</p>
     */
    public let sSECustomerAlgorithm: String?
    /**
     <p>Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This
              value is used to store the object and then it is discarded; Amazon S3 does not store the
              encryption key. The key must be appropriate for use with the algorithm specified in the
                 <code>x-amz-server-side-encryption-customer-algorithm</code> header.</p>
     */
    public let sSECustomerKey: String?
    /**
     <p>Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses
              this header for a message integrity check to ensure that the encryption key was transmitted
              without error.</p>
     */
    public let sSECustomerKeyMD5: String?
    /**
     <p>Specifies the AWS KMS Encryption Context to use for object encryption. The value of this
              header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value
              pairs.</p>
     */
    public let sSEKMSEncryptionContext: String?
    /**
     <p>Specifies the ID of the symmetric customer managed AWS KMS CMK to use for object
              encryption. All GET and PUT requests for an object protected by AWS KMS will fail if not
              made via SSL or using SigV4. For information about configuring using any of the officially
              supported AWS SDKs and AWS CLI, see <a href="https://docs.aws.amazon.com/http:/docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version">Specifying the Signature Version in Request Authentication</a>
              in the <i>Amazon S3 Developer Guide</i>.</p>
     */
    public let sSEKMSKeyId: String?
    /**
     <p>The server-side encryption algorithm used when storing this object in Amazon S3 (for example,
              AES256, aws:kms).</p>
     */
    public let serverSideEncryption: ServerSideEncryption?
    /**
     <p>By default, Amazon S3 uses the STANDARD Storage Class to store newly created objects. The
              STANDARD storage class provides high durability and high availability. Depending on
              performance needs, you can specify a different Storage Class. Amazon S3 on Outposts only uses
              the OUTPOSTS Storage Class. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html">Storage Classes</a> in the <i>Amazon S3
                 Service Developer Guide</i>.</p>
     */
    public let storageClass: StorageClass?
    /// <p>The tag-set for the object. The tag-set must be encoded as URL Query parameters.</p>
    public let tagging: String?
    /**
     <p>If the bucket is configured as a website, redirects requests for this object to another
              object in the same bucket or to an external URL. Amazon S3 stores the value of this header in
              the object metadata.</p>
     */
    public let websiteRedirectLocation: String?

    public init (
        aCL: ObjectCannedACL? = nil,
        bucket: String? = nil,
        bucketKeyEnabled: Bool = false,
        cacheControl: String? = nil,
        contentDisposition: String? = nil,
        contentEncoding: String? = nil,
        contentLanguage: String? = nil,
        contentType: String? = nil,
        expectedBucketOwner: String? = nil,
        expires: Date? = nil,
        grantFullControl: String? = nil,
        grantRead: String? = nil,
        grantReadACP: String? = nil,
        grantWriteACP: String? = nil,
        key: String? = nil,
        metadata: [String:String]? = nil,
        objectLockLegalHoldStatus: ObjectLockLegalHoldStatus? = nil,
        objectLockMode: ObjectLockMode? = nil,
        objectLockRetainUntilDate: Date? = nil,
        requestPayer: RequestPayer? = nil,
        sSECustomerAlgorithm: String? = nil,
        sSECustomerKey: String? = nil,
        sSECustomerKeyMD5: String? = nil,
        sSEKMSEncryptionContext: String? = nil,
        sSEKMSKeyId: String? = nil,
        serverSideEncryption: ServerSideEncryption? = nil,
        storageClass: StorageClass? = nil,
        tagging: String? = nil,
        websiteRedirectLocation: String? = nil
    )
    {
        self.aCL = aCL
        self.bucket = bucket
        self.bucketKeyEnabled = bucketKeyEnabled
        self.cacheControl = cacheControl
        self.contentDisposition = contentDisposition
        self.contentEncoding = contentEncoding
        self.contentLanguage = contentLanguage
        self.contentType = contentType
        self.expectedBucketOwner = expectedBucketOwner
        self.expires = expires
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWriteACP = grantWriteACP
        self.key = key
        self.metadata = metadata
        self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
        self.objectLockMode = objectLockMode
        self.objectLockRetainUntilDate = objectLockRetainUntilDate
        self.requestPayer = requestPayer
        self.sSECustomerAlgorithm = sSECustomerAlgorithm
        self.sSECustomerKey = sSECustomerKey
        self.sSECustomerKeyMD5 = sSECustomerKeyMD5
        self.sSEKMSEncryptionContext = sSEKMSEncryptionContext
        self.sSEKMSKeyId = sSEKMSKeyId
        self.serverSideEncryption = serverSideEncryption
        self.storageClass = storageClass
        self.tagging = tagging
        self.websiteRedirectLocation = websiteRedirectLocation
    }
}
