// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Attribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Attribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Attribute(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>This data type is used in the <a>ImageScanFinding</a> data type.</p>
public struct Attribute: Equatable {
    /// <p>The attribute key.</p>
    public let key: String?
    /// <p>The value assigned to the attribute key.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension AuthorizationData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizationToken
        case expiresAt
        case proxyEndpoint
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationToken = authorizationToken {
            try encodeContainer.encode(authorizationToken, forKey: .authorizationToken)
        }
        if let expiresAt = expiresAt {
            try encodeContainer.encode(expiresAt.timeIntervalSince1970, forKey: .expiresAt)
        }
        if let proxyEndpoint = proxyEndpoint {
            try encodeContainer.encode(proxyEndpoint, forKey: .proxyEndpoint)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationToken)
        authorizationToken = authorizationTokenDecoded
        let expiresAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expiresAt)
        expiresAt = expiresAtDecoded
        let proxyEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .proxyEndpoint)
        proxyEndpoint = proxyEndpointDecoded
    }
}

extension AuthorizationData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizationData(authorizationToken: \(String(describing: authorizationToken)), expiresAt: \(String(describing: expiresAt)), proxyEndpoint: \(String(describing: proxyEndpoint)))"}
}

/// <p>An object representing authorization data for an Amazon ECR registry.</p>
public struct AuthorizationData: Equatable {
    /// <p>A base64-encoded string that contains authorization data for the specified Amazon ECR
    ///             registry. When the string is decoded, it is presented in the format
    ///                 <code>user:password</code> for private registry authentication using <code>docker
    ///                 login</code>.</p>
    public let authorizationToken: String?
    /// <p>The Unix time in seconds and milliseconds when the authorization token expires.
    ///             Authorization tokens are valid for 12 hours.</p>
    public let expiresAt: Date?
    /// <p>The registry URL to use for this authorization token in a <code>docker login</code>
    ///             command. The Amazon ECR registry URL format is
    ///         <code>https://aws_account_id.dkr.ecr.region.amazonaws.com</code>. For example,
    ///         <code>https://012345678910.dkr.ecr.us-east-1.amazonaws.com</code>.. </p>
    public let proxyEndpoint: String?

    public init (
        authorizationToken: String? = nil,
        expiresAt: Date? = nil,
        proxyEndpoint: String? = nil
    )
    {
        self.authorizationToken = authorizationToken
        self.expiresAt = expiresAt
        self.proxyEndpoint = proxyEndpoint
    }
}

public struct BatchCheckLayerAvailabilityInputBodyMiddleware: Middleware {
    public let id: String = "BatchCheckLayerAvailabilityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCheckLayerAvailabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCheckLayerAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCheckLayerAvailabilityInput>
    public typealias MOutput = OperationOutput<BatchCheckLayerAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCheckLayerAvailabilityOutputError>
}

extension BatchCheckLayerAvailabilityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCheckLayerAvailabilityInput(layerDigests: \(String(describing: layerDigests)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension BatchCheckLayerAvailabilityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case layerDigests
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerDigests = layerDigests {
            var layerDigestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerDigests)
            for batchedoperationlayerdigestlist0 in layerDigests {
                try layerDigestsContainer.encode(batchedoperationlayerdigestlist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct BatchCheckLayerAvailabilityInputHeadersMiddleware: Middleware {
    public let id: String = "BatchCheckLayerAvailabilityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCheckLayerAvailabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCheckLayerAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCheckLayerAvailabilityInput>
    public typealias MOutput = OperationOutput<BatchCheckLayerAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCheckLayerAvailabilityOutputError>
}

public struct BatchCheckLayerAvailabilityInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchCheckLayerAvailabilityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCheckLayerAvailabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCheckLayerAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCheckLayerAvailabilityInput>
    public typealias MOutput = OperationOutput<BatchCheckLayerAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCheckLayerAvailabilityOutputError>
}

public struct BatchCheckLayerAvailabilityInput: Equatable {
    /// <p>The digests of the image layers to check.</p>
    public let layerDigests: [String]?
    /// <p>The AWS account ID associated with the registry that contains the image layers to
    ///             check. If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository that is associated with the image layers to check.</p>
    public let repositoryName: String?

    public init (
        layerDigests: [String]? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.layerDigests = layerDigests
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct BatchCheckLayerAvailabilityInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let layerDigests: [String]?
}

extension BatchCheckLayerAvailabilityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layerDigests
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let layerDigestsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .layerDigests)
        var layerDigestsDecoded0:[String]? = nil
        if let layerDigestsContainer = layerDigestsContainer {
            layerDigestsDecoded0 = [String]()
            for string0 in layerDigestsContainer {
                if let string0 = string0 {
                    layerDigestsDecoded0?.append(string0)
                }
            }
        }
        layerDigests = layerDigestsDecoded0
    }
}

extension BatchCheckLayerAvailabilityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCheckLayerAvailabilityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchCheckLayerAvailabilityOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCheckLayerAvailabilityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCheckLayerAvailabilityOutputResponse(failures: \(String(describing: failures)), layers: \(String(describing: layers)))"}
}

extension BatchCheckLayerAvailabilityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchCheckLayerAvailabilityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failures = output.failures
            self.layers = output.layers
        } else {
            self.failures = nil
            self.layers = nil
        }
    }
}

public struct BatchCheckLayerAvailabilityOutputResponse: Equatable {
    /// <p>Any failures associated with the call.</p>
    public let failures: [LayerFailure]?
    /// <p>A list of image layer objects corresponding to the image layer references in the
    ///             request.</p>
    public let layers: [Layer]?

    public init (
        failures: [LayerFailure]? = nil,
        layers: [Layer]? = nil
    )
    {
        self.failures = failures
        self.layers = layers
    }
}

struct BatchCheckLayerAvailabilityOutputResponseBody: Equatable {
    public let layers: [Layer]?
    public let failures: [LayerFailure]?
}

extension BatchCheckLayerAvailabilityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failures
        case layers
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layersContainer = try containerValues.decodeIfPresent([Layer?].self, forKey: .layers)
        var layersDecoded0:[Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let failuresContainer = try containerValues.decodeIfPresent([LayerFailure?].self, forKey: .failures)
        var failuresDecoded0:[LayerFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [LayerFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

public struct BatchDeleteImageInputBodyMiddleware: Middleware {
    public let id: String = "BatchDeleteImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteImageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteImageInput>
    public typealias MOutput = OperationOutput<BatchDeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteImageOutputError>
}

extension BatchDeleteImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteImageInput(imageIds: \(String(describing: imageIds)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension BatchDeleteImageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageIds
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifierlist0 in imageIds {
                try imageIdsContainer.encode(imageidentifierlist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct BatchDeleteImageInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDeleteImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteImageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteImageInput>
    public typealias MOutput = OperationOutput<BatchDeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteImageOutputError>
}

public struct BatchDeleteImageInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDeleteImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteImageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteImageInput>
    public typealias MOutput = OperationOutput<BatchDeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteImageOutputError>
}

/// <p>Deletes specified images within a specified repository. Images are specified with
///             either the <code>imageTag</code> or <code>imageDigest</code>.</p>
public struct BatchDeleteImageInput: Equatable {
    /// <p>A list of image ID references that correspond to images to delete. The format of the
    ///                 <code>imageIds</code> reference is <code>imageTag=tag</code> or
    ///                 <code>imageDigest=digest</code>.</p>
    public let imageIds: [ImageIdentifier]?
    /// <p>The AWS account ID associated with the registry that contains the image to delete.
    ///             If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The repository that contains the image to delete.</p>
    public let repositoryName: String?

    public init (
        imageIds: [ImageIdentifier]? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.imageIds = imageIds
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct BatchDeleteImageInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let imageIds: [ImageIdentifier]?
}

extension BatchDeleteImageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageIds
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
    }
}

extension BatchDeleteImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteImageOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteImageOutputResponse(failures: \(String(describing: failures)), imageIds: \(String(describing: imageIds)))"}
}

extension BatchDeleteImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDeleteImageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failures = output.failures
            self.imageIds = output.imageIds
        } else {
            self.failures = nil
            self.imageIds = nil
        }
    }
}

public struct BatchDeleteImageOutputResponse: Equatable {
    /// <p>Any failures associated with the call.</p>
    public let failures: [ImageFailure]?
    /// <p>The image IDs of the deleted images.</p>
    public let imageIds: [ImageIdentifier]?

    public init (
        failures: [ImageFailure]? = nil,
        imageIds: [ImageIdentifier]? = nil
    )
    {
        self.failures = failures
        self.imageIds = imageIds
    }
}

struct BatchDeleteImageOutputResponseBody: Equatable {
    public let imageIds: [ImageIdentifier]?
    public let failures: [ImageFailure]?
}

extension BatchDeleteImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failures
        case imageIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdsContainer = try containerValues.decodeIfPresent([ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let failuresContainer = try containerValues.decodeIfPresent([ImageFailure?].self, forKey: .failures)
        var failuresDecoded0:[ImageFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [ImageFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

public struct BatchGetImageInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetImageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetImageInput>
    public typealias MOutput = OperationOutput<BatchGetImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetImageOutputError>
}

extension BatchGetImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetImageInput(acceptedMediaTypes: \(String(describing: acceptedMediaTypes)), imageIds: \(String(describing: imageIds)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension BatchGetImageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptedMediaTypes
        case imageIds
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptedMediaTypes = acceptedMediaTypes {
            var acceptedMediaTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceptedMediaTypes)
            for mediatypelist0 in acceptedMediaTypes {
                try acceptedMediaTypesContainer.encode(mediatypelist0)
            }
        }
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifierlist0 in imageIds {
                try imageIdsContainer.encode(imageidentifierlist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct BatchGetImageInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetImageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetImageInput>
    public typealias MOutput = OperationOutput<BatchGetImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetImageOutputError>
}

public struct BatchGetImageInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetImageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetImageInput>
    public typealias MOutput = OperationOutput<BatchGetImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetImageOutputError>
}

public struct BatchGetImageInput: Equatable {
    /// <p>The accepted media types for the request.</p>
    ///         <p>Valid values: <code>application/vnd.docker.distribution.manifest.v1+json</code> |
    ///                 <code>application/vnd.docker.distribution.manifest.v2+json</code> |
    ///                 <code>application/vnd.oci.image.manifest.v1+json</code>
    ///          </p>
    public let acceptedMediaTypes: [String]?
    /// <p>A list of image ID references that correspond to images to describe. The format of the
    ///                 <code>imageIds</code> reference is <code>imageTag=tag</code> or
    ///                 <code>imageDigest=digest</code>.</p>
    public let imageIds: [ImageIdentifier]?
    /// <p>The AWS account ID associated with the registry that contains the images to describe.
    ///             If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The repository that contains the images to describe.</p>
    public let repositoryName: String?

    public init (
        acceptedMediaTypes: [String]? = nil,
        imageIds: [ImageIdentifier]? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.acceptedMediaTypes = acceptedMediaTypes
        self.imageIds = imageIds
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct BatchGetImageInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let imageIds: [ImageIdentifier]?
    public let acceptedMediaTypes: [String]?
}

extension BatchGetImageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptedMediaTypes
        case imageIds
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let acceptedMediaTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .acceptedMediaTypes)
        var acceptedMediaTypesDecoded0:[String]? = nil
        if let acceptedMediaTypesContainer = acceptedMediaTypesContainer {
            acceptedMediaTypesDecoded0 = [String]()
            for string0 in acceptedMediaTypesContainer {
                if let string0 = string0 {
                    acceptedMediaTypesDecoded0?.append(string0)
                }
            }
        }
        acceptedMediaTypes = acceptedMediaTypesDecoded0
    }
}

extension BatchGetImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetImageOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetImageOutputResponse(failures: \(String(describing: failures)), images: \(String(describing: images)))"}
}

extension BatchGetImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetImageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failures = output.failures
            self.images = output.images
        } else {
            self.failures = nil
            self.images = nil
        }
    }
}

public struct BatchGetImageOutputResponse: Equatable {
    /// <p>Any failures associated with the call.</p>
    public let failures: [ImageFailure]?
    /// <p>A list of image objects corresponding to the image references in the request.</p>
    public let images: [Image]?

    public init (
        failures: [ImageFailure]? = nil,
        images: [Image]? = nil
    )
    {
        self.failures = failures
        self.images = images
    }
}

struct BatchGetImageOutputResponseBody: Equatable {
    public let images: [Image]?
    public let failures: [ImageFailure]?
}

extension BatchGetImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failures
        case images
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagesContainer = try containerValues.decodeIfPresent([Image?].self, forKey: .images)
        var imagesDecoded0:[Image]? = nil
        if let imagesContainer = imagesContainer {
            imagesDecoded0 = [Image]()
            for structure0 in imagesContainer {
                if let structure0 = structure0 {
                    imagesDecoded0?.append(structure0)
                }
            }
        }
        images = imagesDecoded0
        let failuresContainer = try containerValues.decodeIfPresent([ImageFailure?].self, forKey: .failures)
        var failuresDecoded0:[ImageFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [ImageFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

public struct CompleteLayerUploadInputBodyMiddleware: Middleware {
    public let id: String = "CompleteLayerUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteLayerUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteLayerUploadInput>
    public typealias MOutput = OperationOutput<CompleteLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteLayerUploadOutputError>
}

extension CompleteLayerUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompleteLayerUploadInput(layerDigests: \(String(describing: layerDigests)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)), uploadId: \(String(describing: uploadId)))"}
}

extension CompleteLayerUploadInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case layerDigests
        case registryId
        case repositoryName
        case uploadId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerDigests = layerDigests {
            var layerDigestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerDigests)
            for layerdigestlist0 in layerDigests {
                try layerDigestsContainer.encode(layerdigestlist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let uploadId = uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

public struct CompleteLayerUploadInputHeadersMiddleware: Middleware {
    public let id: String = "CompleteLayerUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteLayerUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteLayerUploadInput>
    public typealias MOutput = OperationOutput<CompleteLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteLayerUploadOutputError>
}

public struct CompleteLayerUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "CompleteLayerUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteLayerUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteLayerUploadInput>
    public typealias MOutput = OperationOutput<CompleteLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteLayerUploadOutputError>
}

public struct CompleteLayerUploadInput: Equatable {
    /// <p>The <code>sha256</code> digest of the image layer.</p>
    public let layerDigests: [String]?
    /// <p>The AWS account ID associated with the registry to which to upload layers.
    ///             If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository to associate with the image layer.</p>
    public let repositoryName: String?
    /// <p>The upload ID from a previous <a>InitiateLayerUpload</a> operation to
    ///             associate with the image layer.</p>
    public let uploadId: String?

    public init (
        layerDigests: [String]? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil,
        uploadId: String? = nil
    )
    {
        self.layerDigests = layerDigests
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct CompleteLayerUploadInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let uploadId: String?
    public let layerDigests: [String]?
}

extension CompleteLayerUploadInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layerDigests
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let layerDigestsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .layerDigests)
        var layerDigestsDecoded0:[String]? = nil
        if let layerDigestsContainer = layerDigestsContainer {
            layerDigestsDecoded0 = [String]()
            for string0 in layerDigestsContainer {
                if let string0 = string0 {
                    layerDigestsDecoded0?.append(string0)
                }
            }
        }
        layerDigests = layerDigestsDecoded0
    }
}

extension CompleteLayerUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CompleteLayerUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EmptyUploadException" : self = .emptyUploadException(try EmptyUploadException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLayerException" : self = .invalidLayerException(try InvalidLayerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayerAlreadyExistsException" : self = .layerAlreadyExistsException(try LayerAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayerPartTooSmallException" : self = .layerPartTooSmallException(try LayerPartTooSmallException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UploadNotFoundException" : self = .uploadNotFoundException(try UploadNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CompleteLayerUploadOutputError: Equatable {
    case emptyUploadException(EmptyUploadException)
    case invalidLayerException(InvalidLayerException)
    case invalidParameterException(InvalidParameterException)
    case kmsException(KmsException)
    case layerAlreadyExistsException(LayerAlreadyExistsException)
    case layerPartTooSmallException(LayerPartTooSmallException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case uploadNotFoundException(UploadNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteLayerUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompleteLayerUploadOutputResponse(layerDigest: \(String(describing: layerDigest)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)), uploadId: \(String(describing: uploadId)))"}
}

extension CompleteLayerUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CompleteLayerUploadOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.layerDigest = output.layerDigest
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.layerDigest = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
    }
}

public struct CompleteLayerUploadOutputResponse: Equatable {
    /// <p>The <code>sha256</code> digest of the image layer.</p>
    public let layerDigest: String?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?
    /// <p>The upload ID associated with the layer.</p>
    public let uploadId: String?

    public init (
        layerDigest: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil,
        uploadId: String? = nil
    )
    {
        self.layerDigest = layerDigest
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct CompleteLayerUploadOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let uploadId: String?
    public let layerDigest: String?
}

extension CompleteLayerUploadOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layerDigest
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let layerDigestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
    }
}

public struct CreateRepositoryInputBodyMiddleware: Middleware {
    public let id: String = "CreateRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRepositoryOutputError>
}

extension CreateRepositoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRepositoryInput(encryptionConfiguration: \(String(describing: encryptionConfiguration)), imageScanningConfiguration: \(String(describing: imageScanningConfiguration)), imageTagMutability: \(String(describing: imageTagMutability)), repositoryName: \(String(describing: repositoryName)), tags: \(String(describing: tags)))"}
}

extension CreateRepositoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionConfiguration
        case imageScanningConfiguration
        case imageTagMutability
        case repositoryName
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let imageScanningConfiguration = imageScanningConfiguration {
            try encodeContainer.encode(imageScanningConfiguration, forKey: .imageScanningConfiguration)
        }
        if let imageTagMutability = imageTagMutability {
            try encodeContainer.encode(imageTagMutability.rawValue, forKey: .imageTagMutability)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateRepositoryInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInput: Equatable {
    /// <p>The encryption configuration for the repository. This determines how the contents of
    ///             your repository are encrypted at rest.</p>
    public let encryptionConfiguration: EncryptionConfiguration?
    /// <p>The image scanning configuration for the repository. This determines whether images
    ///             are scanned for known vulnerabilities after being pushed to the repository.</p>
    public let imageScanningConfiguration: ImageScanningConfiguration?
    /// <p>The tag mutability setting for the repository. If this parameter is omitted, the
    ///             default setting of <code>MUTABLE</code> will be used which will allow image tags to be
    ///             overwritten. If <code>IMMUTABLE</code> is specified, all image tags within the
    ///             repository will be immutable which will prevent them from being overwritten.</p>
    public let imageTagMutability: ImageTagMutability?
    /// <p>The name to use for the repository. The repository name may be specified on its own
    ///             (such as <code>nginx-web-app</code>) or it can be prepended with a namespace to group
    ///             the repository into a category (such as <code>project-a/nginx-web-app</code>).</p>
    public let repositoryName: String?
    /// <p>The metadata that you apply to the repository to help you categorize and organize
    ///             them. Each tag consists of a key and an optional value, both of which you define.
    ///             Tag keys can have a maximum character length of 128 characters, and tag values can have
    ///             a maximum length of 256 characters.</p>
    public let tags: [Tag]?

    public init (
        encryptionConfiguration: EncryptionConfiguration? = nil,
        imageScanningConfiguration: ImageScanningConfiguration? = nil,
        imageTagMutability: ImageTagMutability? = nil,
        repositoryName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.encryptionConfiguration = encryptionConfiguration
        self.imageScanningConfiguration = imageScanningConfiguration
        self.imageTagMutability = imageTagMutability
        self.repositoryName = repositoryName
        self.tags = tags
    }
}

struct CreateRepositoryInputBody: Equatable {
    public let repositoryName: String?
    public let tags: [Tag]?
    public let imageTagMutability: ImageTagMutability?
    public let imageScanningConfiguration: ImageScanningConfiguration?
    public let encryptionConfiguration: EncryptionConfiguration?
}

extension CreateRepositoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionConfiguration
        case imageScanningConfiguration
        case imageTagMutability
        case repositoryName
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let imageTagMutabilityDecoded = try containerValues.decodeIfPresent(ImageTagMutability.self, forKey: .imageTagMutability)
        imageTagMutability = imageTagMutabilityDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
    }
}

extension CreateRepositoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRepositoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryAlreadyExistsException" : self = .repositoryAlreadyExistsException(try RepositoryAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRepositoryOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case invalidTagParameterException(InvalidTagParameterException)
    case kmsException(KmsException)
    case limitExceededException(LimitExceededException)
    case repositoryAlreadyExistsException(RepositoryAlreadyExistsException)
    case serverException(ServerException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRepositoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRepositoryOutputResponse(repository: \(String(describing: repository)))"}
}

extension CreateRepositoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct CreateRepositoryOutputResponse: Equatable {
    /// <p>The repository that was created.</p>
    public let repository: Repository?

    public init (
        repository: Repository? = nil
    )
    {
        self.repository = repository
    }
}

struct CreateRepositoryOutputResponseBody: Equatable {
    public let repository: Repository?
}

extension CreateRepositoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repository
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(Repository.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

public struct DeleteLifecyclePolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLifecyclePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<DeleteLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLifecyclePolicyOutputError>
}

extension DeleteLifecyclePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLifecyclePolicyInput(registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension DeleteLifecyclePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DeleteLifecyclePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<DeleteLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLifecyclePolicyOutputError>
}

public struct DeleteLifecyclePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<DeleteLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLifecyclePolicyOutputError>
}

public struct DeleteLifecyclePolicyInput: Equatable {
    /// <p>The AWS account ID associated with the registry that contains the repository.
    ///             If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository.</p>
    public let repositoryName: String?

    public init (
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteLifecyclePolicyInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
}

extension DeleteLifecyclePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension DeleteLifecyclePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLifecyclePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LifecyclePolicyNotFoundException" : self = .lifecyclePolicyNotFoundException(try LifecyclePolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLifecyclePolicyOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case lifecyclePolicyNotFoundException(LifecyclePolicyNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLifecyclePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLifecyclePolicyOutputResponse(lastEvaluatedAt: \(String(describing: lastEvaluatedAt)), lifecyclePolicyText: \(String(describing: lifecyclePolicyText)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension DeleteLifecyclePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteLifecyclePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lastEvaluatedAt = output.lastEvaluatedAt
            self.lifecyclePolicyText = output.lifecyclePolicyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.lastEvaluatedAt = nil
            self.lifecyclePolicyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct DeleteLifecyclePolicyOutputResponse: Equatable {
    /// <p>The time stamp of the last time that the lifecycle policy was run.</p>
    public let lastEvaluatedAt: Date?
    /// <p>The JSON lifecycle policy text.</p>
    public let lifecyclePolicyText: String?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?

    public init (
        lastEvaluatedAt: Date? = nil,
        lifecyclePolicyText: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.lastEvaluatedAt = lastEvaluatedAt
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteLifecyclePolicyOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let lifecyclePolicyText: String?
    public let lastEvaluatedAt: Date?
}

extension DeleteLifecyclePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lastEvaluatedAt
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
        let lastEvaluatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastEvaluatedAt)
        lastEvaluatedAt = lastEvaluatedAtDecoded
    }
}

extension DeleteRegistryPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRegistryPolicyInput()"}
}

extension DeleteRegistryPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRegistryPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRegistryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegistryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegistryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegistryPolicyInput>
    public typealias MOutput = OperationOutput<DeleteRegistryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegistryPolicyOutputError>
}

public struct DeleteRegistryPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRegistryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegistryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegistryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegistryPolicyInput>
    public typealias MOutput = OperationOutput<DeleteRegistryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegistryPolicyOutputError>
}

public struct DeleteRegistryPolicyInput: Equatable {

    public init() {}
}

struct DeleteRegistryPolicyInputBody: Equatable {
}

extension DeleteRegistryPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRegistryPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRegistryPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryPolicyNotFoundException" : self = .registryPolicyNotFoundException(try RegistryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRegistryPolicyOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case registryPolicyNotFoundException(RegistryPolicyNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRegistryPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRegistryPolicyOutputResponse(policyText: \(String(describing: policyText)), registryId: \(String(describing: registryId)))"}
}

extension DeleteRegistryPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRegistryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyText = output.policyText
            self.registryId = output.registryId
        } else {
            self.policyText = nil
            self.registryId = nil
        }
    }
}

public struct DeleteRegistryPolicyOutputResponse: Equatable {
    /// <p>The contents of the registry permissions policy that was deleted.</p>
    public let policyText: String?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?

    public init (
        policyText: String? = nil,
        registryId: String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
    }
}

struct DeleteRegistryPolicyOutputResponseBody: Equatable {
    public let registryId: String?
    public let policyText: String?
}

extension DeleteRegistryPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyText
        case registryId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

public struct DeleteRepositoryInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryOutputError>
}

extension DeleteRepositoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRepositoryInput(force: \(String(describing: force)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension DeleteRepositoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case force
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DeleteRepositoryInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInput: Equatable {
    /// <p> If a repository contains images, forces the deletion.</p>
    public let force: Bool
    /// <p>The AWS account ID associated with the registry that contains the repository to
    ///             delete. If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository to delete.</p>
    public let repositoryName: String?

    public init (
        force: Bool = false,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.force = force
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let force: Bool
}

extension DeleteRepositoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case force
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let forceDecoded = try containerValues.decode(Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension DeleteRepositoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotEmptyException" : self = .repositoryNotEmptyException(try RepositoryNotEmptyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRepositoryOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case kmsException(KmsException)
    case repositoryNotEmptyException(RepositoryNotEmptyException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRepositoryOutputResponse(repository: \(String(describing: repository)))"}
}

extension DeleteRepositoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DeleteRepositoryOutputResponse: Equatable {
    /// <p>The repository that was deleted.</p>
    public let repository: Repository?

    public init (
        repository: Repository? = nil
    )
    {
        self.repository = repository
    }
}

struct DeleteRepositoryOutputResponseBody: Equatable {
    public let repository: Repository?
}

extension DeleteRepositoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repository
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(Repository.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

public struct DeleteRepositoryPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRepositoryPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryPolicyOutputError>
}

extension DeleteRepositoryPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRepositoryPolicyInput(registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension DeleteRepositoryPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DeleteRepositoryPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRepositoryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryPolicyOutputError>
}

public struct DeleteRepositoryPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRepositoryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryPolicyOutputError>
}

public struct DeleteRepositoryPolicyInput: Equatable {
    /// <p>The AWS account ID associated with the registry that contains the repository policy to
    ///             delete. If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository that is associated with the repository policy to
    ///             delete.</p>
    public let repositoryName: String?

    public init (
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryPolicyInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
}

extension DeleteRepositoryPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension DeleteRepositoryPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryPolicyNotFoundException" : self = .repositoryPolicyNotFoundException(try RepositoryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRepositoryPolicyOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case repositoryPolicyNotFoundException(RepositoryPolicyNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRepositoryPolicyOutputResponse(policyText: \(String(describing: policyText)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension DeleteRepositoryPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRepositoryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct DeleteRepositoryPolicyOutputResponse: Equatable {
    /// <p>The JSON repository policy that was deleted from the repository.</p>
    public let policyText: String?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?

    public init (
        policyText: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryPolicyOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let policyText: String?
}

extension DeleteRepositoryPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

public struct DescribeImageScanFindingsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeImageScanFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImageScanFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImageScanFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImageScanFindingsInput>
    public typealias MOutput = OperationOutput<DescribeImageScanFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImageScanFindingsOutputError>
}

extension DescribeImageScanFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImageScanFindingsInput(imageId: \(String(describing: imageId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension DescribeImageScanFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageId
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DescribeImageScanFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeImageScanFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImageScanFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImageScanFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImageScanFindingsInput>
    public typealias MOutput = OperationOutput<DescribeImageScanFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImageScanFindingsOutputError>
}

public struct DescribeImageScanFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeImageScanFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImageScanFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImageScanFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImageScanFindingsInput>
    public typealias MOutput = OperationOutput<DescribeImageScanFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImageScanFindingsOutputError>
}

public struct DescribeImageScanFindingsInput: Equatable {
    /// <p>An object with identifying information for an Amazon ECR image.</p>
    public let imageId: ImageIdentifier?
    /// <p>The maximum number of image scan results returned by
    ///                 <code>DescribeImageScanFindings</code> in paginated output. When this parameter is
    ///             used, <code>DescribeImageScanFindings</code> only returns <code>maxResults</code>
    ///             results in a single page along with a <code>nextToken</code> response element. The
    ///             remaining results of the initial request can be seen by sending another
    ///                 <code>DescribeImageScanFindings</code> request with the returned
    ///                 <code>nextToken</code> value. This value can be between 1 and 1000. If this
    ///             parameter is not used, then <code>DescribeImageScanFindings</code> returns up to 100
    ///             results and a <code>nextToken</code> value, if applicable.</p>
    public let maxResults: Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///                 <code>DescribeImageScanFindings</code> request where <code>maxResults</code> was
    ///             used and the results exceeded the value of that parameter. Pagination continues from the
    ///             end of the previous results that returned the <code>nextToken</code> value. This value
    ///             is null when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>The AWS account ID associated with the registry that contains the repository in
    ///             which to describe the image scan findings for. If you do not specify a registry, the
    ///             default registry is assumed.</p>
    public let registryId: String?
    /// <p>The repository for the image for which to describe the scan findings.</p>
    public let repositoryName: String?

    public init (
        imageId: ImageIdentifier? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.imageId = imageId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DescribeImageScanFindingsInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let imageId: ImageIdentifier?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeImageScanFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageId
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeImageScanFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImageScanFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ImageNotFoundException" : self = .imageNotFoundException(try ImageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ScanNotFoundException" : self = .scanNotFoundException(try ScanNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImageScanFindingsOutputError: Equatable {
    case imageNotFoundException(ImageNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case scanNotFoundException(ScanNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImageScanFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImageScanFindingsOutputResponse(imageId: \(String(describing: imageId)), imageScanFindings: \(String(describing: imageScanFindings)), imageScanStatus: \(String(describing: imageScanStatus)), nextToken: \(String(describing: nextToken)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension DescribeImageScanFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeImageScanFindingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageId = output.imageId
            self.imageScanFindings = output.imageScanFindings
            self.imageScanStatus = output.imageScanStatus
            self.nextToken = output.nextToken
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.imageId = nil
            self.imageScanFindings = nil
            self.imageScanStatus = nil
            self.nextToken = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct DescribeImageScanFindingsOutputResponse: Equatable {
    /// <p>An object with identifying information for an Amazon ECR image.</p>
    public let imageId: ImageIdentifier?
    /// <p>The information contained in the image scan findings.</p>
    public let imageScanFindings: ImageScanFindings?
    /// <p>The current state of the scan.</p>
    public let imageScanStatus: ImageScanStatus?
    /// <p>The <code>nextToken</code> value to include in a future
    ///                 <code>DescribeImageScanFindings</code> request. When the results of a
    ///                 <code>DescribeImageScanFindings</code> request exceed <code>maxResults</code>, this
    ///             value can be used to retrieve the next page of results. This value is null when there
    ///             are no more results to return.</p>
    public let nextToken: String?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?

    public init (
        imageId: ImageIdentifier? = nil,
        imageScanFindings: ImageScanFindings? = nil,
        imageScanStatus: ImageScanStatus? = nil,
        nextToken: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.imageId = imageId
        self.imageScanFindings = imageScanFindings
        self.imageScanStatus = imageScanStatus
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DescribeImageScanFindingsOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let imageId: ImageIdentifier?
    public let imageScanStatus: ImageScanStatus?
    public let imageScanFindings: ImageScanFindings?
    public let nextToken: String?
}

extension DescribeImageScanFindingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageId
        case imageScanFindings
        case imageScanStatus
        case nextToken
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imageScanStatusDecoded = try containerValues.decodeIfPresent(ImageScanStatus.self, forKey: .imageScanStatus)
        imageScanStatus = imageScanStatusDecoded
        let imageScanFindingsDecoded = try containerValues.decodeIfPresent(ImageScanFindings.self, forKey: .imageScanFindings)
        imageScanFindings = imageScanFindingsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImagesFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagStatus
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagStatus = tagStatus {
            try encodeContainer.encode(tagStatus.rawValue, forKey: .tagStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagStatusDecoded = try containerValues.decodeIfPresent(TagStatus.self, forKey: .tagStatus)
        tagStatus = tagStatusDecoded
    }
}

extension DescribeImagesFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImagesFilter(tagStatus: \(String(describing: tagStatus)))"}
}

/// <p>An object representing a filter on a <a>DescribeImages</a>
///             operation.</p>
public struct DescribeImagesFilter: Equatable {
    /// <p>The tag status with which to filter your <a>DescribeImages</a> results. You
    ///             can filter results based on whether they are <code>TAGGED</code> or
    ///                 <code>UNTAGGED</code>.</p>
    public let tagStatus: TagStatus?

    public init (
        tagStatus: TagStatus? = nil
    )
    {
        self.tagStatus = tagStatus
    }
}

public struct DescribeImagesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeImagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImagesOutputError>
}

extension DescribeImagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImagesInput(filter: \(String(describing: filter)), imageIds: \(String(describing: imageIds)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension DescribeImagesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifierlist0 in imageIds {
                try imageIdsContainer.encode(imageidentifierlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DescribeImagesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImagesOutputError>
}

public struct DescribeImagesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImagesOutputError>
}

public struct DescribeImagesInput: Equatable {
    /// <p>The filter key and value with which to filter your <code>DescribeImages</code>
    ///             results.</p>
    public let filter: DescribeImagesFilter?
    /// <p>The list of image IDs for the requested repository.</p>
    public let imageIds: [ImageIdentifier]?
    /// <p>The maximum number of repository results returned by <code>DescribeImages</code> in
    ///             paginated output. When this parameter is used, <code>DescribeImages</code> only returns
    ///                 <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///             response element. The remaining results of the initial request can be seen by sending
    ///             another <code>DescribeImages</code> request with the returned <code>nextToken</code>
    ///             value. This value can be between 1 and 1000. If this
    ///             parameter is not used, then <code>DescribeImages</code> returns up to
    ///             100 results and a <code>nextToken</code> value, if applicable. This
    ///             option cannot be used when you specify images with <code>imageIds</code>.</p>
    public let maxResults: Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///                 <code>DescribeImages</code> request where <code>maxResults</code> was used and the
    ///             results exceeded the value of that parameter. Pagination continues from the end of the
    ///             previous results that returned the <code>nextToken</code> value. This value is
    ///                 <code>null</code> when there are no more results to return. This option cannot be
    ///             used when you specify images with <code>imageIds</code>.</p>
    public let nextToken: String?
    /// <p>The AWS account ID associated with the registry that contains the repository in which
    ///             to describe images. If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The repository that contains the images to describe.</p>
    public let repositoryName: String?

    public init (
        filter: DescribeImagesFilter? = nil,
        imageIds: [ImageIdentifier]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.filter = filter
        self.imageIds = imageIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DescribeImagesInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let imageIds: [ImageIdentifier]?
    public let nextToken: String?
    public let maxResults: Int?
    public let filter: DescribeImagesFilter?
}

extension DescribeImagesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(DescribeImagesFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension DescribeImagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ImageNotFoundException" : self = .imageNotFoundException(try ImageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImagesOutputError: Equatable {
    case imageNotFoundException(ImageNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImagesOutputResponse(imageDetails: \(String(describing: imageDetails)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeImagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeImagesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageDetails = output.imageDetails
            self.nextToken = output.nextToken
        } else {
            self.imageDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImagesOutputResponse: Equatable {
    /// <p>A list of <a>ImageDetail</a> objects that contain data about the
    ///             image.</p>
    public let imageDetails: [ImageDetail]?
    /// <p>The <code>nextToken</code> value to include in a future <code>DescribeImages</code>
    ///             request. When the results of a <code>DescribeImages</code> request exceed
    ///                 <code>maxResults</code>, this value can be used to retrieve the next page of
    ///             results. This value is <code>null</code> when there are no more results to
    ///             return.</p>
    public let nextToken: String?

    public init (
        imageDetails: [ImageDetail]? = nil,
        nextToken: String? = nil
    )
    {
        self.imageDetails = imageDetails
        self.nextToken = nextToken
    }
}

struct DescribeImagesOutputResponseBody: Equatable {
    public let imageDetails: [ImageDetail]?
    public let nextToken: String?
}

extension DescribeImagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageDetails
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDetailsContainer = try containerValues.decodeIfPresent([ImageDetail?].self, forKey: .imageDetails)
        var imageDetailsDecoded0:[ImageDetail]? = nil
        if let imageDetailsContainer = imageDetailsContainer {
            imageDetailsDecoded0 = [ImageDetail]()
            for structure0 in imageDetailsContainer {
                if let structure0 = structure0 {
                    imageDetailsDecoded0?.append(structure0)
                }
            }
        }
        imageDetails = imageDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRegistryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRegistryInput()"}
}

extension DescribeRegistryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeRegistryInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRegistryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRegistryInput>
    public typealias MOutput = OperationOutput<DescribeRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRegistryOutputError>
}

public struct DescribeRegistryInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRegistryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRegistryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRegistryInput>
    public typealias MOutput = OperationOutput<DescribeRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRegistryOutputError>
}

public struct DescribeRegistryInput: Equatable {

    public init() {}
}

struct DescribeRegistryInputBody: Equatable {
}

extension DescribeRegistryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeRegistryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRegistryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRegistryOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRegistryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRegistryOutputResponse(registryId: \(String(describing: registryId)), replicationConfiguration: \(String(describing: replicationConfiguration)))"}
}

extension DescribeRegistryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRegistryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.registryId = output.registryId
            self.replicationConfiguration = output.replicationConfiguration
        } else {
            self.registryId = nil
            self.replicationConfiguration = nil
        }
    }
}

public struct DescribeRegistryOutputResponse: Equatable {
    /// <p>The ID of the registry.</p>
    public let registryId: String?
    /// <p>The replication configuration for the registry.</p>
    public let replicationConfiguration: ReplicationConfiguration?

    public init (
        registryId: String? = nil,
        replicationConfiguration: ReplicationConfiguration? = nil
    )
    {
        self.registryId = registryId
        self.replicationConfiguration = replicationConfiguration
    }
}

struct DescribeRegistryOutputResponseBody: Equatable {
    public let registryId: String?
    public let replicationConfiguration: ReplicationConfiguration?
}

extension DescribeRegistryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryId
        case replicationConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

public struct DescribeRepositoriesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRepositoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRepositoriesInput>
    public typealias MOutput = OperationOutput<DescribeRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRepositoriesOutputError>
}

extension DescribeRepositoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRepositoriesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), registryId: \(String(describing: registryId)), repositoryNames: \(String(describing: repositoryNames)))"}
}

extension DescribeRepositoriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryNames
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryNames = repositoryNames {
            var repositoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryNames)
            for repositorynamelist0 in repositoryNames {
                try repositoryNamesContainer.encode(repositorynamelist0)
            }
        }
    }
}

public struct DescribeRepositoriesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRepositoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRepositoriesInput>
    public typealias MOutput = OperationOutput<DescribeRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRepositoriesOutputError>
}

public struct DescribeRepositoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRepositoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRepositoriesInput>
    public typealias MOutput = OperationOutput<DescribeRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRepositoriesOutputError>
}

public struct DescribeRepositoriesInput: Equatable {
    /// <p>The maximum number of repository results returned by <code>DescribeRepositories</code>
    ///             in paginated output. When this parameter is used, <code>DescribeRepositories</code> only
    ///             returns <code>maxResults</code> results in a single page along with a
    ///                 <code>nextToken</code> response element. The remaining results of the initial
    ///             request can be seen by sending another <code>DescribeRepositories</code> request with
    ///             the returned <code>nextToken</code> value. This value can be between 1
    ///             and 1000. If this parameter is not used, then
    ///                 <code>DescribeRepositories</code> returns up to 100 results and a
    ///                 <code>nextToken</code> value, if applicable. This option cannot be used when you
    ///             specify repositories with <code>repositoryNames</code>.</p>
    public let maxResults: Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///                 <code>DescribeRepositories</code> request where <code>maxResults</code> was used and
    ///             the results exceeded the value of that parameter. Pagination continues from the end of
    ///             the previous results that returned the <code>nextToken</code> value. This value is
    ///                 <code>null</code> when there are no more results to return. This option cannot be
    ///             used when you specify repositories with <code>repositoryNames</code>.</p>
    ///         <note>
    ///             <p>This token should be treated as an opaque identifier that is only used to
    ///                 retrieve the next items in a list and not for other programmatic purposes.</p>
    ///         </note>
    public let nextToken: String?
    /// <p>The AWS account ID associated with the registry that contains the repositories to be
    ///             described. If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>A list of repositories to describe. If this parameter is omitted, then all
    ///             repositories in a registry are described.</p>
    public let repositoryNames: [String]?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        registryId: String? = nil,
        repositoryNames: [String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryNames = repositoryNames
    }
}

struct DescribeRepositoriesInputBody: Equatable {
    public let registryId: String?
    public let repositoryNames: [String]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeRepositoriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryNames
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRepositoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRepositoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRepositoriesOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRepositoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRepositoriesOutputResponse(nextToken: \(String(describing: nextToken)), repositories: \(String(describing: repositories)))"}
}

extension DescribeRepositoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

public struct DescribeRepositoriesOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> value to include in a future
    ///                 <code>DescribeRepositories</code> request. When the results of a
    ///                 <code>DescribeRepositories</code> request exceed <code>maxResults</code>, this value
    ///             can be used to retrieve the next page of results. This value is <code>null</code> when
    ///             there are no more results to return.</p>
    public let nextToken: String?
    /// <p>A list of repository objects corresponding to valid repositories.</p>
    public let repositories: [Repository]?

    public init (
        nextToken: String? = nil,
        repositories: [Repository]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct DescribeRepositoriesOutputResponseBody: Equatable {
    public let repositories: [Repository]?
    public let nextToken: String?
}

extension DescribeRepositoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case repositories
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([Repository?].self, forKey: .repositories)
        var repositoriesDecoded0:[Repository]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [Repository]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension EmptyUploadException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmptyUploadException(message: \(String(describing: message)))"}
}

extension EmptyUploadException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EmptyUploadExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified layer upload does not contain any layer parts.</p>
public struct EmptyUploadException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EmptyUploadExceptionBody: Equatable {
    public let message: String?
}

extension EmptyUploadExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EncryptionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionType
        case kmsKey
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let kmsKey = kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension EncryptionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionConfiguration(encryptionType: \(String(describing: encryptionType)), kmsKey: \(String(describing: kmsKey)))"}
}

/// <p>The encryption configuration for the repository. This determines how the contents of
///             your repository are encrypted at rest.</p>
///         <p>By default, when no encryption configuration is set or the <code>AES256</code>
///             encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption
///             keys which encrypts your data at rest using an AES-256 encryption algorithm. This does
///             not require any action on your part.</p>
///         <p>For more control over the encryption of the contents of your repository, you can use
///             server-side encryption with customer master keys (CMKs) stored in AWS Key Management Service (AWS KMS) to
///             encrypt your images. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html">Amazon ECR encryption at
///                 rest</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
public struct EncryptionConfiguration: Equatable {
    /// <p>The encryption type to use.</p>
    ///         <p>If you use the <code>KMS</code> encryption type, the contents of the repository will
    ///             be encrypted using server-side encryption with customer master keys (CMKs) stored in
    ///             AWS KMS. When you use AWS KMS to encrypt your data, you can either use the default AWS
    ///             managed CMK for Amazon ECR, or specify your own CMK, which you already created. For more
    ///             information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">Protecting Data Using Server-Side
    ///                 Encryption with CMKs Stored in AWS Key Management Service (SSE-KMS)</a> in the
    ///                 <i>Amazon Simple Storage Service Console Developer Guide.</i>.</p>
    ///         <p>If you use the <code>AES256</code> encryption type, Amazon ECR uses server-side encryption
    ///             with Amazon S3-managed encryption keys which encrypts the images in the repository using an
    ///             AES-256 encryption algorithm. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html">Protecting Data Using
    ///                 Server-Side Encryption with Amazon S3-Managed Encryption Keys (SSE-S3)</a> in
    ///             the <i>Amazon Simple Storage Service Console Developer Guide.</i>.</p>
    public let encryptionType: EncryptionType?
    /// <p>If you use the <code>KMS</code> encryption type, specify the CMK to use for
    ///             encryption. The alias, key ID, or full ARN of the CMK can be specified. The key must
    ///             exist in the same Region as the repository. If no key is specified, the default AWS
    ///             managed CMK for Amazon ECR will be used.</p>
    public let kmsKey: String?

    public init (
        encryptionType: EncryptionType? = nil,
        kmsKey: String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.kmsKey = kmsKey
    }
}

public enum EncryptionType {
    case aes256
    case kms
    case sdkUnknown(String)
}

extension EncryptionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionType] {
        return [
            .aes256,
            .kms,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aes256: return "AES256"
        case .kms: return "KMS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
    }
}

public enum FindingSeverity {
    case critical
    case high
    case informational
    case low
    case medium
    case undefined
    case sdkUnknown(String)
}

extension FindingSeverity : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FindingSeverity] {
        return [
            .critical,
            .high,
            .informational,
            .low,
            .medium,
            .undefined,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .critical: return "CRITICAL"
        case .high: return "HIGH"
        case .informational: return "INFORMATIONAL"
        case .low: return "LOW"
        case .medium: return "MEDIUM"
        case .undefined: return "UNDEFINED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FindingSeverity(rawValue: rawValue) ?? FindingSeverity.sdkUnknown(rawValue)
    }
}

public struct GetAuthorizationTokenInputBodyMiddleware: Middleware {
    public let id: String = "GetAuthorizationTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAuthorizationTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAuthorizationTokenInput>
    public typealias MOutput = OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAuthorizationTokenOutputError>
}

extension GetAuthorizationTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAuthorizationTokenInput(registryIds: \(String(describing: registryIds)))"}
}

extension GetAuthorizationTokenInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registryIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryIds = registryIds {
            var registryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .registryIds)
            for getauthorizationtokenregistryidlist0 in registryIds {
                try registryIdsContainer.encode(getauthorizationtokenregistryidlist0)
            }
        }
    }
}

public struct GetAuthorizationTokenInputHeadersMiddleware: Middleware {
    public let id: String = "GetAuthorizationTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAuthorizationTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAuthorizationTokenInput>
    public typealias MOutput = OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAuthorizationTokenOutputError>
}

public struct GetAuthorizationTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAuthorizationTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAuthorizationTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAuthorizationTokenInput>
    public typealias MOutput = OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAuthorizationTokenOutputError>
}

public struct GetAuthorizationTokenInput: Equatable {
    /// <p>A list of AWS account IDs that are associated with the registries for which to get
    ///             AuthorizationData objects. If you do not specify a registry, the default registry is assumed.</p>
    @available(*, deprecated, message: "This field is deprecated. The returned authorization token can be used to access any Amazon ECR registry that the IAM principal has access to, specifying a registry ID doesn't change the permissions scope of the authorization token.")
    public let registryIds: [String]?

    public init (
        registryIds: [String]? = nil
    )
    {
        self.registryIds = registryIds
    }
}

struct GetAuthorizationTokenInputBody: Equatable {
    public let registryIds: [String]?
}

extension GetAuthorizationTokenInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .registryIds)
        var registryIdsDecoded0:[String]? = nil
        if let registryIdsContainer = registryIdsContainer {
            registryIdsDecoded0 = [String]()
            for string0 in registryIdsContainer {
                if let string0 = string0 {
                    registryIdsDecoded0?.append(string0)
                }
            }
        }
        registryIds = registryIdsDecoded0
    }
}

extension GetAuthorizationTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthorizationTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAuthorizationTokenOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthorizationTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAuthorizationTokenOutputResponse(authorizationData: \(String(describing: authorizationData)))"}
}

extension GetAuthorizationTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAuthorizationTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorizationData = output.authorizationData
        } else {
            self.authorizationData = nil
        }
    }
}

public struct GetAuthorizationTokenOutputResponse: Equatable {
    /// <p>A list of authorization token data objects that correspond to the
    ///                 <code>registryIds</code> values in the request.</p>
    public let authorizationData: [AuthorizationData]?

    public init (
        authorizationData: [AuthorizationData]? = nil
    )
    {
        self.authorizationData = authorizationData
    }
}

struct GetAuthorizationTokenOutputResponseBody: Equatable {
    public let authorizationData: [AuthorizationData]?
}

extension GetAuthorizationTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizationData
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationDataContainer = try containerValues.decodeIfPresent([AuthorizationData?].self, forKey: .authorizationData)
        var authorizationDataDecoded0:[AuthorizationData]? = nil
        if let authorizationDataContainer = authorizationDataContainer {
            authorizationDataDecoded0 = [AuthorizationData]()
            for structure0 in authorizationDataContainer {
                if let structure0 = structure0 {
                    authorizationDataDecoded0?.append(structure0)
                }
            }
        }
        authorizationData = authorizationDataDecoded0
    }
}

public struct GetDownloadUrlForLayerInputBodyMiddleware: Middleware {
    public let id: String = "GetDownloadUrlForLayerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDownloadUrlForLayerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDownloadUrlForLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDownloadUrlForLayerInput>
    public typealias MOutput = OperationOutput<GetDownloadUrlForLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDownloadUrlForLayerOutputError>
}

extension GetDownloadUrlForLayerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDownloadUrlForLayerInput(layerDigest: \(String(describing: layerDigest)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetDownloadUrlForLayerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case layerDigest
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerDigest = layerDigest {
            try encodeContainer.encode(layerDigest, forKey: .layerDigest)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetDownloadUrlForLayerInputHeadersMiddleware: Middleware {
    public let id: String = "GetDownloadUrlForLayerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDownloadUrlForLayerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDownloadUrlForLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDownloadUrlForLayerInput>
    public typealias MOutput = OperationOutput<GetDownloadUrlForLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDownloadUrlForLayerOutputError>
}

public struct GetDownloadUrlForLayerInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDownloadUrlForLayerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDownloadUrlForLayerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDownloadUrlForLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDownloadUrlForLayerInput>
    public typealias MOutput = OperationOutput<GetDownloadUrlForLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDownloadUrlForLayerOutputError>
}

public struct GetDownloadUrlForLayerInput: Equatable {
    /// <p>The digest of the image layer to download.</p>
    public let layerDigest: String?
    /// <p>The AWS account ID associated with the registry that contains the image layer to
    ///             download. If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository that is associated with the image layer to download.</p>
    public let repositoryName: String?

    public init (
        layerDigest: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.layerDigest = layerDigest
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetDownloadUrlForLayerInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let layerDigest: String?
}

extension GetDownloadUrlForLayerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layerDigest
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let layerDigestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
    }
}

extension GetDownloadUrlForLayerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDownloadUrlForLayerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayerInaccessibleException" : self = .layerInaccessibleException(try LayerInaccessibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayersNotFoundException" : self = .layersNotFoundException(try LayersNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDownloadUrlForLayerOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case layerInaccessibleException(LayerInaccessibleException)
    case layersNotFoundException(LayersNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDownloadUrlForLayerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDownloadUrlForLayerOutputResponse(downloadUrl: \(String(describing: downloadUrl)), layerDigest: \(String(describing: layerDigest)))"}
}

extension GetDownloadUrlForLayerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDownloadUrlForLayerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.downloadUrl = output.downloadUrl
            self.layerDigest = output.layerDigest
        } else {
            self.downloadUrl = nil
            self.layerDigest = nil
        }
    }
}

public struct GetDownloadUrlForLayerOutputResponse: Equatable {
    /// <p>The pre-signed Amazon S3 download URL for the requested layer.</p>
    public let downloadUrl: String?
    /// <p>The digest of the image layer to download.</p>
    public let layerDigest: String?

    public init (
        downloadUrl: String? = nil,
        layerDigest: String? = nil
    )
    {
        self.downloadUrl = downloadUrl
        self.layerDigest = layerDigest
    }
}

struct GetDownloadUrlForLayerOutputResponseBody: Equatable {
    public let downloadUrl: String?
    public let layerDigest: String?
}

extension GetDownloadUrlForLayerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case downloadUrl
        case layerDigest
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let downloadUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
        let layerDigestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
    }
}

public struct GetLifecyclePolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetLifecyclePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<GetLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLifecyclePolicyOutputError>
}

extension GetLifecyclePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLifecyclePolicyInput(registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetLifecyclePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetLifecyclePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<GetLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLifecyclePolicyOutputError>
}

public struct GetLifecyclePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<GetLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLifecyclePolicyOutputError>
}

public struct GetLifecyclePolicyInput: Equatable {
    /// <p>The AWS account ID associated with the registry that contains the repository.
    ///             If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository.</p>
    public let repositoryName: String?

    public init (
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetLifecyclePolicyInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
}

extension GetLifecyclePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetLifecyclePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLifecyclePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LifecyclePolicyNotFoundException" : self = .lifecyclePolicyNotFoundException(try LifecyclePolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLifecyclePolicyOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case lifecyclePolicyNotFoundException(LifecyclePolicyNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLifecyclePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLifecyclePolicyOutputResponse(lastEvaluatedAt: \(String(describing: lastEvaluatedAt)), lifecyclePolicyText: \(String(describing: lifecyclePolicyText)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetLifecyclePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLifecyclePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lastEvaluatedAt = output.lastEvaluatedAt
            self.lifecyclePolicyText = output.lifecyclePolicyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.lastEvaluatedAt = nil
            self.lifecyclePolicyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct GetLifecyclePolicyOutputResponse: Equatable {
    /// <p>The time stamp of the last time that the lifecycle policy was run.</p>
    public let lastEvaluatedAt: Date?
    /// <p>The JSON lifecycle policy text.</p>
    public let lifecyclePolicyText: String?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?

    public init (
        lastEvaluatedAt: Date? = nil,
        lifecyclePolicyText: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.lastEvaluatedAt = lastEvaluatedAt
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetLifecyclePolicyOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let lifecyclePolicyText: String?
    public let lastEvaluatedAt: Date?
}

extension GetLifecyclePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lastEvaluatedAt
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
        let lastEvaluatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastEvaluatedAt)
        lastEvaluatedAt = lastEvaluatedAtDecoded
    }
}

public struct GetLifecyclePolicyPreviewInputBodyMiddleware: Middleware {
    public let id: String = "GetLifecyclePolicyPreviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLifecyclePolicyPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLifecyclePolicyPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLifecyclePolicyPreviewInput>
    public typealias MOutput = OperationOutput<GetLifecyclePolicyPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLifecyclePolicyPreviewOutputError>
}

extension GetLifecyclePolicyPreviewInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLifecyclePolicyPreviewInput(filter: \(String(describing: filter)), imageIds: \(String(describing: imageIds)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetLifecyclePolicyPreviewInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifierlist0 in imageIds {
                try imageIdsContainer.encode(imageidentifierlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetLifecyclePolicyPreviewInputHeadersMiddleware: Middleware {
    public let id: String = "GetLifecyclePolicyPreviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLifecyclePolicyPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLifecyclePolicyPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLifecyclePolicyPreviewInput>
    public typealias MOutput = OperationOutput<GetLifecyclePolicyPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLifecyclePolicyPreviewOutputError>
}

public struct GetLifecyclePolicyPreviewInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLifecyclePolicyPreviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLifecyclePolicyPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLifecyclePolicyPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLifecyclePolicyPreviewInput>
    public typealias MOutput = OperationOutput<GetLifecyclePolicyPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLifecyclePolicyPreviewOutputError>
}

public struct GetLifecyclePolicyPreviewInput: Equatable {
    /// <p>An optional parameter that filters results based on image tag status and all tags, if
    ///             tagged.</p>
    public let filter: LifecyclePolicyPreviewFilter?
    /// <p>The list of imageIDs to be included.</p>
    public let imageIds: [ImageIdentifier]?
    /// <p>The maximum number of repository results returned by
    ///                 <code>GetLifecyclePolicyPreviewRequest</code> in paginated output. When this
    ///             parameter is used, <code>GetLifecyclePolicyPreviewRequest</code> only returns
    ///                 <code>maxResults</code> results in a single page along with a
    ///             <code>nextToken</code> response element. The remaining results of the initial request
    ///             can be seen by sending another <code>GetLifecyclePolicyPreviewRequest</code> request
    ///             with the returned <code>nextToken</code> value. This value can be between
    ///             1 and 1000. If this parameter is not used, then
    ///                 <code>GetLifecyclePolicyPreviewRequest</code> returns up to 100
    ///             results and a <code>nextToken</code> value, if applicable. This option cannot be used
    ///             when you specify images with <code>imageIds</code>.</p>
    public let maxResults: Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///                 <code>GetLifecyclePolicyPreviewRequest</code> request where <code>maxResults</code>
    ///             was used and the results exceeded the value of that parameter. Pagination continues
    ///             from the end of the previous results that returned the <code>nextToken</code> value.
    ///             This value is <code>null</code> when there are no more results to return. This option
    ///             cannot be used when you specify images with <code>imageIds</code>.</p>
    public let nextToken: String?
    /// <p>The AWS account ID associated with the registry that contains the repository.
    ///             If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository.</p>
    public let repositoryName: String?

    public init (
        filter: LifecyclePolicyPreviewFilter? = nil,
        imageIds: [ImageIdentifier]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.filter = filter
        self.imageIds = imageIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetLifecyclePolicyPreviewInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let imageIds: [ImageIdentifier]?
    public let nextToken: String?
    public let maxResults: Int?
    public let filter: LifecyclePolicyPreviewFilter?
}

extension GetLifecyclePolicyPreviewInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(LifecyclePolicyPreviewFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension GetLifecyclePolicyPreviewOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLifecyclePolicyPreviewOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LifecyclePolicyPreviewNotFoundException" : self = .lifecyclePolicyPreviewNotFoundException(try LifecyclePolicyPreviewNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLifecyclePolicyPreviewOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case lifecyclePolicyPreviewNotFoundException(LifecyclePolicyPreviewNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLifecyclePolicyPreviewOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLifecyclePolicyPreviewOutputResponse(lifecyclePolicyText: \(String(describing: lifecyclePolicyText)), nextToken: \(String(describing: nextToken)), previewResults: \(String(describing: previewResults)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)), status: \(String(describing: status)), summary: \(String(describing: summary)))"}
}

extension GetLifecyclePolicyPreviewOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLifecyclePolicyPreviewOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lifecyclePolicyText = output.lifecyclePolicyText
            self.nextToken = output.nextToken
            self.previewResults = output.previewResults
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.status = output.status
            self.summary = output.summary
        } else {
            self.lifecyclePolicyText = nil
            self.nextToken = nil
            self.previewResults = nil
            self.registryId = nil
            self.repositoryName = nil
            self.status = nil
            self.summary = nil
        }
    }
}

public struct GetLifecyclePolicyPreviewOutputResponse: Equatable {
    /// <p>The JSON lifecycle policy text.</p>
    public let lifecyclePolicyText: String?
    /// <p>The <code>nextToken</code> value to include in a future
    ///                 <code>GetLifecyclePolicyPreview</code> request. When the results of a
    ///                 <code>GetLifecyclePolicyPreview</code> request exceed <code>maxResults</code>, this
    ///             value can be used to retrieve the next page of results. This value is <code>null</code>
    ///             when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>The results of the lifecycle policy preview request.</p>
    public let previewResults: [LifecyclePolicyPreviewResult]?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?
    /// <p>The status of the lifecycle policy preview request.</p>
    public let status: LifecyclePolicyPreviewStatus?
    /// <p>The list of images that is returned as a result of the action.</p>
    public let summary: LifecyclePolicyPreviewSummary?

    public init (
        lifecyclePolicyText: String? = nil,
        nextToken: String? = nil,
        previewResults: [LifecyclePolicyPreviewResult]? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil,
        status: LifecyclePolicyPreviewStatus? = nil,
        summary: LifecyclePolicyPreviewSummary? = nil
    )
    {
        self.lifecyclePolicyText = lifecyclePolicyText
        self.nextToken = nextToken
        self.previewResults = previewResults
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.status = status
        self.summary = summary
    }
}

struct GetLifecyclePolicyPreviewOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let lifecyclePolicyText: String?
    public let status: LifecyclePolicyPreviewStatus?
    public let nextToken: String?
    public let previewResults: [LifecyclePolicyPreviewResult]?
    public let summary: LifecyclePolicyPreviewSummary?
}

extension GetLifecyclePolicyPreviewOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lifecyclePolicyText
        case nextToken
        case previewResults
        case registryId
        case repositoryName
        case status
        case summary
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LifecyclePolicyPreviewStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let previewResultsContainer = try containerValues.decodeIfPresent([LifecyclePolicyPreviewResult?].self, forKey: .previewResults)
        var previewResultsDecoded0:[LifecyclePolicyPreviewResult]? = nil
        if let previewResultsContainer = previewResultsContainer {
            previewResultsDecoded0 = [LifecyclePolicyPreviewResult]()
            for structure0 in previewResultsContainer {
                if let structure0 = structure0 {
                    previewResultsDecoded0?.append(structure0)
                }
            }
        }
        previewResults = previewResultsDecoded0
        let summaryDecoded = try containerValues.decodeIfPresent(LifecyclePolicyPreviewSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

extension GetRegistryPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRegistryPolicyInput()"}
}

extension GetRegistryPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRegistryPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetRegistryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegistryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegistryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegistryPolicyInput>
    public typealias MOutput = OperationOutput<GetRegistryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegistryPolicyOutputError>
}

public struct GetRegistryPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRegistryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegistryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegistryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegistryPolicyInput>
    public typealias MOutput = OperationOutput<GetRegistryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegistryPolicyOutputError>
}

public struct GetRegistryPolicyInput: Equatable {

    public init() {}
}

struct GetRegistryPolicyInputBody: Equatable {
}

extension GetRegistryPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRegistryPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRegistryPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryPolicyNotFoundException" : self = .registryPolicyNotFoundException(try RegistryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRegistryPolicyOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case registryPolicyNotFoundException(RegistryPolicyNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRegistryPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRegistryPolicyOutputResponse(policyText: \(String(describing: policyText)), registryId: \(String(describing: registryId)))"}
}

extension GetRegistryPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRegistryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyText = output.policyText
            self.registryId = output.registryId
        } else {
            self.policyText = nil
            self.registryId = nil
        }
    }
}

public struct GetRegistryPolicyOutputResponse: Equatable {
    /// <p>The JSON text of the permissions policy for a registry.</p>
    public let policyText: String?
    /// <p>The ID of the registry.</p>
    public let registryId: String?

    public init (
        policyText: String? = nil,
        registryId: String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
    }
}

struct GetRegistryPolicyOutputResponseBody: Equatable {
    public let registryId: String?
    public let policyText: String?
}

extension GetRegistryPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyText
        case registryId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

public struct GetRepositoryPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetRepositoryPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<GetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryPolicyOutputError>
}

extension GetRepositoryPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRepositoryPolicyInput(registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetRepositoryPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetRepositoryPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetRepositoryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<GetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryPolicyOutputError>
}

public struct GetRepositoryPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRepositoryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<GetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryPolicyOutputError>
}

public struct GetRepositoryPolicyInput: Equatable {
    /// <p>The AWS account ID associated with the registry that contains the repository.
    ///             If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository with the policy to retrieve.</p>
    public let repositoryName: String?

    public init (
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryPolicyInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
}

extension GetRepositoryPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetRepositoryPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryPolicyNotFoundException" : self = .repositoryPolicyNotFoundException(try RepositoryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRepositoryPolicyOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case repositoryPolicyNotFoundException(RepositoryPolicyNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRepositoryPolicyOutputResponse(policyText: \(String(describing: policyText)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetRepositoryPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRepositoryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct GetRepositoryPolicyOutputResponse: Equatable {
    /// <p>The JSON repository policy text associated with the repository.</p>
    public let policyText: String?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?

    public init (
        policyText: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryPolicyOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let policyText: String?
}

extension GetRepositoryPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

extension Image: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageId
        case imageManifest
        case imageManifestMediaType
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let imageManifest = imageManifest {
            try encodeContainer.encode(imageManifest, forKey: .imageManifest)
        }
        if let imageManifestMediaType = imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imageManifestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageManifest)
        imageManifest = imageManifestDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
    }
}

extension Image: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Image(imageId: \(String(describing: imageId)), imageManifest: \(String(describing: imageManifest)), imageManifestMediaType: \(String(describing: imageManifestMediaType)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

/// <p>An object representing an Amazon ECR image.</p>
public struct Image: Equatable {
    /// <p>An object containing the image tag and image digest associated with an image.</p>
    public let imageId: ImageIdentifier?
    /// <p>The image manifest associated with the image.</p>
    public let imageManifest: String?
    /// <p>The manifest media type of the image.</p>
    public let imageManifestMediaType: String?
    /// <p>The AWS account ID associated with the registry containing the image.</p>
    public let registryId: String?
    /// <p>The name of the repository associated with the image.</p>
    public let repositoryName: String?

    public init (
        imageId: ImageIdentifier? = nil,
        imageManifest: String? = nil,
        imageManifestMediaType: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.imageId = imageId
        self.imageManifest = imageManifest
        self.imageManifestMediaType = imageManifestMediaType
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

public enum ImageActionType {
    case expire
    case sdkUnknown(String)
}

extension ImageActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImageActionType] {
        return [
            .expire,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .expire: return "EXPIRE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImageActionType(rawValue: rawValue) ?? ImageActionType.sdkUnknown(rawValue)
    }
}

extension ImageAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ImageAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImageAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified image has already been pushed, and there were no changes to the manifest
///             or image tag after the last push.</p>
public struct ImageAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ImageAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ImageAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImageDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactMediaType
        case imageDigest
        case imageManifestMediaType
        case imagePushedAt
        case imageScanFindingsSummary
        case imageScanStatus
        case imageSizeInBytes
        case imageTags
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactMediaType = artifactMediaType {
            try encodeContainer.encode(artifactMediaType, forKey: .artifactMediaType)
        }
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageManifestMediaType = imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let imagePushedAt = imagePushedAt {
            try encodeContainer.encode(imagePushedAt.timeIntervalSince1970, forKey: .imagePushedAt)
        }
        if let imageScanFindingsSummary = imageScanFindingsSummary {
            try encodeContainer.encode(imageScanFindingsSummary, forKey: .imageScanFindingsSummary)
        }
        if let imageScanStatus = imageScanStatus {
            try encodeContainer.encode(imageScanStatus, forKey: .imageScanStatus)
        }
        if let imageSizeInBytes = imageSizeInBytes {
            try encodeContainer.encode(imageSizeInBytes, forKey: .imageSizeInBytes)
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for imagetaglist0 in imageTags {
                try imageTagsContainer.encode(imagetaglist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imageTagsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .imageTags)
        var imageTagsDecoded0:[String]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [String]()
            for string0 in imageTagsContainer {
                if let string0 = string0 {
                    imageTagsDecoded0?.append(string0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let imageSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .imageSizeInBytes)
        imageSizeInBytes = imageSizeInBytesDecoded
        let imagePushedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .imagePushedAt)
        imagePushedAt = imagePushedAtDecoded
        let imageScanStatusDecoded = try containerValues.decodeIfPresent(ImageScanStatus.self, forKey: .imageScanStatus)
        imageScanStatus = imageScanStatusDecoded
        let imageScanFindingsSummaryDecoded = try containerValues.decodeIfPresent(ImageScanFindingsSummary.self, forKey: .imageScanFindingsSummary)
        imageScanFindingsSummary = imageScanFindingsSummaryDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
        let artifactMediaTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .artifactMediaType)
        artifactMediaType = artifactMediaTypeDecoded
    }
}

extension ImageDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageDetail(artifactMediaType: \(String(describing: artifactMediaType)), imageDigest: \(String(describing: imageDigest)), imageManifestMediaType: \(String(describing: imageManifestMediaType)), imagePushedAt: \(String(describing: imagePushedAt)), imageScanFindingsSummary: \(String(describing: imageScanFindingsSummary)), imageScanStatus: \(String(describing: imageScanStatus)), imageSizeInBytes: \(String(describing: imageSizeInBytes)), imageTags: \(String(describing: imageTags)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

/// <p>An object that describes an image returned by a <a>DescribeImages</a>
///             operation.</p>
public struct ImageDetail: Equatable {
    /// <p>The artifact media type of the image.</p>
    public let artifactMediaType: String?
    /// <p>The <code>sha256</code> digest of the image manifest.</p>
    public let imageDigest: String?
    /// <p>The media type of the image manifest.</p>
    public let imageManifestMediaType: String?
    /// <p>The date and time, expressed in standard JavaScript date format, at which the current
    ///             image was pushed to the repository. </p>
    public let imagePushedAt: Date?
    /// <p>A summary of the last completed image scan.</p>
    public let imageScanFindingsSummary: ImageScanFindingsSummary?
    /// <p>The current state of the scan.</p>
    public let imageScanStatus: ImageScanStatus?
    /// <p>The size, in bytes, of the image in the repository.</p>
    ///         <p>If the image is a manifest list, this will be the max size of all manifests in the
    ///             list.</p>
    ///         <note>
    ///             <p>Beginning with Docker version 1.9, the Docker client compresses image layers
    ///                 before pushing them to a V2 Docker registry. The output of the <code>docker
    ///                     images</code> command shows the uncompressed image size, so it may return a
    ///                 larger image size than the image sizes returned by <a>DescribeImages</a>.</p>
    ///         </note>
    public let imageSizeInBytes: Int?
    /// <p>The list of tags associated with this image.</p>
    public let imageTags: [String]?
    /// <p>The AWS account ID associated with the registry to which this image belongs.</p>
    public let registryId: String?
    /// <p>The name of the repository to which this image belongs.</p>
    public let repositoryName: String?

    public init (
        artifactMediaType: String? = nil,
        imageDigest: String? = nil,
        imageManifestMediaType: String? = nil,
        imagePushedAt: Date? = nil,
        imageScanFindingsSummary: ImageScanFindingsSummary? = nil,
        imageScanStatus: ImageScanStatus? = nil,
        imageSizeInBytes: Int? = nil,
        imageTags: [String]? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.artifactMediaType = artifactMediaType
        self.imageDigest = imageDigest
        self.imageManifestMediaType = imageManifestMediaType
        self.imagePushedAt = imagePushedAt
        self.imageScanFindingsSummary = imageScanFindingsSummary
        self.imageScanStatus = imageScanStatus
        self.imageSizeInBytes = imageSizeInBytes
        self.imageTags = imageTags
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

extension ImageDigestDoesNotMatchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageDigestDoesNotMatchException(message: \(String(describing: message)))"}
}

extension ImageDigestDoesNotMatchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImageDigestDoesNotMatchExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified image digest does not match the digest that Amazon ECR calculated for the
///             image.</p>
public struct ImageDigestDoesNotMatchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ImageDigestDoesNotMatchExceptionBody: Equatable {
    public let message: String?
}

extension ImageDigestDoesNotMatchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImageFailure: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureCode
        case failureReason
        case imageId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(ImageFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension ImageFailure: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageFailure(failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), imageId: \(String(describing: imageId)))"}
}

/// <p>An object representing an Amazon ECR image failure.</p>
public struct ImageFailure: Equatable {
    /// <p>The code associated with the failure.</p>
    public let failureCode: ImageFailureCode?
    /// <p>The reason for the failure.</p>
    public let failureReason: String?
    /// <p>The image ID associated with the failure.</p>
    public let imageId: ImageIdentifier?

    public init (
        failureCode: ImageFailureCode? = nil,
        failureReason: String? = nil,
        imageId: ImageIdentifier? = nil
    )
    {
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.imageId = imageId
    }
}

public enum ImageFailureCode {
    case imagenotfound
    case imagereferencedbymanifestlist
    case imagetagdoesnotmatchdigest
    case invalidimagedigest
    case invalidimagetag
    case kmserror
    case missingdigestandtag
    case sdkUnknown(String)
}

extension ImageFailureCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImageFailureCode] {
        return [
            .imagenotfound,
            .imagereferencedbymanifestlist,
            .imagetagdoesnotmatchdigest,
            .invalidimagedigest,
            .invalidimagetag,
            .kmserror,
            .missingdigestandtag,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .imagenotfound: return "ImageNotFound"
        case .imagereferencedbymanifestlist: return "ImageReferencedByManifestList"
        case .imagetagdoesnotmatchdigest: return "ImageTagDoesNotMatchDigest"
        case .invalidimagedigest: return "InvalidImageDigest"
        case .invalidimagetag: return "InvalidImageTag"
        case .kmserror: return "KmsError"
        case .missingdigestandtag: return "MissingDigestAndTag"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImageFailureCode(rawValue: rawValue) ?? ImageFailureCode.sdkUnknown(rawValue)
    }
}

extension ImageIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageDigest
        case imageTag
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageTag = imageTag {
            try encodeContainer.encode(imageTag, forKey: .imageTag)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDigestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imageTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageTag)
        imageTag = imageTagDecoded
    }
}

extension ImageIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageIdentifier(imageDigest: \(String(describing: imageDigest)), imageTag: \(String(describing: imageTag)))"}
}

/// <p>An object with identifying information for an Amazon ECR image.</p>
public struct ImageIdentifier: Equatable {
    /// <p>The <code>sha256</code> digest of the image manifest.</p>
    public let imageDigest: String?
    /// <p>The tag used for the image.</p>
    public let imageTag: String?

    public init (
        imageDigest: String? = nil,
        imageTag: String? = nil
    )
    {
        self.imageDigest = imageDigest
        self.imageTag = imageTag
    }
}

extension ImageNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageNotFoundException(message: \(String(describing: message)))"}
}

extension ImageNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImageNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The image requested does not exist in the specified repository.</p>
public struct ImageNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ImageNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ImageNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImageScanFinding: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case description
        case name
        case severity
        case uri
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributelist0 in attributes {
                try attributesContainer.encode(attributelist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
        let severityDecoded = try containerValues.decodeIfPresent(FindingSeverity.self, forKey: .severity)
        severity = severityDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ImageScanFinding: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageScanFinding(attributes: \(String(describing: attributes)), description: \(String(describing: description)), name: \(String(describing: name)), severity: \(String(describing: severity)), uri: \(String(describing: uri)))"}
}

/// <p>Contains information about an image scan finding.</p>
public struct ImageScanFinding: Equatable {
    /// <p>A collection of attributes of the host from which the finding is generated.</p>
    public let attributes: [Attribute]?
    /// <p>The description of the finding.</p>
    public let description: String?
    /// <p>The name associated with the finding, usually a CVE number.</p>
    public let name: String?
    /// <p>The finding severity.</p>
    public let severity: FindingSeverity?
    /// <p>A link containing additional details about the security vulnerability.</p>
    public let uri: String?

    public init (
        attributes: [Attribute]? = nil,
        description: String? = nil,
        name: String? = nil,
        severity: FindingSeverity? = nil,
        uri: String? = nil
    )
    {
        self.attributes = attributes
        self.description = description
        self.name = name
        self.severity = severity
        self.uri = uri
    }
}

extension ImageScanFindings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingSeverityCounts
        case findings
        case imageScanCompletedAt
        case vulnerabilitySourceUpdatedAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingSeverityCounts = findingSeverityCounts {
            var findingSeverityCountsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .findingSeverityCounts)
            for (dictKey0, findingseveritycounts0) in findingSeverityCounts {
                try findingSeverityCountsContainer.encode(findingseveritycounts0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let findings = findings {
            var findingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findings)
            for imagescanfindinglist0 in findings {
                try findingsContainer.encode(imagescanfindinglist0)
            }
        }
        if let imageScanCompletedAt = imageScanCompletedAt {
            try encodeContainer.encode(imageScanCompletedAt.timeIntervalSince1970, forKey: .imageScanCompletedAt)
        }
        if let vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAt {
            try encodeContainer.encode(vulnerabilitySourceUpdatedAt.timeIntervalSince1970, forKey: .vulnerabilitySourceUpdatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageScanCompletedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .imageScanCompletedAt)
        imageScanCompletedAt = imageScanCompletedAtDecoded
        let vulnerabilitySourceUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .vulnerabilitySourceUpdatedAt)
        vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAtDecoded
        let findingsContainer = try containerValues.decodeIfPresent([ImageScanFinding?].self, forKey: .findings)
        var findingsDecoded0:[ImageScanFinding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [ImageScanFinding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let findingSeverityCountsContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .findingSeverityCounts)
        var findingSeverityCountsDecoded0: [String:Int]? = nil
        if let findingSeverityCountsContainer = findingSeverityCountsContainer {
            findingSeverityCountsDecoded0 = [String:Int]()
            for (key0, severitycount0) in findingSeverityCountsContainer {
                if let severitycount0 = severitycount0 {
                    findingSeverityCountsDecoded0?[key0] = severitycount0
                }
            }
        }
        findingSeverityCounts = findingSeverityCountsDecoded0
    }
}

extension ImageScanFindings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageScanFindings(findingSeverityCounts: \(String(describing: findingSeverityCounts)), findings: \(String(describing: findings)), imageScanCompletedAt: \(String(describing: imageScanCompletedAt)), vulnerabilitySourceUpdatedAt: \(String(describing: vulnerabilitySourceUpdatedAt)))"}
}

/// <p>The details of an image scan.</p>
public struct ImageScanFindings: Equatable {
    /// <p>The image vulnerability counts, sorted by severity.</p>
    public let findingSeverityCounts: [String:Int]?
    /// <p>The findings from the image scan.</p>
    public let findings: [ImageScanFinding]?
    /// <p>The time of the last completed image scan.</p>
    public let imageScanCompletedAt: Date?
    /// <p>The time when the vulnerability data was last scanned.</p>
    public let vulnerabilitySourceUpdatedAt: Date?

    public init (
        findingSeverityCounts: [String:Int]? = nil,
        findings: [ImageScanFinding]? = nil,
        imageScanCompletedAt: Date? = nil,
        vulnerabilitySourceUpdatedAt: Date? = nil
    )
    {
        self.findingSeverityCounts = findingSeverityCounts
        self.findings = findings
        self.imageScanCompletedAt = imageScanCompletedAt
        self.vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAt
    }
}

extension ImageScanFindingsSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingSeverityCounts
        case imageScanCompletedAt
        case vulnerabilitySourceUpdatedAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingSeverityCounts = findingSeverityCounts {
            var findingSeverityCountsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .findingSeverityCounts)
            for (dictKey0, findingseveritycounts0) in findingSeverityCounts {
                try findingSeverityCountsContainer.encode(findingseveritycounts0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let imageScanCompletedAt = imageScanCompletedAt {
            try encodeContainer.encode(imageScanCompletedAt.timeIntervalSince1970, forKey: .imageScanCompletedAt)
        }
        if let vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAt {
            try encodeContainer.encode(vulnerabilitySourceUpdatedAt.timeIntervalSince1970, forKey: .vulnerabilitySourceUpdatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageScanCompletedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .imageScanCompletedAt)
        imageScanCompletedAt = imageScanCompletedAtDecoded
        let vulnerabilitySourceUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .vulnerabilitySourceUpdatedAt)
        vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAtDecoded
        let findingSeverityCountsContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .findingSeverityCounts)
        var findingSeverityCountsDecoded0: [String:Int]? = nil
        if let findingSeverityCountsContainer = findingSeverityCountsContainer {
            findingSeverityCountsDecoded0 = [String:Int]()
            for (key0, severitycount0) in findingSeverityCountsContainer {
                if let severitycount0 = severitycount0 {
                    findingSeverityCountsDecoded0?[key0] = severitycount0
                }
            }
        }
        findingSeverityCounts = findingSeverityCountsDecoded0
    }
}

extension ImageScanFindingsSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageScanFindingsSummary(findingSeverityCounts: \(String(describing: findingSeverityCounts)), imageScanCompletedAt: \(String(describing: imageScanCompletedAt)), vulnerabilitySourceUpdatedAt: \(String(describing: vulnerabilitySourceUpdatedAt)))"}
}

/// <p>A summary of the last completed image scan.</p>
public struct ImageScanFindingsSummary: Equatable {
    /// <p>The image vulnerability counts, sorted by severity.</p>
    public let findingSeverityCounts: [String:Int]?
    /// <p>The time of the last completed image scan.</p>
    public let imageScanCompletedAt: Date?
    /// <p>The time when the vulnerability data was last scanned.</p>
    public let vulnerabilitySourceUpdatedAt: Date?

    public init (
        findingSeverityCounts: [String:Int]? = nil,
        imageScanCompletedAt: Date? = nil,
        vulnerabilitySourceUpdatedAt: Date? = nil
    )
    {
        self.findingSeverityCounts = findingSeverityCounts
        self.imageScanCompletedAt = imageScanCompletedAt
        self.vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAt
    }
}

extension ImageScanStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ScanStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ImageScanStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageScanStatus(description: \(String(describing: description)), status: \(String(describing: status)))"}
}

/// <p>The current status of an image scan.</p>
public struct ImageScanStatus: Equatable {
    /// <p>The description of the image scan status.</p>
    public let description: String?
    /// <p>The current state of an image scan.</p>
    public let status: ScanStatus?

    public init (
        description: String? = nil,
        status: ScanStatus? = nil
    )
    {
        self.description = description
        self.status = status
    }
}

extension ImageScanningConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case scanOnPush
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if scanOnPush != false {
            try encodeContainer.encode(scanOnPush, forKey: .scanOnPush)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanOnPushDecoded = try containerValues.decode(Bool.self, forKey: .scanOnPush)
        scanOnPush = scanOnPushDecoded
    }
}

extension ImageScanningConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageScanningConfiguration(scanOnPush: \(String(describing: scanOnPush)))"}
}

/// <p>The image scanning configuration for a repository.</p>
public struct ImageScanningConfiguration: Equatable {
    /// <p>The setting that determines whether images are scanned after being pushed to a
    ///             repository. If set to <code>true</code>, images will be scanned after being pushed. If
    ///             this parameter is not specified, it will default to <code>false</code> and images will
    ///             not be scanned unless a scan is manually started with the <a>StartImageScan</a> API.</p>
    public let scanOnPush: Bool

    public init (
        scanOnPush: Bool = false
    )
    {
        self.scanOnPush = scanOnPush
    }
}

extension ImageTagAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageTagAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ImageTagAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImageTagAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified image is tagged with a tag that already exists. The repository is
///             configured for tag immutability.</p>
public struct ImageTagAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ImageTagAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ImageTagAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ImageTagMutability {
    case immutable
    case mutable
    case sdkUnknown(String)
}

extension ImageTagMutability : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImageTagMutability] {
        return [
            .immutable,
            .mutable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .immutable: return "IMMUTABLE"
        case .mutable: return "MUTABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImageTagMutability(rawValue: rawValue) ?? ImageTagMutability.sdkUnknown(rawValue)
    }
}

public struct InitiateLayerUploadInputBodyMiddleware: Middleware {
    public let id: String = "InitiateLayerUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateLayerUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateLayerUploadInput>
    public typealias MOutput = OperationOutput<InitiateLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateLayerUploadOutputError>
}

extension InitiateLayerUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitiateLayerUploadInput(registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension InitiateLayerUploadInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct InitiateLayerUploadInputHeadersMiddleware: Middleware {
    public let id: String = "InitiateLayerUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateLayerUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateLayerUploadInput>
    public typealias MOutput = OperationOutput<InitiateLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateLayerUploadOutputError>
}

public struct InitiateLayerUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "InitiateLayerUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateLayerUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateLayerUploadInput>
    public typealias MOutput = OperationOutput<InitiateLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateLayerUploadOutputError>
}

public struct InitiateLayerUploadInput: Equatable {
    /// <p>The AWS account ID associated with the registry to which you intend to upload layers.
    ///             If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository to which you intend to upload layers.</p>
    public let repositoryName: String?

    public init (
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct InitiateLayerUploadInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
}

extension InitiateLayerUploadInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension InitiateLayerUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateLayerUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitiateLayerUploadOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case kmsException(KmsException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateLayerUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitiateLayerUploadOutputResponse(partSize: \(String(describing: partSize)), uploadId: \(String(describing: uploadId)))"}
}

extension InitiateLayerUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InitiateLayerUploadOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.partSize = output.partSize
            self.uploadId = output.uploadId
        } else {
            self.partSize = nil
            self.uploadId = nil
        }
    }
}

public struct InitiateLayerUploadOutputResponse: Equatable {
    /// <p>The size, in bytes, that Amazon ECR expects future layer part uploads to be.</p>
    public let partSize: Int?
    /// <p>The upload ID for the layer upload. This parameter is passed to further <a>UploadLayerPart</a> and <a>CompleteLayerUpload</a>
    ///             operations.</p>
    public let uploadId: String?

    public init (
        partSize: Int? = nil,
        uploadId: String? = nil
    )
    {
        self.partSize = partSize
        self.uploadId = uploadId
    }
}

struct InitiateLayerUploadOutputResponseBody: Equatable {
    public let uploadId: String?
    public let partSize: Int?
}

extension InitiateLayerUploadOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case partSize
        case uploadId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let partSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .partSize)
        partSize = partSizeDecoded
    }
}

extension InvalidLayerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidLayerException(message: \(String(describing: message)))"}
}

extension InvalidLayerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidLayerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The layer digest calculation performed by Amazon ECR upon receipt of the image layer does
///             not match the digest specified.</p>
public struct InvalidLayerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLayerExceptionBody: Equatable {
    public let message: String?
}

extension InvalidLayerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLayerPartException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidLayerPartException(lastValidByteReceived: \(String(describing: lastValidByteReceived)), message: \(String(describing: message)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)), uploadId: \(String(describing: uploadId)))"}
}

extension InvalidLayerPartException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidLayerPartExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lastValidByteReceived = output.lastValidByteReceived
            self.message = output.message
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.lastValidByteReceived = nil
            self.message = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The layer part size is not valid, or the first byte specified is not consecutive to
///             the last byte of a previous layer part upload.</p>
public struct InvalidLayerPartException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The last valid byte received from the layer part upload that is associated with the
    ///             exception.</p>
    public var lastValidByteReceived: Int?
    /// <p>The error message associated with the exception.</p>
    public var message: String?
    /// <p>The registry ID associated with the exception.</p>
    public var registryId: String?
    /// <p>The repository name associated with the exception.</p>
    public var repositoryName: String?
    /// <p>The upload ID associated with the exception.</p>
    public var uploadId: String?

    public init (
        lastValidByteReceived: Int? = nil,
        message: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil,
        uploadId: String? = nil
    )
    {
        self.lastValidByteReceived = lastValidByteReceived
        self.message = message
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct InvalidLayerPartExceptionBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let uploadId: String?
    public let lastValidByteReceived: Int?
    public let message: String?
}

extension InvalidLayerPartExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lastValidByteReceived
        case message
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let lastValidByteReceivedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .lastValidByteReceived)
        lastValidByteReceived = lastValidByteReceivedDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified parameter is invalid. Review the available parameters for the API
///             request.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTagParameterException(message: \(String(describing: message)))"}
}

extension InvalidTagParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTagParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An invalid parameter has been specified. Tag keys can have a maximum character length of 128 characters, and tag values can have
///             a maximum length of 256 characters.</p>
public struct InvalidTagParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTagParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KmsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KmsException(kmsError: \(String(describing: kmsError)), message: \(String(describing: message)))"}
}

extension KmsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KmsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.kmsError = output.kmsError
            self.message = output.message
        } else {
            self.kmsError = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed due to a KMS exception.</p>
public struct KmsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error code returned by AWS KMS.</p>
    public var kmsError: String?
    public var message: String?

    public init (
        kmsError: String? = nil,
        message: String? = nil
    )
    {
        self.kmsError = kmsError
        self.message = message
    }
}

struct KmsExceptionBody: Equatable {
    public let message: String?
    public let kmsError: String?
}

extension KmsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case kmsError
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let kmsErrorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsError)
        kmsError = kmsErrorDecoded
    }
}

extension Layer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case layerAvailability
        case layerDigest
        case layerSize
        case mediaType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerAvailability = layerAvailability {
            try encodeContainer.encode(layerAvailability.rawValue, forKey: .layerAvailability)
        }
        if let layerDigest = layerDigest {
            try encodeContainer.encode(layerDigest, forKey: .layerDigest)
        }
        if let layerSize = layerSize {
            try encodeContainer.encode(layerSize, forKey: .layerSize)
        }
        if let mediaType = mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerDigestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
        let layerAvailabilityDecoded = try containerValues.decodeIfPresent(LayerAvailability.self, forKey: .layerAvailability)
        layerAvailability = layerAvailabilityDecoded
        let layerSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .layerSize)
        layerSize = layerSizeDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
    }
}

extension Layer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Layer(layerAvailability: \(String(describing: layerAvailability)), layerDigest: \(String(describing: layerDigest)), layerSize: \(String(describing: layerSize)), mediaType: \(String(describing: mediaType)))"}
}

/// <p>An object representing an Amazon ECR image layer.</p>
public struct Layer: Equatable {
    /// <p>The availability status of the image layer.</p>
    public let layerAvailability: LayerAvailability?
    /// <p>The <code>sha256</code> digest of the image layer.</p>
    public let layerDigest: String?
    /// <p>The size, in bytes, of the image layer.</p>
    public let layerSize: Int?
    /// <p>The media type of the layer, such as
    ///                 <code>application/vnd.docker.image.rootfs.diff.tar.gzip</code> or
    ///                 <code>application/vnd.oci.image.layer.v1.tar+gzip</code>.</p>
    public let mediaType: String?

    public init (
        layerAvailability: LayerAvailability? = nil,
        layerDigest: String? = nil,
        layerSize: Int? = nil,
        mediaType: String? = nil
    )
    {
        self.layerAvailability = layerAvailability
        self.layerDigest = layerDigest
        self.layerSize = layerSize
        self.mediaType = mediaType
    }
}

extension LayerAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LayerAlreadyExistsException(message: \(String(describing: message)))"}
}

extension LayerAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LayerAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The image layer already exists in the associated repository.</p>
public struct LayerAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LayerAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension LayerAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum LayerAvailability {
    case available
    case unavailable
    case sdkUnknown(String)
}

extension LayerAvailability : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LayerAvailability] {
        return [
            .available,
            .unavailable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .unavailable: return "UNAVAILABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LayerAvailability(rawValue: rawValue) ?? LayerAvailability.sdkUnknown(rawValue)
    }
}

extension LayerFailure: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureCode
        case failureReason
        case layerDigest
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let layerDigest = layerDigest {
            try encodeContainer.encode(layerDigest, forKey: .layerDigest)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerDigestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(LayerFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension LayerFailure: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LayerFailure(failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), layerDigest: \(String(describing: layerDigest)))"}
}

/// <p>An object representing an Amazon ECR image layer failure.</p>
public struct LayerFailure: Equatable {
    /// <p>The failure code associated with the failure.</p>
    public let failureCode: LayerFailureCode?
    /// <p>The reason for the failure.</p>
    public let failureReason: String?
    /// <p>The layer digest associated with the failure.</p>
    public let layerDigest: String?

    public init (
        failureCode: LayerFailureCode? = nil,
        failureReason: String? = nil,
        layerDigest: String? = nil
    )
    {
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.layerDigest = layerDigest
    }
}

public enum LayerFailureCode {
    case invalidlayerdigest
    case missinglayerdigest
    case sdkUnknown(String)
}

extension LayerFailureCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LayerFailureCode] {
        return [
            .invalidlayerdigest,
            .missinglayerdigest,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .invalidlayerdigest: return "InvalidLayerDigest"
        case .missinglayerdigest: return "MissingLayerDigest"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LayerFailureCode(rawValue: rawValue) ?? LayerFailureCode.sdkUnknown(rawValue)
    }
}

extension LayerInaccessibleException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LayerInaccessibleException(message: \(String(describing: message)))"}
}

extension LayerInaccessibleException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LayerInaccessibleExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified layer is not available because it is not associated with an image.
///             Unassociated image layers may be cleaned up at any time.</p>
public struct LayerInaccessibleException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LayerInaccessibleExceptionBody: Equatable {
    public let message: String?
}

extension LayerInaccessibleExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LayerPartTooSmallException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LayerPartTooSmallException(message: \(String(describing: message)))"}
}

extension LayerPartTooSmallException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LayerPartTooSmallExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Layer parts must be at least 5 MiB in size.</p>
public struct LayerPartTooSmallException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LayerPartTooSmallExceptionBody: Equatable {
    public let message: String?
}

extension LayerPartTooSmallExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LayersNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LayersNotFoundException(message: \(String(describing: message)))"}
}

extension LayersNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LayersNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified layers could not be found, or the specified layer is not valid for this
///             repository.</p>
public struct LayersNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LayersNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension LayersNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LifecyclePolicyNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecyclePolicyNotFoundException(message: \(String(describing: message)))"}
}

extension LifecyclePolicyNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LifecyclePolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The lifecycle policy could not be found, and no policy is set to the
///             repository.</p>
public struct LifecyclePolicyNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LifecyclePolicyNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension LifecyclePolicyNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LifecyclePolicyPreviewFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagStatus
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagStatus = tagStatus {
            try encodeContainer.encode(tagStatus.rawValue, forKey: .tagStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagStatusDecoded = try containerValues.decodeIfPresent(TagStatus.self, forKey: .tagStatus)
        tagStatus = tagStatusDecoded
    }
}

extension LifecyclePolicyPreviewFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecyclePolicyPreviewFilter(tagStatus: \(String(describing: tagStatus)))"}
}

/// <p>The filter for the lifecycle policy preview.</p>
public struct LifecyclePolicyPreviewFilter: Equatable {
    /// <p>The tag status of the image.</p>
    public let tagStatus: TagStatus?

    public init (
        tagStatus: TagStatus? = nil
    )
    {
        self.tagStatus = tagStatus
    }
}

extension LifecyclePolicyPreviewInProgressException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecyclePolicyPreviewInProgressException(message: \(String(describing: message)))"}
}

extension LifecyclePolicyPreviewInProgressException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LifecyclePolicyPreviewInProgressExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The previous lifecycle policy preview request has not completed. Wait and try
///             again.</p>
public struct LifecyclePolicyPreviewInProgressException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LifecyclePolicyPreviewInProgressExceptionBody: Equatable {
    public let message: String?
}

extension LifecyclePolicyPreviewInProgressExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LifecyclePolicyPreviewNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecyclePolicyPreviewNotFoundException(message: \(String(describing: message)))"}
}

extension LifecyclePolicyPreviewNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LifecyclePolicyPreviewNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is no dry run for this repository.</p>
public struct LifecyclePolicyPreviewNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LifecyclePolicyPreviewNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension LifecyclePolicyPreviewNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LifecyclePolicyPreviewResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case appliedRulePriority
        case imageDigest
        case imagePushedAt
        case imageTags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let appliedRulePriority = appliedRulePriority {
            try encodeContainer.encode(appliedRulePriority, forKey: .appliedRulePriority)
        }
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imagePushedAt = imagePushedAt {
            try encodeContainer.encode(imagePushedAt.timeIntervalSince1970, forKey: .imagePushedAt)
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for imagetaglist0 in imageTags {
                try imageTagsContainer.encode(imagetaglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageTagsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .imageTags)
        var imageTagsDecoded0:[String]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [String]()
            for string0 in imageTagsContainer {
                if let string0 = string0 {
                    imageTagsDecoded0?.append(string0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let imageDigestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imagePushedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .imagePushedAt)
        imagePushedAt = imagePushedAtDecoded
        let actionDecoded = try containerValues.decodeIfPresent(LifecyclePolicyRuleAction.self, forKey: .action)
        action = actionDecoded
        let appliedRulePriorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .appliedRulePriority)
        appliedRulePriority = appliedRulePriorityDecoded
    }
}

extension LifecyclePolicyPreviewResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecyclePolicyPreviewResult(action: \(String(describing: action)), appliedRulePriority: \(String(describing: appliedRulePriority)), imageDigest: \(String(describing: imageDigest)), imagePushedAt: \(String(describing: imagePushedAt)), imageTags: \(String(describing: imageTags)))"}
}

/// <p>The result of the lifecycle policy preview.</p>
public struct LifecyclePolicyPreviewResult: Equatable {
    /// <p>The type of action to be taken.</p>
    public let action: LifecyclePolicyRuleAction?
    /// <p>The priority of the applied rule.</p>
    public let appliedRulePriority: Int?
    /// <p>The <code>sha256</code> digest of the image manifest.</p>
    public let imageDigest: String?
    /// <p>The date and time, expressed in standard JavaScript date format, at which the current
    ///             image was pushed to the repository.</p>
    public let imagePushedAt: Date?
    /// <p>The list of tags associated with this image.</p>
    public let imageTags: [String]?

    public init (
        action: LifecyclePolicyRuleAction? = nil,
        appliedRulePriority: Int? = nil,
        imageDigest: String? = nil,
        imagePushedAt: Date? = nil,
        imageTags: [String]? = nil
    )
    {
        self.action = action
        self.appliedRulePriority = appliedRulePriority
        self.imageDigest = imageDigest
        self.imagePushedAt = imagePushedAt
        self.imageTags = imageTags
    }
}

public enum LifecyclePolicyPreviewStatus {
    case complete
    case expired
    case failed
    case inProgress
    case sdkUnknown(String)
}

extension LifecyclePolicyPreviewStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LifecyclePolicyPreviewStatus] {
        return [
            .complete,
            .expired,
            .failed,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "COMPLETE"
        case .expired: return "EXPIRED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LifecyclePolicyPreviewStatus(rawValue: rawValue) ?? LifecyclePolicyPreviewStatus.sdkUnknown(rawValue)
    }
}

extension LifecyclePolicyPreviewSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expiringImageTotalCount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiringImageTotalCount = expiringImageTotalCount {
            try encodeContainer.encode(expiringImageTotalCount, forKey: .expiringImageTotalCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expiringImageTotalCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expiringImageTotalCount)
        expiringImageTotalCount = expiringImageTotalCountDecoded
    }
}

extension LifecyclePolicyPreviewSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecyclePolicyPreviewSummary(expiringImageTotalCount: \(String(describing: expiringImageTotalCount)))"}
}

/// <p>The summary of the lifecycle policy preview request.</p>
public struct LifecyclePolicyPreviewSummary: Equatable {
    /// <p>The number of expiring images.</p>
    public let expiringImageTotalCount: Int?

    public init (
        expiringImageTotalCount: Int? = nil
    )
    {
        self.expiringImageTotalCount = expiringImageTotalCount
    }
}

extension LifecyclePolicyRuleAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ImageActionType.self, forKey: .type)
        type = typeDecoded
    }
}

extension LifecyclePolicyRuleAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecyclePolicyRuleAction(type: \(String(describing: type)))"}
}

/// <p>The type of action to be taken.</p>
public struct LifecyclePolicyRuleAction: Equatable {
    /// <p>The type of action to be taken.</p>
    public let type: ImageActionType?

    public init (
        type: ImageActionType? = nil
    )
    {
        self.type = type
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation did not succeed because it would have exceeded a service limit for your
///             account. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/service-quotas.html">Amazon ECR Service Quotas</a> in
///             the Amazon Elastic Container Registry User Guide.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListImagesFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagStatus
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagStatus = tagStatus {
            try encodeContainer.encode(tagStatus.rawValue, forKey: .tagStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagStatusDecoded = try containerValues.decodeIfPresent(TagStatus.self, forKey: .tagStatus)
        tagStatus = tagStatusDecoded
    }
}

extension ListImagesFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImagesFilter(tagStatus: \(String(describing: tagStatus)))"}
}

/// <p>An object representing a filter on a <a>ListImages</a> operation.</p>
public struct ListImagesFilter: Equatable {
    /// <p>The tag status with which to filter your <a>ListImages</a> results. You can
    ///             filter results based on whether they are <code>TAGGED</code> or
    ///             <code>UNTAGGED</code>.</p>
    public let tagStatus: TagStatus?

    public init (
        tagStatus: TagStatus? = nil
    )
    {
        self.tagStatus = tagStatus
    }
}

public struct ListImagesInputBodyMiddleware: Middleware {
    public let id: String = "ListImagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImagesInput>
    public typealias MOutput = OperationOutput<ListImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImagesOutputError>
}

extension ListImagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImagesInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension ListImagesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct ListImagesInputHeadersMiddleware: Middleware {
    public let id: String = "ListImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImagesInput>
    public typealias MOutput = OperationOutput<ListImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImagesOutputError>
}

public struct ListImagesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImagesInput>
    public typealias MOutput = OperationOutput<ListImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImagesOutputError>
}

public struct ListImagesInput: Equatable {
    /// <p>The filter key and value with which to filter your <code>ListImages</code>
    ///             results.</p>
    public let filter: ListImagesFilter?
    /// <p>The maximum number of image results returned by <code>ListImages</code> in paginated
    ///             output. When this parameter is used, <code>ListImages</code> only returns
    ///                 <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///             response element. The remaining results of the initial request can be seen by sending
    ///             another <code>ListImages</code> request with the returned <code>nextToken</code> value.
    ///             This value can be between 1 and 1000. If this parameter is
    ///             not used, then <code>ListImages</code> returns up to 100 results and a
    ///                 <code>nextToken</code> value, if applicable.</p>
    public let maxResults: Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///                 <code>ListImages</code> request where <code>maxResults</code> was used and the
    ///             results exceeded the value of that parameter. Pagination continues from the end of the
    ///             previous results that returned the <code>nextToken</code> value. This value is
    ///                 <code>null</code> when there are no more results to return.</p>
    ///         <note>
    ///             <p>This token should be treated as an opaque identifier that is only used to
    ///                 retrieve the next items in a list and not for other programmatic purposes.</p>
    ///         </note>
    public let nextToken: String?
    /// <p>The AWS account ID associated with the registry that contains the repository in which
    ///             to list images. If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The repository with image IDs to be listed.</p>
    public let repositoryName: String?

    public init (
        filter: ListImagesFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct ListImagesInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let nextToken: String?
    public let maxResults: Int?
    public let filter: ListImagesFilter?
}

extension ListImagesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(ListImagesFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListImagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImagesOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImagesOutputResponse(imageIds: \(String(describing: imageIds)), nextToken: \(String(describing: nextToken)))"}
}

extension ListImagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListImagesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageIds = output.imageIds
            self.nextToken = output.nextToken
        } else {
            self.imageIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListImagesOutputResponse: Equatable {
    /// <p>The list of image IDs for the requested repository.</p>
    public let imageIds: [ImageIdentifier]?
    /// <p>The <code>nextToken</code> value to include in a future <code>ListImages</code>
    ///             request. When the results of a <code>ListImages</code> request exceed
    ///                 <code>maxResults</code>, this value can be used to retrieve the next page of
    ///             results. This value is <code>null</code> when there are no more results to
    ///             return.</p>
    public let nextToken: String?

    public init (
        imageIds: [ImageIdentifier]? = nil,
        nextToken: String? = nil
    )
    {
        self.imageIds = imageIds
        self.nextToken = nextToken
    }
}

struct ListImagesOutputResponseBody: Equatable {
    public let imageIds: [ImageIdentifier]?
    public let nextToken: String?
}

extension ListImagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageIds
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdsContainer = try containerValues.decodeIfPresent([ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the
    ///             only supported resource is an Amazon ECR repository.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags for the resource.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct PutImageInputBodyMiddleware: Middleware {
    public let id: String = "PutImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImageInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImageInput>
    public typealias MOutput = OperationOutput<PutImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImageOutputError>
}

extension PutImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutImageInput(imageDigest: \(String(describing: imageDigest)), imageManifest: \(String(describing: imageManifest)), imageManifestMediaType: \(String(describing: imageManifestMediaType)), imageTag: \(String(describing: imageTag)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension PutImageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageDigest
        case imageManifest
        case imageManifestMediaType
        case imageTag
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageManifest = imageManifest {
            try encodeContainer.encode(imageManifest, forKey: .imageManifest)
        }
        if let imageManifestMediaType = imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let imageTag = imageTag {
            try encodeContainer.encode(imageTag, forKey: .imageTag)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct PutImageInputHeadersMiddleware: Middleware {
    public let id: String = "PutImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImageInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImageInput>
    public typealias MOutput = OperationOutput<PutImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImageOutputError>
}

public struct PutImageInputQueryItemMiddleware: Middleware {
    public let id: String = "PutImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImageInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImageInput>
    public typealias MOutput = OperationOutput<PutImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImageOutputError>
}

public struct PutImageInput: Equatable {
    /// <p>The image digest of the image manifest corresponding to the image.</p>
    public let imageDigest: String?
    /// <p>The image manifest corresponding to the image to be uploaded.</p>
    public let imageManifest: String?
    /// <p>The media type of the image manifest. If you push an image manifest that does not
    ///             contain the <code>mediaType</code> field, you must specify the
    ///                 <code>imageManifestMediaType</code> in the request.</p>
    public let imageManifestMediaType: String?
    /// <p>The tag to associate with the image. This parameter is required for images that use
    ///             the Docker Image Manifest V2 Schema 2 or Open Container Initiative (OCI) formats.</p>
    public let imageTag: String?
    /// <p>The AWS account ID associated with the registry that contains the repository in which
    ///             to put the image. If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository in which to put the image.</p>
    public let repositoryName: String?

    public init (
        imageDigest: String? = nil,
        imageManifest: String? = nil,
        imageManifestMediaType: String? = nil,
        imageTag: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.imageDigest = imageDigest
        self.imageManifest = imageManifest
        self.imageManifestMediaType = imageManifestMediaType
        self.imageTag = imageTag
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let imageManifest: String?
    public let imageManifestMediaType: String?
    public let imageTag: String?
    public let imageDigest: String?
}

extension PutImageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageDigest
        case imageManifest
        case imageManifestMediaType
        case imageTag
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageManifestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageManifest)
        imageManifest = imageManifestDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
        let imageTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageTag)
        imageTag = imageTagDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

extension PutImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ImageAlreadyExistsException" : self = .imageAlreadyExistsException(try ImageAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ImageDigestDoesNotMatchException" : self = .imageDigestDoesNotMatchException(try ImageDigestDoesNotMatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ImageTagAlreadyExistsException" : self = .imageTagAlreadyExistsException(try ImageTagAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayersNotFoundException" : self = .layersNotFoundException(try LayersNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReferencedImagesNotFoundException" : self = .referencedImagesNotFoundException(try ReferencedImagesNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutImageOutputError: Equatable {
    case imageAlreadyExistsException(ImageAlreadyExistsException)
    case imageDigestDoesNotMatchException(ImageDigestDoesNotMatchException)
    case imageTagAlreadyExistsException(ImageTagAlreadyExistsException)
    case invalidParameterException(InvalidParameterException)
    case kmsException(KmsException)
    case layersNotFoundException(LayersNotFoundException)
    case limitExceededException(LimitExceededException)
    case referencedImagesNotFoundException(ReferencedImagesNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutImageOutputResponse(image: \(String(describing: image)))"}
}

extension PutImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutImageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.image = output.image
        } else {
            self.image = nil
        }
    }
}

public struct PutImageOutputResponse: Equatable {
    /// <p>Details of the image uploaded.</p>
    public let image: Image?

    public init (
        image: Image? = nil
    )
    {
        self.image = image
    }
}

struct PutImageOutputResponseBody: Equatable {
    public let image: Image?
}

extension PutImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case image
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(Image.self, forKey: .image)
        image = imageDecoded
    }
}

public struct PutImageScanningConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutImageScanningConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImageScanningConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImageScanningConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImageScanningConfigurationInput>
    public typealias MOutput = OperationOutput<PutImageScanningConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImageScanningConfigurationOutputError>
}

extension PutImageScanningConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutImageScanningConfigurationInput(imageScanningConfiguration: \(String(describing: imageScanningConfiguration)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension PutImageScanningConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageScanningConfiguration
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageScanningConfiguration = imageScanningConfiguration {
            try encodeContainer.encode(imageScanningConfiguration, forKey: .imageScanningConfiguration)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct PutImageScanningConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutImageScanningConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImageScanningConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImageScanningConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImageScanningConfigurationInput>
    public typealias MOutput = OperationOutput<PutImageScanningConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImageScanningConfigurationOutputError>
}

public struct PutImageScanningConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutImageScanningConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImageScanningConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImageScanningConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImageScanningConfigurationInput>
    public typealias MOutput = OperationOutput<PutImageScanningConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImageScanningConfigurationOutputError>
}

public struct PutImageScanningConfigurationInput: Equatable {
    /// <p>The image scanning configuration for the repository. This setting determines whether
    ///             images are scanned for known vulnerabilities after being pushed to the
    ///             repository.</p>
    public let imageScanningConfiguration: ImageScanningConfiguration?
    /// <p>The AWS account ID associated with the registry that contains the repository in
    ///             which to update the image scanning configuration setting.
    ///             If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository in which to update the image scanning configuration
    ///             setting.</p>
    public let repositoryName: String?

    public init (
        imageScanningConfiguration: ImageScanningConfiguration? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.imageScanningConfiguration = imageScanningConfiguration
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageScanningConfigurationInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let imageScanningConfiguration: ImageScanningConfiguration?
}

extension PutImageScanningConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageScanningConfiguration
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
    }
}

extension PutImageScanningConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutImageScanningConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutImageScanningConfigurationOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutImageScanningConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutImageScanningConfigurationOutputResponse(imageScanningConfiguration: \(String(describing: imageScanningConfiguration)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension PutImageScanningConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutImageScanningConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageScanningConfiguration = output.imageScanningConfiguration
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.imageScanningConfiguration = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct PutImageScanningConfigurationOutputResponse: Equatable {
    /// <p>The image scanning configuration setting for the repository.</p>
    public let imageScanningConfiguration: ImageScanningConfiguration?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?

    public init (
        imageScanningConfiguration: ImageScanningConfiguration? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.imageScanningConfiguration = imageScanningConfiguration
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageScanningConfigurationOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let imageScanningConfiguration: ImageScanningConfiguration?
}

extension PutImageScanningConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageScanningConfiguration
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
    }
}

public struct PutImageTagMutabilityInputBodyMiddleware: Middleware {
    public let id: String = "PutImageTagMutabilityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImageTagMutabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImageTagMutabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImageTagMutabilityInput>
    public typealias MOutput = OperationOutput<PutImageTagMutabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImageTagMutabilityOutputError>
}

extension PutImageTagMutabilityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutImageTagMutabilityInput(imageTagMutability: \(String(describing: imageTagMutability)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension PutImageTagMutabilityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageTagMutability
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageTagMutability = imageTagMutability {
            try encodeContainer.encode(imageTagMutability.rawValue, forKey: .imageTagMutability)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct PutImageTagMutabilityInputHeadersMiddleware: Middleware {
    public let id: String = "PutImageTagMutabilityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImageTagMutabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImageTagMutabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImageTagMutabilityInput>
    public typealias MOutput = OperationOutput<PutImageTagMutabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImageTagMutabilityOutputError>
}

public struct PutImageTagMutabilityInputQueryItemMiddleware: Middleware {
    public let id: String = "PutImageTagMutabilityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImageTagMutabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImageTagMutabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImageTagMutabilityInput>
    public typealias MOutput = OperationOutput<PutImageTagMutabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImageTagMutabilityOutputError>
}

public struct PutImageTagMutabilityInput: Equatable {
    /// <p>The tag mutability setting for the repository. If <code>MUTABLE</code> is specified,
    ///             image tags can be overwritten. If <code>IMMUTABLE</code> is specified, all image tags
    ///             within the repository will be immutable which will prevent them from being
    ///             overwritten.</p>
    public let imageTagMutability: ImageTagMutability?
    /// <p>The AWS account ID associated with the registry that contains the repository in which
    ///             to update the image tag mutability settings. If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository in which to update the image tag mutability
    ///             settings.</p>
    public let repositoryName: String?

    public init (
        imageTagMutability: ImageTagMutability? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.imageTagMutability = imageTagMutability
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageTagMutabilityInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let imageTagMutability: ImageTagMutability?
}

extension PutImageTagMutabilityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageTagMutability
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageTagMutabilityDecoded = try containerValues.decodeIfPresent(ImageTagMutability.self, forKey: .imageTagMutability)
        imageTagMutability = imageTagMutabilityDecoded
    }
}

extension PutImageTagMutabilityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutImageTagMutabilityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutImageTagMutabilityOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutImageTagMutabilityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutImageTagMutabilityOutputResponse(imageTagMutability: \(String(describing: imageTagMutability)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension PutImageTagMutabilityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutImageTagMutabilityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageTagMutability = output.imageTagMutability
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.imageTagMutability = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct PutImageTagMutabilityOutputResponse: Equatable {
    /// <p>The image tag mutability setting for the repository.</p>
    public let imageTagMutability: ImageTagMutability?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?

    public init (
        imageTagMutability: ImageTagMutability? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.imageTagMutability = imageTagMutability
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageTagMutabilityOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let imageTagMutability: ImageTagMutability?
}

extension PutImageTagMutabilityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageTagMutability
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageTagMutabilityDecoded = try containerValues.decodeIfPresent(ImageTagMutability.self, forKey: .imageTagMutability)
        imageTagMutability = imageTagMutabilityDecoded
    }
}

public struct PutLifecyclePolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutLifecyclePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<PutLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLifecyclePolicyOutputError>
}

extension PutLifecyclePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLifecyclePolicyInput(lifecyclePolicyText: \(String(describing: lifecyclePolicyText)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension PutLifecyclePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecyclePolicyText = lifecyclePolicyText {
            try encodeContainer.encode(lifecyclePolicyText, forKey: .lifecyclePolicyText)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct PutLifecyclePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<PutLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLifecyclePolicyOutputError>
}

public struct PutLifecyclePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<PutLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLifecyclePolicyOutputError>
}

public struct PutLifecyclePolicyInput: Equatable {
    /// <p>The JSON repository policy text to apply to the repository.</p>
    public let lifecyclePolicyText: String?
    /// <p>The AWS account ID associated with the registry that contains the repository. If you
    ///             do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository to receive the policy.</p>
    public let repositoryName: String?

    public init (
        lifecyclePolicyText: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutLifecyclePolicyInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let lifecyclePolicyText: String?
}

extension PutLifecyclePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
    }
}

extension PutLifecyclePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLifecyclePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLifecyclePolicyOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLifecyclePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLifecyclePolicyOutputResponse(lifecyclePolicyText: \(String(describing: lifecyclePolicyText)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension PutLifecyclePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutLifecyclePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lifecyclePolicyText = output.lifecyclePolicyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.lifecyclePolicyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct PutLifecyclePolicyOutputResponse: Equatable {
    /// <p>The JSON repository policy text.</p>
    public let lifecyclePolicyText: String?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?

    public init (
        lifecyclePolicyText: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutLifecyclePolicyOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let lifecyclePolicyText: String?
}

extension PutLifecyclePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
    }
}

public struct PutRegistryPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutRegistryPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRegistryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRegistryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRegistryPolicyInput>
    public typealias MOutput = OperationOutput<PutRegistryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRegistryPolicyOutputError>
}

extension PutRegistryPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRegistryPolicyInput(policyText: \(String(describing: policyText)))"}
}

extension PutRegistryPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyText
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyText = policyText {
            try encodeContainer.encode(policyText, forKey: .policyText)
        }
    }
}

public struct PutRegistryPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutRegistryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRegistryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRegistryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRegistryPolicyInput>
    public typealias MOutput = OperationOutput<PutRegistryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRegistryPolicyOutputError>
}

public struct PutRegistryPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRegistryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRegistryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRegistryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRegistryPolicyInput>
    public typealias MOutput = OperationOutput<PutRegistryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRegistryPolicyOutputError>
}

public struct PutRegistryPolicyInput: Equatable {
    /// <p>The JSON policy text to apply to your registry. The policy text follows the same
    ///             format as IAM policy text. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry-permissions.html">Registry
    ///                 permissions</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
    public let policyText: String?

    public init (
        policyText: String? = nil
    )
    {
        self.policyText = policyText
    }
}

struct PutRegistryPolicyInputBody: Equatable {
    public let policyText: String?
}

extension PutRegistryPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyText
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

extension PutRegistryPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRegistryPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRegistryPolicyOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRegistryPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRegistryPolicyOutputResponse(policyText: \(String(describing: policyText)), registryId: \(String(describing: registryId)))"}
}

extension PutRegistryPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutRegistryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyText = output.policyText
            self.registryId = output.registryId
        } else {
            self.policyText = nil
            self.registryId = nil
        }
    }
}

public struct PutRegistryPolicyOutputResponse: Equatable {
    /// <p>The JSON policy text for your registry.</p>
    public let policyText: String?
    /// <p>The registry ID.</p>
    public let registryId: String?

    public init (
        policyText: String? = nil,
        registryId: String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
    }
}

struct PutRegistryPolicyOutputResponseBody: Equatable {
    public let registryId: String?
    public let policyText: String?
}

extension PutRegistryPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyText
        case registryId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

public struct PutReplicationConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutReplicationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<PutReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutReplicationConfigurationOutputError>
}

extension PutReplicationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutReplicationConfigurationInput(replicationConfiguration: \(String(describing: replicationConfiguration)))"}
}

extension PutReplicationConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationConfiguration = replicationConfiguration {
            try encodeContainer.encode(replicationConfiguration, forKey: .replicationConfiguration)
        }
    }
}

public struct PutReplicationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutReplicationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<PutReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutReplicationConfigurationOutputError>
}

public struct PutReplicationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutReplicationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<PutReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutReplicationConfigurationOutputError>
}

public struct PutReplicationConfigurationInput: Equatable {
    /// <p>An object representing the replication configuration for a registry.</p>
    public let replicationConfiguration: ReplicationConfiguration?

    public init (
        replicationConfiguration: ReplicationConfiguration? = nil
    )
    {
        self.replicationConfiguration = replicationConfiguration
    }
}

struct PutReplicationConfigurationInputBody: Equatable {
    public let replicationConfiguration: ReplicationConfiguration?
}

extension PutReplicationConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

extension PutReplicationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutReplicationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutReplicationConfigurationOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutReplicationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutReplicationConfigurationOutputResponse(replicationConfiguration: \(String(describing: replicationConfiguration)))"}
}

extension PutReplicationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutReplicationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationConfiguration = output.replicationConfiguration
        } else {
            self.replicationConfiguration = nil
        }
    }
}

public struct PutReplicationConfigurationOutputResponse: Equatable {
    /// <p>The contents of the replication configuration for the registry.</p>
    public let replicationConfiguration: ReplicationConfiguration?

    public init (
        replicationConfiguration: ReplicationConfiguration? = nil
    )
    {
        self.replicationConfiguration = replicationConfiguration
    }
}

struct PutReplicationConfigurationOutputResponseBody: Equatable {
    public let replicationConfiguration: ReplicationConfiguration?
}

extension PutReplicationConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

extension ReferencedImagesNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReferencedImagesNotFoundException(message: \(String(describing: message)))"}
}

extension ReferencedImagesNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReferencedImagesNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The manifest list is referencing an image that does not exist.</p>
public struct ReferencedImagesNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReferencedImagesNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ReferencedImagesNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RegistryPolicyNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegistryPolicyNotFoundException(message: \(String(describing: message)))"}
}

extension RegistryPolicyNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegistryPolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The registry doesn't have an associated registry policy.</p>
public struct RegistryPolicyNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RegistryPolicyNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension RegistryPolicyNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReplicationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rules
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for replicationrulelist0 in rules {
                try rulesContainer.encode(replicationrulelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([ReplicationRule?].self, forKey: .rules)
        var rulesDecoded0:[ReplicationRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [ReplicationRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension ReplicationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationConfiguration(rules: \(String(describing: rules)))"}
}

/// <p>The replication configuration for a registry.</p>
public struct ReplicationConfiguration: Equatable {
    /// <p>An array of objects representing the replication rules for a replication
    ///             configuration. A replication configuration may contain only one replication rule but the
    ///             rule may contain one or more replication destinations.</p>
    public let rules: [ReplicationRule]?

    public init (
        rules: [ReplicationRule]? = nil
    )
    {
        self.rules = rules
    }
}

extension ReplicationDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case region
        case registryId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
    }
}

extension ReplicationDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationDestination(region: \(String(describing: region)), registryId: \(String(describing: registryId)))"}
}

/// <p>An array of objects representing the details of a replication destination.</p>
public struct ReplicationDestination: Equatable {
    /// <p>A Region to replicate to.</p>
    public let region: String?
    /// <p>The account ID of the destination registry to replicate to.</p>
    public let registryId: String?

    public init (
        region: String? = nil,
        registryId: String? = nil
    )
    {
        self.region = region
        self.registryId = registryId
    }
}

extension ReplicationRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for replicationdestinationlist0 in destinations {
                try destinationsContainer.encode(replicationdestinationlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationsContainer = try containerValues.decodeIfPresent([ReplicationDestination?].self, forKey: .destinations)
        var destinationsDecoded0:[ReplicationDestination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [ReplicationDestination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
    }
}

extension ReplicationRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationRule(destinations: \(String(describing: destinations)))"}
}

/// <p>An array of objects representing the replication destinations for a replication
///             configuration. A replication configuration may contain only one replication rule but the
///             rule may contain one or more replication destinations.</p>
public struct ReplicationRule: Equatable {
    /// <p>An array of objects representing the details of a replication destination.</p>
    public let destinations: [ReplicationDestination]?

    public init (
        destinations: [ReplicationDestination]? = nil
    )
    {
        self.destinations = destinations
    }
}

extension Repository: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case encryptionConfiguration
        case imageScanningConfiguration
        case imageTagMutability
        case registryId
        case repositoryArn
        case repositoryName
        case repositoryUri
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let imageScanningConfiguration = imageScanningConfiguration {
            try encodeContainer.encode(imageScanningConfiguration, forKey: .imageScanningConfiguration)
        }
        if let imageTagMutability = imageTagMutability {
            try encodeContainer.encode(imageTagMutability.rawValue, forKey: .imageTagMutability)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryArn = repositoryArn {
            try encodeContainer.encode(repositoryArn, forKey: .repositoryArn)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryUri = repositoryUri {
            try encodeContainer.encode(repositoryUri, forKey: .repositoryUri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryArn)
        repositoryArn = repositoryArnDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryUri)
        repositoryUri = repositoryUriDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let imageTagMutabilityDecoded = try containerValues.decodeIfPresent(ImageTagMutability.self, forKey: .imageTagMutability)
        imageTagMutability = imageTagMutabilityDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
    }
}

extension Repository: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Repository(createdAt: \(String(describing: createdAt)), encryptionConfiguration: \(String(describing: encryptionConfiguration)), imageScanningConfiguration: \(String(describing: imageScanningConfiguration)), imageTagMutability: \(String(describing: imageTagMutability)), registryId: \(String(describing: registryId)), repositoryArn: \(String(describing: repositoryArn)), repositoryName: \(String(describing: repositoryName)), repositoryUri: \(String(describing: repositoryUri)))"}
}

/// <p>An object representing a repository.</p>
public struct Repository: Equatable {
    /// <p>The date and time, in JavaScript date format, when the repository was created.</p>
    public let createdAt: Date?
    /// <p>The encryption configuration for the repository. This determines how the contents of
    ///             your repository are encrypted at rest.</p>
    public let encryptionConfiguration: EncryptionConfiguration?
    /// <p>The image scanning configuration for a repository.</p>
    public let imageScanningConfiguration: ImageScanningConfiguration?
    /// <p>The tag mutability setting for the repository.</p>
    public let imageTagMutability: ImageTagMutability?
    /// <p>The AWS account ID associated with the registry that contains the repository.</p>
    public let registryId: String?
    /// <p>The Amazon Resource Name (ARN) that identifies the repository. The ARN contains the <code>arn:aws:ecr</code> namespace, followed by the region of the
    ///     repository, AWS account ID of the repository owner, repository namespace, and repository name.
    ///     For example, <code>arn:aws:ecr:region:012345678910:repository/test</code>.</p>
    public let repositoryArn: String?
    /// <p>The name of the repository.</p>
    public let repositoryName: String?
    /// <p>The URI for the repository. You can use this URI for container image <code>push</code>
    ///             and <code>pull</code> operations.</p>
    public let repositoryUri: String?

    public init (
        createdAt: Date? = nil,
        encryptionConfiguration: EncryptionConfiguration? = nil,
        imageScanningConfiguration: ImageScanningConfiguration? = nil,
        imageTagMutability: ImageTagMutability? = nil,
        registryId: String? = nil,
        repositoryArn: String? = nil,
        repositoryName: String? = nil,
        repositoryUri: String? = nil
    )
    {
        self.createdAt = createdAt
        self.encryptionConfiguration = encryptionConfiguration
        self.imageScanningConfiguration = imageScanningConfiguration
        self.imageTagMutability = imageTagMutability
        self.registryId = registryId
        self.repositoryArn = repositoryArn
        self.repositoryName = repositoryName
        self.repositoryUri = repositoryUri
    }
}

extension RepositoryAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryAlreadyExistsException(message: \(String(describing: message)))"}
}

extension RepositoryAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified repository already exists in the specified registry.</p>
public struct RepositoryAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryNotEmptyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryNotEmptyException(message: \(String(describing: message)))"}
}

extension RepositoryNotEmptyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryNotEmptyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified repository contains images. To delete a repository that contains images,
///             you must force the deletion with the <code>force</code> parameter.</p>
public struct RepositoryNotEmptyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNotEmptyExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryNotEmptyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryNotFoundException(message: \(String(describing: message)))"}
}

extension RepositoryNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified repository could not be found. Check the spelling of the specified
///             repository and ensure that you are performing operations on the correct registry.</p>
public struct RepositoryNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryPolicyNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryPolicyNotFoundException(message: \(String(describing: message)))"}
}

extension RepositoryPolicyNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryPolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified repository and registry combination does not have an associated
///             repository policy.</p>
public struct RepositoryPolicyNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryPolicyNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryPolicyNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ScanNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScanNotFoundException(message: \(String(describing: message)))"}
}

extension ScanNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ScanNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified image scan could not be found. Ensure that image scanning is enabled on
///             the repository and try again.</p>
public struct ScanNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ScanNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ScanNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ScanStatus {
    case complete
    case failed
    case inProgress
    case sdkUnknown(String)
}

extension ScanStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScanStatus] {
        return [
            .complete,
            .failed,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "COMPLETE"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScanStatus(rawValue: rawValue) ?? ScanStatus.sdkUnknown(rawValue)
    }
}

extension ServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerException(message: \(String(describing: message)))"}
}

extension ServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>These errors are usually caused by a server-side issue.</p>
public struct ServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The error message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServerExceptionBody: Equatable {
    public let message: String?
}

extension ServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SetRepositoryPolicyInputBodyMiddleware: Middleware {
    public let id: String = "SetRepositoryPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<SetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetRepositoryPolicyOutputError>
}

extension SetRepositoryPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetRepositoryPolicyInput(force: \(String(describing: force)), policyText: \(String(describing: policyText)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension SetRepositoryPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case force
        case policyText
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let policyText = policyText {
            try encodeContainer.encode(policyText, forKey: .policyText)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct SetRepositoryPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "SetRepositoryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<SetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetRepositoryPolicyOutputError>
}

public struct SetRepositoryPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "SetRepositoryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<SetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetRepositoryPolicyOutputError>
}

public struct SetRepositoryPolicyInput: Equatable {
    /// <p>If the policy you are attempting to set on a repository policy would prevent you from
    ///             setting another policy in the future, you must force the <a>SetRepositoryPolicy</a> operation. This is intended to prevent accidental
    ///             repository lock outs.</p>
    public let force: Bool
    /// <p>The JSON repository policy text to apply to the repository. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policy-examples.html">Amazon ECR Repository
    ///                 Policies</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
    public let policyText: String?
    /// <p>The AWS account ID associated with the registry that contains the repository.
    ///             If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository to receive the policy.</p>
    public let repositoryName: String?

    public init (
        force: Bool = false,
        policyText: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.force = force
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct SetRepositoryPolicyInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let policyText: String?
    public let force: Bool
}

extension SetRepositoryPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case force
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyText)
        policyText = policyTextDecoded
        let forceDecoded = try containerValues.decode(Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension SetRepositoryPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetRepositoryPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetRepositoryPolicyOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetRepositoryPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetRepositoryPolicyOutputResponse(policyText: \(String(describing: policyText)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension SetRepositoryPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SetRepositoryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct SetRepositoryPolicyOutputResponse: Equatable {
    /// <p>The JSON repository policy text applied to the repository.</p>
    public let policyText: String?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?

    public init (
        policyText: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct SetRepositoryPolicyOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let policyText: String?
}

extension SetRepositoryPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

public struct StartImageScanInputBodyMiddleware: Middleware {
    public let id: String = "StartImageScanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImageScanInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImageScanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImageScanInput>
    public typealias MOutput = OperationOutput<StartImageScanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImageScanOutputError>
}

extension StartImageScanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartImageScanInput(imageId: \(String(describing: imageId)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension StartImageScanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageId
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct StartImageScanInputHeadersMiddleware: Middleware {
    public let id: String = "StartImageScanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImageScanInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImageScanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImageScanInput>
    public typealias MOutput = OperationOutput<StartImageScanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImageScanOutputError>
}

public struct StartImageScanInputQueryItemMiddleware: Middleware {
    public let id: String = "StartImageScanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImageScanInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImageScanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImageScanInput>
    public typealias MOutput = OperationOutput<StartImageScanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImageScanOutputError>
}

public struct StartImageScanInput: Equatable {
    /// <p>An object with identifying information for an Amazon ECR image.</p>
    public let imageId: ImageIdentifier?
    /// <p>The AWS account ID associated with the registry that contains the repository in
    ///             which to start an image scan request. If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository that contains the images to scan.</p>
    public let repositoryName: String?

    public init (
        imageId: ImageIdentifier? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.imageId = imageId
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct StartImageScanInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let imageId: ImageIdentifier?
}

extension StartImageScanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageId
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension StartImageScanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartImageScanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ImageNotFoundException" : self = .imageNotFoundException(try ImageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedImageTypeException" : self = .unsupportedImageTypeException(try UnsupportedImageTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartImageScanOutputError: Equatable {
    case imageNotFoundException(ImageNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unsupportedImageTypeException(UnsupportedImageTypeException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartImageScanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartImageScanOutputResponse(imageId: \(String(describing: imageId)), imageScanStatus: \(String(describing: imageScanStatus)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension StartImageScanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartImageScanOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageId = output.imageId
            self.imageScanStatus = output.imageScanStatus
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.imageId = nil
            self.imageScanStatus = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct StartImageScanOutputResponse: Equatable {
    /// <p>An object with identifying information for an Amazon ECR image.</p>
    public let imageId: ImageIdentifier?
    /// <p>The current state of the scan.</p>
    public let imageScanStatus: ImageScanStatus?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?

    public init (
        imageId: ImageIdentifier? = nil,
        imageScanStatus: ImageScanStatus? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.imageId = imageId
        self.imageScanStatus = imageScanStatus
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct StartImageScanOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let imageId: ImageIdentifier?
    public let imageScanStatus: ImageScanStatus?
}

extension StartImageScanOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageId
        case imageScanStatus
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imageScanStatusDecoded = try containerValues.decodeIfPresent(ImageScanStatus.self, forKey: .imageScanStatus)
        imageScanStatus = imageScanStatusDecoded
    }
}

public struct StartLifecyclePolicyPreviewInputBodyMiddleware: Middleware {
    public let id: String = "StartLifecyclePolicyPreviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartLifecyclePolicyPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<StartLifecyclePolicyPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartLifecyclePolicyPreviewInput>
    public typealias MOutput = OperationOutput<StartLifecyclePolicyPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartLifecyclePolicyPreviewOutputError>
}

extension StartLifecyclePolicyPreviewInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartLifecyclePolicyPreviewInput(lifecyclePolicyText: \(String(describing: lifecyclePolicyText)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension StartLifecyclePolicyPreviewInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecyclePolicyText = lifecyclePolicyText {
            try encodeContainer.encode(lifecyclePolicyText, forKey: .lifecyclePolicyText)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct StartLifecyclePolicyPreviewInputHeadersMiddleware: Middleware {
    public let id: String = "StartLifecyclePolicyPreviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartLifecyclePolicyPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<StartLifecyclePolicyPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartLifecyclePolicyPreviewInput>
    public typealias MOutput = OperationOutput<StartLifecyclePolicyPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartLifecyclePolicyPreviewOutputError>
}

public struct StartLifecyclePolicyPreviewInputQueryItemMiddleware: Middleware {
    public let id: String = "StartLifecyclePolicyPreviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartLifecyclePolicyPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<StartLifecyclePolicyPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartLifecyclePolicyPreviewInput>
    public typealias MOutput = OperationOutput<StartLifecyclePolicyPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartLifecyclePolicyPreviewOutputError>
}

public struct StartLifecyclePolicyPreviewInput: Equatable {
    /// <p>The policy to be evaluated against. If you do not specify a policy, the current policy
    ///             for the repository is used.</p>
    public let lifecyclePolicyText: String?
    /// <p>The AWS account ID associated with the registry that contains the repository.
    ///             If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository to be evaluated.</p>
    public let repositoryName: String?

    public init (
        lifecyclePolicyText: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct StartLifecyclePolicyPreviewInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let lifecyclePolicyText: String?
}

extension StartLifecyclePolicyPreviewInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
    }
}

extension StartLifecyclePolicyPreviewOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartLifecyclePolicyPreviewOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LifecyclePolicyNotFoundException" : self = .lifecyclePolicyNotFoundException(try LifecyclePolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LifecyclePolicyPreviewInProgressException" : self = .lifecyclePolicyPreviewInProgressException(try LifecyclePolicyPreviewInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartLifecyclePolicyPreviewOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case lifecyclePolicyNotFoundException(LifecyclePolicyNotFoundException)
    case lifecyclePolicyPreviewInProgressException(LifecyclePolicyPreviewInProgressException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartLifecyclePolicyPreviewOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartLifecyclePolicyPreviewOutputResponse(lifecyclePolicyText: \(String(describing: lifecyclePolicyText)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)), status: \(String(describing: status)))"}
}

extension StartLifecyclePolicyPreviewOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartLifecyclePolicyPreviewOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lifecyclePolicyText = output.lifecyclePolicyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.status = output.status
        } else {
            self.lifecyclePolicyText = nil
            self.registryId = nil
            self.repositoryName = nil
            self.status = nil
        }
    }
}

public struct StartLifecyclePolicyPreviewOutputResponse: Equatable {
    /// <p>The JSON repository policy text.</p>
    public let lifecyclePolicyText: String?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?
    /// <p>The status of the lifecycle policy preview request.</p>
    public let status: LifecyclePolicyPreviewStatus?

    public init (
        lifecyclePolicyText: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil,
        status: LifecyclePolicyPreviewStatus? = nil
    )
    {
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.status = status
    }
}

struct StartLifecyclePolicyPreviewOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let lifecyclePolicyText: String?
    public let status: LifecyclePolicyPreviewStatus?
}

extension StartLifecyclePolicyPreviewOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LifecyclePolicyPreviewStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>The metadata that you apply to a resource to help you categorize and organize them.
///             Each tag consists of a key and an optional value, both of which you define.
///             Tag keys can have a maximum character length of 128 characters, and tag values can have
///             a maximum length of 256 characters.</p>
public struct Tag: Equatable {
    /// <p>One part of a key-value pair that make up a tag. A <code>key</code> is a general label
    ///             that acts like a category for more specific tag values.</p>
    public let key: String?
    /// <p>The optional part of a key-value pair that make up a tag. A <code>value</code> acts as
    ///             a descriptor within a tag category (key).</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the the resource to which to add tags. Currently, the only supported
    ///             resource is an Amazon ECR repository.</p>
    public let resourceArn: String?
    /// <p>The tags to add to the resource. A tag is an array of key-value pairs.
    ///             Tag keys can have a maximum character length of 128 characters, and tag values can have
    ///             a maximum length of 256 characters.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case invalidTagParameterException(InvalidTagParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum TagStatus {
    case any
    case tagged
    case untagged
    case sdkUnknown(String)
}

extension TagStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TagStatus] {
        return [
            .any,
            .tagged,
            .untagged,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .any: return "ANY"
        case .tagged: return "TAGGED"
        case .untagged: return "UNTAGGED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TagStatus(rawValue: rawValue) ?? TagStatus.sdkUnknown(rawValue)
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The list of tags on the repository is over the limit. The maximum number of tags that
///             can be applied to a repository is 50.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedImageTypeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedImageTypeException(message: \(String(describing: message)))"}
}

extension UnsupportedImageTypeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedImageTypeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The image is of a type that cannot be scanned.</p>
public struct UnsupportedImageTypeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedImageTypeExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedImageTypeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource from which to remove tags. Currently, the only supported
    ///             resource is an Amazon ECR repository.</p>
    public let resourceArn: String?
    /// <p>The keys of the tags to be removed.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case invalidTagParameterException(InvalidTagParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UploadLayerPartInputBodyMiddleware: Middleware {
    public let id: String = "UploadLayerPartInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadLayerPartInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadLayerPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadLayerPartInput>
    public typealias MOutput = OperationOutput<UploadLayerPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadLayerPartOutputError>
}

extension UploadLayerPartInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadLayerPartInput(layerPartBlob: \(String(describing: layerPartBlob)), partFirstByte: \(String(describing: partFirstByte)), partLastByte: \(String(describing: partLastByte)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)), uploadId: \(String(describing: uploadId)))"}
}

extension UploadLayerPartInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case layerPartBlob
        case partFirstByte
        case partLastByte
        case registryId
        case repositoryName
        case uploadId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerPartBlob = layerPartBlob {
            try encodeContainer.encode(layerPartBlob.base64EncodedString(), forKey: .layerPartBlob)
        }
        if let partFirstByte = partFirstByte {
            try encodeContainer.encode(partFirstByte, forKey: .partFirstByte)
        }
        if let partLastByte = partLastByte {
            try encodeContainer.encode(partLastByte, forKey: .partLastByte)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let uploadId = uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

public struct UploadLayerPartInputHeadersMiddleware: Middleware {
    public let id: String = "UploadLayerPartInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadLayerPartInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadLayerPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadLayerPartInput>
    public typealias MOutput = OperationOutput<UploadLayerPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadLayerPartOutputError>
}

public struct UploadLayerPartInputQueryItemMiddleware: Middleware {
    public let id: String = "UploadLayerPartInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadLayerPartInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadLayerPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadLayerPartInput>
    public typealias MOutput = OperationOutput<UploadLayerPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadLayerPartOutputError>
}

public struct UploadLayerPartInput: Equatable {
    /// <p>The base64-encoded layer part payload.</p>
    public let layerPartBlob: Data?
    /// <p>The position of the first byte of the layer part witin the overall image layer.</p>
    public let partFirstByte: Int?
    /// <p>The position of the last byte of the layer part within the overall image layer.</p>
    public let partLastByte: Int?
    /// <p>The AWS account ID associated with the registry to which you are uploading layer
    ///             parts. If you do not specify a registry, the default registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository to which you are uploading layer parts.</p>
    public let repositoryName: String?
    /// <p>The upload ID from a previous <a>InitiateLayerUpload</a> operation to
    ///             associate with the layer part upload.</p>
    public let uploadId: String?

    public init (
        layerPartBlob: Data? = nil,
        partFirstByte: Int? = nil,
        partLastByte: Int? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil,
        uploadId: String? = nil
    )
    {
        self.layerPartBlob = layerPartBlob
        self.partFirstByte = partFirstByte
        self.partLastByte = partLastByte
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct UploadLayerPartInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let uploadId: String?
    public let partFirstByte: Int?
    public let partLastByte: Int?
    public let layerPartBlob: Data?
}

extension UploadLayerPartInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layerPartBlob
        case partFirstByte
        case partLastByte
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let partFirstByteDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .partFirstByte)
        partFirstByte = partFirstByteDecoded
        let partLastByteDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .partLastByte)
        partLastByte = partLastByteDecoded
        let layerPartBlobDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .layerPartBlob)
        layerPartBlob = layerPartBlobDecoded
    }
}

extension UploadLayerPartOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UploadLayerPartOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLayerPartException" : self = .invalidLayerPartException(try InvalidLayerPartException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UploadNotFoundException" : self = .uploadNotFoundException(try UploadNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UploadLayerPartOutputError: Equatable {
    case invalidLayerPartException(InvalidLayerPartException)
    case invalidParameterException(InvalidParameterException)
    case kmsException(KmsException)
    case limitExceededException(LimitExceededException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case uploadNotFoundException(UploadNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadLayerPartOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadLayerPartOutputResponse(lastByteReceived: \(String(describing: lastByteReceived)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)), uploadId: \(String(describing: uploadId)))"}
}

extension UploadLayerPartOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UploadLayerPartOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lastByteReceived = output.lastByteReceived
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.lastByteReceived = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
    }
}

public struct UploadLayerPartOutputResponse: Equatable {
    /// <p>The integer value of the last byte received in the request.</p>
    public let lastByteReceived: Int?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?
    /// <p>The upload ID associated with the request.</p>
    public let uploadId: String?

    public init (
        lastByteReceived: Int? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil,
        uploadId: String? = nil
    )
    {
        self.lastByteReceived = lastByteReceived
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct UploadLayerPartOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let uploadId: String?
    public let lastByteReceived: Int?
}

extension UploadLayerPartOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lastByteReceived
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let lastByteReceivedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .lastByteReceived)
        lastByteReceived = lastByteReceivedDecoded
    }
}

extension UploadNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadNotFoundException(message: \(String(describing: message)))"}
}

extension UploadNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UploadNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The upload could not be found, or the specified upload ID is not valid for this
///             repository.</p>
public struct UploadNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UploadNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension UploadNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was an exception validating this request.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
