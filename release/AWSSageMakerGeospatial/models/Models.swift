// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    public enum AlgorithmNameCloudRemoval: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// INTERPOLATION
        case interpolation
        case sdkUnknown(Swift.String)

        public static var allCases: [AlgorithmNameCloudRemoval] {
            return [
                .interpolation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .interpolation: return "INTERPOLATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlgorithmNameCloudRemoval(rawValue: rawValue) ?? AlgorithmNameCloudRemoval.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum AlgorithmNameGeoMosaic: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// AVERAGE
        case average
        /// BILINEAR
        case bilinear
        /// CUBIC
        case cubic
        /// CUBICSPLINE
        case cubicspline
        /// LANCZOS
        case lanczos
        /// MAX
        case max
        /// MED
        case med
        /// MIN
        case min
        /// MODE
        case mode
        /// NEAR
        case near
        /// Q1
        case q1
        /// Q3
        case q3
        /// RMS
        case rms
        /// SUM
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [AlgorithmNameGeoMosaic] {
            return [
                .average,
                .bilinear,
                .cubic,
                .cubicspline,
                .lanczos,
                .max,
                .med,
                .min,
                .mode,
                .near,
                .q1,
                .q3,
                .rms,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .bilinear: return "BILINEAR"
            case .cubic: return "CUBIC"
            case .cubicspline: return "CUBICSPLINE"
            case .lanczos: return "LANCZOS"
            case .max: return "MAX"
            case .med: return "MED"
            case .min: return "MIN"
            case .mode: return "MODE"
            case .near: return "NEAR"
            case .q1: return "Q1"
            case .q3: return "Q3"
            case .rms: return "RMS"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlgorithmNameGeoMosaic(rawValue: rawValue) ?? AlgorithmNameGeoMosaic.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum AlgorithmNameResampling: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// AVERAGE
        case average
        /// BILINEAR
        case bilinear
        /// CUBIC
        case cubic
        /// CUBICSPLINE
        case cubicspline
        /// LANCZOS
        case lanczos
        /// MAX
        case max
        /// MED
        case med
        /// MIN
        case min
        /// MODE
        case mode
        /// NEAR
        case near
        /// Q1
        case q1
        /// Q3
        case q3
        /// RMS
        case rms
        /// SUM
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [AlgorithmNameResampling] {
            return [
                .average,
                .bilinear,
                .cubic,
                .cubicspline,
                .lanczos,
                .max,
                .med,
                .min,
                .mode,
                .near,
                .q1,
                .q3,
                .rms,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .bilinear: return "BILINEAR"
            case .cubic: return "CUBIC"
            case .cubicspline: return "CUBICSPLINE"
            case .lanczos: return "LANCZOS"
            case .max: return "MAX"
            case .med: return "MED"
            case .min: return "MIN"
            case .mode: return "MODE"
            case .near: return "NEAR"
            case .q1: return "Q1"
            case .q3: return "Q3"
            case .rms: return "RMS"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlgorithmNameResampling(rawValue: rawValue) ?? AlgorithmNameResampling.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.AreaOfInterest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areaofinterestgeometry = "AreaOfInterestGeometry"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .areaofinterestgeometry(areaofinterestgeometry):
                try container.encode(areaofinterestgeometry, forKey: .areaofinterestgeometry)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let areaofinterestgeometryDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.AreaOfInterestGeometry.self, forKey: .areaofinterestgeometry)
        if let areaofinterestgeometry = areaofinterestgeometryDecoded {
            self = .areaofinterestgeometry(areaofinterestgeometry)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public enum AreaOfInterest: Swift.Equatable {
        ///
        case areaofinterestgeometry(SageMakerGeospatialClientTypes.AreaOfInterestGeometry)
        case sdkUnknown(Swift.String)
    }

}

extension SageMakerGeospatialClientTypes.AreaOfInterestGeometry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multipolygongeometry = "MultiPolygonGeometry"
        case polygongeometry = "PolygonGeometry"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .multipolygongeometry(multipolygongeometry):
                try container.encode(multipolygongeometry, forKey: .multipolygongeometry)
            case let .polygongeometry(polygongeometry):
                try container.encode(polygongeometry, forKey: .polygongeometry)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let polygongeometryDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.PolygonGeometryInput.self, forKey: .polygongeometry)
        if let polygongeometry = polygongeometryDecoded {
            self = .polygongeometry(polygongeometry)
            return
        }
        let multipolygongeometryDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.MultiPolygonGeometryInput.self, forKey: .multipolygongeometry)
        if let multipolygongeometry = multipolygongeometryDecoded {
            self = .multipolygongeometry(multipolygongeometry)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public enum AreaOfInterestGeometry: Swift.Equatable {
        ///
        case polygongeometry(SageMakerGeospatialClientTypes.PolygonGeometryInput)
        ///
        case multipolygongeometry(SageMakerGeospatialClientTypes.MultiPolygonGeometryInput)
        case sdkUnknown(Swift.String)
    }

}

extension SageMakerGeospatialClientTypes.AssetValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case href = "Href"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let href = self.href {
            try encodeContainer.encode(href, forKey: .href)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hrefDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .href)
        href = hrefDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct AssetValue: Swift.Equatable {
        ///
        public var href: Swift.String?

        public init (
            href: Swift.String? = nil
        )
        {
            self.href = href
        }
    }

}

extension SageMakerGeospatialClientTypes.BandMathConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customIndices = "CustomIndices"
        case predefinedIndices = "PredefinedIndices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customIndices = self.customIndices {
            try encodeContainer.encode(customIndices, forKey: .customIndices)
        }
        if let predefinedIndices = predefinedIndices {
            var predefinedIndicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predefinedIndices)
            for string0 in predefinedIndices {
                try predefinedIndicesContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predefinedIndicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .predefinedIndices)
        var predefinedIndicesDecoded0:[Swift.String]? = nil
        if let predefinedIndicesContainer = predefinedIndicesContainer {
            predefinedIndicesDecoded0 = [Swift.String]()
            for string0 in predefinedIndicesContainer {
                if let string0 = string0 {
                    predefinedIndicesDecoded0?.append(string0)
                }
            }
        }
        predefinedIndices = predefinedIndicesDecoded0
        let customIndicesDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.CustomIndicesInput.self, forKey: .customIndices)
        customIndices = customIndicesDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct BandMathConfigInput: Swift.Equatable {
        ///
        public var customIndices: SageMakerGeospatialClientTypes.CustomIndicesInput?
        ///
        public var predefinedIndices: [Swift.String]?

        public init (
            customIndices: SageMakerGeospatialClientTypes.CustomIndicesInput? = nil,
            predefinedIndices: [Swift.String]? = nil
        )
        {
            self.customIndices = customIndices
            self.predefinedIndices = predefinedIndices
        }
    }

}

extension SageMakerGeospatialClientTypes.CloudMaskingConfigInput: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct CloudMaskingConfigInput: Swift.Equatable {

        public init () { }
    }

}

extension SageMakerGeospatialClientTypes.CloudRemovalConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmName = "AlgorithmName"
        case interpolationValue = "InterpolationValue"
        case targetBands = "TargetBands"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmName = self.algorithmName {
            try encodeContainer.encode(algorithmName.rawValue, forKey: .algorithmName)
        }
        if let interpolationValue = self.interpolationValue {
            try encodeContainer.encode(interpolationValue, forKey: .interpolationValue)
        }
        if let targetBands = targetBands {
            var targetBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetBands)
            for string0 in targetBands {
                try targetBandsContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmNameDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.AlgorithmNameCloudRemoval.self, forKey: .algorithmName)
        algorithmName = algorithmNameDecoded
        let interpolationValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interpolationValue)
        interpolationValue = interpolationValueDecoded
        let targetBandsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetBands)
        var targetBandsDecoded0:[Swift.String]? = nil
        if let targetBandsContainer = targetBandsContainer {
            targetBandsDecoded0 = [Swift.String]()
            for string0 in targetBandsContainer {
                if let string0 = string0 {
                    targetBandsDecoded0?.append(string0)
                }
            }
        }
        targetBands = targetBandsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct CloudRemovalConfigInput: Swift.Equatable {
        /// The name of the algorithm used for cloud removal.
        public var algorithmName: SageMakerGeospatialClientTypes.AlgorithmNameCloudRemoval?
        /// The interpolation value you provide for cloud removal.
        public var interpolationValue: Swift.String?
        ///
        public var targetBands: [Swift.String]?

        public init (
            algorithmName: SageMakerGeospatialClientTypes.AlgorithmNameCloudRemoval? = nil,
            interpolationValue: Swift.String? = nil,
            targetBands: [Swift.String]? = nil
        )
        {
            self.algorithmName = algorithmName
            self.interpolationValue = interpolationValue
            self.targetBands = targetBands
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// EQUALS
        case equals
        /// NOT_EQUALS
        case notEquals
        /// STARTS_WITH
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .equals,
                .notEquals,
                .startsWith,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    ///
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension SageMakerGeospatialClientTypes.CustomIndicesInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operations = "Operations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for operation0 in operations {
                try operationsContainer.encode(operation0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.Operation?].self, forKey: .operations)
        var operationsDecoded0:[SageMakerGeospatialClientTypes.Operation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [SageMakerGeospatialClientTypes.Operation]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct CustomIndicesInput: Swift.Equatable {
        ///
        public var operations: [SageMakerGeospatialClientTypes.Operation]?

        public init (
            operations: [SageMakerGeospatialClientTypes.Operation]? = nil
        )
        {
            self.operations = operations
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum DataCollectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// PREMIUM
        case premium
        /// PUBLIC
        case `public`
        /// USER
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [DataCollectionType] {
            return [
                .premium,
                .public,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .premium: return "PREMIUM"
            case .public: return "PUBLIC"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataCollectionType(rawValue: rawValue) ?? DataCollectionType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteEarthObservationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/earth-observation-jobs/\(arn.urlPercentEncoding())"
    }
}

public struct DeleteEarthObservationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Earth Observation job being deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteEarthObservationJobInputBody: Swift.Equatable {
}

extension DeleteEarthObservationJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEarthObservationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEarthObservationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteEarthObservationJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEarthObservationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEarthObservationJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVectorEnrichmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/vector-enrichment-jobs/\(arn.urlPercentEncoding())"
    }
}

public struct DeleteVectorEnrichmentJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Vector Enrichment job being deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteVectorEnrichmentJobInputBody: Swift.Equatable {
}

extension DeleteVectorEnrichmentJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVectorEnrichmentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVectorEnrichmentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVectorEnrichmentJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVectorEnrichmentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVectorEnrichmentJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension SageMakerGeospatialClientTypes.EarthObservationJobErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EarthObservationJobErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure representing the errors in an EarthObservationJob.
    public struct EarthObservationJobErrorDetails: Swift.Equatable {
        ///
        public var message: Swift.String?
        ///
        public var type: SageMakerGeospatialClientTypes.EarthObservationJobErrorType?

        public init (
            message: Swift.String? = nil,
            type: SageMakerGeospatialClientTypes.EarthObservationJobErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum EarthObservationJobErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// CLIENT_ERROR
        case clientError
        /// SERVER_ERROR
        case serverError
        case sdkUnknown(Swift.String)

        public static var allCases: [EarthObservationJobErrorType] {
            return [
                .clientError,
                .serverError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clientError: return "CLIENT_ERROR"
            case .serverError: return "SERVER_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EarthObservationJobErrorType(rawValue: rawValue) ?? EarthObservationJobErrorType.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum EarthObservationJobExportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// FAILED
        case failed
        /// IN_PROGRESS
        case inProgress
        /// SUCCEEDED
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [EarthObservationJobExportStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EarthObservationJobExportStatus(rawValue: rawValue) ?? EarthObservationJobExportStatus.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum EarthObservationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// COMPLETED
        case completed
        /// DELETED
        case deleted
        /// DELETING
        case deleting
        /// FAILED
        case failed
        /// INITIALIZING
        case initializing
        /// IN_PROGRESS
        case inProgress
        /// STOPPED
        case stopped
        /// STOPPING
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [EarthObservationJobStatus] {
            return [
                .completed,
                .deleted,
                .deleting,
                .failed,
                .initializing,
                .inProgress,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .initializing: return "INITIALIZING"
            case .inProgress: return "IN_PROGRESS"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EarthObservationJobStatus(rawValue: rawValue) ?? EarthObservationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.EoCloudCoverInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lowerBound = "LowerBound"
        case upperBound = "UpperBound"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lowerBound = self.lowerBound {
            try encodeContainer.encode(lowerBound, forKey: .lowerBound)
        }
        if let upperBound = self.upperBound {
            try encodeContainer.encode(upperBound, forKey: .upperBound)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lowerBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .lowerBound)
        lowerBound = lowerBoundDecoded
        let upperBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .upperBound)
        upperBound = upperBoundDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct EoCloudCoverInput: Swift.Equatable {
        ///
        /// This member is required.
        public var lowerBound: Swift.Float?
        ///
        /// This member is required.
        public var upperBound: Swift.Float?

        public init (
            lowerBound: Swift.Float? = nil,
            upperBound: Swift.Float? = nil
        )
        {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }
    }

}

extension SageMakerGeospatialClientTypes.EojDataSourceConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3data = "S3Data"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3data(s3data):
                try container.encode(s3data, forKey: .s3data)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3dataDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.S3DataInput.self, forKey: .s3data)
        if let s3data = s3dataDecoded {
            self = .s3data(s3data)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public enum EojDataSourceConfigInput: Swift.Equatable {
        ///
        case s3data(SageMakerGeospatialClientTypes.S3DataInput)
        case sdkUnknown(Swift.String)
    }

}

extension ExportEarthObservationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case executionRoleArn = "ExecutionRoleArn"
        case exportSourceImages = "ExportSourceImages"
        case outputConfig = "OutputConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let exportSourceImages = self.exportSourceImages {
            try encodeContainer.encode(exportSourceImages, forKey: .exportSourceImages)
        }
        if let outputConfig = self.outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
    }
}

extension ExportEarthObservationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/export-earth-observation-job"
    }
}

public struct ExportEarthObservationJobInput: Swift.Equatable {
    /// The input Amazon Resource Name (ARN) of the Earth Observation job being exported.
    /// This member is required.
    public var arn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The source images provided to the Earth Observation job being exported.
    public var exportSourceImages: Swift.Bool?
    /// An object containing information about the output file.
    /// This member is required.
    public var outputConfig: SageMakerGeospatialClientTypes.OutputConfigInput?

    public init (
        arn: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        exportSourceImages: Swift.Bool? = nil,
        outputConfig: SageMakerGeospatialClientTypes.OutputConfigInput? = nil
    )
    {
        self.arn = arn
        self.executionRoleArn = executionRoleArn
        self.exportSourceImages = exportSourceImages
        self.outputConfig = outputConfig
    }
}

struct ExportEarthObservationJobInputBody: Swift.Equatable {
    let arn: Swift.String?
    let executionRoleArn: Swift.String?
    let outputConfig: SageMakerGeospatialClientTypes.OutputConfigInput?
    let exportSourceImages: Swift.Bool?
}

extension ExportEarthObservationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case executionRoleArn = "ExecutionRoleArn"
        case exportSourceImages = "ExportSourceImages"
        case outputConfig = "OutputConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.OutputConfigInput.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let exportSourceImagesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .exportSourceImages)
        exportSourceImages = exportSourceImagesDecoded
    }
}

extension ExportEarthObservationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportEarthObservationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExportEarthObservationJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportEarthObservationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExportEarthObservationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.executionRoleArn = output.executionRoleArn
            self.exportSourceImages = output.exportSourceImages
            self.exportStatus = output.exportStatus
            self.outputConfig = output.outputConfig
        } else {
            self.arn = nil
            self.creationTime = nil
            self.executionRoleArn = nil
            self.exportSourceImages = nil
            self.exportStatus = nil
            self.outputConfig = nil
        }
    }
}

public struct ExportEarthObservationJobOutputResponse: Swift.Equatable {
    /// The output Amazon Resource Name (ARN) of the Earth Observation job being exported.
    /// This member is required.
    public var arn: Swift.String?
    /// The creation time.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The source images provided to the Earth Observation job being exported.
    public var exportSourceImages: Swift.Bool?
    /// The status of the results of the Earth Observation job being exported.
    /// This member is required.
    public var exportStatus: SageMakerGeospatialClientTypes.EarthObservationJobExportStatus?
    /// An object containing information about the output file.
    /// This member is required.
    public var outputConfig: SageMakerGeospatialClientTypes.OutputConfigInput?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        executionRoleArn: Swift.String? = nil,
        exportSourceImages: Swift.Bool? = nil,
        exportStatus: SageMakerGeospatialClientTypes.EarthObservationJobExportStatus? = nil,
        outputConfig: SageMakerGeospatialClientTypes.OutputConfigInput? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.executionRoleArn = executionRoleArn
        self.exportSourceImages = exportSourceImages
        self.exportStatus = exportStatus
        self.outputConfig = outputConfig
    }
}

struct ExportEarthObservationJobOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let exportStatus: SageMakerGeospatialClientTypes.EarthObservationJobExportStatus?
    let executionRoleArn: Swift.String?
    let outputConfig: SageMakerGeospatialClientTypes.OutputConfigInput?
    let exportSourceImages: Swift.Bool?
}

extension ExportEarthObservationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case executionRoleArn = "ExecutionRoleArn"
        case exportSourceImages = "ExportSourceImages"
        case exportStatus = "ExportStatus"
        case outputConfig = "OutputConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EarthObservationJobExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.OutputConfigInput.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let exportSourceImagesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .exportSourceImages)
        exportSourceImages = exportSourceImagesDecoded
    }
}

extension SageMakerGeospatialClientTypes.ExportErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportResults = "ExportResults"
        case exportSourceImages = "ExportSourceImages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportResults = self.exportResults {
            try encodeContainer.encode(exportResults, forKey: .exportResults)
        }
        if let exportSourceImages = self.exportSourceImages {
            try encodeContainer.encode(exportSourceImages, forKey: .exportSourceImages)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportResultsDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.ExportErrorDetailsOutput.self, forKey: .exportResults)
        exportResults = exportResultsDecoded
        let exportSourceImagesDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.ExportErrorDetailsOutput.self, forKey: .exportSourceImages)
        exportSourceImages = exportSourceImagesDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure for returning the export error details in a GetEarthObservationJob.
    public struct ExportErrorDetails: Swift.Equatable {
        ///
        public var exportResults: SageMakerGeospatialClientTypes.ExportErrorDetailsOutput?
        ///
        public var exportSourceImages: SageMakerGeospatialClientTypes.ExportErrorDetailsOutput?

        public init (
            exportResults: SageMakerGeospatialClientTypes.ExportErrorDetailsOutput? = nil,
            exportSourceImages: SageMakerGeospatialClientTypes.ExportErrorDetailsOutput? = nil
        )
        {
            self.exportResults = exportResults
            self.exportSourceImages = exportSourceImages
        }
    }

}

extension SageMakerGeospatialClientTypes.ExportErrorDetailsOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.ExportErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct ExportErrorDetailsOutput: Swift.Equatable {
        ///
        public var message: Swift.String?
        ///
        public var type: SageMakerGeospatialClientTypes.ExportErrorType?

        public init (
            message: Swift.String? = nil,
            type: SageMakerGeospatialClientTypes.ExportErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum ExportErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// CLIENT_ERROR
        case clientError
        /// SERVER_ERROR
        case serverError
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportErrorType] {
            return [
                .clientError,
                .serverError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clientError: return "CLIENT_ERROR"
            case .serverError: return "SERVER_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExportErrorType(rawValue: rawValue) ?? ExportErrorType.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.ExportS3DataInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct ExportS3DataInput: Swift.Equatable {
        /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
        public var kmsKeyId: Swift.String?
        /// The URL to the Amazon S3 data input.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }
    }

}

extension ExportVectorEnrichmentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case executionRoleArn = "ExecutionRoleArn"
        case outputConfig = "OutputConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let outputConfig = self.outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
    }
}

extension ExportVectorEnrichmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/export-vector-enrichment-jobs"
    }
}

public struct ExportVectorEnrichmentJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
    /// This member is required.
    public var arn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM rolewith permission to upload to the location in OutputConfig.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// Output location information for exporting Vector Enrichment Job results.
    /// This member is required.
    public var outputConfig: SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig?

    public init (
        arn: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        outputConfig: SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig? = nil
    )
    {
        self.arn = arn
        self.executionRoleArn = executionRoleArn
        self.outputConfig = outputConfig
    }
}

struct ExportVectorEnrichmentJobInputBody: Swift.Equatable {
    let arn: Swift.String?
    let executionRoleArn: Swift.String?
    let outputConfig: SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig?
}

extension ExportVectorEnrichmentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case executionRoleArn = "ExecutionRoleArn"
        case outputConfig = "OutputConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
    }
}

extension SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Data = "S3Data"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Data = self.s3Data {
            try encodeContainer.encode(s3Data, forKey: .s3Data)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobS3Data.self, forKey: .s3Data)
        s3Data = s3DataDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// An object containing information about the output file.
    public struct ExportVectorEnrichmentJobOutputConfig: Swift.Equatable {
        ///
        /// This member is required.
        public var s3Data: SageMakerGeospatialClientTypes.VectorEnrichmentJobS3Data?

        public init (
            s3Data: SageMakerGeospatialClientTypes.VectorEnrichmentJobS3Data? = nil
        )
        {
            self.s3Data = s3Data
        }
    }

}

extension ExportVectorEnrichmentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportVectorEnrichmentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExportVectorEnrichmentJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportVectorEnrichmentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExportVectorEnrichmentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.executionRoleArn = output.executionRoleArn
            self.exportStatus = output.exportStatus
            self.outputConfig = output.outputConfig
        } else {
            self.arn = nil
            self.creationTime = nil
            self.executionRoleArn = nil
            self.exportStatus = nil
            self.outputConfig = nil
        }
    }
}

public struct ExportVectorEnrichmentJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Vector Enrichment job being exported.
    /// This member is required.
    public var arn: Swift.String?
    /// The creation time.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the IAM role with permission to upload to the location in OutputConfig.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The status of the results the Vector Enrichment job being exported.
    /// This member is required.
    public var exportStatus: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportStatus?
    /// Output location information for exporting Vector Enrichment Job results.
    /// This member is required.
    public var outputConfig: SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        executionRoleArn: Swift.String? = nil,
        exportStatus: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportStatus? = nil,
        outputConfig: SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.executionRoleArn = executionRoleArn
        self.exportStatus = exportStatus
        self.outputConfig = outputConfig
    }
}

struct ExportVectorEnrichmentJobOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let executionRoleArn: Swift.String?
    let exportStatus: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportStatus?
    let outputConfig: SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig?
}

extension ExportVectorEnrichmentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case executionRoleArn = "ExecutionRoleArn"
        case exportStatus = "ExportStatus"
        case outputConfig = "OutputConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.ExportVectorEnrichmentJobOutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
    }
}

extension SageMakerGeospatialClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximum = "Maximum"
        case minimum = "Minimum"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximum = self.maximum {
            try encodeContainer.encode(maximum, forKey: .maximum)
        }
        if let minimum = self.minimum {
            try encodeContainer.encode(minimum, forKey: .minimum)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let minimumDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .minimum)
        minimum = minimumDecoded
        let maximumDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .maximum)
        maximum = maximumDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The structure representing the filters supported by a RasterDataCollection.
    public struct Filter: Swift.Equatable {
        /// The maximum value of the filter.
        public var maximum: Swift.Float?
        /// The minimum value of the filter.
        public var minimum: Swift.Float?
        /// The name of the filter.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the filter being used.
        /// This member is required.
        public var type: Swift.String?

        public init (
            maximum: Swift.Float? = nil,
            minimum: Swift.Float? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.maximum = maximum
            self.minimum = minimum
            self.name = name
            self.type = type
        }
    }

}

extension SageMakerGeospatialClientTypes.GeoMosaicConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmName = "AlgorithmName"
        case targetBands = "TargetBands"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmName = self.algorithmName {
            try encodeContainer.encode(algorithmName.rawValue, forKey: .algorithmName)
        }
        if let targetBands = targetBands {
            var targetBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetBands)
            for string0 in targetBands {
                try targetBandsContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmNameDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.AlgorithmNameGeoMosaic.self, forKey: .algorithmName)
        algorithmName = algorithmNameDecoded
        let targetBandsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetBands)
        var targetBandsDecoded0:[Swift.String]? = nil
        if let targetBandsContainer = targetBandsContainer {
            targetBandsDecoded0 = [Swift.String]()
            for string0 in targetBandsContainer {
                if let string0 = string0 {
                    targetBandsDecoded0?.append(string0)
                }
            }
        }
        targetBands = targetBandsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    /// Input configuration information for the geomosaic.
    public struct GeoMosaicConfigInput: Swift.Equatable {
        /// The name of the algorithm being used for geomosaic.
        public var algorithmName: SageMakerGeospatialClientTypes.AlgorithmNameGeoMosaic?
        /// The target bands for geomosaic.
        public var targetBands: [Swift.String]?

        public init (
            algorithmName: SageMakerGeospatialClientTypes.AlgorithmNameGeoMosaic? = nil,
            targetBands: [Swift.String]? = nil
        )
        {
            self.algorithmName = algorithmName
            self.targetBands = targetBands
        }
    }

}

extension SageMakerGeospatialClientTypes.Geometry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coordinates = "Coordinates"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coordinates = coordinates {
            var coordinatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .coordinates)
            for linearring0 in coordinates {
                var linearring0Container = coordinatesContainer.nestedUnkeyedContainer()
                for position1 in linearring0 {
                    var position1Container = linearring0Container.nestedUnkeyedContainer()
                    for double2 in position1 {
                        try position1Container.encode(double2)
                    }
                }
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let coordinatesContainer = try containerValues.decodeIfPresent([[[Swift.Double?]?]?].self, forKey: .coordinates)
        var coordinatesDecoded0:[[[Swift.Double]]]? = nil
        if let coordinatesContainer = coordinatesContainer {
            coordinatesDecoded0 = [[[Swift.Double]]]()
            for list0 in coordinatesContainer {
                var list0Decoded0: [[Swift.Double]]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [[Swift.Double]]()
                    for list1 in list0 {
                        var list1Decoded1: [Swift.Double]? = nil
                        if let list1 = list1 {
                            list1Decoded1 = [Swift.Double]()
                            for double2 in list1 {
                                if let double2 = double2 {
                                    list1Decoded1?.append(double2)
                                }
                            }
                        }
                        if let list1Decoded1 = list1Decoded1 {
                            list0Decoded0?.append(list1Decoded1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    coordinatesDecoded0?.append(list0Decoded0)
                }
            }
        }
        coordinates = coordinatesDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct Geometry: Swift.Equatable {
        ///
        /// This member is required.
        public var coordinates: [[[Swift.Double]]]?
        ///
        /// This member is required.
        public var type: Swift.String?

        public init (
            coordinates: [[[Swift.Double]]]? = nil,
            type: Swift.String? = nil
        )
        {
            self.coordinates = coordinates
            self.type = type
        }
    }

}

extension GetEarthObservationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/earth-observation-jobs/\(arn.urlPercentEncoding())"
    }
}

public struct GetEarthObservationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Earth Observation job.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetEarthObservationJobInputBody: Swift.Equatable {
}

extension GetEarthObservationJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEarthObservationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEarthObservationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetEarthObservationJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEarthObservationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetEarthObservationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.durationInSeconds = output.durationInSeconds
            self.errorDetails = output.errorDetails
            self.executionRoleArn = output.executionRoleArn
            self.exportErrorDetails = output.exportErrorDetails
            self.exportStatus = output.exportStatus
            self.inputConfig = output.inputConfig
            self.jobConfig = output.jobConfig
            self.kmsKeyId = output.kmsKeyId
            self.name = output.name
            self.outputBands = output.outputBands
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTime = nil
            self.durationInSeconds = nil
            self.errorDetails = nil
            self.executionRoleArn = nil
            self.exportErrorDetails = nil
            self.exportStatus = nil
            self.inputConfig = nil
            self.jobConfig = nil
            self.kmsKeyId = nil
            self.name = nil
            self.outputBands = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetEarthObservationJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Earth Observation job.
    /// This member is required.
    public var arn: Swift.String?
    /// The creation time of the initiated Earth Observation job.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The duration of Earth Observation job, in seconds.
    /// This member is required.
    public var durationInSeconds: Swift.Int?
    /// Details about the errors generated during the Earth Observation job.
    public var errorDetails: SageMakerGeospatialClientTypes.EarthObservationJobErrorDetails?
    /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
    public var executionRoleArn: Swift.String?
    /// Details about the errors generated during ExportEarthObservationJob.
    public var exportErrorDetails: SageMakerGeospatialClientTypes.ExportErrorDetails?
    /// The status of the Earth Observation job.
    public var exportStatus: SageMakerGeospatialClientTypes.EarthObservationJobExportStatus?
    /// Input data for the Earth Observation job.
    /// This member is required.
    public var inputConfig: SageMakerGeospatialClientTypes.InputConfigOutput?
    /// An object containing information about the job configuration.
    /// This member is required.
    public var jobConfig: SageMakerGeospatialClientTypes.JobConfigInput?
    /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
    public var kmsKeyId: Swift.String?
    /// The name of the Earth Observation job.
    /// This member is required.
    public var name: Swift.String?
    ///
    public var outputBands: [SageMakerGeospatialClientTypes.OutputBand]?
    /// The status of a previously initiated Earth Observation job.
    /// This member is required.
    public var status: SageMakerGeospatialClientTypes.EarthObservationJobStatus?
    /// Each tag consists of a key and a value.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        durationInSeconds: Swift.Int? = nil,
        errorDetails: SageMakerGeospatialClientTypes.EarthObservationJobErrorDetails? = nil,
        executionRoleArn: Swift.String? = nil,
        exportErrorDetails: SageMakerGeospatialClientTypes.ExportErrorDetails? = nil,
        exportStatus: SageMakerGeospatialClientTypes.EarthObservationJobExportStatus? = nil,
        inputConfig: SageMakerGeospatialClientTypes.InputConfigOutput? = nil,
        jobConfig: SageMakerGeospatialClientTypes.JobConfigInput? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        outputBands: [SageMakerGeospatialClientTypes.OutputBand]? = nil,
        status: SageMakerGeospatialClientTypes.EarthObservationJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.durationInSeconds = durationInSeconds
        self.errorDetails = errorDetails
        self.executionRoleArn = executionRoleArn
        self.exportErrorDetails = exportErrorDetails
        self.exportStatus = exportStatus
        self.inputConfig = inputConfig
        self.jobConfig = jobConfig
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.outputBands = outputBands
        self.status = status
        self.tags = tags
    }
}

struct GetEarthObservationJobOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let creationTime: ClientRuntime.Date?
    let durationInSeconds: Swift.Int?
    let status: SageMakerGeospatialClientTypes.EarthObservationJobStatus?
    let kmsKeyId: Swift.String?
    let inputConfig: SageMakerGeospatialClientTypes.InputConfigOutput?
    let jobConfig: SageMakerGeospatialClientTypes.JobConfigInput?
    let outputBands: [SageMakerGeospatialClientTypes.OutputBand]?
    let executionRoleArn: Swift.String?
    let errorDetails: SageMakerGeospatialClientTypes.EarthObservationJobErrorDetails?
    let exportStatus: SageMakerGeospatialClientTypes.EarthObservationJobExportStatus?
    let exportErrorDetails: SageMakerGeospatialClientTypes.ExportErrorDetails?
    let tags: [Swift.String:Swift.String]?
}

extension GetEarthObservationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case durationInSeconds = "DurationInSeconds"
        case errorDetails = "ErrorDetails"
        case executionRoleArn = "ExecutionRoleArn"
        case exportErrorDetails = "ExportErrorDetails"
        case exportStatus = "ExportStatus"
        case inputConfig = "InputConfig"
        case jobConfig = "JobConfig"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case outputBands = "OutputBands"
        case status = "Status"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EarthObservationJobStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.InputConfigOutput.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
        let jobConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.JobConfigInput.self, forKey: .jobConfig)
        jobConfig = jobConfigDecoded
        let outputBandsContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.OutputBand?].self, forKey: .outputBands)
        var outputBandsDecoded0:[SageMakerGeospatialClientTypes.OutputBand]? = nil
        if let outputBandsContainer = outputBandsContainer {
            outputBandsDecoded0 = [SageMakerGeospatialClientTypes.OutputBand]()
            for structure0 in outputBandsContainer {
                if let structure0 = structure0 {
                    outputBandsDecoded0?.append(structure0)
                }
            }
        }
        outputBands = outputBandsDecoded0
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EarthObservationJobErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EarthObservationJobExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let exportErrorDetailsDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.ExportErrorDetails.self, forKey: .exportErrorDetails)
        exportErrorDetails = exportErrorDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetRasterDataCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/raster-data-collection/\(arn.urlPercentEncoding())"
    }
}

public struct GetRasterDataCollectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the raster data collection.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetRasterDataCollectionInputBody: Swift.Equatable {
}

extension GetRasterDataCollectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRasterDataCollectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRasterDataCollectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRasterDataCollectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRasterDataCollectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRasterDataCollectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.descriptionPageUrl = output.descriptionPageUrl
            self.imageSourceBands = output.imageSourceBands
            self.name = output.name
            self.supportedFilters = output.supportedFilters
            self.tags = output.tags
            self.type = output.type
        } else {
            self.arn = nil
            self.description = nil
            self.descriptionPageUrl = nil
            self.imageSourceBands = nil
            self.name = nil
            self.supportedFilters = nil
            self.tags = nil
            self.type = nil
        }
    }
}

public struct GetRasterDataCollectionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the raster data collection.
    /// This member is required.
    public var arn: Swift.String?
    /// A description of the raster data collection.
    /// This member is required.
    public var description: Swift.String?
    /// The URL of the description page.
    /// This member is required.
    public var descriptionPageUrl: Swift.String?
    ///
    /// This member is required.
    public var imageSourceBands: [Swift.String]?
    /// The name of the raster data collection.
    /// This member is required.
    public var name: Swift.String?
    /// The filters supported by the raster data collection.
    /// This member is required.
    public var supportedFilters: [SageMakerGeospatialClientTypes.Filter]?
    /// Each tag consists of a key and a value.
    public var tags: [Swift.String:Swift.String]?
    /// The raster data collection type.
    /// This member is required.
    public var type: SageMakerGeospatialClientTypes.DataCollectionType?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        descriptionPageUrl: Swift.String? = nil,
        imageSourceBands: [Swift.String]? = nil,
        name: Swift.String? = nil,
        supportedFilters: [SageMakerGeospatialClientTypes.Filter]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: SageMakerGeospatialClientTypes.DataCollectionType? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.descriptionPageUrl = descriptionPageUrl
        self.imageSourceBands = imageSourceBands
        self.name = name
        self.supportedFilters = supportedFilters
        self.tags = tags
        self.type = type
    }
}

struct GetRasterDataCollectionOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let type: SageMakerGeospatialClientTypes.DataCollectionType?
    let description: Swift.String?
    let descriptionPageUrl: Swift.String?
    let supportedFilters: [SageMakerGeospatialClientTypes.Filter]?
    let imageSourceBands: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension GetRasterDataCollectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case descriptionPageUrl = "DescriptionPageUrl"
        case imageSourceBands = "ImageSourceBands"
        case name = "Name"
        case supportedFilters = "SupportedFilters"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.DataCollectionType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let descriptionPageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .descriptionPageUrl)
        descriptionPageUrl = descriptionPageUrlDecoded
        let supportedFiltersContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.Filter?].self, forKey: .supportedFilters)
        var supportedFiltersDecoded0:[SageMakerGeospatialClientTypes.Filter]? = nil
        if let supportedFiltersContainer = supportedFiltersContainer {
            supportedFiltersDecoded0 = [SageMakerGeospatialClientTypes.Filter]()
            for structure0 in supportedFiltersContainer {
                if let structure0 = structure0 {
                    supportedFiltersDecoded0?.append(structure0)
                }
            }
        }
        supportedFilters = supportedFiltersDecoded0
        let imageSourceBandsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageSourceBands)
        var imageSourceBandsDecoded0:[Swift.String]? = nil
        if let imageSourceBandsContainer = imageSourceBandsContainer {
            imageSourceBandsDecoded0 = [Swift.String]()
            for string0 in imageSourceBandsContainer {
                if let string0 = string0 {
                    imageSourceBandsDecoded0?.append(string0)
                }
            }
        }
        imageSourceBands = imageSourceBandsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetTileInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imageAssets = imageAssets else {
                let message = "Creating a URL Query Item failed. imageAssets is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            imageAssets.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "ImageAssets".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            if let imageMask = imageMask {
                let imageMaskQueryItem = ClientRuntime.URLQueryItem(name: "ImageMask".urlPercentEncoding(), value: Swift.String(imageMask).urlPercentEncoding())
                items.append(imageMaskQueryItem)
            }
            guard let target = target else {
                let message = "Creating a URL Query Item failed. target is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let targetQueryItem = ClientRuntime.URLQueryItem(name: "Target".urlPercentEncoding(), value: Swift.String(target.rawValue).urlPercentEncoding())
            items.append(targetQueryItem)
            if let propertyFilters = propertyFilters {
                let propertyFiltersQueryItem = ClientRuntime.URLQueryItem(name: "PropertyFilters".urlPercentEncoding(), value: Swift.String(propertyFilters).urlPercentEncoding())
                items.append(propertyFiltersQueryItem)
            }
            if let outputDataType = outputDataType {
                let outputDataTypeQueryItem = ClientRuntime.URLQueryItem(name: "OutputDataType".urlPercentEncoding(), value: Swift.String(outputDataType.rawValue).urlPercentEncoding())
                items.append(outputDataTypeQueryItem)
            }
            if let timeRangeFilter = timeRangeFilter {
                let timeRangeFilterQueryItem = ClientRuntime.URLQueryItem(name: "TimeRangeFilter".urlPercentEncoding(), value: Swift.String(timeRangeFilter).urlPercentEncoding())
                items.append(timeRangeFilterQueryItem)
            }
            if let outputFormat = outputFormat {
                let outputFormatQueryItem = ClientRuntime.URLQueryItem(name: "OutputFormat".urlPercentEncoding(), value: Swift.String(outputFormat).urlPercentEncoding())
                items.append(outputFormatQueryItem)
            }
            guard let arn = arn else {
                let message = "Creating a URL Query Item failed. arn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let arnQueryItem = ClientRuntime.URLQueryItem(name: "Arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
            items.append(arnQueryItem)
            return items
        }
    }
}

extension GetTileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let z = z else {
            return nil
        }
        guard let x = x else {
            return nil
        }
        guard let y = y else {
            return nil
        }
        return "/tile/\(z)/\(x)/\(y)"
    }
}

public struct GetTileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the tile operation.
    /// This member is required.
    public var arn: Swift.String?
    /// The particular assets or bands to tile.
    /// This member is required.
    public var imageAssets: [Swift.String]?
    /// Determines whether or not to return a valid data mask.
    public var imageMask: Swift.Bool?
    /// The output data type of the tile operation.
    public var outputDataType: SageMakerGeospatialClientTypes.OutputType?
    /// The data format of the output tile. The formats include .npy, .png and .jpg.
    public var outputFormat: Swift.String?
    /// Property filters for the imagery to tile.
    public var propertyFilters: Swift.String?
    /// Determines what part of the Earth Observation job to tile. 'INPUT' or 'OUTPUT' are the valid options.
    /// This member is required.
    public var target: SageMakerGeospatialClientTypes.TargetOptions?
    /// Time range filter applied to imagery to find the images to tile.
    public var timeRangeFilter: Swift.String?
    /// The x coordinate of the tile input.
    /// This member is required.
    public var x: Swift.Int?
    /// The y coordinate of the tile input.
    /// This member is required.
    public var y: Swift.Int?
    /// The z coordinate of the tile input.
    /// This member is required.
    public var z: Swift.Int?

    public init (
        arn: Swift.String? = nil,
        imageAssets: [Swift.String]? = nil,
        imageMask: Swift.Bool? = nil,
        outputDataType: SageMakerGeospatialClientTypes.OutputType? = nil,
        outputFormat: Swift.String? = nil,
        propertyFilters: Swift.String? = nil,
        target: SageMakerGeospatialClientTypes.TargetOptions? = nil,
        timeRangeFilter: Swift.String? = nil,
        x: Swift.Int? = nil,
        y: Swift.Int? = nil,
        z: Swift.Int? = nil
    )
    {
        self.arn = arn
        self.imageAssets = imageAssets
        self.imageMask = imageMask
        self.outputDataType = outputDataType
        self.outputFormat = outputFormat
        self.propertyFilters = propertyFilters
        self.target = target
        self.timeRangeFilter = timeRangeFilter
        self.x = x
        self.y = y
        self.z = z
    }
}

struct GetTileInputBody: Swift.Equatable {
}

extension GetTileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            self.binaryFile = ByteStream.from(data: data)
        } else {
            self.binaryFile = nil
        }
    }
}

public struct GetTileOutputResponse: Swift.Equatable {
    /// The output binary file.
    public var binaryFile: ClientRuntime.ByteStream?

    public init (
        binaryFile: ClientRuntime.ByteStream? = nil
    )
    {
        self.binaryFile = binaryFile
    }
}

struct GetTileOutputResponseBody: Swift.Equatable {
    let binaryFile: ClientRuntime.ByteStream?
}

extension GetTileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binaryFile = "BinaryFile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let binaryFileDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .binaryFile)
        binaryFile = binaryFileDecoded
    }
}

extension GetVectorEnrichmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/vector-enrichment-jobs/\(arn.urlPercentEncoding())"
    }
}

public struct GetVectorEnrichmentJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetVectorEnrichmentJobInputBody: Swift.Equatable {
}

extension GetVectorEnrichmentJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVectorEnrichmentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVectorEnrichmentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVectorEnrichmentJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVectorEnrichmentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVectorEnrichmentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.durationInSeconds = output.durationInSeconds
            self.errorDetails = output.errorDetails
            self.executionRoleArn = output.executionRoleArn
            self.exportErrorDetails = output.exportErrorDetails
            self.exportStatus = output.exportStatus
            self.inputConfig = output.inputConfig
            self.jobConfig = output.jobConfig
            self.kmsKeyId = output.kmsKeyId
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
            self.type = output.type
        } else {
            self.arn = nil
            self.creationTime = nil
            self.durationInSeconds = nil
            self.errorDetails = nil
            self.executionRoleArn = nil
            self.exportErrorDetails = nil
            self.exportStatus = nil
            self.inputConfig = nil
            self.jobConfig = nil
            self.kmsKeyId = nil
            self.name = nil
            self.status = nil
            self.tags = nil
            self.type = nil
        }
    }
}

public struct GetVectorEnrichmentJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
    /// This member is required.
    public var arn: Swift.String?
    /// The creation time.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The duration of the Vector Enrichment job, in seconds.
    /// This member is required.
    public var durationInSeconds: Swift.Int?
    /// Details about the errors generated during the Vector Enrichment job.
    public var errorDetails: SageMakerGeospatialClientTypes.VectorEnrichmentJobErrorDetails?
    /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// Details about the errors generated during the ExportVectorEnrichmentJob.
    public var exportErrorDetails: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportErrorDetails?
    /// The export status of the Vector Enrichment job being initiated.
    public var exportStatus: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportStatus?
    /// Input configuration information for the Vector Enrichment job.
    /// This member is required.
    public var inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig?
    /// An object containing information about the job configuration.
    /// This member is required.
    public var jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig?
    /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
    public var kmsKeyId: Swift.String?
    /// The name of the Vector Enrichment job.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the initiated Vector Enrichment job.
    /// This member is required.
    public var status: SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus?
    /// Each tag consists of a key and a value.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the Vector Enrichment job being initiated.
    /// This member is required.
    public var type: SageMakerGeospatialClientTypes.VectorEnrichmentJobType?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        durationInSeconds: Swift.Int? = nil,
        errorDetails: SageMakerGeospatialClientTypes.VectorEnrichmentJobErrorDetails? = nil,
        executionRoleArn: Swift.String? = nil,
        exportErrorDetails: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportErrorDetails? = nil,
        exportStatus: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportStatus? = nil,
        inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig? = nil,
        jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: SageMakerGeospatialClientTypes.VectorEnrichmentJobType? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.durationInSeconds = durationInSeconds
        self.errorDetails = errorDetails
        self.executionRoleArn = executionRoleArn
        self.exportErrorDetails = exportErrorDetails
        self.exportStatus = exportStatus
        self.inputConfig = inputConfig
        self.jobConfig = jobConfig
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.status = status
        self.tags = tags
        self.type = type
    }
}

struct GetVectorEnrichmentJobOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let type: SageMakerGeospatialClientTypes.VectorEnrichmentJobType?
    let name: Swift.String?
    let creationTime: ClientRuntime.Date?
    let durationInSeconds: Swift.Int?
    let status: SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus?
    let kmsKeyId: Swift.String?
    let inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig?
    let jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig?
    let executionRoleArn: Swift.String?
    let errorDetails: SageMakerGeospatialClientTypes.VectorEnrichmentJobErrorDetails?
    let exportStatus: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportStatus?
    let exportErrorDetails: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportErrorDetails?
    let tags: [Swift.String:Swift.String]?
}

extension GetVectorEnrichmentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case durationInSeconds = "DurationInSeconds"
        case errorDetails = "ErrorDetails"
        case executionRoleArn = "ExecutionRoleArn"
        case exportErrorDetails = "ExportErrorDetails"
        case exportStatus = "ExportStatus"
        case inputConfig = "InputConfig"
        case jobConfig = "JobConfig"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case status = "Status"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
        let jobConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig.self, forKey: .jobConfig)
        jobConfig = jobConfigDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let exportErrorDetailsDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobExportErrorDetails.self, forKey: .exportErrorDetails)
        exportErrorDetails = exportErrorDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    public enum GroupBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// ALL
        case all
        /// YEARLY
        case yearly
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupBy] {
            return [
                .all,
                .yearly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .yearly: return "YEARLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupBy(rawValue: rawValue) ?? GroupBy.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.InputConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceConfig = "DataSourceConfig"
        case previousEarthObservationJobArn = "PreviousEarthObservationJobArn"
        case rasterDataCollectionQuery = "RasterDataCollectionQuery"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceConfig = self.dataSourceConfig {
            try encodeContainer.encode(dataSourceConfig, forKey: .dataSourceConfig)
        }
        if let previousEarthObservationJobArn = self.previousEarthObservationJobArn {
            try encodeContainer.encode(previousEarthObservationJobArn, forKey: .previousEarthObservationJobArn)
        }
        if let rasterDataCollectionQuery = self.rasterDataCollectionQuery {
            try encodeContainer.encode(rasterDataCollectionQuery, forKey: .rasterDataCollectionQuery)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let previousEarthObservationJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previousEarthObservationJobArn)
        previousEarthObservationJobArn = previousEarthObservationJobArnDecoded
        let dataSourceConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EojDataSourceConfigInput.self, forKey: .dataSourceConfig)
        dataSourceConfig = dataSourceConfigDecoded
        let rasterDataCollectionQueryDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.RasterDataCollectionQueryInput.self, forKey: .rasterDataCollectionQuery)
        rasterDataCollectionQuery = rasterDataCollectionQueryDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// Input configuration information.
    public struct InputConfigInput: Swift.Equatable {
        /// The location of the input data.>
        public var dataSourceConfig: SageMakerGeospatialClientTypes.EojDataSourceConfigInput?
        /// The Amazon Resource Name (ARN) of the previous Earth Observation job.
        public var previousEarthObservationJobArn: Swift.String?
        ///
        public var rasterDataCollectionQuery: SageMakerGeospatialClientTypes.RasterDataCollectionQueryInput?

        public init (
            dataSourceConfig: SageMakerGeospatialClientTypes.EojDataSourceConfigInput? = nil,
            previousEarthObservationJobArn: Swift.String? = nil,
            rasterDataCollectionQuery: SageMakerGeospatialClientTypes.RasterDataCollectionQueryInput? = nil
        )
        {
            self.dataSourceConfig = dataSourceConfig
            self.previousEarthObservationJobArn = previousEarthObservationJobArn
            self.rasterDataCollectionQuery = rasterDataCollectionQuery
        }
    }

}

extension SageMakerGeospatialClientTypes.InputConfigOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceConfig = "DataSourceConfig"
        case previousEarthObservationJobArn = "PreviousEarthObservationJobArn"
        case rasterDataCollectionQuery = "RasterDataCollectionQuery"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceConfig = self.dataSourceConfig {
            try encodeContainer.encode(dataSourceConfig, forKey: .dataSourceConfig)
        }
        if let previousEarthObservationJobArn = self.previousEarthObservationJobArn {
            try encodeContainer.encode(previousEarthObservationJobArn, forKey: .previousEarthObservationJobArn)
        }
        if let rasterDataCollectionQuery = self.rasterDataCollectionQuery {
            try encodeContainer.encode(rasterDataCollectionQuery, forKey: .rasterDataCollectionQuery)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let previousEarthObservationJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previousEarthObservationJobArn)
        previousEarthObservationJobArn = previousEarthObservationJobArnDecoded
        let dataSourceConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EojDataSourceConfigInput.self, forKey: .dataSourceConfig)
        dataSourceConfig = dataSourceConfigDecoded
        let rasterDataCollectionQueryDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.RasterDataCollectionQueryOutput.self, forKey: .rasterDataCollectionQuery)
        rasterDataCollectionQuery = rasterDataCollectionQueryDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The InputConfig for an EarthObservationJob response.
    public struct InputConfigOutput: Swift.Equatable {
        /// The location of the input data.
        public var dataSourceConfig: SageMakerGeospatialClientTypes.EojDataSourceConfigInput?
        /// The Amazon Resource Name (ARN) of the previous Earth Observation job.
        public var previousEarthObservationJobArn: Swift.String?
        ///
        public var rasterDataCollectionQuery: SageMakerGeospatialClientTypes.RasterDataCollectionQueryOutput?

        public init (
            dataSourceConfig: SageMakerGeospatialClientTypes.EojDataSourceConfigInput? = nil,
            previousEarthObservationJobArn: Swift.String? = nil,
            rasterDataCollectionQuery: SageMakerGeospatialClientTypes.RasterDataCollectionQueryOutput? = nil
        )
        {
            self.dataSourceConfig = dataSourceConfig
            self.previousEarthObservationJobArn = previousEarthObservationJobArn
            self.rasterDataCollectionQuery = rasterDataCollectionQuery
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request processing has failed because of an unknown error, exception, or failure.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    ///
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension SageMakerGeospatialClientTypes.ItemSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assets = "Assets"
        case dateTime = "DateTime"
        case geometry = "Geometry"
        case id = "Id"
        case properties = "Properties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assets = assets {
            var assetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .assets)
            for (dictKey0, assetsMap0) in assets {
                try assetsContainer.encode(assetsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dateTime = self.dateTime {
            try encodeContainer.encodeTimestamp(dateTime, format: .epochSeconds, forKey: .dateTime)
        }
        if let geometry = self.geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let properties = self.properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.Geometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let assetsContainer = try containerValues.decodeIfPresent([Swift.String: SageMakerGeospatialClientTypes.AssetValue?].self, forKey: .assets)
        var assetsDecoded0: [Swift.String:SageMakerGeospatialClientTypes.AssetValue]? = nil
        if let assetsContainer = assetsContainer {
            assetsDecoded0 = [Swift.String:SageMakerGeospatialClientTypes.AssetValue]()
            for (key0, assetvalue0) in assetsContainer {
                if let assetvalue0 = assetvalue0 {
                    assetsDecoded0?[key0] = assetvalue0
                }
            }
        }
        assets = assetsDecoded0
        let dateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateTime)
        dateTime = dateTimeDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.Properties.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// Structure representing the items in the response for SearchRasterDataCollection.
    public struct ItemSource: Swift.Equatable {
        ///
        public var assets: [Swift.String:SageMakerGeospatialClientTypes.AssetValue]?
        ///
        /// This member is required.
        public var dateTime: ClientRuntime.Date?
        ///
        /// This member is required.
        public var geometry: SageMakerGeospatialClientTypes.Geometry?
        /// A unique Id for the source item.
        /// This member is required.
        public var id: Swift.String?
        ///
        public var properties: SageMakerGeospatialClientTypes.Properties?

        public init (
            assets: [Swift.String:SageMakerGeospatialClientTypes.AssetValue]? = nil,
            dateTime: ClientRuntime.Date? = nil,
            geometry: SageMakerGeospatialClientTypes.Geometry? = nil,
            id: Swift.String? = nil,
            properties: SageMakerGeospatialClientTypes.Properties? = nil
        )
        {
            self.assets = assets
            self.dateTime = dateTime
            self.geometry = geometry
            self.id = id
            self.properties = properties
        }
    }

}

extension SageMakerGeospatialClientTypes.JobConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandmathconfig = "BandMathConfig"
        case cloudmaskingconfig = "CloudMaskingConfig"
        case cloudremovalconfig = "CloudRemovalConfig"
        case geomosaicconfig = "GeoMosaicConfig"
        case landcoversegmentationconfig = "LandCoverSegmentationConfig"
        case resamplingconfig = "ResamplingConfig"
        case stackconfig = "StackConfig"
        case temporalstatisticsconfig = "TemporalStatisticsConfig"
        case zonalstatisticsconfig = "ZonalStatisticsConfig"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .bandmathconfig(bandmathconfig):
                try container.encode(bandmathconfig, forKey: .bandmathconfig)
            case let .cloudmaskingconfig(cloudmaskingconfig):
                try container.encode(cloudmaskingconfig, forKey: .cloudmaskingconfig)
            case let .cloudremovalconfig(cloudremovalconfig):
                try container.encode(cloudremovalconfig, forKey: .cloudremovalconfig)
            case let .geomosaicconfig(geomosaicconfig):
                try container.encode(geomosaicconfig, forKey: .geomosaicconfig)
            case let .landcoversegmentationconfig(landcoversegmentationconfig):
                try container.encode(landcoversegmentationconfig, forKey: .landcoversegmentationconfig)
            case let .resamplingconfig(resamplingconfig):
                try container.encode(resamplingconfig, forKey: .resamplingconfig)
            case let .stackconfig(stackconfig):
                try container.encode(stackconfig, forKey: .stackconfig)
            case let .temporalstatisticsconfig(temporalstatisticsconfig):
                try container.encode(temporalstatisticsconfig, forKey: .temporalstatisticsconfig)
            case let .zonalstatisticsconfig(zonalstatisticsconfig):
                try container.encode(zonalstatisticsconfig, forKey: .zonalstatisticsconfig)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let bandmathconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.BandMathConfigInput.self, forKey: .bandmathconfig)
        if let bandmathconfig = bandmathconfigDecoded {
            self = .bandmathconfig(bandmathconfig)
            return
        }
        let resamplingconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.ResamplingConfigInput.self, forKey: .resamplingconfig)
        if let resamplingconfig = resamplingconfigDecoded {
            self = .resamplingconfig(resamplingconfig)
            return
        }
        let temporalstatisticsconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.TemporalStatisticsConfigInput.self, forKey: .temporalstatisticsconfig)
        if let temporalstatisticsconfig = temporalstatisticsconfigDecoded {
            self = .temporalstatisticsconfig(temporalstatisticsconfig)
            return
        }
        let cloudremovalconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.CloudRemovalConfigInput.self, forKey: .cloudremovalconfig)
        if let cloudremovalconfig = cloudremovalconfigDecoded {
            self = .cloudremovalconfig(cloudremovalconfig)
            return
        }
        let zonalstatisticsconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.ZonalStatisticsConfigInput.self, forKey: .zonalstatisticsconfig)
        if let zonalstatisticsconfig = zonalstatisticsconfigDecoded {
            self = .zonalstatisticsconfig(zonalstatisticsconfig)
            return
        }
        let geomosaicconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.GeoMosaicConfigInput.self, forKey: .geomosaicconfig)
        if let geomosaicconfig = geomosaicconfigDecoded {
            self = .geomosaicconfig(geomosaicconfig)
            return
        }
        let stackconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.StackConfigInput.self, forKey: .stackconfig)
        if let stackconfig = stackconfigDecoded {
            self = .stackconfig(stackconfig)
            return
        }
        let cloudmaskingconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.CloudMaskingConfigInput.self, forKey: .cloudmaskingconfig)
        if let cloudmaskingconfig = cloudmaskingconfigDecoded {
            self = .cloudmaskingconfig(cloudmaskingconfig)
            return
        }
        let landcoversegmentationconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.LandCoverSegmentationConfigInput.self, forKey: .landcoversegmentationconfig)
        if let landcoversegmentationconfig = landcoversegmentationconfigDecoded {
            self = .landcoversegmentationconfig(landcoversegmentationconfig)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SageMakerGeospatialClientTypes {
    /// The input structure for the JobConfig in an EarthObservationJob.
    public enum JobConfigInput: Swift.Equatable {
        ///
        case bandmathconfig(SageMakerGeospatialClientTypes.BandMathConfigInput)
        /// An object containing information about the job configuration for resampling.
        case resamplingconfig(SageMakerGeospatialClientTypes.ResamplingConfigInput)
        /// An object containing information about the job configuration for temporal statistics.
        case temporalstatisticsconfig(SageMakerGeospatialClientTypes.TemporalStatisticsConfigInput)
        /// An object containing information about the job configuration for cloud removal.
        case cloudremovalconfig(SageMakerGeospatialClientTypes.CloudRemovalConfigInput)
        /// An object containing information about the job configuration for zonal statistics.
        case zonalstatisticsconfig(SageMakerGeospatialClientTypes.ZonalStatisticsConfigInput)
        /// An object containing information about the job configuration for geomosaic.
        case geomosaicconfig(SageMakerGeospatialClientTypes.GeoMosaicConfigInput)
        ///
        case stackconfig(SageMakerGeospatialClientTypes.StackConfigInput)
        /// An object containing information about the job configuration for cloud masking.
        case cloudmaskingconfig(SageMakerGeospatialClientTypes.CloudMaskingConfigInput)
        /// An object containing information about the job configuration for land cover segmentation.
        case landcoversegmentationconfig(SageMakerGeospatialClientTypes.LandCoverSegmentationConfigInput)
        case sdkUnknown(Swift.String)
    }

}

extension SageMakerGeospatialClientTypes.LandCoverSegmentationConfigInput: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct LandCoverSegmentationConfigInput: Swift.Equatable {

        public init () { }
    }

}

extension SageMakerGeospatialClientTypes.LandsatCloudCoverLandInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lowerBound = "LowerBound"
        case upperBound = "UpperBound"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lowerBound = self.lowerBound {
            try encodeContainer.encode(lowerBound, forKey: .lowerBound)
        }
        if let upperBound = self.upperBound {
            try encodeContainer.encode(upperBound, forKey: .upperBound)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lowerBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .lowerBound)
        lowerBound = lowerBoundDecoded
        let upperBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .upperBound)
        upperBound = upperBoundDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct LandsatCloudCoverLandInput: Swift.Equatable {
        ///
        /// This member is required.
        public var lowerBound: Swift.Float?
        ///
        /// This member is required.
        public var upperBound: Swift.Float?

        public init (
            lowerBound: Swift.Float? = nil,
            upperBound: Swift.Float? = nil
        )
        {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }
    }

}

extension SageMakerGeospatialClientTypes.ListEarthObservationJobOutputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case durationInSeconds = "DurationInSeconds"
        case name = "Name"
        case operationType = "OperationType"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let durationInSeconds = self.durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let operationType = self.operationType {
            try encodeContainer.encode(operationType, forKey: .operationType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EarthObservationJobStatus.self, forKey: .status)
        status = statusDecoded
        let operationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationType)
        operationType = operationTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    /// An object containing information about the output file.
    public struct ListEarthObservationJobOutputConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the list of the Earth Observation jobs.
        /// This member is required.
        public var arn: Swift.String?
        /// The creation time.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The duration of the session, in seconds.
        /// This member is required.
        public var durationInSeconds: Swift.Int?
        /// The names of the Earth Observation jobs in the list.
        /// This member is required.
        public var name: Swift.String?
        ///
        /// This member is required.
        public var operationType: Swift.String?
        /// The status of the list of the Earth Observation jobs.
        /// This member is required.
        public var status: SageMakerGeospatialClientTypes.EarthObservationJobStatus?
        /// Each tag consists of a key and a value.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            durationInSeconds: Swift.Int? = nil,
            name: Swift.String? = nil,
            operationType: Swift.String? = nil,
            status: SageMakerGeospatialClientTypes.EarthObservationJobStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.durationInSeconds = durationInSeconds
            self.name = name
            self.operationType = operationType
            self.status = status
            self.tags = tags
        }
    }

}

extension ListEarthObservationJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEarthObservationJobsInput(maxResults: \(Swift.String(describing: maxResults)), sortBy: \(Swift.String(describing: sortBy)), sortOrder: \(Swift.String(describing: sortOrder)), statusEquals: \(Swift.String(describing: statusEquals)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListEarthObservationJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
        case statusEquals = "StatusEquals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
        if let statusEquals = self.statusEquals {
            try encodeContainer.encode(statusEquals.rawValue, forKey: .statusEquals)
        }
    }
}

extension ListEarthObservationJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-earth-observation-jobs"
    }
}

public struct ListEarthObservationJobsInput: Swift.Equatable {
    /// The total number of items to return.
    public var maxResults: Swift.Int?
    /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
    public var nextToken: Swift.String?
    /// The parameter by which to sort the results.
    public var sortBy: Swift.String?
    /// An optional value that specifies whether you want the results sorted in Ascending or Descending order.
    public var sortOrder: SageMakerGeospatialClientTypes.SortOrder?
    /// A filter that retrieves only jobs with a specific status.
    public var statusEquals: SageMakerGeospatialClientTypes.EarthObservationJobStatus?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: Swift.String? = nil,
        sortOrder: SageMakerGeospatialClientTypes.SortOrder? = nil,
        statusEquals: SageMakerGeospatialClientTypes.EarthObservationJobStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

struct ListEarthObservationJobsInputBody: Swift.Equatable {
    let statusEquals: SageMakerGeospatialClientTypes.EarthObservationJobStatus?
    let sortOrder: SageMakerGeospatialClientTypes.SortOrder?
    let sortBy: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEarthObservationJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
        case statusEquals = "StatusEquals"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusEqualsDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EarthObservationJobStatus.self, forKey: .statusEquals)
        statusEquals = statusEqualsDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEarthObservationJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEarthObservationJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListEarthObservationJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEarthObservationJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEarthObservationJobsOutputResponse(earthObservationJobSummaries: \(Swift.String(describing: earthObservationJobSummaries)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListEarthObservationJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListEarthObservationJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.earthObservationJobSummaries = output.earthObservationJobSummaries
            self.nextToken = output.nextToken
        } else {
            self.earthObservationJobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListEarthObservationJobsOutputResponse: Swift.Equatable {
    /// Contains summary information about the Earth Observation jobs.
    /// This member is required.
    public var earthObservationJobSummaries: [SageMakerGeospatialClientTypes.ListEarthObservationJobOutputConfig]?
    /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        earthObservationJobSummaries: [SageMakerGeospatialClientTypes.ListEarthObservationJobOutputConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.earthObservationJobSummaries = earthObservationJobSummaries
        self.nextToken = nextToken
    }
}

struct ListEarthObservationJobsOutputResponseBody: Swift.Equatable {
    let earthObservationJobSummaries: [SageMakerGeospatialClientTypes.ListEarthObservationJobOutputConfig]?
    let nextToken: Swift.String?
}

extension ListEarthObservationJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case earthObservationJobSummaries = "EarthObservationJobSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let earthObservationJobSummariesContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.ListEarthObservationJobOutputConfig?].self, forKey: .earthObservationJobSummaries)
        var earthObservationJobSummariesDecoded0:[SageMakerGeospatialClientTypes.ListEarthObservationJobOutputConfig]? = nil
        if let earthObservationJobSummariesContainer = earthObservationJobSummariesContainer {
            earthObservationJobSummariesDecoded0 = [SageMakerGeospatialClientTypes.ListEarthObservationJobOutputConfig]()
            for structure0 in earthObservationJobSummariesContainer {
                if let structure0 = structure0 {
                    earthObservationJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        earthObservationJobSummaries = earthObservationJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRasterDataCollectionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRasterDataCollectionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListRasterDataCollectionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRasterDataCollectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/raster-data-collections"
    }
}

public struct ListRasterDataCollectionsInput: Swift.Equatable {
    /// The total number of items to return.
    public var maxResults: Swift.Int?
    /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRasterDataCollectionsInputBody: Swift.Equatable {
}

extension ListRasterDataCollectionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRasterDataCollectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRasterDataCollectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRasterDataCollectionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRasterDataCollectionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRasterDataCollectionsOutputResponse(rasterDataCollectionSummaries: \(Swift.String(describing: rasterDataCollectionSummaries)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListRasterDataCollectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRasterDataCollectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rasterDataCollectionSummaries = output.rasterDataCollectionSummaries
        } else {
            self.nextToken = nil
            self.rasterDataCollectionSummaries = nil
        }
    }
}

public struct ListRasterDataCollectionsOutputResponse: Swift.Equatable {
    /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
    public var nextToken: Swift.String?
    /// Contains summary information about the raster data collection.
    /// This member is required.
    public var rasterDataCollectionSummaries: [SageMakerGeospatialClientTypes.RasterDataCollectionMetadata]?

    public init (
        nextToken: Swift.String? = nil,
        rasterDataCollectionSummaries: [SageMakerGeospatialClientTypes.RasterDataCollectionMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.rasterDataCollectionSummaries = rasterDataCollectionSummaries
    }
}

struct ListRasterDataCollectionsOutputResponseBody: Swift.Equatable {
    let rasterDataCollectionSummaries: [SageMakerGeospatialClientTypes.RasterDataCollectionMetadata]?
    let nextToken: Swift.String?
}

extension ListRasterDataCollectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case rasterDataCollectionSummaries = "RasterDataCollectionSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rasterDataCollectionSummariesContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.RasterDataCollectionMetadata?].self, forKey: .rasterDataCollectionSummaries)
        var rasterDataCollectionSummariesDecoded0:[SageMakerGeospatialClientTypes.RasterDataCollectionMetadata]? = nil
        if let rasterDataCollectionSummariesContainer = rasterDataCollectionSummariesContainer {
            rasterDataCollectionSummariesDecoded0 = [SageMakerGeospatialClientTypes.RasterDataCollectionMetadata]()
            for structure0 in rasterDataCollectionSummariesContainer {
                if let structure0 = structure0 {
                    rasterDataCollectionSummariesDecoded0?.append(structure0)
                }
            }
        }
        rasterDataCollectionSummaries = rasterDataCollectionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Each tag consists of a key and a value.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SageMakerGeospatialClientTypes.ListVectorEnrichmentJobOutputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case durationInSeconds = "DurationInSeconds"
        case name = "Name"
        case status = "Status"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let durationInSeconds = self.durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobType.self, forKey: .type)
        type = typeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    /// An object containing information about the output file.
    public struct ListVectorEnrichmentJobOutputConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the list of the Vector Enrichment jobs.
        /// This member is required.
        public var arn: Swift.String?
        /// The creation time.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The duration of the session, in seconds.
        /// This member is required.
        public var durationInSeconds: Swift.Int?
        /// The names of the Vector Enrichment jobs in the list.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the Vector Enrichment jobs list.
        /// This member is required.
        public var status: SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus?
        /// Each tag consists of a key and a value.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the list of Vector Enrichment jobs.
        /// This member is required.
        public var type: SageMakerGeospatialClientTypes.VectorEnrichmentJobType?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            durationInSeconds: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: SageMakerGeospatialClientTypes.VectorEnrichmentJobType? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.durationInSeconds = durationInSeconds
            self.name = name
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

extension ListVectorEnrichmentJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVectorEnrichmentJobsInput(maxResults: \(Swift.String(describing: maxResults)), sortBy: \(Swift.String(describing: sortBy)), sortOrder: \(Swift.String(describing: sortOrder)), statusEquals: \(Swift.String(describing: statusEquals)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListVectorEnrichmentJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
        case statusEquals = "StatusEquals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
        if let statusEquals = self.statusEquals {
            try encodeContainer.encode(statusEquals, forKey: .statusEquals)
        }
    }
}

extension ListVectorEnrichmentJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-vector-enrichment-jobs"
    }
}

public struct ListVectorEnrichmentJobsInput: Swift.Equatable {
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
    public var nextToken: Swift.String?
    /// The parameter by which to sort the results.
    public var sortBy: Swift.String?
    /// An optional value that specifies whether you want the results sorted in Ascending or Descending order.
    public var sortOrder: SageMakerGeospatialClientTypes.SortOrder?
    /// A filter that retrieves only jobs with a specific status.
    public var statusEquals: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: Swift.String? = nil,
        sortOrder: SageMakerGeospatialClientTypes.SortOrder? = nil,
        statusEquals: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

struct ListVectorEnrichmentJobsInputBody: Swift.Equatable {
    let statusEquals: Swift.String?
    let sortOrder: SageMakerGeospatialClientTypes.SortOrder?
    let sortBy: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListVectorEnrichmentJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
        case statusEquals = "StatusEquals"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusEqualsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusEquals)
        statusEquals = statusEqualsDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListVectorEnrichmentJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVectorEnrichmentJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVectorEnrichmentJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVectorEnrichmentJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVectorEnrichmentJobsOutputResponse(vectorEnrichmentJobSummaries: \(Swift.String(describing: vectorEnrichmentJobSummaries)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListVectorEnrichmentJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVectorEnrichmentJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.vectorEnrichmentJobSummaries = output.vectorEnrichmentJobSummaries
        } else {
            self.nextToken = nil
            self.vectorEnrichmentJobSummaries = nil
        }
    }
}

public struct ListVectorEnrichmentJobsOutputResponse: Swift.Equatable {
    /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
    public var nextToken: Swift.String?
    /// Contains summary information about the Vector Enrichment jobs.
    /// This member is required.
    public var vectorEnrichmentJobSummaries: [SageMakerGeospatialClientTypes.ListVectorEnrichmentJobOutputConfig]?

    public init (
        nextToken: Swift.String? = nil,
        vectorEnrichmentJobSummaries: [SageMakerGeospatialClientTypes.ListVectorEnrichmentJobOutputConfig]? = nil
    )
    {
        self.nextToken = nextToken
        self.vectorEnrichmentJobSummaries = vectorEnrichmentJobSummaries
    }
}

struct ListVectorEnrichmentJobsOutputResponseBody: Swift.Equatable {
    let vectorEnrichmentJobSummaries: [SageMakerGeospatialClientTypes.ListVectorEnrichmentJobOutputConfig]?
    let nextToken: Swift.String?
}

extension ListVectorEnrichmentJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case vectorEnrichmentJobSummaries = "VectorEnrichmentJobSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vectorEnrichmentJobSummariesContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.ListVectorEnrichmentJobOutputConfig?].self, forKey: .vectorEnrichmentJobSummaries)
        var vectorEnrichmentJobSummariesDecoded0:[SageMakerGeospatialClientTypes.ListVectorEnrichmentJobOutputConfig]? = nil
        if let vectorEnrichmentJobSummariesContainer = vectorEnrichmentJobSummariesContainer {
            vectorEnrichmentJobSummariesDecoded0 = [SageMakerGeospatialClientTypes.ListVectorEnrichmentJobOutputConfig]()
            for structure0 in vectorEnrichmentJobSummariesContainer {
                if let structure0 = structure0 {
                    vectorEnrichmentJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        vectorEnrichmentJobSummaries = vectorEnrichmentJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    public enum LogicalOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// AND
        case and
        case sdkUnknown(Swift.String)

        public static var allCases: [LogicalOperator] {
            return [
                .and,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .and: return "AND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogicalOperator(rawValue: rawValue) ?? LogicalOperator.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.MapMatchingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idAttributeName = "IdAttributeName"
        case timestampAttributeName = "TimestampAttributeName"
        case xAttributeName = "XAttributeName"
        case yAttributeName = "YAttributeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idAttributeName = self.idAttributeName {
            try encodeContainer.encode(idAttributeName, forKey: .idAttributeName)
        }
        if let timestampAttributeName = self.timestampAttributeName {
            try encodeContainer.encode(timestampAttributeName, forKey: .timestampAttributeName)
        }
        if let xAttributeName = self.xAttributeName {
            try encodeContainer.encode(xAttributeName, forKey: .xAttributeName)
        }
        if let yAttributeName = self.yAttributeName {
            try encodeContainer.encode(yAttributeName, forKey: .yAttributeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idAttributeName)
        idAttributeName = idAttributeNameDecoded
        let yAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .yAttributeName)
        yAttributeName = yAttributeNameDecoded
        let xAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .xAttributeName)
        xAttributeName = xAttributeNameDecoded
        let timestampAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestampAttributeName)
        timestampAttributeName = timestampAttributeNameDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct MapMatchingConfig: Swift.Equatable {
        ///
        /// This member is required.
        public var idAttributeName: Swift.String?
        /// The name of the timestamp attribute.
        /// This member is required.
        public var timestampAttributeName: Swift.String?
        /// The name of the X-attribute
        /// This member is required.
        public var xAttributeName: Swift.String?
        /// The name of the Y-attribute
        /// This member is required.
        public var yAttributeName: Swift.String?

        public init (
            idAttributeName: Swift.String? = nil,
            timestampAttributeName: Swift.String? = nil,
            xAttributeName: Swift.String? = nil,
            yAttributeName: Swift.String? = nil
        )
        {
            self.idAttributeName = idAttributeName
            self.timestampAttributeName = timestampAttributeName
            self.xAttributeName = xAttributeName
            self.yAttributeName = yAttributeName
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum MetadataProvider: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// PLANET_ORDER
        case planetOrder
        case sdkUnknown(Swift.String)

        public static var allCases: [MetadataProvider] {
            return [
                .planetOrder,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .planetOrder: return "PLANET_ORDER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MetadataProvider(rawValue: rawValue) ?? MetadataProvider.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.MultiPolygonGeometryInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coordinates = "Coordinates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coordinates = coordinates {
            var coordinatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .coordinates)
            for linearrings0 in coordinates {
                var linearrings0Container = coordinatesContainer.nestedUnkeyedContainer()
                for linearring1 in linearrings0 {
                    var linearring1Container = linearrings0Container.nestedUnkeyedContainer()
                    for position2 in linearring1 {
                        var position2Container = linearring1Container.nestedUnkeyedContainer()
                        for double3 in position2 {
                            try position2Container.encode(double3)
                        }
                    }
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coordinatesContainer = try containerValues.decodeIfPresent([[[[Swift.Double?]?]?]?].self, forKey: .coordinates)
        var coordinatesDecoded0:[[[[Swift.Double]]]]? = nil
        if let coordinatesContainer = coordinatesContainer {
            coordinatesDecoded0 = [[[[Swift.Double]]]]()
            for list0 in coordinatesContainer {
                var list0Decoded0: [[[Swift.Double]]]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [[[Swift.Double]]]()
                    for list1 in list0 {
                        var list1Decoded1: [[Swift.Double]]? = nil
                        if let list1 = list1 {
                            list1Decoded1 = [[Swift.Double]]()
                            for list2 in list1 {
                                var list2Decoded2: [Swift.Double]? = nil
                                if let list2 = list2 {
                                    list2Decoded2 = [Swift.Double]()
                                    for double3 in list2 {
                                        if let double3 = double3 {
                                            list2Decoded2?.append(double3)
                                        }
                                    }
                                }
                                if let list2Decoded2 = list2Decoded2 {
                                    list1Decoded1?.append(list2Decoded2)
                                }
                            }
                        }
                        if let list1Decoded1 = list1Decoded1 {
                            list0Decoded0?.append(list1Decoded1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    coordinatesDecoded0?.append(list0Decoded0)
                }
            }
        }
        coordinates = coordinatesDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct MultiPolygonGeometryInput: Swift.Equatable {
        /// The coordinates of the multipolygon geometry.
        /// This member is required.
        public var coordinates: [[[[Swift.Double]]]]?

        public init (
            coordinates: [[[[Swift.Double]]]]? = nil
        )
        {
            self.coordinates = coordinates
        }
    }

}

extension SageMakerGeospatialClientTypes.Operation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case equation = "Equation"
        case name = "Name"
        case outputType = "OutputType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let equation = self.equation {
            try encodeContainer.encode(equation, forKey: .equation)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputType = self.outputType {
            try encodeContainer.encode(outputType.rawValue, forKey: .outputType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let equationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .equation)
        equation = equationDecoded
        let outputTypeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.OutputType.self, forKey: .outputType)
        outputType = outputTypeDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct Operation: Swift.Equatable {
        ///
        /// This member is required.
        public var equation: Swift.String?
        /// The name of the operation.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the operation.
        public var outputType: SageMakerGeospatialClientTypes.OutputType?

        public init (
            equation: Swift.String? = nil,
            name: Swift.String? = nil,
            outputType: SageMakerGeospatialClientTypes.OutputType? = nil
        )
        {
            self.equation = equation
            self.name = name
            self.outputType = outputType
        }
    }

}

extension SageMakerGeospatialClientTypes.OutputBand: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandName = "BandName"
        case outputDataType = "OutputDataType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandName = self.bandName {
            try encodeContainer.encode(bandName, forKey: .bandName)
        }
        if let outputDataType = self.outputDataType {
            try encodeContainer.encode(outputDataType.rawValue, forKey: .outputDataType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bandNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bandName)
        bandName = bandNameDecoded
        let outputDataTypeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.OutputType.self, forKey: .outputDataType)
        outputDataType = outputDataTypeDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// A single EarthObservationJob output band.
    public struct OutputBand: Swift.Equatable {
        /// The name of the band.
        /// This member is required.
        public var bandName: Swift.String?
        /// The datatype of the output band.
        /// This member is required.
        public var outputDataType: SageMakerGeospatialClientTypes.OutputType?

        public init (
            bandName: Swift.String? = nil,
            outputDataType: SageMakerGeospatialClientTypes.OutputType? = nil
        )
        {
            self.bandName = bandName
            self.outputDataType = outputDataType
        }
    }

}

extension SageMakerGeospatialClientTypes.OutputConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Data = "S3Data"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Data = self.s3Data {
            try encodeContainer.encode(s3Data, forKey: .s3Data)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.ExportS3DataInput.self, forKey: .s3Data)
        s3Data = s3DataDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The response structure for an OutputConfig returned by an ExportEarthObservationJob.
    public struct OutputConfigInput: Swift.Equatable {
        /// Path to Amazon S3 storage location for the output configuration file.
        /// This member is required.
        public var s3Data: SageMakerGeospatialClientTypes.ExportS3DataInput?

        public init (
            s3Data: SageMakerGeospatialClientTypes.ExportS3DataInput? = nil
        )
        {
            self.s3Data = s3Data
        }
    }

}

extension SageMakerGeospatialClientTypes.OutputResolutionResamplingInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userDefined = "UserDefined"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userDefined = self.userDefined {
            try encodeContainer.encode(userDefined, forKey: .userDefined)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDefinedDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.UserDefined.self, forKey: .userDefined)
        userDefined = userDefinedDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct OutputResolutionResamplingInput: Swift.Equatable {
        ///
        /// This member is required.
        public var userDefined: SageMakerGeospatialClientTypes.UserDefined?

        public init (
            userDefined: SageMakerGeospatialClientTypes.UserDefined? = nil
        )
        {
            self.userDefined = userDefined
        }
    }

}

extension SageMakerGeospatialClientTypes.OutputResolutionStackInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predefined = "Predefined"
        case userDefined = "UserDefined"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predefined = self.predefined {
            try encodeContainer.encode(predefined.rawValue, forKey: .predefined)
        }
        if let userDefined = self.userDefined {
            try encodeContainer.encode(userDefined, forKey: .userDefined)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predefinedDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.PredefinedResolution.self, forKey: .predefined)
        predefined = predefinedDecoded
        let userDefinedDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.UserDefined.self, forKey: .userDefined)
        userDefined = userDefinedDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct OutputResolutionStackInput: Swift.Equatable {
        ///
        public var predefined: SageMakerGeospatialClientTypes.PredefinedResolution?
        ///
        public var userDefined: SageMakerGeospatialClientTypes.UserDefined?

        public init (
            predefined: SageMakerGeospatialClientTypes.PredefinedResolution? = nil,
            userDefined: SageMakerGeospatialClientTypes.UserDefined? = nil
        )
        {
            self.predefined = predefined
            self.userDefined = userDefined
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum OutputType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// FLOAT32
        case float32
        /// FLOAT64
        case float64
        /// INT16
        case int16
        /// INT32
        case int32
        /// UINT16
        case uint16
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputType] {
            return [
                .float32,
                .float64,
                .int16,
                .int32,
                .uint16,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .float32: return "FLOAT32"
            case .float64: return "FLOAT64"
            case .int16: return "INT16"
            case .int32: return "INT32"
            case .uint16: return "UINT16"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutputType(rawValue: rawValue) ?? OutputType.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.PlatformInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = self.comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct PlatformInput: Swift.Equatable {
        ///
        public var comparisonOperator: SageMakerGeospatialClientTypes.ComparisonOperator?
        /// The value of the platform.
        /// This member is required.
        public var value: Swift.String?

        public init (
            comparisonOperator: SageMakerGeospatialClientTypes.ComparisonOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.value = value
        }
    }

}

extension SageMakerGeospatialClientTypes.PolygonGeometryInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coordinates = "Coordinates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coordinates = coordinates {
            var coordinatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .coordinates)
            for linearring0 in coordinates {
                var linearring0Container = coordinatesContainer.nestedUnkeyedContainer()
                for position1 in linearring0 {
                    var position1Container = linearring0Container.nestedUnkeyedContainer()
                    for double2 in position1 {
                        try position1Container.encode(double2)
                    }
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coordinatesContainer = try containerValues.decodeIfPresent([[[Swift.Double?]?]?].self, forKey: .coordinates)
        var coordinatesDecoded0:[[[Swift.Double]]]? = nil
        if let coordinatesContainer = coordinatesContainer {
            coordinatesDecoded0 = [[[Swift.Double]]]()
            for list0 in coordinatesContainer {
                var list0Decoded0: [[Swift.Double]]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [[Swift.Double]]()
                    for list1 in list0 {
                        var list1Decoded1: [Swift.Double]? = nil
                        if let list1 = list1 {
                            list1Decoded1 = [Swift.Double]()
                            for double2 in list1 {
                                if let double2 = double2 {
                                    list1Decoded1?.append(double2)
                                }
                            }
                        }
                        if let list1Decoded1 = list1Decoded1 {
                            list0Decoded0?.append(list1Decoded1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    coordinatesDecoded0?.append(list0Decoded0)
                }
            }
        }
        coordinates = coordinatesDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct PolygonGeometryInput: Swift.Equatable {
        ///
        /// This member is required.
        public var coordinates: [[[Swift.Double]]]?

        public init (
            coordinates: [[[Swift.Double]]]? = nil
        )
        {
            self.coordinates = coordinates
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum PredefinedResolution: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// AVERAGE
        case average
        /// HIGHEST
        case highest
        /// LOWEST
        case lowest
        case sdkUnknown(Swift.String)

        public static var allCases: [PredefinedResolution] {
            return [
                .average,
                .highest,
                .lowest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .highest: return "HIGHEST"
            case .lowest: return "LOWEST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PredefinedResolution(rawValue: rawValue) ?? PredefinedResolution.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.Properties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eoCloudCover = "EoCloudCover"
        case landsatCloudCoverLand = "LandsatCloudCoverLand"
        case platform = "Platform"
        case viewOffNadir = "ViewOffNadir"
        case viewSunAzimuth = "ViewSunAzimuth"
        case viewSunElevation = "ViewSunElevation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eoCloudCover = self.eoCloudCover {
            try encodeContainer.encode(eoCloudCover, forKey: .eoCloudCover)
        }
        if let landsatCloudCoverLand = self.landsatCloudCoverLand {
            try encodeContainer.encode(landsatCloudCoverLand, forKey: .landsatCloudCoverLand)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let viewOffNadir = self.viewOffNadir {
            try encodeContainer.encode(viewOffNadir, forKey: .viewOffNadir)
        }
        if let viewSunAzimuth = self.viewSunAzimuth {
            try encodeContainer.encode(viewSunAzimuth, forKey: .viewSunAzimuth)
        }
        if let viewSunElevation = self.viewSunElevation {
            try encodeContainer.encode(viewSunElevation, forKey: .viewSunElevation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eoCloudCoverDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .eoCloudCover)
        eoCloudCover = eoCloudCoverDecoded
        let viewOffNadirDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .viewOffNadir)
        viewOffNadir = viewOffNadirDecoded
        let viewSunAzimuthDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .viewSunAzimuth)
        viewSunAzimuth = viewSunAzimuthDecoded
        let viewSunElevationDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .viewSunElevation)
        viewSunElevation = viewSunElevationDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let landsatCloudCoverLandDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .landsatCloudCoverLand)
        landsatCloudCoverLand = landsatCloudCoverLandDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct Properties: Swift.Equatable {
        ///
        public var eoCloudCover: Swift.Float?
        ///
        public var landsatCloudCoverLand: Swift.Float?
        ///
        public var platform: Swift.String?
        ///
        public var viewOffNadir: Swift.Float?
        ///
        public var viewSunAzimuth: Swift.Float?
        ///
        public var viewSunElevation: Swift.Float?

        public init (
            eoCloudCover: Swift.Float? = nil,
            landsatCloudCoverLand: Swift.Float? = nil,
            platform: Swift.String? = nil,
            viewOffNadir: Swift.Float? = nil,
            viewSunAzimuth: Swift.Float? = nil,
            viewSunElevation: Swift.Float? = nil
        )
        {
            self.eoCloudCover = eoCloudCover
            self.landsatCloudCoverLand = landsatCloudCoverLand
            self.platform = platform
            self.viewOffNadir = viewOffNadir
            self.viewSunAzimuth = viewSunAzimuth
            self.viewSunElevation = viewSunElevation
        }
    }

}

extension SageMakerGeospatialClientTypes.Property: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eocloudcover = "EoCloudCover"
        case landsatcloudcoverland = "LandsatCloudCoverLand"
        case platform = "Platform"
        case viewoffnadir = "ViewOffNadir"
        case viewsunazimuth = "ViewSunAzimuth"
        case viewsunelevation = "ViewSunElevation"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .eocloudcover(eocloudcover):
                try container.encode(eocloudcover, forKey: .eocloudcover)
            case let .landsatcloudcoverland(landsatcloudcoverland):
                try container.encode(landsatcloudcoverland, forKey: .landsatcloudcoverland)
            case let .platform(platform):
                try container.encode(platform, forKey: .platform)
            case let .viewoffnadir(viewoffnadir):
                try container.encode(viewoffnadir, forKey: .viewoffnadir)
            case let .viewsunazimuth(viewsunazimuth):
                try container.encode(viewsunazimuth, forKey: .viewsunazimuth)
            case let .viewsunelevation(viewsunelevation):
                try container.encode(viewsunelevation, forKey: .viewsunelevation)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let eocloudcoverDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.EoCloudCoverInput.self, forKey: .eocloudcover)
        if let eocloudcover = eocloudcoverDecoded {
            self = .eocloudcover(eocloudcover)
            return
        }
        let viewoffnadirDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.ViewOffNadirInput.self, forKey: .viewoffnadir)
        if let viewoffnadir = viewoffnadirDecoded {
            self = .viewoffnadir(viewoffnadir)
            return
        }
        let viewsunazimuthDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.ViewSunAzimuthInput.self, forKey: .viewsunazimuth)
        if let viewsunazimuth = viewsunazimuthDecoded {
            self = .viewsunazimuth(viewsunazimuth)
            return
        }
        let viewsunelevationDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.ViewSunElevationInput.self, forKey: .viewsunelevation)
        if let viewsunelevation = viewsunelevationDecoded {
            self = .viewsunelevation(viewsunelevation)
            return
        }
        let platformDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.PlatformInput.self, forKey: .platform)
        if let platform = platformDecoded {
            self = .platform(platform)
            return
        }
        let landsatcloudcoverlandDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.LandsatCloudCoverLandInput.self, forKey: .landsatcloudcoverland)
        if let landsatcloudcoverland = landsatcloudcoverlandDecoded {
            self = .landsatcloudcoverland(landsatcloudcoverland)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public enum Property: Swift.Equatable {
        ///
        case eocloudcover(SageMakerGeospatialClientTypes.EoCloudCoverInput)
        ///
        case viewoffnadir(SageMakerGeospatialClientTypes.ViewOffNadirInput)
        ///
        case viewsunazimuth(SageMakerGeospatialClientTypes.ViewSunAzimuthInput)
        ///
        case viewsunelevation(SageMakerGeospatialClientTypes.ViewSunElevationInput)
        ///
        case platform(SageMakerGeospatialClientTypes.PlatformInput)
        ///
        case landsatcloudcoverland(SageMakerGeospatialClientTypes.LandsatCloudCoverLandInput)
        case sdkUnknown(Swift.String)
    }

}

extension SageMakerGeospatialClientTypes.PropertyFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case property = "Property"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let property = self.property {
            try encodeContainer.encode(property, forKey: .property)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.Property.self, forKey: .property)
        property = propertyDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct PropertyFilter: Swift.Equatable {
        ///
        /// This member is required.
        public var property: SageMakerGeospatialClientTypes.Property?

        public init (
            property: SageMakerGeospatialClientTypes.Property? = nil
        )
        {
            self.property = property
        }
    }

}

extension SageMakerGeospatialClientTypes.PropertyFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logicalOperator = "LogicalOperator"
        case properties = "Properties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logicalOperator = self.logicalOperator {
            try encodeContainer.encode(logicalOperator.rawValue, forKey: .logicalOperator)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for propertyfilter0 in properties {
                try propertiesContainer.encode(propertyfilter0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertiesContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.PropertyFilter?].self, forKey: .properties)
        var propertiesDecoded0:[SageMakerGeospatialClientTypes.PropertyFilter]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [SageMakerGeospatialClientTypes.PropertyFilter]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
        let logicalOperatorDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.LogicalOperator.self, forKey: .logicalOperator)
        logicalOperator = logicalOperatorDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct PropertyFilters: Swift.Equatable {
        ///
        public var logicalOperator: SageMakerGeospatialClientTypes.LogicalOperator?
        ///
        public var properties: [SageMakerGeospatialClientTypes.PropertyFilter]?

        public init (
            logicalOperator: SageMakerGeospatialClientTypes.LogicalOperator? = nil,
            properties: [SageMakerGeospatialClientTypes.PropertyFilter]? = nil
        )
        {
            self.logicalOperator = logicalOperator
            self.properties = properties
        }
    }

}

extension SageMakerGeospatialClientTypes.RasterDataCollectionMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case descriptionPageUrl = "DescriptionPageUrl"
        case name = "Name"
        case supportedFilters = "SupportedFilters"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let descriptionPageUrl = self.descriptionPageUrl {
            try encodeContainer.encode(descriptionPageUrl, forKey: .descriptionPageUrl)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let supportedFilters = supportedFilters {
            var supportedFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedFilters)
            for filter0 in supportedFilters {
                try supportedFiltersContainer.encode(filter0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.DataCollectionType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let descriptionPageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .descriptionPageUrl)
        descriptionPageUrl = descriptionPageUrlDecoded
        let supportedFiltersContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.Filter?].self, forKey: .supportedFilters)
        var supportedFiltersDecoded0:[SageMakerGeospatialClientTypes.Filter]? = nil
        if let supportedFiltersContainer = supportedFiltersContainer {
            supportedFiltersDecoded0 = [SageMakerGeospatialClientTypes.Filter]()
            for structure0 in supportedFiltersContainer {
                if let structure0 = structure0 {
                    supportedFiltersDecoded0?.append(structure0)
                }
            }
        }
        supportedFilters = supportedFiltersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    /// Response object containing details for a specific RasterDataCollection.
    public struct RasterDataCollectionMetadata: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the raster data collection.
        /// This member is required.
        public var arn: Swift.String?
        /// A description of the raster data collection.
        /// This member is required.
        public var description: Swift.String?
        /// The description URL of the raster data collection.
        public var descriptionPageUrl: Swift.String?
        /// The name of the raster data collection.
        /// This member is required.
        public var name: Swift.String?
        ///
        /// This member is required.
        public var supportedFilters: [SageMakerGeospatialClientTypes.Filter]?
        /// Each tag consists of a key and a value.
        public var tags: [Swift.String:Swift.String]?
        /// The type of raster data collection.
        /// This member is required.
        public var type: SageMakerGeospatialClientTypes.DataCollectionType?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            descriptionPageUrl: Swift.String? = nil,
            name: Swift.String? = nil,
            supportedFilters: [SageMakerGeospatialClientTypes.Filter]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: SageMakerGeospatialClientTypes.DataCollectionType? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.descriptionPageUrl = descriptionPageUrl
            self.name = name
            self.supportedFilters = supportedFilters
            self.tags = tags
            self.type = type
        }
    }

}

extension SageMakerGeospatialClientTypes.RasterDataCollectionQueryInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areaOfInterest = "AreaOfInterest"
        case propertyFilters = "PropertyFilters"
        case rasterDataCollectionArn = "RasterDataCollectionArn"
        case timeRangeFilter = "TimeRangeFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let areaOfInterest = self.areaOfInterest {
            try encodeContainer.encode(areaOfInterest, forKey: .areaOfInterest)
        }
        if let propertyFilters = self.propertyFilters {
            try encodeContainer.encode(propertyFilters, forKey: .propertyFilters)
        }
        if let rasterDataCollectionArn = self.rasterDataCollectionArn {
            try encodeContainer.encode(rasterDataCollectionArn, forKey: .rasterDataCollectionArn)
        }
        if let timeRangeFilter = self.timeRangeFilter {
            try encodeContainer.encode(timeRangeFilter, forKey: .timeRangeFilter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rasterDataCollectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rasterDataCollectionArn)
        rasterDataCollectionArn = rasterDataCollectionArnDecoded
        let timeRangeFilterDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.TimeRangeFilterInput.self, forKey: .timeRangeFilter)
        timeRangeFilter = timeRangeFilterDecoded
        let areaOfInterestDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.AreaOfInterest.self, forKey: .areaOfInterest)
        areaOfInterest = areaOfInterestDecoded
        let propertyFiltersDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.PropertyFilters.self, forKey: .propertyFilters)
        propertyFilters = propertyFiltersDecoded
    }
}

extension SageMakerGeospatialClientTypes.RasterDataCollectionQueryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RasterDataCollectionQueryInput(areaOfInterest: \(Swift.String(describing: areaOfInterest)), propertyFilters: \(Swift.String(describing: propertyFilters)), rasterDataCollectionArn: \(Swift.String(describing: rasterDataCollectionArn)), timeRangeFilter: \"CONTENT_REDACTED\")"}
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct RasterDataCollectionQueryInput: Swift.Equatable {
        /// The area of interest being queried for the raster data collection.
        public var areaOfInterest: SageMakerGeospatialClientTypes.AreaOfInterest?
        ///
        public var propertyFilters: SageMakerGeospatialClientTypes.PropertyFilters?
        /// The Amazon Resource Name (ARN) of the raster data collection.
        /// This member is required.
        public var rasterDataCollectionArn: Swift.String?
        ///
        /// This member is required.
        public var timeRangeFilter: SageMakerGeospatialClientTypes.TimeRangeFilterInput?

        public init (
            areaOfInterest: SageMakerGeospatialClientTypes.AreaOfInterest? = nil,
            propertyFilters: SageMakerGeospatialClientTypes.PropertyFilters? = nil,
            rasterDataCollectionArn: Swift.String? = nil,
            timeRangeFilter: SageMakerGeospatialClientTypes.TimeRangeFilterInput? = nil
        )
        {
            self.areaOfInterest = areaOfInterest
            self.propertyFilters = propertyFilters
            self.rasterDataCollectionArn = rasterDataCollectionArn
            self.timeRangeFilter = timeRangeFilter
        }
    }

}

extension SageMakerGeospatialClientTypes.RasterDataCollectionQueryOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areaOfInterest = "AreaOfInterest"
        case propertyFilters = "PropertyFilters"
        case rasterDataCollectionArn = "RasterDataCollectionArn"
        case rasterDataCollectionName = "RasterDataCollectionName"
        case timeRangeFilter = "TimeRangeFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let areaOfInterest = self.areaOfInterest {
            try encodeContainer.encode(areaOfInterest, forKey: .areaOfInterest)
        }
        if let propertyFilters = self.propertyFilters {
            try encodeContainer.encode(propertyFilters, forKey: .propertyFilters)
        }
        if let rasterDataCollectionArn = self.rasterDataCollectionArn {
            try encodeContainer.encode(rasterDataCollectionArn, forKey: .rasterDataCollectionArn)
        }
        if let rasterDataCollectionName = self.rasterDataCollectionName {
            try encodeContainer.encode(rasterDataCollectionName, forKey: .rasterDataCollectionName)
        }
        if let timeRangeFilter = self.timeRangeFilter {
            try encodeContainer.encode(timeRangeFilter, forKey: .timeRangeFilter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rasterDataCollectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rasterDataCollectionArn)
        rasterDataCollectionArn = rasterDataCollectionArnDecoded
        let rasterDataCollectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rasterDataCollectionName)
        rasterDataCollectionName = rasterDataCollectionNameDecoded
        let timeRangeFilterDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.TimeRangeFilterInput.self, forKey: .timeRangeFilter)
        timeRangeFilter = timeRangeFilterDecoded
        let areaOfInterestDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.AreaOfInterest.self, forKey: .areaOfInterest)
        areaOfInterest = areaOfInterestDecoded
        let propertyFiltersDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.PropertyFilters.self, forKey: .propertyFilters)
        propertyFilters = propertyFiltersDecoded
    }
}

extension SageMakerGeospatialClientTypes.RasterDataCollectionQueryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RasterDataCollectionQueryOutput(areaOfInterest: \(Swift.String(describing: areaOfInterest)), propertyFilters: \(Swift.String(describing: propertyFilters)), rasterDataCollectionArn: \(Swift.String(describing: rasterDataCollectionArn)), rasterDataCollectionName: \(Swift.String(describing: rasterDataCollectionName)), timeRangeFilter: \"CONTENT_REDACTED\")"}
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct RasterDataCollectionQueryOutput: Swift.Equatable {
        ///
        public var areaOfInterest: SageMakerGeospatialClientTypes.AreaOfInterest?
        ///
        public var propertyFilters: SageMakerGeospatialClientTypes.PropertyFilters?
        ///
        /// This member is required.
        public var rasterDataCollectionArn: Swift.String?
        /// The name of the raster data collection.
        /// This member is required.
        public var rasterDataCollectionName: Swift.String?
        ///
        /// This member is required.
        public var timeRangeFilter: SageMakerGeospatialClientTypes.TimeRangeFilterInput?

        public init (
            areaOfInterest: SageMakerGeospatialClientTypes.AreaOfInterest? = nil,
            propertyFilters: SageMakerGeospatialClientTypes.PropertyFilters? = nil,
            rasterDataCollectionArn: Swift.String? = nil,
            rasterDataCollectionName: Swift.String? = nil,
            timeRangeFilter: SageMakerGeospatialClientTypes.TimeRangeFilterInput? = nil
        )
        {
            self.areaOfInterest = areaOfInterest
            self.propertyFilters = propertyFilters
            self.rasterDataCollectionArn = rasterDataCollectionArn
            self.rasterDataCollectionName = rasterDataCollectionName
            self.timeRangeFilter = timeRangeFilter
        }
    }

}

extension SageMakerGeospatialClientTypes.RasterDataCollectionQueryWithBandFilterInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areaOfInterest = "AreaOfInterest"
        case bandFilter = "BandFilter"
        case propertyFilters = "PropertyFilters"
        case timeRangeFilter = "TimeRangeFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let areaOfInterest = self.areaOfInterest {
            try encodeContainer.encode(areaOfInterest, forKey: .areaOfInterest)
        }
        if let bandFilter = bandFilter {
            var bandFilterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bandFilter)
            for string0 in bandFilter {
                try bandFilterContainer.encode(string0)
            }
        }
        if let propertyFilters = self.propertyFilters {
            try encodeContainer.encode(propertyFilters, forKey: .propertyFilters)
        }
        if let timeRangeFilter = self.timeRangeFilter {
            try encodeContainer.encode(timeRangeFilter, forKey: .timeRangeFilter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeRangeFilterDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.TimeRangeFilterInput.self, forKey: .timeRangeFilter)
        timeRangeFilter = timeRangeFilterDecoded
        let areaOfInterestDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.AreaOfInterest.self, forKey: .areaOfInterest)
        areaOfInterest = areaOfInterestDecoded
        let propertyFiltersDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.PropertyFilters.self, forKey: .propertyFilters)
        propertyFilters = propertyFiltersDecoded
        let bandFilterContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bandFilter)
        var bandFilterDecoded0:[Swift.String]? = nil
        if let bandFilterContainer = bandFilterContainer {
            bandFilterDecoded0 = [Swift.String]()
            for string0 in bandFilterContainer {
                if let string0 = string0 {
                    bandFilterDecoded0?.append(string0)
                }
            }
        }
        bandFilter = bandFilterDecoded0
    }
}

extension SageMakerGeospatialClientTypes.RasterDataCollectionQueryWithBandFilterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RasterDataCollectionQueryWithBandFilterInput(areaOfInterest: \(Swift.String(describing: areaOfInterest)), bandFilter: \(Swift.String(describing: bandFilter)), propertyFilters: \(Swift.String(describing: propertyFilters)), timeRangeFilter: \"CONTENT_REDACTED\")"}
}

extension SageMakerGeospatialClientTypes {
    /// This is a RasterDataCollectionQueryInput containing AreaOfInterest, Time Range filter and Property filters.
    public struct RasterDataCollectionQueryWithBandFilterInput: Swift.Equatable {
        ///
        public var areaOfInterest: SageMakerGeospatialClientTypes.AreaOfInterest?
        ///
        public var bandFilter: [Swift.String]?
        ///
        public var propertyFilters: SageMakerGeospatialClientTypes.PropertyFilters?
        ///
        /// This member is required.
        public var timeRangeFilter: SageMakerGeospatialClientTypes.TimeRangeFilterInput?

        public init (
            areaOfInterest: SageMakerGeospatialClientTypes.AreaOfInterest? = nil,
            bandFilter: [Swift.String]? = nil,
            propertyFilters: SageMakerGeospatialClientTypes.PropertyFilters? = nil,
            timeRangeFilter: SageMakerGeospatialClientTypes.TimeRangeFilterInput? = nil
        )
        {
            self.areaOfInterest = areaOfInterest
            self.bandFilter = bandFilter
            self.propertyFilters = propertyFilters
            self.timeRangeFilter = timeRangeFilter
        }
    }

}

extension SageMakerGeospatialClientTypes.ResamplingConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmName = "AlgorithmName"
        case outputResolution = "OutputResolution"
        case targetBands = "TargetBands"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmName = self.algorithmName {
            try encodeContainer.encode(algorithmName.rawValue, forKey: .algorithmName)
        }
        if let outputResolution = self.outputResolution {
            try encodeContainer.encode(outputResolution, forKey: .outputResolution)
        }
        if let targetBands = targetBands {
            var targetBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetBands)
            for string0 in targetBands {
                try targetBandsContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputResolutionDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.OutputResolutionResamplingInput.self, forKey: .outputResolution)
        outputResolution = outputResolutionDecoded
        let algorithmNameDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.AlgorithmNameResampling.self, forKey: .algorithmName)
        algorithmName = algorithmNameDecoded
        let targetBandsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetBands)
        var targetBandsDecoded0:[Swift.String]? = nil
        if let targetBandsContainer = targetBandsContainer {
            targetBandsDecoded0 = [Swift.String]()
            for string0 in targetBandsContainer {
                if let string0 = string0 {
                    targetBandsDecoded0?.append(string0)
                }
            }
        }
        targetBands = targetBandsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct ResamplingConfigInput: Swift.Equatable {
        /// The name of the algorithm used for resampling.
        public var algorithmName: SageMakerGeospatialClientTypes.AlgorithmNameResampling?
        ///
        /// This member is required.
        public var outputResolution: SageMakerGeospatialClientTypes.OutputResolutionResamplingInput?
        ///
        public var targetBands: [Swift.String]?

        public init (
            algorithmName: SageMakerGeospatialClientTypes.AlgorithmNameResampling? = nil,
            outputResolution: SageMakerGeospatialClientTypes.OutputResolutionResamplingInput? = nil,
            targetBands: [Swift.String]? = nil
        )
        {
            self.algorithmName = algorithmName
            self.outputResolution = outputResolution
            self.targetBands = targetBands
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    ///
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension SageMakerGeospatialClientTypes.ReverseGeocodingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case xAttributeName = "XAttributeName"
        case yAttributeName = "YAttributeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let xAttributeName = self.xAttributeName {
            try encodeContainer.encode(xAttributeName, forKey: .xAttributeName)
        }
        if let yAttributeName = self.yAttributeName {
            try encodeContainer.encode(yAttributeName, forKey: .yAttributeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let yAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .yAttributeName)
        yAttributeName = yAttributeNameDecoded
        let xAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .xAttributeName)
        xAttributeName = xAttributeNameDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct ReverseGeocodingConfig: Swift.Equatable {
        ///
        /// This member is required.
        public var xAttributeName: Swift.String?
        ///
        /// This member is required.
        public var yAttributeName: Swift.String?

        public init (
            xAttributeName: Swift.String? = nil,
            yAttributeName: Swift.String? = nil
        )
        {
            self.xAttributeName = xAttributeName
            self.yAttributeName = yAttributeName
        }
    }

}

extension SageMakerGeospatialClientTypes.S3DataInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case metadataProvider = "MetadataProvider"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let metadataProvider = self.metadataProvider {
            try encodeContainer.encode(metadataProvider.rawValue, forKey: .metadataProvider)
        }
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let metadataProviderDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.MetadataProvider.self, forKey: .metadataProvider)
        metadataProvider = metadataProviderDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// Path to Amazon S3 storage location for input data.
    public struct S3DataInput: Swift.Equatable {
        /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
        public var kmsKeyId: Swift.String?
        ///
        /// This member is required.
        public var metadataProvider: SageMakerGeospatialClientTypes.MetadataProvider?
        /// The URL to the Amazon S3 input.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil,
            metadataProvider: SageMakerGeospatialClientTypes.MetadataProvider? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.metadataProvider = metadataProvider
            self.s3Uri = s3Uri
        }
    }

}

extension SearchRasterDataCollectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchRasterDataCollectionInput(arn: \(Swift.String(describing: arn)), rasterDataCollectionQuery: \(Swift.String(describing: rasterDataCollectionQuery)), nextToken: \"CONTENT_REDACTED\")"}
}

extension SearchRasterDataCollectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case nextToken = "NextToken"
        case rasterDataCollectionQuery = "RasterDataCollectionQuery"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let rasterDataCollectionQuery = self.rasterDataCollectionQuery {
            try encodeContainer.encode(rasterDataCollectionQuery, forKey: .rasterDataCollectionQuery)
        }
    }
}

extension SearchRasterDataCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/search-raster-data-collection"
    }
}

public struct SearchRasterDataCollectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the raster data collection.
    /// This member is required.
    public var arn: Swift.String?
    /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
    public var nextToken: Swift.String?
    ///
    /// This member is required.
    public var rasterDataCollectionQuery: SageMakerGeospatialClientTypes.RasterDataCollectionQueryWithBandFilterInput?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        rasterDataCollectionQuery: SageMakerGeospatialClientTypes.RasterDataCollectionQueryWithBandFilterInput? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.rasterDataCollectionQuery = rasterDataCollectionQuery
    }
}

struct SearchRasterDataCollectionInputBody: Swift.Equatable {
    let arn: Swift.String?
    let rasterDataCollectionQuery: SageMakerGeospatialClientTypes.RasterDataCollectionQueryWithBandFilterInput?
    let nextToken: Swift.String?
}

extension SearchRasterDataCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case nextToken = "NextToken"
        case rasterDataCollectionQuery = "RasterDataCollectionQuery"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let rasterDataCollectionQueryDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.RasterDataCollectionQueryWithBandFilterInput.self, forKey: .rasterDataCollectionQuery)
        rasterDataCollectionQuery = rasterDataCollectionQueryDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SearchRasterDataCollectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchRasterDataCollectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchRasterDataCollectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchRasterDataCollectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchRasterDataCollectionOutputResponse(approximateResultCount: \(Swift.String(describing: approximateResultCount)), items: \(Swift.String(describing: items)), nextToken: \"CONTENT_REDACTED\")"}
}

extension SearchRasterDataCollectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchRasterDataCollectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approximateResultCount = output.approximateResultCount
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.approximateResultCount = nil
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct SearchRasterDataCollectionOutputResponse: Swift.Equatable {
    ///
    /// This member is required.
    public var approximateResultCount: Swift.Int?
    ///
    public var items: [SageMakerGeospatialClientTypes.ItemSource]?
    /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        approximateResultCount: Swift.Int? = nil,
        items: [SageMakerGeospatialClientTypes.ItemSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.approximateResultCount = approximateResultCount
        self.items = items
        self.nextToken = nextToken
    }
}

struct SearchRasterDataCollectionOutputResponseBody: Swift.Equatable {
    let approximateResultCount: Swift.Int?
    let nextToken: Swift.String?
    let items: [SageMakerGeospatialClientTypes.ItemSource]?
}

extension SearchRasterDataCollectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateResultCount = "ApproximateResultCount"
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approximateResultCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateResultCount)
        approximateResultCount = approximateResultCountDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let itemsContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.ItemSource?].self, forKey: .items)
        var itemsDecoded0:[SageMakerGeospatialClientTypes.ItemSource]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [SageMakerGeospatialClientTypes.ItemSource]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the service quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    ///
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// ASCENDING
        case ascending
        /// DESCENDING
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.StackConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputResolution = "OutputResolution"
        case targetBands = "TargetBands"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputResolution = self.outputResolution {
            try encodeContainer.encode(outputResolution, forKey: .outputResolution)
        }
        if let targetBands = targetBands {
            var targetBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetBands)
            for string0 in targetBands {
                try targetBandsContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputResolutionDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.OutputResolutionStackInput.self, forKey: .outputResolution)
        outputResolution = outputResolutionDecoded
        let targetBandsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetBands)
        var targetBandsDecoded0:[Swift.String]? = nil
        if let targetBandsContainer = targetBandsContainer {
            targetBandsDecoded0 = [Swift.String]()
            for string0 in targetBandsContainer {
                if let string0 = string0 {
                    targetBandsDecoded0?.append(string0)
                }
            }
        }
        targetBands = targetBandsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct StackConfigInput: Swift.Equatable {
        ///
        public var outputResolution: SageMakerGeospatialClientTypes.OutputResolutionStackInput?
        ///
        public var targetBands: [Swift.String]?

        public init (
            outputResolution: SageMakerGeospatialClientTypes.OutputResolutionStackInput? = nil,
            targetBands: [Swift.String]? = nil
        )
        {
            self.outputResolution = outputResolution
            self.targetBands = targetBands
        }
    }

}

extension StartEarthObservationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case executionRoleArn = "ExecutionRoleArn"
        case inputConfig = "InputConfig"
        case jobConfig = "JobConfig"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let inputConfig = self.inputConfig {
            try encodeContainer.encode(inputConfig, forKey: .inputConfig)
        }
        if let jobConfig = self.jobConfig {
            try encodeContainer.encode(jobConfig, forKey: .jobConfig)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartEarthObservationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/earth-observation-jobs"
    }
}

public struct StartEarthObservationJobInput: Swift.Equatable {
    /// A unique token that guarantees that the call to this API is idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
    public var executionRoleArn: Swift.String?
    /// Input configuration information for the Earth Observation job.
    /// This member is required.
    public var inputConfig: SageMakerGeospatialClientTypes.InputConfigInput?
    /// An object containing information about the job configuration.
    /// This member is required.
    public var jobConfig: SageMakerGeospatialClientTypes.JobConfigInput?
    /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
    public var kmsKeyId: Swift.String?
    /// The name of the Earth Observation job.
    /// This member is required.
    public var name: Swift.String?
    /// Each tag consists of a key and a value.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        inputConfig: SageMakerGeospatialClientTypes.InputConfigInput? = nil,
        jobConfig: SageMakerGeospatialClientTypes.JobConfigInput? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.executionRoleArn = executionRoleArn
        self.inputConfig = inputConfig
        self.jobConfig = jobConfig
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.tags = tags
    }
}

struct StartEarthObservationJobInputBody: Swift.Equatable {
    let name: Swift.String?
    let clientToken: Swift.String?
    let kmsKeyId: Swift.String?
    let inputConfig: SageMakerGeospatialClientTypes.InputConfigInput?
    let jobConfig: SageMakerGeospatialClientTypes.JobConfigInput?
    let executionRoleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartEarthObservationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case executionRoleArn = "ExecutionRoleArn"
        case inputConfig = "InputConfig"
        case jobConfig = "JobConfig"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.InputConfigInput.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
        let jobConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.JobConfigInput.self, forKey: .jobConfig)
        jobConfig = jobConfigDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartEarthObservationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartEarthObservationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartEarthObservationJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartEarthObservationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartEarthObservationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.durationInSeconds = output.durationInSeconds
            self.executionRoleArn = output.executionRoleArn
            self.inputConfig = output.inputConfig
            self.jobConfig = output.jobConfig
            self.kmsKeyId = output.kmsKeyId
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTime = nil
            self.durationInSeconds = nil
            self.executionRoleArn = nil
            self.inputConfig = nil
            self.jobConfig = nil
            self.kmsKeyId = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct StartEarthObservationJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Earth Observation job.
    /// This member is required.
    public var arn: Swift.String?
    /// The creation time.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The duration of the session, in seconds.
    /// This member is required.
    public var durationInSeconds: Swift.Int?
    /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
    public var executionRoleArn: Swift.String?
    /// Input configuration information for the Earth Observation job.
    public var inputConfig: SageMakerGeospatialClientTypes.InputConfigOutput?
    /// An object containing information about the job configuration.
    /// This member is required.
    public var jobConfig: SageMakerGeospatialClientTypes.JobConfigInput?
    /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
    public var kmsKeyId: Swift.String?
    /// The name of the Earth Observation job.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the Earth Observation job.
    /// This member is required.
    public var status: SageMakerGeospatialClientTypes.EarthObservationJobStatus?
    /// Each tag consists of a key and a value.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        durationInSeconds: Swift.Int? = nil,
        executionRoleArn: Swift.String? = nil,
        inputConfig: SageMakerGeospatialClientTypes.InputConfigOutput? = nil,
        jobConfig: SageMakerGeospatialClientTypes.JobConfigInput? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: SageMakerGeospatialClientTypes.EarthObservationJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.durationInSeconds = durationInSeconds
        self.executionRoleArn = executionRoleArn
        self.inputConfig = inputConfig
        self.jobConfig = jobConfig
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct StartEarthObservationJobOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let durationInSeconds: Swift.Int?
    let status: SageMakerGeospatialClientTypes.EarthObservationJobStatus?
    let kmsKeyId: Swift.String?
    let inputConfig: SageMakerGeospatialClientTypes.InputConfigOutput?
    let jobConfig: SageMakerGeospatialClientTypes.JobConfigInput?
    let executionRoleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartEarthObservationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case durationInSeconds = "DurationInSeconds"
        case executionRoleArn = "ExecutionRoleArn"
        case inputConfig = "InputConfig"
        case jobConfig = "JobConfig"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case status = "Status"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.EarthObservationJobStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.InputConfigOutput.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
        let jobConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.JobConfigInput.self, forKey: .jobConfig)
        jobConfig = jobConfigDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartVectorEnrichmentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case executionRoleArn = "ExecutionRoleArn"
        case inputConfig = "InputConfig"
        case jobConfig = "JobConfig"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let inputConfig = self.inputConfig {
            try encodeContainer.encode(inputConfig, forKey: .inputConfig)
        }
        if let jobConfig = self.jobConfig {
            try encodeContainer.encode(jobConfig, forKey: .jobConfig)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartVectorEnrichmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/vector-enrichment-jobs"
    }
}

public struct StartVectorEnrichmentJobInput: Swift.Equatable {
    /// A unique token that guarantees that the call to this API is idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// Input configuration information for the Vector Enrichment job.
    /// This member is required.
    public var inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig?
    /// An object containing information about the job configuration.
    /// This member is required.
    public var jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig?
    /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
    public var kmsKeyId: Swift.String?
    /// The name of the Vector Enrichment job.
    /// This member is required.
    public var name: Swift.String?
    /// Each tag consists of a key and a value.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig? = nil,
        jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.executionRoleArn = executionRoleArn
        self.inputConfig = inputConfig
        self.jobConfig = jobConfig
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.tags = tags
    }
}

struct StartVectorEnrichmentJobInputBody: Swift.Equatable {
    let name: Swift.String?
    let clientToken: Swift.String?
    let kmsKeyId: Swift.String?
    let inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig?
    let jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig?
    let executionRoleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartVectorEnrichmentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case executionRoleArn = "ExecutionRoleArn"
        case inputConfig = "InputConfig"
        case jobConfig = "JobConfig"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
        let jobConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig.self, forKey: .jobConfig)
        jobConfig = jobConfigDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartVectorEnrichmentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartVectorEnrichmentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartVectorEnrichmentJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartVectorEnrichmentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartVectorEnrichmentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.durationInSeconds = output.durationInSeconds
            self.executionRoleArn = output.executionRoleArn
            self.inputConfig = output.inputConfig
            self.jobConfig = output.jobConfig
            self.kmsKeyId = output.kmsKeyId
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
            self.type = output.type
        } else {
            self.arn = nil
            self.creationTime = nil
            self.durationInSeconds = nil
            self.executionRoleArn = nil
            self.inputConfig = nil
            self.jobConfig = nil
            self.kmsKeyId = nil
            self.name = nil
            self.status = nil
            self.tags = nil
            self.type = nil
        }
    }
}

public struct StartVectorEnrichmentJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
    /// This member is required.
    public var arn: Swift.String?
    /// The creation time.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The duration of the Vector Enrichment job, in seconds.
    /// This member is required.
    public var durationInSeconds: Swift.Int?
    /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// Input configuration information for starting the Vector Enrichment job.
    /// This member is required.
    public var inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig?
    /// An object containing information about the job configuration.
    /// This member is required.
    public var jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig?
    /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
    public var kmsKeyId: Swift.String?
    /// The name of the Vector Enrichment job.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the Vector Enrichment job being started.
    /// This member is required.
    public var status: SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus?
    /// Each tag consists of a key and a value.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the Vector Enrichment job.
    /// This member is required.
    public var type: SageMakerGeospatialClientTypes.VectorEnrichmentJobType?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        durationInSeconds: Swift.Int? = nil,
        executionRoleArn: Swift.String? = nil,
        inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig? = nil,
        jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        status: SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: SageMakerGeospatialClientTypes.VectorEnrichmentJobType? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.durationInSeconds = durationInSeconds
        self.executionRoleArn = executionRoleArn
        self.inputConfig = inputConfig
        self.jobConfig = jobConfig
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.status = status
        self.tags = tags
        self.type = type
    }
}

struct StartVectorEnrichmentJobOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let type: SageMakerGeospatialClientTypes.VectorEnrichmentJobType?
    let creationTime: ClientRuntime.Date?
    let durationInSeconds: Swift.Int?
    let status: SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus?
    let kmsKeyId: Swift.String?
    let inputConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig?
    let jobConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig?
    let executionRoleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartVectorEnrichmentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case durationInSeconds = "DurationInSeconds"
        case executionRoleArn = "ExecutionRoleArn"
        case inputConfig = "InputConfig"
        case jobConfig = "JobConfig"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case status = "Status"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobType.self, forKey: .type)
        type = typeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
        let jobConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig.self, forKey: .jobConfig)
        jobConfig = jobConfigDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StopEarthObservationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension StopEarthObservationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/earth-observation-jobs/stop"
    }
}

public struct StopEarthObservationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Earth Observation job being stopped.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct StopEarthObservationJobInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension StopEarthObservationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StopEarthObservationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopEarthObservationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopEarthObservationJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopEarthObservationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopEarthObservationJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension StopVectorEnrichmentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension StopVectorEnrichmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/vector-enrichment-jobs/stop"
    }
}

public struct StopVectorEnrichmentJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct StopVectorEnrichmentJobInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension StopVectorEnrichmentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StopVectorEnrichmentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopVectorEnrichmentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopVectorEnrichmentJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopVectorEnrichmentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopVectorEnrichmentJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Each tag consists of a key and a value.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension SageMakerGeospatialClientTypes {
    public enum TargetOptions: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// INPUT
        case input
        /// OUTPUT
        case output
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetOptions] {
            return [
                .input,
                .output,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .input: return "INPUT"
            case .output: return "OUTPUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetOptions(rawValue: rawValue) ?? TargetOptions.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum TemporalStatistics: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// MEAN
        case mean
        /// MEDIAN
        case median
        /// STANDARD_DEVIATION
        case standardDeviation
        case sdkUnknown(Swift.String)

        public static var allCases: [TemporalStatistics] {
            return [
                .mean,
                .median,
                .standardDeviation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mean: return "MEAN"
            case .median: return "MEDIAN"
            case .standardDeviation: return "STANDARD_DEVIATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemporalStatistics(rawValue: rawValue) ?? TemporalStatistics.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.TemporalStatisticsConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupBy = "GroupBy"
        case statistics = "Statistics"
        case targetBands = "TargetBands"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupBy = self.groupBy {
            try encodeContainer.encode(groupBy.rawValue, forKey: .groupBy)
        }
        if let statistics = statistics {
            var statisticsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statistics)
            for temporalstatistics0 in statistics {
                try statisticsContainer.encode(temporalstatistics0.rawValue)
            }
        }
        if let targetBands = targetBands {
            var targetBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetBands)
            for string0 in targetBands {
                try targetBandsContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupByDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.GroupBy.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let statisticsContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.TemporalStatistics?].self, forKey: .statistics)
        var statisticsDecoded0:[SageMakerGeospatialClientTypes.TemporalStatistics]? = nil
        if let statisticsContainer = statisticsContainer {
            statisticsDecoded0 = [SageMakerGeospatialClientTypes.TemporalStatistics]()
            for string0 in statisticsContainer {
                if let string0 = string0 {
                    statisticsDecoded0?.append(string0)
                }
            }
        }
        statistics = statisticsDecoded0
        let targetBandsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetBands)
        var targetBandsDecoded0:[Swift.String]? = nil
        if let targetBandsContainer = targetBandsContainer {
            targetBandsDecoded0 = [Swift.String]()
            for string0 in targetBandsContainer {
                if let string0 = string0 {
                    targetBandsDecoded0?.append(string0)
                }
            }
        }
        targetBands = targetBandsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct TemporalStatisticsConfigInput: Swift.Equatable {
        ///
        public var groupBy: SageMakerGeospatialClientTypes.GroupBy?
        ///
        /// This member is required.
        public var statistics: [SageMakerGeospatialClientTypes.TemporalStatistics]?
        ///
        public var targetBands: [Swift.String]?

        public init (
            groupBy: SageMakerGeospatialClientTypes.GroupBy? = nil,
            statistics: [SageMakerGeospatialClientTypes.TemporalStatistics]? = nil,
            targetBands: [Swift.String]? = nil
        )
        {
            self.groupBy = groupBy
            self.statistics = statistics
            self.targetBands = targetBands
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    ///
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension SageMakerGeospatialClientTypes.TimeRangeFilterInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension SageMakerGeospatialClientTypes.TimeRangeFilterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension SageMakerGeospatialClientTypes {
    /// The input for the time-range filter.
    public struct TimeRangeFilterInput: Swift.Equatable {
        /// The end time for the time-range filter.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// The start time for the time-range filter.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init (
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum Unit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// METERS
        case meters
        case sdkUnknown(Swift.String)

        public static var allCases: [Unit] {
            return [
                .meters,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .meters: return "METERS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Unit(rawValue: rawValue) ?? Unit.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys of the tags you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension SageMakerGeospatialClientTypes.UserDefined: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unit = "Unit"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.Unit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct UserDefined: Swift.Equatable {
        ///
        /// This member is required.
        public var unit: SageMakerGeospatialClientTypes.Unit?
        ///
        /// This member is required.
        public var value: Swift.Float?

        public init (
            unit: SageMakerGeospatialClientTypes.Unit? = nil,
            value: Swift.Float? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    ///
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension SageMakerGeospatialClientTypes.VectorEnrichmentJobConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mapmatchingconfig = "MapMatchingConfig"
        case reversegeocodingconfig = "ReverseGeocodingConfig"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .mapmatchingconfig(mapmatchingconfig):
                try container.encode(mapmatchingconfig, forKey: .mapmatchingconfig)
            case let .reversegeocodingconfig(reversegeocodingconfig):
                try container.encode(reversegeocodingconfig, forKey: .reversegeocodingconfig)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let reversegeocodingconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.ReverseGeocodingConfig.self, forKey: .reversegeocodingconfig)
        if let reversegeocodingconfig = reversegeocodingconfigDecoded {
            self = .reversegeocodingconfig(reversegeocodingconfig)
            return
        }
        let mapmatchingconfigDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.MapMatchingConfig.self, forKey: .mapmatchingconfig)
        if let mapmatchingconfig = mapmatchingconfigDecoded {
            self = .mapmatchingconfig(mapmatchingconfig)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SageMakerGeospatialClientTypes {
    /// It contains configs such as ReverseGeocodingConfig and MapMatchingConfig.
    public enum VectorEnrichmentJobConfig: Swift.Equatable {
        ///
        case reversegeocodingconfig(SageMakerGeospatialClientTypes.ReverseGeocodingConfig)
        ///
        case mapmatchingconfig(SageMakerGeospatialClientTypes.MapMatchingConfig)
        case sdkUnknown(Swift.String)
    }

}

extension SageMakerGeospatialClientTypes.VectorEnrichmentJobDataSourceConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3data = "S3Data"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3data(s3data):
                try container.encode(s3data, forKey: .s3data)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3dataDecoded = try values.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobS3Data.self, forKey: .s3data)
        if let s3data = s3dataDecoded {
            self = .s3data(s3data)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public enum VectorEnrichmentJobDataSourceConfigInput: Swift.Equatable {
        ///
        case s3data(SageMakerGeospatialClientTypes.VectorEnrichmentJobS3Data)
        case sdkUnknown(Swift.String)
    }

}

extension SageMakerGeospatialClientTypes {
    public enum VectorEnrichmentJobDocumentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case sdkUnknown(Swift.String)

        public static var allCases: [VectorEnrichmentJobDocumentType] {
            return [
                .csv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VectorEnrichmentJobDocumentType(rawValue: rawValue) ?? VectorEnrichmentJobDocumentType.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.VectorEnrichmentJobErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage = "ErrorMessage"
        case errorType = "ErrorType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorType = self.errorType {
            try encodeContainer.encode(errorType.rawValue, forKey: .errorType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorTypeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobErrorType.self, forKey: .errorType)
        errorType = errorTypeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// VectorEnrichmentJob error details in response from GetVectorEnrichmentJob.
    public struct VectorEnrichmentJobErrorDetails: Swift.Equatable {
        /// A message that you define and then is processed and rendered by the Vector Enrichment job when the error occurs.
        public var errorMessage: Swift.String?
        /// The type of error generated during the Vector Enrichment job.
        public var errorType: SageMakerGeospatialClientTypes.VectorEnrichmentJobErrorType?

        public init (
            errorMessage: Swift.String? = nil,
            errorType: SageMakerGeospatialClientTypes.VectorEnrichmentJobErrorType? = nil
        )
        {
            self.errorMessage = errorMessage
            self.errorType = errorType
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum VectorEnrichmentJobErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// CLIENT_ERROR
        case clientError
        /// SERVER_ERROR
        case serverError
        case sdkUnknown(Swift.String)

        public static var allCases: [VectorEnrichmentJobErrorType] {
            return [
                .clientError,
                .serverError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clientError: return "CLIENT_ERROR"
            case .serverError: return "SERVER_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VectorEnrichmentJobErrorType(rawValue: rawValue) ?? VectorEnrichmentJobErrorType.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.VectorEnrichmentJobExportErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobExportErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// VectorEnrichmentJob export error details in response from GetVectorEnrichmentJob.
    public struct VectorEnrichmentJobExportErrorDetails: Swift.Equatable {
        /// The message providing details about the errors generated during the Vector Enrichment job.
        public var message: Swift.String?
        ///
        public var type: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportErrorType?

        public init (
            message: Swift.String? = nil,
            type: SageMakerGeospatialClientTypes.VectorEnrichmentJobExportErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum VectorEnrichmentJobExportErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clientError
        case serverError
        case sdkUnknown(Swift.String)

        public static var allCases: [VectorEnrichmentJobExportErrorType] {
            return [
                .clientError,
                .serverError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clientError: return "CLIENT_ERROR"
            case .serverError: return "SERVER_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VectorEnrichmentJobExportErrorType(rawValue: rawValue) ?? VectorEnrichmentJobExportErrorType.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum VectorEnrichmentJobExportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [VectorEnrichmentJobExportStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VectorEnrichmentJobExportStatus(rawValue: rawValue) ?? VectorEnrichmentJobExportStatus.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.VectorEnrichmentJobInputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceConfig = "DataSourceConfig"
        case documentType = "DocumentType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceConfig = self.dataSourceConfig {
            try encodeContainer.encode(dataSourceConfig, forKey: .dataSourceConfig)
        }
        if let documentType = self.documentType {
            try encodeContainer.encode(documentType.rawValue, forKey: .documentType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentTypeDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobDocumentType.self, forKey: .documentType)
        documentType = documentTypeDecoded
        let dataSourceConfigDecoded = try containerValues.decodeIfPresent(SageMakerGeospatialClientTypes.VectorEnrichmentJobDataSourceConfigInput.self, forKey: .dataSourceConfig)
        dataSourceConfig = dataSourceConfigDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The input structure for the InputConfig in a VectorEnrichmentJob.
    public struct VectorEnrichmentJobInputConfig: Swift.Equatable {
        ///
        /// This member is required.
        public var dataSourceConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobDataSourceConfigInput?
        ///
        /// This member is required.
        public var documentType: SageMakerGeospatialClientTypes.VectorEnrichmentJobDocumentType?

        public init (
            dataSourceConfig: SageMakerGeospatialClientTypes.VectorEnrichmentJobDataSourceConfigInput? = nil,
            documentType: SageMakerGeospatialClientTypes.VectorEnrichmentJobDocumentType? = nil
        )
        {
            self.dataSourceConfig = dataSourceConfig
            self.documentType = documentType
        }
    }

}

extension SageMakerGeospatialClientTypes.VectorEnrichmentJobS3Data: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    /// The Amazon S3 data for the Vector Enrichment job.
    public struct VectorEnrichmentJobS3Data: Swift.Equatable {
        /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
        public var kmsKeyId: Swift.String?
        /// The URL to the Amazon S3 data for the Vector Enrichment job.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum VectorEnrichmentJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case deleted
        case deleting
        case failed
        case initializing
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [VectorEnrichmentJobStatus] {
            return [
                .completed,
                .deleted,
                .deleting,
                .failed,
                .initializing,
                .inProgress,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .initializing: return "INITIALIZING"
            case .inProgress: return "IN_PROGRESS"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VectorEnrichmentJobStatus(rawValue: rawValue) ?? VectorEnrichmentJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes {
    public enum VectorEnrichmentJobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mapMatching
        case reverseGeocoding
        case sdkUnknown(Swift.String)

        public static var allCases: [VectorEnrichmentJobType] {
            return [
                .mapMatching,
                .reverseGeocoding,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mapMatching: return "MAP_MATCHING"
            case .reverseGeocoding: return "REVERSE_GEOCODING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VectorEnrichmentJobType(rawValue: rawValue) ?? VectorEnrichmentJobType.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.ViewOffNadirInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lowerBound = "LowerBound"
        case upperBound = "UpperBound"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lowerBound = self.lowerBound {
            try encodeContainer.encode(lowerBound, forKey: .lowerBound)
        }
        if let upperBound = self.upperBound {
            try encodeContainer.encode(upperBound, forKey: .upperBound)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lowerBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .lowerBound)
        lowerBound = lowerBoundDecoded
        let upperBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .upperBound)
        upperBound = upperBoundDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct ViewOffNadirInput: Swift.Equatable {
        ///
        /// This member is required.
        public var lowerBound: Swift.Float?
        ///
        /// This member is required.
        public var upperBound: Swift.Float?

        public init (
            lowerBound: Swift.Float? = nil,
            upperBound: Swift.Float? = nil
        )
        {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }
    }

}

extension SageMakerGeospatialClientTypes.ViewSunAzimuthInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lowerBound = "LowerBound"
        case upperBound = "UpperBound"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lowerBound = self.lowerBound {
            try encodeContainer.encode(lowerBound, forKey: .lowerBound)
        }
        if let upperBound = self.upperBound {
            try encodeContainer.encode(upperBound, forKey: .upperBound)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lowerBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .lowerBound)
        lowerBound = lowerBoundDecoded
        let upperBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .upperBound)
        upperBound = upperBoundDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct ViewSunAzimuthInput: Swift.Equatable {
        ///
        /// This member is required.
        public var lowerBound: Swift.Float?
        ///
        /// This member is required.
        public var upperBound: Swift.Float?

        public init (
            lowerBound: Swift.Float? = nil,
            upperBound: Swift.Float? = nil
        )
        {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }
    }

}

extension SageMakerGeospatialClientTypes.ViewSunElevationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lowerBound = "LowerBound"
        case upperBound = "UpperBound"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lowerBound = self.lowerBound {
            try encodeContainer.encode(lowerBound, forKey: .lowerBound)
        }
        if let upperBound = self.upperBound {
            try encodeContainer.encode(upperBound, forKey: .upperBound)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lowerBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .lowerBound)
        lowerBound = lowerBoundDecoded
        let upperBoundDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .upperBound)
        upperBound = upperBoundDecoded
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct ViewSunElevationInput: Swift.Equatable {
        /// The lower bound to view the sun elevation.
        /// This member is required.
        public var lowerBound: Swift.Float?
        /// The upper bound to view the sun elevation.
        /// This member is required.
        public var upperBound: Swift.Float?

        public init (
            lowerBound: Swift.Float? = nil,
            upperBound: Swift.Float? = nil
        )
        {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }
    }

}

extension SageMakerGeospatialClientTypes {
    public enum ZonalStatistics: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// MAX
        case max
        /// MEAN
        case mean
        /// MEDIAN
        case median
        /// MIN
        case min
        /// STANDARD_DEVIATION
        case standardDeviation
        /// SUM
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [ZonalStatistics] {
            return [
                .max,
                .mean,
                .median,
                .min,
                .standardDeviation,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .max: return "MAX"
            case .mean: return "MEAN"
            case .median: return "MEDIAN"
            case .min: return "MIN"
            case .standardDeviation: return "STANDARD_DEVIATION"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ZonalStatistics(rawValue: rawValue) ?? ZonalStatistics.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerGeospatialClientTypes.ZonalStatisticsConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statistics = "Statistics"
        case targetBands = "TargetBands"
        case zoneS3Path = "ZoneS3Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statistics = statistics {
            var statisticsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statistics)
            for zonalstatistics0 in statistics {
                try statisticsContainer.encode(zonalstatistics0.rawValue)
            }
        }
        if let targetBands = targetBands {
            var targetBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetBands)
            for string0 in targetBands {
                try targetBandsContainer.encode(string0)
            }
        }
        if let zoneS3Path = self.zoneS3Path {
            try encodeContainer.encode(zoneS3Path, forKey: .zoneS3Path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zoneS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zoneS3Path)
        zoneS3Path = zoneS3PathDecoded
        let statisticsContainer = try containerValues.decodeIfPresent([SageMakerGeospatialClientTypes.ZonalStatistics?].self, forKey: .statistics)
        var statisticsDecoded0:[SageMakerGeospatialClientTypes.ZonalStatistics]? = nil
        if let statisticsContainer = statisticsContainer {
            statisticsDecoded0 = [SageMakerGeospatialClientTypes.ZonalStatistics]()
            for string0 in statisticsContainer {
                if let string0 = string0 {
                    statisticsDecoded0?.append(string0)
                }
            }
        }
        statistics = statisticsDecoded0
        let targetBandsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetBands)
        var targetBandsDecoded0:[Swift.String]? = nil
        if let targetBandsContainer = targetBandsContainer {
            targetBandsDecoded0 = [Swift.String]()
            for string0 in targetBandsContainer {
                if let string0 = string0 {
                    targetBandsDecoded0?.append(string0)
                }
            }
        }
        targetBands = targetBandsDecoded0
    }
}

extension SageMakerGeospatialClientTypes {
    ///
    public struct ZonalStatisticsConfigInput: Swift.Equatable {
        ///
        /// This member is required.
        public var statistics: [SageMakerGeospatialClientTypes.ZonalStatistics]?
        ///
        public var targetBands: [Swift.String]?
        ///
        /// This member is required.
        public var zoneS3Path: Swift.String?

        public init (
            statistics: [SageMakerGeospatialClientTypes.ZonalStatistics]? = nil,
            targetBands: [Swift.String]? = nil,
            zoneS3Path: Swift.String? = nil
        )
        {
            self.statistics = statistics
            self.targetBands = targetBands
            self.zoneS3Path = zoneS3Path
        }
    }

}
