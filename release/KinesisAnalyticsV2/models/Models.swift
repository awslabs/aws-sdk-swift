// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AddApplicationCloudWatchLoggingOptionInputBodyMiddleware: Middleware {
    public let id: String = "AddApplicationCloudWatchLoggingOptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationCloudWatchLoggingOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationCloudWatchLoggingOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationCloudWatchLoggingOptionInput>
    public typealias MOutput = OperationOutput<AddApplicationCloudWatchLoggingOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationCloudWatchLoggingOptionOutputError>
}

extension AddApplicationCloudWatchLoggingOptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationCloudWatchLoggingOptionInput(applicationName: \(String(describing: applicationName)), cloudWatchLoggingOption: \(String(describing: cloudWatchLoggingOption)), conditionalToken: \(String(describing: conditionalToken)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)))"}
}

extension AddApplicationCloudWatchLoggingOptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOption = "CloudWatchLoggingOption"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let cloudWatchLoggingOption = cloudWatchLoggingOption {
            try encodeContainer.encode(cloudWatchLoggingOption, forKey: .cloudWatchLoggingOption)
        }
        if let conditionalToken = conditionalToken {
            try encodeContainer.encode(conditionalToken, forKey: .conditionalToken)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
    }
}

public struct AddApplicationCloudWatchLoggingOptionInputHeadersMiddleware: Middleware {
    public let id: String = "AddApplicationCloudWatchLoggingOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationCloudWatchLoggingOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationCloudWatchLoggingOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationCloudWatchLoggingOptionInput>
    public typealias MOutput = OperationOutput<AddApplicationCloudWatchLoggingOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationCloudWatchLoggingOptionOutputError>
}

public struct AddApplicationCloudWatchLoggingOptionInputQueryItemMiddleware: Middleware {
    public let id: String = "AddApplicationCloudWatchLoggingOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationCloudWatchLoggingOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationCloudWatchLoggingOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationCloudWatchLoggingOptionInput>
    public typealias MOutput = OperationOutput<AddApplicationCloudWatchLoggingOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationCloudWatchLoggingOptionOutputError>
}

public struct AddApplicationCloudWatchLoggingOptionInput: Equatable {
    /// <p>The Kinesis Data Analytics application name.</p>
    public let applicationName: String?
    /// <p>Provides the Amazon CloudWatch log stream Amazon Resource Name (ARN). </p>
    public let cloudWatchLoggingOption: CloudWatchLoggingOption?
    /// <p>A value you use to implement strong concurrency for application updates. You must
    ///       provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
    ///       get the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
    ///         <code>ConditionalToken</code> parameter instead of
    ///       <code>CurrentApplicationVersionId</code>.</p>
    public let conditionalToken: String?
    /// <p>The version ID of the Kinesis Data Analytics application. You must provide the
    ///         <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>.You can
    ///       retrieve the application version ID using <a>DescribeApplication</a>. For better
    ///       concurrency support, use the <code>ConditionalToken</code> parameter instead of
    ///         <code>CurrentApplicationVersionId</code>.</p>
    public let currentApplicationVersionId: Int?

    public init (
        applicationName: String? = nil,
        cloudWatchLoggingOption: CloudWatchLoggingOption? = nil,
        conditionalToken: String? = nil,
        currentApplicationVersionId: Int? = nil
    )
    {
        self.applicationName = applicationName
        self.cloudWatchLoggingOption = cloudWatchLoggingOption
        self.conditionalToken = conditionalToken
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

struct AddApplicationCloudWatchLoggingOptionInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let cloudWatchLoggingOption: CloudWatchLoggingOption?
    public let conditionalToken: String?
}

extension AddApplicationCloudWatchLoggingOptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOption = "CloudWatchLoggingOption"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let cloudWatchLoggingOptionDecoded = try containerValues.decodeIfPresent(CloudWatchLoggingOption.self, forKey: .cloudWatchLoggingOption)
        cloudWatchLoggingOption = cloudWatchLoggingOptionDecoded
        let conditionalTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conditionalToken)
        conditionalToken = conditionalTokenDecoded
    }
}

extension AddApplicationCloudWatchLoggingOptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationCloudWatchLoggingOptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddApplicationCloudWatchLoggingOptionOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationCloudWatchLoggingOptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationCloudWatchLoggingOptionOutputResponse(applicationARN: \(String(describing: applicationARN)), applicationVersionId: \(String(describing: applicationVersionId)), cloudWatchLoggingOptionDescriptions: \(String(describing: cloudWatchLoggingOptionDescriptions)))"}
}

extension AddApplicationCloudWatchLoggingOptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddApplicationCloudWatchLoggingOptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
            self.cloudWatchLoggingOptionDescriptions = output.cloudWatchLoggingOptionDescriptions
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
            self.cloudWatchLoggingOptionDescriptions = nil
        }
    }
}

public struct AddApplicationCloudWatchLoggingOptionOutputResponse: Equatable {
    /// <p>The application's ARN.</p>
    public let applicationARN: String?
    /// <p>The new version ID of the Kinesis Data Analytics application. Kinesis Data Analytics
    ///       updates the <code>ApplicationVersionId</code> each time you change the CloudWatch logging
    ///       options. </p>
    public let applicationVersionId: Int?
    /// <p>The descriptions of the current CloudWatch logging options for the Kinesis Data Analytics application.</p>
    public let cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]?

    public init (
        applicationARN: String? = nil,
        applicationVersionId: Int? = nil,
        cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
    }
}

struct AddApplicationCloudWatchLoggingOptionOutputResponseBody: Equatable {
    public let applicationARN: String?
    public let applicationVersionId: Int?
    public let cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]?
}

extension AddApplicationCloudWatchLoggingOptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
        case cloudWatchLoggingOptionDescriptions = "CloudWatchLoggingOptionDescriptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let cloudWatchLoggingOptionDescriptionsContainer = try containerValues.decodeIfPresent([CloudWatchLoggingOptionDescription?].self, forKey: .cloudWatchLoggingOptionDescriptions)
        var cloudWatchLoggingOptionDescriptionsDecoded0:[CloudWatchLoggingOptionDescription]? = nil
        if let cloudWatchLoggingOptionDescriptionsContainer = cloudWatchLoggingOptionDescriptionsContainer {
            cloudWatchLoggingOptionDescriptionsDecoded0 = [CloudWatchLoggingOptionDescription]()
            for structure0 in cloudWatchLoggingOptionDescriptionsContainer {
                if let structure0 = structure0 {
                    cloudWatchLoggingOptionDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptionsDecoded0
    }
}

public struct AddApplicationInputInputBodyMiddleware: Middleware {
    public let id: String = "AddApplicationInputInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationInputInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationInputInput>
    public typealias MOutput = OperationOutput<AddApplicationInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationInputOutputError>
}

extension AddApplicationInputInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationInputInput(applicationName: \(String(describing: applicationName)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), input: \(String(describing: input)))"}
}

extension AddApplicationInputInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case input = "Input"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
    }
}

public struct AddApplicationInputInputHeadersMiddleware: Middleware {
    public let id: String = "AddApplicationInputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationInputInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationInputInput>
    public typealias MOutput = OperationOutput<AddApplicationInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationInputOutputError>
}

public struct AddApplicationInputInputQueryItemMiddleware: Middleware {
    public let id: String = "AddApplicationInputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationInputInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationInputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationInputInput>
    public typealias MOutput = OperationOutput<AddApplicationInputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationInputOutputError>
}

public struct AddApplicationInputInput: Equatable {
    /// <p>The name of your existing application to which you want to add the streaming
    ///       source.</p>
    public let applicationName: String?
    /// <p>The current version of your application.
    ///         You must provide the <code>ApplicationVersionID</code> or the <code>ConditionalToken</code>.You can use the <a>DescribeApplication</a> operation to find the current application version.</p>
    public let currentApplicationVersionId: Int?
    /// <p>The <a>Input</a> to add.</p>
    public let input: Input?

    public init (
        applicationName: String? = nil,
        currentApplicationVersionId: Int? = nil,
        input: Input? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.input = input
    }
}

struct AddApplicationInputInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let input: Input?
}

extension AddApplicationInputInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case input = "Input"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Input.self, forKey: .input)
        input = inputDecoded
    }
}

extension AddApplicationInputOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationInputOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeValidationException" : self = .codeValidationException(try CodeValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddApplicationInputOutputError: Equatable {
    case codeValidationException(CodeValidationException)
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationInputOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationInputOutputResponse(applicationARN: \(String(describing: applicationARN)), applicationVersionId: \(String(describing: applicationVersionId)), inputDescriptions: \(String(describing: inputDescriptions)))"}
}

extension AddApplicationInputOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddApplicationInputOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
            self.inputDescriptions = output.inputDescriptions
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
            self.inputDescriptions = nil
        }
    }
}

public struct AddApplicationInputOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationARN: String?
    /// <p>Provides the current application version.</p>
    public let applicationVersionId: Int?
    /// <p>Describes the application input configuration.
    ///
    ///
    ///     </p>
    public let inputDescriptions: [InputDescription]?

    public init (
        applicationARN: String? = nil,
        applicationVersionId: Int? = nil,
        inputDescriptions: [InputDescription]? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.inputDescriptions = inputDescriptions
    }
}

struct AddApplicationInputOutputResponseBody: Equatable {
    public let applicationARN: String?
    public let applicationVersionId: Int?
    public let inputDescriptions: [InputDescription]?
}

extension AddApplicationInputOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
        case inputDescriptions = "InputDescriptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let inputDescriptionsContainer = try containerValues.decodeIfPresent([InputDescription?].self, forKey: .inputDescriptions)
        var inputDescriptionsDecoded0:[InputDescription]? = nil
        if let inputDescriptionsContainer = inputDescriptionsContainer {
            inputDescriptionsDecoded0 = [InputDescription]()
            for structure0 in inputDescriptionsContainer {
                if let structure0 = structure0 {
                    inputDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        inputDescriptions = inputDescriptionsDecoded0
    }
}

public struct AddApplicationInputProcessingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "AddApplicationInputProcessingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationInputProcessingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationInputProcessingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationInputProcessingConfigurationInput>
    public typealias MOutput = OperationOutput<AddApplicationInputProcessingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationInputProcessingConfigurationOutputError>
}

extension AddApplicationInputProcessingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationInputProcessingConfigurationInput(applicationName: \(String(describing: applicationName)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), inputId: \(String(describing: inputId)), inputProcessingConfiguration: \(String(describing: inputProcessingConfiguration)))"}
}

extension AddApplicationInputProcessingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case inputId = "InputId"
        case inputProcessingConfiguration = "InputProcessingConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let inputId = inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
        if let inputProcessingConfiguration = inputProcessingConfiguration {
            try encodeContainer.encode(inputProcessingConfiguration, forKey: .inputProcessingConfiguration)
        }
    }
}

public struct AddApplicationInputProcessingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "AddApplicationInputProcessingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationInputProcessingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationInputProcessingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationInputProcessingConfigurationInput>
    public typealias MOutput = OperationOutput<AddApplicationInputProcessingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationInputProcessingConfigurationOutputError>
}

public struct AddApplicationInputProcessingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "AddApplicationInputProcessingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationInputProcessingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationInputProcessingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationInputProcessingConfigurationInput>
    public typealias MOutput = OperationOutput<AddApplicationInputProcessingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationInputProcessingConfigurationOutputError>
}

public struct AddApplicationInputProcessingConfigurationInput: Equatable {
    /// <p>The name of the application to which you want to add the input processing
    ///       configuration.</p>
    public let applicationName: String?
    /// <p>The version of the application to which you want to add the input processing
    ///       configuration. You can use the <a>DescribeApplication</a> operation to get the
    ///       current application version. If the version specified is not the current version, the
    ///         <code>ConcurrentModificationException</code> is returned.</p>
    public let currentApplicationVersionId: Int?
    /// <p>The ID of the input configuration to add the input processing configuration to. You
    ///       can get a list of the input IDs for an application using the <a>DescribeApplication</a> operation.</p>
    public let inputId: String?
    /// <p>The <a>InputProcessingConfiguration</a> to add to the application.</p>
    public let inputProcessingConfiguration: InputProcessingConfiguration?

    public init (
        applicationName: String? = nil,
        currentApplicationVersionId: Int? = nil,
        inputId: String? = nil,
        inputProcessingConfiguration: InputProcessingConfiguration? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.inputId = inputId
        self.inputProcessingConfiguration = inputProcessingConfiguration
    }
}

struct AddApplicationInputProcessingConfigurationInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let inputId: String?
    public let inputProcessingConfiguration: InputProcessingConfiguration?
}

extension AddApplicationInputProcessingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case inputId = "InputId"
        case inputProcessingConfiguration = "InputProcessingConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let inputIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputId)
        inputId = inputIdDecoded
        let inputProcessingConfigurationDecoded = try containerValues.decodeIfPresent(InputProcessingConfiguration.self, forKey: .inputProcessingConfiguration)
        inputProcessingConfiguration = inputProcessingConfigurationDecoded
    }
}

extension AddApplicationInputProcessingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationInputProcessingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddApplicationInputProcessingConfigurationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationInputProcessingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationInputProcessingConfigurationOutputResponse(applicationARN: \(String(describing: applicationARN)), applicationVersionId: \(String(describing: applicationVersionId)), inputId: \(String(describing: inputId)), inputProcessingConfigurationDescription: \(String(describing: inputProcessingConfigurationDescription)))"}
}

extension AddApplicationInputProcessingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddApplicationInputProcessingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
            self.inputId = output.inputId
            self.inputProcessingConfigurationDescription = output.inputProcessingConfigurationDescription
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
            self.inputId = nil
            self.inputProcessingConfigurationDescription = nil
        }
    }
}

public struct AddApplicationInputProcessingConfigurationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationARN: String?
    /// <p>Provides the current application version. </p>
    public let applicationVersionId: Int?
    /// <p>The input ID that is associated with the application input. This is the ID that Kinesis Data Analytics assigns
    ///       to each input configuration that you add to your
    ///       application.</p>
    public let inputId: String?
    /// <p>The description of the preprocessor that executes on records in this input before the application's code is run.</p>
    public let inputProcessingConfigurationDescription: InputProcessingConfigurationDescription?

    public init (
        applicationARN: String? = nil,
        applicationVersionId: Int? = nil,
        inputId: String? = nil,
        inputProcessingConfigurationDescription: InputProcessingConfigurationDescription? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.inputId = inputId
        self.inputProcessingConfigurationDescription = inputProcessingConfigurationDescription
    }
}

struct AddApplicationInputProcessingConfigurationOutputResponseBody: Equatable {
    public let applicationARN: String?
    public let applicationVersionId: Int?
    public let inputId: String?
    public let inputProcessingConfigurationDescription: InputProcessingConfigurationDescription?
}

extension AddApplicationInputProcessingConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
        case inputId = "InputId"
        case inputProcessingConfigurationDescription = "InputProcessingConfigurationDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let inputIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputId)
        inputId = inputIdDecoded
        let inputProcessingConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(InputProcessingConfigurationDescription.self, forKey: .inputProcessingConfigurationDescription)
        inputProcessingConfigurationDescription = inputProcessingConfigurationDescriptionDecoded
    }
}

public struct AddApplicationOutputInputBodyMiddleware: Middleware {
    public let id: String = "AddApplicationOutputInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationOutputInput>
    public typealias MOutput = OperationOutput<AddApplicationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationOutputOutputError>
}

extension AddApplicationOutputInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationOutputInput(applicationName: \(String(describing: applicationName)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), output: \(String(describing: output)))"}
}

extension AddApplicationOutputInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case output = "Output"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
    }
}

public struct AddApplicationOutputInputHeadersMiddleware: Middleware {
    public let id: String = "AddApplicationOutputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationOutputInput>
    public typealias MOutput = OperationOutput<AddApplicationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationOutputOutputError>
}

public struct AddApplicationOutputInputQueryItemMiddleware: Middleware {
    public let id: String = "AddApplicationOutputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationOutputInput>
    public typealias MOutput = OperationOutput<AddApplicationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationOutputOutputError>
}

public struct AddApplicationOutputInput: Equatable {
    /// <p>The name of the application to which you want to add the output configuration.</p>
    public let applicationName: String?
    /// <p>The version of the application to which you want to add the output configuration. You can
    ///       use the <a>DescribeApplication</a> operation to get the current application
    ///       version. If the version specified is not the current version, the
    ///         <code>ConcurrentModificationException</code> is returned. </p>
    public let currentApplicationVersionId: Int?
    /// <p>An array of objects, each describing one output configuration. In the output
    ///       configuration, you specify the name of an in-application stream, a destination (that is, a
    ///       Kinesis data stream, a Kinesis Data Firehose delivery stream, or an AWS Lambda function), and
    ///       record the formation to use when writing to the destination.</p>
    public let output: Output?

    public init (
        applicationName: String? = nil,
        currentApplicationVersionId: Int? = nil,
        output: Output? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.output = output
    }
}

struct AddApplicationOutputInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let output: Output?
}

extension AddApplicationOutputInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case output = "Output"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let outputDecoded = try containerValues.decodeIfPresent(Output.self, forKey: .output)
        output = outputDecoded
    }
}

extension AddApplicationOutputOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationOutputOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddApplicationOutputOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationOutputOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationOutputOutputResponse(applicationARN: \(String(describing: applicationARN)), applicationVersionId: \(String(describing: applicationVersionId)), outputDescriptions: \(String(describing: outputDescriptions)))"}
}

extension AddApplicationOutputOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddApplicationOutputOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
            self.outputDescriptions = output.outputDescriptions
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
            self.outputDescriptions = nil
        }
    }
}

public struct AddApplicationOutputOutputResponse: Equatable {
    /// <p>The application Amazon Resource Name (ARN).</p>
    public let applicationARN: String?
    /// <p>The updated application version ID. Kinesis Data Analytics increments this ID when the application is
    ///       updated.</p>
    public let applicationVersionId: Int?
    /// <p>Describes the application output configuration.
    ///       For more information,
    ///       see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-output.html">Configuring Application Output</a>.
    ///
    ///     </p>
    public let outputDescriptions: [OutputDescription]?

    public init (
        applicationARN: String? = nil,
        applicationVersionId: Int? = nil,
        outputDescriptions: [OutputDescription]? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.outputDescriptions = outputDescriptions
    }
}

struct AddApplicationOutputOutputResponseBody: Equatable {
    public let applicationARN: String?
    public let applicationVersionId: Int?
    public let outputDescriptions: [OutputDescription]?
}

extension AddApplicationOutputOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
        case outputDescriptions = "OutputDescriptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let outputDescriptionsContainer = try containerValues.decodeIfPresent([OutputDescription?].self, forKey: .outputDescriptions)
        var outputDescriptionsDecoded0:[OutputDescription]? = nil
        if let outputDescriptionsContainer = outputDescriptionsContainer {
            outputDescriptionsDecoded0 = [OutputDescription]()
            for structure0 in outputDescriptionsContainer {
                if let structure0 = structure0 {
                    outputDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        outputDescriptions = outputDescriptionsDecoded0
    }
}

public struct AddApplicationReferenceDataSourceInputBodyMiddleware: Middleware {
    public let id: String = "AddApplicationReferenceDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationReferenceDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationReferenceDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationReferenceDataSourceInput>
    public typealias MOutput = OperationOutput<AddApplicationReferenceDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationReferenceDataSourceOutputError>
}

extension AddApplicationReferenceDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationReferenceDataSourceInput(applicationName: \(String(describing: applicationName)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), referenceDataSource: \(String(describing: referenceDataSource)))"}
}

extension AddApplicationReferenceDataSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case referenceDataSource = "ReferenceDataSource"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let referenceDataSource = referenceDataSource {
            try encodeContainer.encode(referenceDataSource, forKey: .referenceDataSource)
        }
    }
}

public struct AddApplicationReferenceDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "AddApplicationReferenceDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationReferenceDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationReferenceDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationReferenceDataSourceInput>
    public typealias MOutput = OperationOutput<AddApplicationReferenceDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationReferenceDataSourceOutputError>
}

public struct AddApplicationReferenceDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "AddApplicationReferenceDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationReferenceDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationReferenceDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationReferenceDataSourceInput>
    public typealias MOutput = OperationOutput<AddApplicationReferenceDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationReferenceDataSourceOutputError>
}

public struct AddApplicationReferenceDataSourceInput: Equatable {
    /// <p>The name of an existing application.</p>
    public let applicationName: String?
    /// <p>The version of the application for which you are adding the reference data source.
    ///         You can
    ///       use the <a>DescribeApplication</a> operation to get the current application
    ///       version. If the version specified is not the current version, the
    ///         <code>ConcurrentModificationException</code> is returned.</p>
    public let currentApplicationVersionId: Int?
    /// <p>The reference data source can be an object in your Amazon S3 bucket. Kinesis Data Analytics reads the object and copies the data
    ///       into the in-application table that is created. You provide an S3 bucket, object key name, and the resulting
    ///       in-application table that is
    ///       created. </p>
    public let referenceDataSource: ReferenceDataSource?

    public init (
        applicationName: String? = nil,
        currentApplicationVersionId: Int? = nil,
        referenceDataSource: ReferenceDataSource? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.referenceDataSource = referenceDataSource
    }
}

struct AddApplicationReferenceDataSourceInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let referenceDataSource: ReferenceDataSource?
}

extension AddApplicationReferenceDataSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case referenceDataSource = "ReferenceDataSource"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let referenceDataSourceDecoded = try containerValues.decodeIfPresent(ReferenceDataSource.self, forKey: .referenceDataSource)
        referenceDataSource = referenceDataSourceDecoded
    }
}

extension AddApplicationReferenceDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationReferenceDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddApplicationReferenceDataSourceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationReferenceDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationReferenceDataSourceOutputResponse(applicationARN: \(String(describing: applicationARN)), applicationVersionId: \(String(describing: applicationVersionId)), referenceDataSourceDescriptions: \(String(describing: referenceDataSourceDescriptions)))"}
}

extension AddApplicationReferenceDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddApplicationReferenceDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
            self.referenceDataSourceDescriptions = output.referenceDataSourceDescriptions
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
            self.referenceDataSourceDescriptions = nil
        }
    }
}

public struct AddApplicationReferenceDataSourceOutputResponse: Equatable {
    /// <p>The application Amazon Resource Name (ARN).</p>
    public let applicationARN: String?
    /// <p>The updated application version ID. Kinesis Data Analytics increments this ID when
    ///       the application is updated.</p>
    public let applicationVersionId: Int?
    /// <p>Describes reference data sources configured for the application.
    ///
    ///
    ///
    ///     </p>
    public let referenceDataSourceDescriptions: [ReferenceDataSourceDescription]?

    public init (
        applicationARN: String? = nil,
        applicationVersionId: Int? = nil,
        referenceDataSourceDescriptions: [ReferenceDataSourceDescription]? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.referenceDataSourceDescriptions = referenceDataSourceDescriptions
    }
}

struct AddApplicationReferenceDataSourceOutputResponseBody: Equatable {
    public let applicationARN: String?
    public let applicationVersionId: Int?
    public let referenceDataSourceDescriptions: [ReferenceDataSourceDescription]?
}

extension AddApplicationReferenceDataSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
        case referenceDataSourceDescriptions = "ReferenceDataSourceDescriptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let referenceDataSourceDescriptionsContainer = try containerValues.decodeIfPresent([ReferenceDataSourceDescription?].self, forKey: .referenceDataSourceDescriptions)
        var referenceDataSourceDescriptionsDecoded0:[ReferenceDataSourceDescription]? = nil
        if let referenceDataSourceDescriptionsContainer = referenceDataSourceDescriptionsContainer {
            referenceDataSourceDescriptionsDecoded0 = [ReferenceDataSourceDescription]()
            for structure0 in referenceDataSourceDescriptionsContainer {
                if let structure0 = structure0 {
                    referenceDataSourceDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        referenceDataSourceDescriptions = referenceDataSourceDescriptionsDecoded0
    }
}

public struct AddApplicationVpcConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "AddApplicationVpcConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationVpcConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationVpcConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationVpcConfigurationInput>
    public typealias MOutput = OperationOutput<AddApplicationVpcConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationVpcConfigurationOutputError>
}

extension AddApplicationVpcConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationVpcConfigurationInput(applicationName: \(String(describing: applicationName)), conditionalToken: \(String(describing: conditionalToken)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), vpcConfiguration: \(String(describing: vpcConfiguration)))"}
}

extension AddApplicationVpcConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let conditionalToken = conditionalToken {
            try encodeContainer.encode(conditionalToken, forKey: .conditionalToken)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let vpcConfiguration = vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }
}

public struct AddApplicationVpcConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "AddApplicationVpcConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationVpcConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationVpcConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationVpcConfigurationInput>
    public typealias MOutput = OperationOutput<AddApplicationVpcConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationVpcConfigurationOutputError>
}

public struct AddApplicationVpcConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "AddApplicationVpcConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddApplicationVpcConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<AddApplicationVpcConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddApplicationVpcConfigurationInput>
    public typealias MOutput = OperationOutput<AddApplicationVpcConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddApplicationVpcConfigurationOutputError>
}

public struct AddApplicationVpcConfigurationInput: Equatable {
    /// <p>The name of an existing application.</p>
    public let applicationName: String?
    /// <p>A value you use to implement strong concurrency for application updates. You must
    ///       provide the <code>ApplicationVersionID</code> or the <code>ConditionalToken</code>. You get
    ///       the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
    ///         <code>ConditionalToken</code> parameter instead of
    ///       <code>CurrentApplicationVersionId</code>.</p>
    public let conditionalToken: String?
    /// <p>The version of the application to which you want to add the VPC configuration. You must
    ///       provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
    ///       can use the <a>DescribeApplication</a> operation to get the current application
    ///       version. If the version specified is not the current version, the
    ///         <code>ConcurrentModificationException</code> is returned. For better concurrency support,
    ///       use the <code>ConditionalToken</code> parameter instead of
    ///         <code>CurrentApplicationVersionId</code>.</p>
    public let currentApplicationVersionId: Int?
    /// <p>Description of the VPC to add to the application.</p>
    public let vpcConfiguration: VpcConfiguration?

    public init (
        applicationName: String? = nil,
        conditionalToken: String? = nil,
        currentApplicationVersionId: Int? = nil,
        vpcConfiguration: VpcConfiguration? = nil
    )
    {
        self.applicationName = applicationName
        self.conditionalToken = conditionalToken
        self.currentApplicationVersionId = currentApplicationVersionId
        self.vpcConfiguration = vpcConfiguration
    }
}

struct AddApplicationVpcConfigurationInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let vpcConfiguration: VpcConfiguration?
    public let conditionalToken: String?
}

extension AddApplicationVpcConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case vpcConfiguration = "VpcConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let conditionalTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conditionalToken)
        conditionalToken = conditionalTokenDecoded
    }
}

extension AddApplicationVpcConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationVpcConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddApplicationVpcConfigurationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationVpcConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddApplicationVpcConfigurationOutputResponse(applicationARN: \(String(describing: applicationARN)), applicationVersionId: \(String(describing: applicationVersionId)), vpcConfigurationDescription: \(String(describing: vpcConfigurationDescription)))"}
}

extension AddApplicationVpcConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddApplicationVpcConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
            self.vpcConfigurationDescription = output.vpcConfigurationDescription
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
            self.vpcConfigurationDescription = nil
        }
    }
}

public struct AddApplicationVpcConfigurationOutputResponse: Equatable {
    /// <p>The ARN of the application.</p>
    public let applicationARN: String?
    /// <p>Provides the current application version. Kinesis Data Analytics updates the ApplicationVersionId each
    ///       time you update the application.</p>
    public let applicationVersionId: Int?
    /// <p>The parameters of the new VPC configuration.</p>
    public let vpcConfigurationDescription: VpcConfigurationDescription?

    public init (
        applicationARN: String? = nil,
        applicationVersionId: Int? = nil,
        vpcConfigurationDescription: VpcConfigurationDescription? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.vpcConfigurationDescription = vpcConfigurationDescription
    }
}

struct AddApplicationVpcConfigurationOutputResponseBody: Equatable {
    public let applicationARN: String?
    public let applicationVersionId: Int?
    public let vpcConfigurationDescription: VpcConfigurationDescription?
}

extension AddApplicationVpcConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
        case vpcConfigurationDescription = "VpcConfigurationDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let vpcConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(VpcConfigurationDescription.self, forKey: .vpcConfigurationDescription)
        vpcConfigurationDescription = vpcConfigurationDescriptionDecoded
    }
}

extension ApplicationCodeConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeContent = "CodeContent"
        case codeContentType = "CodeContentType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeContent = codeContent {
            try encodeContainer.encode(codeContent, forKey: .codeContent)
        }
        if let codeContentType = codeContentType {
            try encodeContainer.encode(codeContentType.rawValue, forKey: .codeContentType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeContentDecoded = try containerValues.decodeIfPresent(CodeContent.self, forKey: .codeContent)
        codeContent = codeContentDecoded
        let codeContentTypeDecoded = try containerValues.decodeIfPresent(CodeContentType.self, forKey: .codeContentType)
        codeContentType = codeContentTypeDecoded
    }
}

extension ApplicationCodeConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationCodeConfiguration(codeContent: \(String(describing: codeContent)), codeContentType: \(String(describing: codeContentType)))"}
}

/// <p>Describes code configuration for an application.</p>
public struct ApplicationCodeConfiguration: Equatable {
    /// <p>The location and type of the application code.</p>
    public let codeContent: CodeContent?
    /// <p>Specifies whether the code content is in text or zip format.</p>
    public let codeContentType: CodeContentType?

    public init (
        codeContent: CodeContent? = nil,
        codeContentType: CodeContentType? = nil
    )
    {
        self.codeContent = codeContent
        self.codeContentType = codeContentType
    }
}

extension ApplicationCodeConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeContentDescription = "CodeContentDescription"
        case codeContentType = "CodeContentType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeContentDescription = codeContentDescription {
            try encodeContainer.encode(codeContentDescription, forKey: .codeContentDescription)
        }
        if let codeContentType = codeContentType {
            try encodeContainer.encode(codeContentType.rawValue, forKey: .codeContentType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeContentTypeDecoded = try containerValues.decodeIfPresent(CodeContentType.self, forKey: .codeContentType)
        codeContentType = codeContentTypeDecoded
        let codeContentDescriptionDecoded = try containerValues.decodeIfPresent(CodeContentDescription.self, forKey: .codeContentDescription)
        codeContentDescription = codeContentDescriptionDecoded
    }
}

extension ApplicationCodeConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationCodeConfigurationDescription(codeContentDescription: \(String(describing: codeContentDescription)), codeContentType: \(String(describing: codeContentType)))"}
}

/// <p>Describes code configuration for an application.</p>
public struct ApplicationCodeConfigurationDescription: Equatable {
    /// <p>Describes details about the location and format of the application code.</p>
    public let codeContentDescription: CodeContentDescription?
    /// <p>Specifies whether the code content is in text or zip format.</p>
    public let codeContentType: CodeContentType?

    public init (
        codeContentDescription: CodeContentDescription? = nil,
        codeContentType: CodeContentType? = nil
    )
    {
        self.codeContentDescription = codeContentDescription
        self.codeContentType = codeContentType
    }
}

extension ApplicationCodeConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeContentTypeUpdate = "CodeContentTypeUpdate"
        case codeContentUpdate = "CodeContentUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeContentTypeUpdate = codeContentTypeUpdate {
            try encodeContainer.encode(codeContentTypeUpdate.rawValue, forKey: .codeContentTypeUpdate)
        }
        if let codeContentUpdate = codeContentUpdate {
            try encodeContainer.encode(codeContentUpdate, forKey: .codeContentUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeContentTypeUpdateDecoded = try containerValues.decodeIfPresent(CodeContentType.self, forKey: .codeContentTypeUpdate)
        codeContentTypeUpdate = codeContentTypeUpdateDecoded
        let codeContentUpdateDecoded = try containerValues.decodeIfPresent(CodeContentUpdate.self, forKey: .codeContentUpdate)
        codeContentUpdate = codeContentUpdateDecoded
    }
}

extension ApplicationCodeConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationCodeConfigurationUpdate(codeContentTypeUpdate: \(String(describing: codeContentTypeUpdate)), codeContentUpdate: \(String(describing: codeContentUpdate)))"}
}

/// <p>Describes code configuration updates for an application. This is supported for a Flink-based Kinesis Data Analytics application or a SQL-based Kinesis Data Analytics application.</p>
public struct ApplicationCodeConfigurationUpdate: Equatable {
    /// <p>Describes updates to the code content type.</p>
    public let codeContentTypeUpdate: CodeContentType?
    /// <p>Describes updates to the code content of an application.</p>
    public let codeContentUpdate: CodeContentUpdate?

    public init (
        codeContentTypeUpdate: CodeContentType? = nil,
        codeContentUpdate: CodeContentUpdate? = nil
    )
    {
        self.codeContentTypeUpdate = codeContentTypeUpdate
        self.codeContentUpdate = codeContentUpdate
    }
}

extension ApplicationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationCodeConfiguration = "ApplicationCodeConfiguration"
        case applicationSnapshotConfiguration = "ApplicationSnapshotConfiguration"
        case environmentProperties = "EnvironmentProperties"
        case flinkApplicationConfiguration = "FlinkApplicationConfiguration"
        case sqlApplicationConfiguration = "SqlApplicationConfiguration"
        case vpcConfigurations = "VpcConfigurations"
        case zeppelinApplicationConfiguration = "ZeppelinApplicationConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationCodeConfiguration = applicationCodeConfiguration {
            try encodeContainer.encode(applicationCodeConfiguration, forKey: .applicationCodeConfiguration)
        }
        if let applicationSnapshotConfiguration = applicationSnapshotConfiguration {
            try encodeContainer.encode(applicationSnapshotConfiguration, forKey: .applicationSnapshotConfiguration)
        }
        if let environmentProperties = environmentProperties {
            try encodeContainer.encode(environmentProperties, forKey: .environmentProperties)
        }
        if let flinkApplicationConfiguration = flinkApplicationConfiguration {
            try encodeContainer.encode(flinkApplicationConfiguration, forKey: .flinkApplicationConfiguration)
        }
        if let sqlApplicationConfiguration = sqlApplicationConfiguration {
            try encodeContainer.encode(sqlApplicationConfiguration, forKey: .sqlApplicationConfiguration)
        }
        if let vpcConfigurations = vpcConfigurations {
            var vpcConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcConfigurations)
            for vpcconfigurations0 in vpcConfigurations {
                try vpcConfigurationsContainer.encode(vpcconfigurations0)
            }
        }
        if let zeppelinApplicationConfiguration = zeppelinApplicationConfiguration {
            try encodeContainer.encode(zeppelinApplicationConfiguration, forKey: .zeppelinApplicationConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlApplicationConfigurationDecoded = try containerValues.decodeIfPresent(SqlApplicationConfiguration.self, forKey: .sqlApplicationConfiguration)
        sqlApplicationConfiguration = sqlApplicationConfigurationDecoded
        let flinkApplicationConfigurationDecoded = try containerValues.decodeIfPresent(FlinkApplicationConfiguration.self, forKey: .flinkApplicationConfiguration)
        flinkApplicationConfiguration = flinkApplicationConfigurationDecoded
        let environmentPropertiesDecoded = try containerValues.decodeIfPresent(EnvironmentProperties.self, forKey: .environmentProperties)
        environmentProperties = environmentPropertiesDecoded
        let applicationCodeConfigurationDecoded = try containerValues.decodeIfPresent(ApplicationCodeConfiguration.self, forKey: .applicationCodeConfiguration)
        applicationCodeConfiguration = applicationCodeConfigurationDecoded
        let applicationSnapshotConfigurationDecoded = try containerValues.decodeIfPresent(ApplicationSnapshotConfiguration.self, forKey: .applicationSnapshotConfiguration)
        applicationSnapshotConfiguration = applicationSnapshotConfigurationDecoded
        let vpcConfigurationsContainer = try containerValues.decodeIfPresent([VpcConfiguration?].self, forKey: .vpcConfigurations)
        var vpcConfigurationsDecoded0:[VpcConfiguration]? = nil
        if let vpcConfigurationsContainer = vpcConfigurationsContainer {
            vpcConfigurationsDecoded0 = [VpcConfiguration]()
            for structure0 in vpcConfigurationsContainer {
                if let structure0 = structure0 {
                    vpcConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        vpcConfigurations = vpcConfigurationsDecoded0
        let zeppelinApplicationConfigurationDecoded = try containerValues.decodeIfPresent(ZeppelinApplicationConfiguration.self, forKey: .zeppelinApplicationConfiguration)
        zeppelinApplicationConfiguration = zeppelinApplicationConfigurationDecoded
    }
}

extension ApplicationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationConfiguration(applicationCodeConfiguration: \(String(describing: applicationCodeConfiguration)), applicationSnapshotConfiguration: \(String(describing: applicationSnapshotConfiguration)), environmentProperties: \(String(describing: environmentProperties)), flinkApplicationConfiguration: \(String(describing: flinkApplicationConfiguration)), sqlApplicationConfiguration: \(String(describing: sqlApplicationConfiguration)), vpcConfigurations: \(String(describing: vpcConfigurations)), zeppelinApplicationConfiguration: \(String(describing: zeppelinApplicationConfiguration)))"}
}

/// <p>Specifies the creation parameters for a Kinesis Data Analytics application.</p>
public struct ApplicationConfiguration: Equatable {
    /// <p>The code location and type parameters for a Flink-based Kinesis Data Analytics application.</p>
    public let applicationCodeConfiguration: ApplicationCodeConfiguration?
    /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
    public let applicationSnapshotConfiguration: ApplicationSnapshotConfiguration?
    /// <p>Describes execution properties for a Flink-based Kinesis Data Analytics application.</p>
    public let environmentProperties: EnvironmentProperties?
    /// <p>The creation and update parameters for a Flink-based Kinesis Data Analytics application.</p>
    public let flinkApplicationConfiguration: FlinkApplicationConfiguration?
    /// <p>The creation and update parameters for a SQL-based Kinesis Data Analytics application.</p>
    public let sqlApplicationConfiguration: SqlApplicationConfiguration?
    /// <p>The array of descriptions of VPC configurations available to the application.</p>
    public let vpcConfigurations: [VpcConfiguration]?
    /// <p>The configuration parameters for a Kinesis Data Analytics Studio notebook.</p>
    public let zeppelinApplicationConfiguration: ZeppelinApplicationConfiguration?

    public init (
        applicationCodeConfiguration: ApplicationCodeConfiguration? = nil,
        applicationSnapshotConfiguration: ApplicationSnapshotConfiguration? = nil,
        environmentProperties: EnvironmentProperties? = nil,
        flinkApplicationConfiguration: FlinkApplicationConfiguration? = nil,
        sqlApplicationConfiguration: SqlApplicationConfiguration? = nil,
        vpcConfigurations: [VpcConfiguration]? = nil,
        zeppelinApplicationConfiguration: ZeppelinApplicationConfiguration? = nil
    )
    {
        self.applicationCodeConfiguration = applicationCodeConfiguration
        self.applicationSnapshotConfiguration = applicationSnapshotConfiguration
        self.environmentProperties = environmentProperties
        self.flinkApplicationConfiguration = flinkApplicationConfiguration
        self.sqlApplicationConfiguration = sqlApplicationConfiguration
        self.vpcConfigurations = vpcConfigurations
        self.zeppelinApplicationConfiguration = zeppelinApplicationConfiguration
    }
}

extension ApplicationConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationCodeConfigurationDescription = "ApplicationCodeConfigurationDescription"
        case applicationSnapshotConfigurationDescription = "ApplicationSnapshotConfigurationDescription"
        case environmentPropertyDescriptions = "EnvironmentPropertyDescriptions"
        case flinkApplicationConfigurationDescription = "FlinkApplicationConfigurationDescription"
        case runConfigurationDescription = "RunConfigurationDescription"
        case sqlApplicationConfigurationDescription = "SqlApplicationConfigurationDescription"
        case vpcConfigurationDescriptions = "VpcConfigurationDescriptions"
        case zeppelinApplicationConfigurationDescription = "ZeppelinApplicationConfigurationDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationCodeConfigurationDescription = applicationCodeConfigurationDescription {
            try encodeContainer.encode(applicationCodeConfigurationDescription, forKey: .applicationCodeConfigurationDescription)
        }
        if let applicationSnapshotConfigurationDescription = applicationSnapshotConfigurationDescription {
            try encodeContainer.encode(applicationSnapshotConfigurationDescription, forKey: .applicationSnapshotConfigurationDescription)
        }
        if let environmentPropertyDescriptions = environmentPropertyDescriptions {
            try encodeContainer.encode(environmentPropertyDescriptions, forKey: .environmentPropertyDescriptions)
        }
        if let flinkApplicationConfigurationDescription = flinkApplicationConfigurationDescription {
            try encodeContainer.encode(flinkApplicationConfigurationDescription, forKey: .flinkApplicationConfigurationDescription)
        }
        if let runConfigurationDescription = runConfigurationDescription {
            try encodeContainer.encode(runConfigurationDescription, forKey: .runConfigurationDescription)
        }
        if let sqlApplicationConfigurationDescription = sqlApplicationConfigurationDescription {
            try encodeContainer.encode(sqlApplicationConfigurationDescription, forKey: .sqlApplicationConfigurationDescription)
        }
        if let vpcConfigurationDescriptions = vpcConfigurationDescriptions {
            var vpcConfigurationDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcConfigurationDescriptions)
            for vpcconfigurationdescriptions0 in vpcConfigurationDescriptions {
                try vpcConfigurationDescriptionsContainer.encode(vpcconfigurationdescriptions0)
            }
        }
        if let zeppelinApplicationConfigurationDescription = zeppelinApplicationConfigurationDescription {
            try encodeContainer.encode(zeppelinApplicationConfigurationDescription, forKey: .zeppelinApplicationConfigurationDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlApplicationConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(SqlApplicationConfigurationDescription.self, forKey: .sqlApplicationConfigurationDescription)
        sqlApplicationConfigurationDescription = sqlApplicationConfigurationDescriptionDecoded
        let applicationCodeConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(ApplicationCodeConfigurationDescription.self, forKey: .applicationCodeConfigurationDescription)
        applicationCodeConfigurationDescription = applicationCodeConfigurationDescriptionDecoded
        let runConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(RunConfigurationDescription.self, forKey: .runConfigurationDescription)
        runConfigurationDescription = runConfigurationDescriptionDecoded
        let flinkApplicationConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(FlinkApplicationConfigurationDescription.self, forKey: .flinkApplicationConfigurationDescription)
        flinkApplicationConfigurationDescription = flinkApplicationConfigurationDescriptionDecoded
        let environmentPropertyDescriptionsDecoded = try containerValues.decodeIfPresent(EnvironmentPropertyDescriptions.self, forKey: .environmentPropertyDescriptions)
        environmentPropertyDescriptions = environmentPropertyDescriptionsDecoded
        let applicationSnapshotConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(ApplicationSnapshotConfigurationDescription.self, forKey: .applicationSnapshotConfigurationDescription)
        applicationSnapshotConfigurationDescription = applicationSnapshotConfigurationDescriptionDecoded
        let vpcConfigurationDescriptionsContainer = try containerValues.decodeIfPresent([VpcConfigurationDescription?].self, forKey: .vpcConfigurationDescriptions)
        var vpcConfigurationDescriptionsDecoded0:[VpcConfigurationDescription]? = nil
        if let vpcConfigurationDescriptionsContainer = vpcConfigurationDescriptionsContainer {
            vpcConfigurationDescriptionsDecoded0 = [VpcConfigurationDescription]()
            for structure0 in vpcConfigurationDescriptionsContainer {
                if let structure0 = structure0 {
                    vpcConfigurationDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        vpcConfigurationDescriptions = vpcConfigurationDescriptionsDecoded0
        let zeppelinApplicationConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(ZeppelinApplicationConfigurationDescription.self, forKey: .zeppelinApplicationConfigurationDescription)
        zeppelinApplicationConfigurationDescription = zeppelinApplicationConfigurationDescriptionDecoded
    }
}

extension ApplicationConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationConfigurationDescription(applicationCodeConfigurationDescription: \(String(describing: applicationCodeConfigurationDescription)), applicationSnapshotConfigurationDescription: \(String(describing: applicationSnapshotConfigurationDescription)), environmentPropertyDescriptions: \(String(describing: environmentPropertyDescriptions)), flinkApplicationConfigurationDescription: \(String(describing: flinkApplicationConfigurationDescription)), runConfigurationDescription: \(String(describing: runConfigurationDescription)), sqlApplicationConfigurationDescription: \(String(describing: sqlApplicationConfigurationDescription)), vpcConfigurationDescriptions: \(String(describing: vpcConfigurationDescriptions)), zeppelinApplicationConfigurationDescription: \(String(describing: zeppelinApplicationConfigurationDescription)))"}
}

/// <p>Describes details about the application code and starting parameters for a Kinesis Data Analytics application.</p>
public struct ApplicationConfigurationDescription: Equatable {
    /// <p>The details about the application code for a Flink-based Kinesis Data Analytics application.</p>
    public let applicationCodeConfigurationDescription: ApplicationCodeConfigurationDescription?
    /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
    public let applicationSnapshotConfigurationDescription: ApplicationSnapshotConfigurationDescription?
    /// <p>Describes execution properties for a Flink-based Kinesis Data Analytics application.</p>
    public let environmentPropertyDescriptions: EnvironmentPropertyDescriptions?
    /// <p>The details about a Flink-based Kinesis Data Analytics application.</p>
    public let flinkApplicationConfigurationDescription: FlinkApplicationConfigurationDescription?
    /// <p>The details about the starting properties for a Kinesis Data Analytics application.</p>
    public let runConfigurationDescription: RunConfigurationDescription?
    /// <p>The details about inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.</p>
    public let sqlApplicationConfigurationDescription: SqlApplicationConfigurationDescription?
    /// <p>The array of descriptions of VPC configurations available to the application.</p>
    public let vpcConfigurationDescriptions: [VpcConfigurationDescription]?
    /// <p>The configuration parameters for a Kinesis Data Analytics Studio notebook.</p>
    public let zeppelinApplicationConfigurationDescription: ZeppelinApplicationConfigurationDescription?

    public init (
        applicationCodeConfigurationDescription: ApplicationCodeConfigurationDescription? = nil,
        applicationSnapshotConfigurationDescription: ApplicationSnapshotConfigurationDescription? = nil,
        environmentPropertyDescriptions: EnvironmentPropertyDescriptions? = nil,
        flinkApplicationConfigurationDescription: FlinkApplicationConfigurationDescription? = nil,
        runConfigurationDescription: RunConfigurationDescription? = nil,
        sqlApplicationConfigurationDescription: SqlApplicationConfigurationDescription? = nil,
        vpcConfigurationDescriptions: [VpcConfigurationDescription]? = nil,
        zeppelinApplicationConfigurationDescription: ZeppelinApplicationConfigurationDescription? = nil
    )
    {
        self.applicationCodeConfigurationDescription = applicationCodeConfigurationDescription
        self.applicationSnapshotConfigurationDescription = applicationSnapshotConfigurationDescription
        self.environmentPropertyDescriptions = environmentPropertyDescriptions
        self.flinkApplicationConfigurationDescription = flinkApplicationConfigurationDescription
        self.runConfigurationDescription = runConfigurationDescription
        self.sqlApplicationConfigurationDescription = sqlApplicationConfigurationDescription
        self.vpcConfigurationDescriptions = vpcConfigurationDescriptions
        self.zeppelinApplicationConfigurationDescription = zeppelinApplicationConfigurationDescription
    }
}

extension ApplicationConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationCodeConfigurationUpdate = "ApplicationCodeConfigurationUpdate"
        case applicationSnapshotConfigurationUpdate = "ApplicationSnapshotConfigurationUpdate"
        case environmentPropertyUpdates = "EnvironmentPropertyUpdates"
        case flinkApplicationConfigurationUpdate = "FlinkApplicationConfigurationUpdate"
        case sqlApplicationConfigurationUpdate = "SqlApplicationConfigurationUpdate"
        case vpcConfigurationUpdates = "VpcConfigurationUpdates"
        case zeppelinApplicationConfigurationUpdate = "ZeppelinApplicationConfigurationUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationCodeConfigurationUpdate = applicationCodeConfigurationUpdate {
            try encodeContainer.encode(applicationCodeConfigurationUpdate, forKey: .applicationCodeConfigurationUpdate)
        }
        if let applicationSnapshotConfigurationUpdate = applicationSnapshotConfigurationUpdate {
            try encodeContainer.encode(applicationSnapshotConfigurationUpdate, forKey: .applicationSnapshotConfigurationUpdate)
        }
        if let environmentPropertyUpdates = environmentPropertyUpdates {
            try encodeContainer.encode(environmentPropertyUpdates, forKey: .environmentPropertyUpdates)
        }
        if let flinkApplicationConfigurationUpdate = flinkApplicationConfigurationUpdate {
            try encodeContainer.encode(flinkApplicationConfigurationUpdate, forKey: .flinkApplicationConfigurationUpdate)
        }
        if let sqlApplicationConfigurationUpdate = sqlApplicationConfigurationUpdate {
            try encodeContainer.encode(sqlApplicationConfigurationUpdate, forKey: .sqlApplicationConfigurationUpdate)
        }
        if let vpcConfigurationUpdates = vpcConfigurationUpdates {
            var vpcConfigurationUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcConfigurationUpdates)
            for vpcconfigurationupdates0 in vpcConfigurationUpdates {
                try vpcConfigurationUpdatesContainer.encode(vpcconfigurationupdates0)
            }
        }
        if let zeppelinApplicationConfigurationUpdate = zeppelinApplicationConfigurationUpdate {
            try encodeContainer.encode(zeppelinApplicationConfigurationUpdate, forKey: .zeppelinApplicationConfigurationUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlApplicationConfigurationUpdateDecoded = try containerValues.decodeIfPresent(SqlApplicationConfigurationUpdate.self, forKey: .sqlApplicationConfigurationUpdate)
        sqlApplicationConfigurationUpdate = sqlApplicationConfigurationUpdateDecoded
        let applicationCodeConfigurationUpdateDecoded = try containerValues.decodeIfPresent(ApplicationCodeConfigurationUpdate.self, forKey: .applicationCodeConfigurationUpdate)
        applicationCodeConfigurationUpdate = applicationCodeConfigurationUpdateDecoded
        let flinkApplicationConfigurationUpdateDecoded = try containerValues.decodeIfPresent(FlinkApplicationConfigurationUpdate.self, forKey: .flinkApplicationConfigurationUpdate)
        flinkApplicationConfigurationUpdate = flinkApplicationConfigurationUpdateDecoded
        let environmentPropertyUpdatesDecoded = try containerValues.decodeIfPresent(EnvironmentPropertyUpdates.self, forKey: .environmentPropertyUpdates)
        environmentPropertyUpdates = environmentPropertyUpdatesDecoded
        let applicationSnapshotConfigurationUpdateDecoded = try containerValues.decodeIfPresent(ApplicationSnapshotConfigurationUpdate.self, forKey: .applicationSnapshotConfigurationUpdate)
        applicationSnapshotConfigurationUpdate = applicationSnapshotConfigurationUpdateDecoded
        let vpcConfigurationUpdatesContainer = try containerValues.decodeIfPresent([VpcConfigurationUpdate?].self, forKey: .vpcConfigurationUpdates)
        var vpcConfigurationUpdatesDecoded0:[VpcConfigurationUpdate]? = nil
        if let vpcConfigurationUpdatesContainer = vpcConfigurationUpdatesContainer {
            vpcConfigurationUpdatesDecoded0 = [VpcConfigurationUpdate]()
            for structure0 in vpcConfigurationUpdatesContainer {
                if let structure0 = structure0 {
                    vpcConfigurationUpdatesDecoded0?.append(structure0)
                }
            }
        }
        vpcConfigurationUpdates = vpcConfigurationUpdatesDecoded0
        let zeppelinApplicationConfigurationUpdateDecoded = try containerValues.decodeIfPresent(ZeppelinApplicationConfigurationUpdate.self, forKey: .zeppelinApplicationConfigurationUpdate)
        zeppelinApplicationConfigurationUpdate = zeppelinApplicationConfigurationUpdateDecoded
    }
}

extension ApplicationConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationConfigurationUpdate(applicationCodeConfigurationUpdate: \(String(describing: applicationCodeConfigurationUpdate)), applicationSnapshotConfigurationUpdate: \(String(describing: applicationSnapshotConfigurationUpdate)), environmentPropertyUpdates: \(String(describing: environmentPropertyUpdates)), flinkApplicationConfigurationUpdate: \(String(describing: flinkApplicationConfigurationUpdate)), sqlApplicationConfigurationUpdate: \(String(describing: sqlApplicationConfigurationUpdate)), vpcConfigurationUpdates: \(String(describing: vpcConfigurationUpdates)), zeppelinApplicationConfigurationUpdate: \(String(describing: zeppelinApplicationConfigurationUpdate)))"}
}

/// <p>Describes updates to an application's configuration.</p>
public struct ApplicationConfigurationUpdate: Equatable {
    /// <p>Describes updates to an application's code
    ///       configuration.</p>
    public let applicationCodeConfigurationUpdate: ApplicationCodeConfigurationUpdate?
    /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
    public let applicationSnapshotConfigurationUpdate: ApplicationSnapshotConfigurationUpdate?
    /// <p>Describes updates to the environment properties for a Flink-based Kinesis Data Analytics application.</p>
    public let environmentPropertyUpdates: EnvironmentPropertyUpdates?
    /// <p>Describes updates to a Flink-based Kinesis Data Analytics application's configuration.</p>
    public let flinkApplicationConfigurationUpdate: FlinkApplicationConfigurationUpdate?
    /// <p>Describes updates to a SQL-based Kinesis Data Analytics application's
    ///       configuration.</p>
    public let sqlApplicationConfigurationUpdate: SqlApplicationConfigurationUpdate?
    /// <p>Updates to the array of descriptions of VPC configurations available to the application.</p>
    public let vpcConfigurationUpdates: [VpcConfigurationUpdate]?
    /// <p>Updates to the configuration of a Kinesis Data Analytics Studio notebook.</p>
    public let zeppelinApplicationConfigurationUpdate: ZeppelinApplicationConfigurationUpdate?

    public init (
        applicationCodeConfigurationUpdate: ApplicationCodeConfigurationUpdate? = nil,
        applicationSnapshotConfigurationUpdate: ApplicationSnapshotConfigurationUpdate? = nil,
        environmentPropertyUpdates: EnvironmentPropertyUpdates? = nil,
        flinkApplicationConfigurationUpdate: FlinkApplicationConfigurationUpdate? = nil,
        sqlApplicationConfigurationUpdate: SqlApplicationConfigurationUpdate? = nil,
        vpcConfigurationUpdates: [VpcConfigurationUpdate]? = nil,
        zeppelinApplicationConfigurationUpdate: ZeppelinApplicationConfigurationUpdate? = nil
    )
    {
        self.applicationCodeConfigurationUpdate = applicationCodeConfigurationUpdate
        self.applicationSnapshotConfigurationUpdate = applicationSnapshotConfigurationUpdate
        self.environmentPropertyUpdates = environmentPropertyUpdates
        self.flinkApplicationConfigurationUpdate = flinkApplicationConfigurationUpdate
        self.sqlApplicationConfigurationUpdate = sqlApplicationConfigurationUpdate
        self.vpcConfigurationUpdates = vpcConfigurationUpdates
        self.zeppelinApplicationConfigurationUpdate = zeppelinApplicationConfigurationUpdate
    }
}

extension ApplicationDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationConfigurationDescription = "ApplicationConfigurationDescription"
        case applicationDescription = "ApplicationDescription"
        case applicationMaintenanceConfigurationDescription = "ApplicationMaintenanceConfigurationDescription"
        case applicationMode = "ApplicationMode"
        case applicationName = "ApplicationName"
        case applicationStatus = "ApplicationStatus"
        case applicationVersionId = "ApplicationVersionId"
        case applicationVersionRolledBackFrom = "ApplicationVersionRolledBackFrom"
        case applicationVersionRolledBackTo = "ApplicationVersionRolledBackTo"
        case applicationVersionUpdatedFrom = "ApplicationVersionUpdatedFrom"
        case cloudWatchLoggingOptionDescriptions = "CloudWatchLoggingOptionDescriptions"
        case conditionalToken = "ConditionalToken"
        case createTimestamp = "CreateTimestamp"
        case lastUpdateTimestamp = "LastUpdateTimestamp"
        case runtimeEnvironment = "RuntimeEnvironment"
        case serviceExecutionRole = "ServiceExecutionRole"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationARN = applicationARN {
            try encodeContainer.encode(applicationARN, forKey: .applicationARN)
        }
        if let applicationConfigurationDescription = applicationConfigurationDescription {
            try encodeContainer.encode(applicationConfigurationDescription, forKey: .applicationConfigurationDescription)
        }
        if let applicationDescription = applicationDescription {
            try encodeContainer.encode(applicationDescription, forKey: .applicationDescription)
        }
        if let applicationMaintenanceConfigurationDescription = applicationMaintenanceConfigurationDescription {
            try encodeContainer.encode(applicationMaintenanceConfigurationDescription, forKey: .applicationMaintenanceConfigurationDescription)
        }
        if let applicationMode = applicationMode {
            try encodeContainer.encode(applicationMode.rawValue, forKey: .applicationMode)
        }
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let applicationStatus = applicationStatus {
            try encodeContainer.encode(applicationStatus.rawValue, forKey: .applicationStatus)
        }
        if let applicationVersionId = applicationVersionId {
            try encodeContainer.encode(applicationVersionId, forKey: .applicationVersionId)
        }
        if let applicationVersionRolledBackFrom = applicationVersionRolledBackFrom {
            try encodeContainer.encode(applicationVersionRolledBackFrom, forKey: .applicationVersionRolledBackFrom)
        }
        if let applicationVersionRolledBackTo = applicationVersionRolledBackTo {
            try encodeContainer.encode(applicationVersionRolledBackTo, forKey: .applicationVersionRolledBackTo)
        }
        if let applicationVersionUpdatedFrom = applicationVersionUpdatedFrom {
            try encodeContainer.encode(applicationVersionUpdatedFrom, forKey: .applicationVersionUpdatedFrom)
        }
        if let cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions {
            var cloudWatchLoggingOptionDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchLoggingOptionDescriptions)
            for cloudwatchloggingoptiondescriptions0 in cloudWatchLoggingOptionDescriptions {
                try cloudWatchLoggingOptionDescriptionsContainer.encode(cloudwatchloggingoptiondescriptions0)
            }
        }
        if let conditionalToken = conditionalToken {
            try encodeContainer.encode(conditionalToken, forKey: .conditionalToken)
        }
        if let createTimestamp = createTimestamp {
            try encodeContainer.encode(createTimestamp.timeIntervalSince1970, forKey: .createTimestamp)
        }
        if let lastUpdateTimestamp = lastUpdateTimestamp {
            try encodeContainer.encode(lastUpdateTimestamp.timeIntervalSince1970, forKey: .lastUpdateTimestamp)
        }
        if let runtimeEnvironment = runtimeEnvironment {
            try encodeContainer.encode(runtimeEnvironment.rawValue, forKey: .runtimeEnvironment)
        }
        if let serviceExecutionRole = serviceExecutionRole {
            try encodeContainer.encode(serviceExecutionRole, forKey: .serviceExecutionRole)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationDescription)
        applicationDescription = applicationDescriptionDecoded
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let runtimeEnvironmentDecoded = try containerValues.decodeIfPresent(RuntimeEnvironment.self, forKey: .runtimeEnvironment)
        runtimeEnvironment = runtimeEnvironmentDecoded
        let serviceExecutionRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceExecutionRole)
        serviceExecutionRole = serviceExecutionRoleDecoded
        let applicationStatusDecoded = try containerValues.decodeIfPresent(ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let createTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
        let lastUpdateTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTimestamp)
        lastUpdateTimestamp = lastUpdateTimestampDecoded
        let applicationConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(ApplicationConfigurationDescription.self, forKey: .applicationConfigurationDescription)
        applicationConfigurationDescription = applicationConfigurationDescriptionDecoded
        let cloudWatchLoggingOptionDescriptionsContainer = try containerValues.decodeIfPresent([CloudWatchLoggingOptionDescription?].self, forKey: .cloudWatchLoggingOptionDescriptions)
        var cloudWatchLoggingOptionDescriptionsDecoded0:[CloudWatchLoggingOptionDescription]? = nil
        if let cloudWatchLoggingOptionDescriptionsContainer = cloudWatchLoggingOptionDescriptionsContainer {
            cloudWatchLoggingOptionDescriptionsDecoded0 = [CloudWatchLoggingOptionDescription]()
            for structure0 in cloudWatchLoggingOptionDescriptionsContainer {
                if let structure0 = structure0 {
                    cloudWatchLoggingOptionDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptionsDecoded0
        let applicationMaintenanceConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(ApplicationMaintenanceConfigurationDescription.self, forKey: .applicationMaintenanceConfigurationDescription)
        applicationMaintenanceConfigurationDescription = applicationMaintenanceConfigurationDescriptionDecoded
        let applicationVersionUpdatedFromDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionUpdatedFrom)
        applicationVersionUpdatedFrom = applicationVersionUpdatedFromDecoded
        let applicationVersionRolledBackFromDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionRolledBackFrom)
        applicationVersionRolledBackFrom = applicationVersionRolledBackFromDecoded
        let conditionalTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conditionalToken)
        conditionalToken = conditionalTokenDecoded
        let applicationVersionRolledBackToDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionRolledBackTo)
        applicationVersionRolledBackTo = applicationVersionRolledBackToDecoded
        let applicationModeDecoded = try containerValues.decodeIfPresent(ApplicationMode.self, forKey: .applicationMode)
        applicationMode = applicationModeDecoded
    }
}

extension ApplicationDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationDetail(applicationARN: \(String(describing: applicationARN)), applicationConfigurationDescription: \(String(describing: applicationConfigurationDescription)), applicationDescription: \(String(describing: applicationDescription)), applicationMaintenanceConfigurationDescription: \(String(describing: applicationMaintenanceConfigurationDescription)), applicationMode: \(String(describing: applicationMode)), applicationName: \(String(describing: applicationName)), applicationStatus: \(String(describing: applicationStatus)), applicationVersionId: \(String(describing: applicationVersionId)), applicationVersionRolledBackFrom: \(String(describing: applicationVersionRolledBackFrom)), applicationVersionRolledBackTo: \(String(describing: applicationVersionRolledBackTo)), applicationVersionUpdatedFrom: \(String(describing: applicationVersionUpdatedFrom)), cloudWatchLoggingOptionDescriptions: \(String(describing: cloudWatchLoggingOptionDescriptions)), conditionalToken: \(String(describing: conditionalToken)), createTimestamp: \(String(describing: createTimestamp)), lastUpdateTimestamp: \(String(describing: lastUpdateTimestamp)), runtimeEnvironment: \(String(describing: runtimeEnvironment)), serviceExecutionRole: \(String(describing: serviceExecutionRole)))"}
}

/// <p>Describes the application, including the application Amazon Resource Name (ARN), status,
///       latest version, and input and output configurations.</p>
public struct ApplicationDetail: Equatable {
    /// <p>The ARN of the application.</p>
    public let applicationARN: String?
    /// <p>Describes details about the application code and starting parameters for a Kinesis Data Analytics application.</p>
    public let applicationConfigurationDescription: ApplicationConfigurationDescription?
    /// <p>The description of the application.</p>
    public let applicationDescription: String?
    /// <p>The details of the maintenance configuration for the application.</p>
    public let applicationMaintenanceConfigurationDescription: ApplicationMaintenanceConfigurationDescription?
    /// <p>To create a Kinesis Data Analytics Studio notebook, you must set the mode to <code>INTERACTIVE</code>. However, for a Kinesis Data Analytics for Apache Flink application, the mode is optional.</p>
    public let applicationMode: ApplicationMode?
    /// <p>The name of the application.</p>
    public let applicationName: String?
    /// <p>The status of the application.</p>
    public let applicationStatus: ApplicationStatus?
    /// <p>Provides the current application version. Kinesis Data Analytics updates the
    ///         <code>ApplicationVersionId</code> each time you update the application.</p>
    public let applicationVersionId: Int?
    /// <p>If you reverted the application using <a>RollbackApplication</a>,
    ///         the application version when <code>RollbackApplication</code> was called.</p>
    public let applicationVersionRolledBackFrom: Int?
    /// <p>The version to which you want to roll back the application.</p>
    public let applicationVersionRolledBackTo: Int?
    /// <p>The previous application version before the latest application update. <a>RollbackApplication</a>
    ///         reverts the application to this version.</p>
    public let applicationVersionUpdatedFrom: Int?
    /// <p>Describes the application Amazon CloudWatch logging options.</p>
    public let cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]?
    /// <p>A value you use to implement strong concurrency for application updates.</p>
    public let conditionalToken: String?
    /// <p>The current timestamp when the application was created.</p>
    public let createTimestamp: Date?
    /// <p>The current timestamp when the application was last updated.</p>
    public let lastUpdateTimestamp: Date?
    /// <p>The runtime environment for the application (<code>SQL-1_0</code>, <code>FLINK-1_6</code>, <code>FLINK-1_8</code>, or <code>FLINK-1_11</code>).</p>
    public let runtimeEnvironment: RuntimeEnvironment?
    /// <p>Specifies the IAM role that the application uses to access external resources.</p>
    public let serviceExecutionRole: String?

    public init (
        applicationARN: String? = nil,
        applicationConfigurationDescription: ApplicationConfigurationDescription? = nil,
        applicationDescription: String? = nil,
        applicationMaintenanceConfigurationDescription: ApplicationMaintenanceConfigurationDescription? = nil,
        applicationMode: ApplicationMode? = nil,
        applicationName: String? = nil,
        applicationStatus: ApplicationStatus? = nil,
        applicationVersionId: Int? = nil,
        applicationVersionRolledBackFrom: Int? = nil,
        applicationVersionRolledBackTo: Int? = nil,
        applicationVersionUpdatedFrom: Int? = nil,
        cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]? = nil,
        conditionalToken: String? = nil,
        createTimestamp: Date? = nil,
        lastUpdateTimestamp: Date? = nil,
        runtimeEnvironment: RuntimeEnvironment? = nil,
        serviceExecutionRole: String? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationConfigurationDescription = applicationConfigurationDescription
        self.applicationDescription = applicationDescription
        self.applicationMaintenanceConfigurationDescription = applicationMaintenanceConfigurationDescription
        self.applicationMode = applicationMode
        self.applicationName = applicationName
        self.applicationStatus = applicationStatus
        self.applicationVersionId = applicationVersionId
        self.applicationVersionRolledBackFrom = applicationVersionRolledBackFrom
        self.applicationVersionRolledBackTo = applicationVersionRolledBackTo
        self.applicationVersionUpdatedFrom = applicationVersionUpdatedFrom
        self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
        self.conditionalToken = conditionalToken
        self.createTimestamp = createTimestamp
        self.lastUpdateTimestamp = lastUpdateTimestamp
        self.runtimeEnvironment = runtimeEnvironment
        self.serviceExecutionRole = serviceExecutionRole
    }
}

extension ApplicationMaintenanceConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationMaintenanceWindowEndTime = "ApplicationMaintenanceWindowEndTime"
        case applicationMaintenanceWindowStartTime = "ApplicationMaintenanceWindowStartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationMaintenanceWindowEndTime = applicationMaintenanceWindowEndTime {
            try encodeContainer.encode(applicationMaintenanceWindowEndTime, forKey: .applicationMaintenanceWindowEndTime)
        }
        if let applicationMaintenanceWindowStartTime = applicationMaintenanceWindowStartTime {
            try encodeContainer.encode(applicationMaintenanceWindowStartTime, forKey: .applicationMaintenanceWindowStartTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationMaintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationMaintenanceWindowStartTime)
        applicationMaintenanceWindowStartTime = applicationMaintenanceWindowStartTimeDecoded
        let applicationMaintenanceWindowEndTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationMaintenanceWindowEndTime)
        applicationMaintenanceWindowEndTime = applicationMaintenanceWindowEndTimeDecoded
    }
}

extension ApplicationMaintenanceConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationMaintenanceConfigurationDescription(applicationMaintenanceWindowEndTime: \(String(describing: applicationMaintenanceWindowEndTime)), applicationMaintenanceWindowStartTime: \(String(describing: applicationMaintenanceWindowStartTime)))"}
}

/// <p>The details of the maintenance configuration for the application.</p>
public struct ApplicationMaintenanceConfigurationDescription: Equatable {
    /// <p>The end time for the maintenance window.</p>
    public let applicationMaintenanceWindowEndTime: String?
    /// <p>The start time for the maintenance window.</p>
    public let applicationMaintenanceWindowStartTime: String?

    public init (
        applicationMaintenanceWindowEndTime: String? = nil,
        applicationMaintenanceWindowStartTime: String? = nil
    )
    {
        self.applicationMaintenanceWindowEndTime = applicationMaintenanceWindowEndTime
        self.applicationMaintenanceWindowStartTime = applicationMaintenanceWindowStartTime
    }
}

extension ApplicationMaintenanceConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationMaintenanceWindowStartTimeUpdate = "ApplicationMaintenanceWindowStartTimeUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationMaintenanceWindowStartTimeUpdate = applicationMaintenanceWindowStartTimeUpdate {
            try encodeContainer.encode(applicationMaintenanceWindowStartTimeUpdate, forKey: .applicationMaintenanceWindowStartTimeUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationMaintenanceWindowStartTimeUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationMaintenanceWindowStartTimeUpdate)
        applicationMaintenanceWindowStartTimeUpdate = applicationMaintenanceWindowStartTimeUpdateDecoded
    }
}

extension ApplicationMaintenanceConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationMaintenanceConfigurationUpdate(applicationMaintenanceWindowStartTimeUpdate: \(String(describing: applicationMaintenanceWindowStartTimeUpdate)))"}
}

/// <p>Describes the updated maintenance configuration for the application.</p>
public struct ApplicationMaintenanceConfigurationUpdate: Equatable {
    /// <p>The updated start time for the maintenance window.</p>
    public let applicationMaintenanceWindowStartTimeUpdate: String?

    public init (
        applicationMaintenanceWindowStartTimeUpdate: String? = nil
    )
    {
        self.applicationMaintenanceWindowStartTimeUpdate = applicationMaintenanceWindowStartTimeUpdate
    }
}

public enum ApplicationMode {
    case interactive
    case streaming
    case sdkUnknown(String)
}

extension ApplicationMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApplicationMode] {
        return [
            .interactive,
            .streaming,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .interactive: return "INTERACTIVE"
        case .streaming: return "STREAMING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApplicationMode(rawValue: rawValue) ?? ApplicationMode.sdkUnknown(rawValue)
    }
}

extension ApplicationRestoreConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationRestoreType = "ApplicationRestoreType"
        case snapshotName = "SnapshotName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationRestoreType = applicationRestoreType {
            try encodeContainer.encode(applicationRestoreType.rawValue, forKey: .applicationRestoreType)
        }
        if let snapshotName = snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationRestoreTypeDecoded = try containerValues.decodeIfPresent(ApplicationRestoreType.self, forKey: .applicationRestoreType)
        applicationRestoreType = applicationRestoreTypeDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
    }
}

extension ApplicationRestoreConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationRestoreConfiguration(applicationRestoreType: \(String(describing: applicationRestoreType)), snapshotName: \(String(describing: snapshotName)))"}
}

/// <p>Specifies the method and snapshot to use when restarting an application using previously saved application state.</p>
public struct ApplicationRestoreConfiguration: Equatable {
    /// <p>Specifies how the application should be restored.</p>
    public let applicationRestoreType: ApplicationRestoreType?
    /// <p>The identifier of an existing snapshot of application state to use to restart an application.
    ///       The application uses this value if <code>RESTORE_FROM_CUSTOM_SNAPSHOT</code> is specified for the
    ///       <code>ApplicationRestoreType</code>.</p>
    public let snapshotName: String?

    public init (
        applicationRestoreType: ApplicationRestoreType? = nil,
        snapshotName: String? = nil
    )
    {
        self.applicationRestoreType = applicationRestoreType
        self.snapshotName = snapshotName
    }
}

public enum ApplicationRestoreType {
    case restoreFromCustomSnapshot
    case restoreFromLatestSnapshot
    case skipRestoreFromSnapshot
    case sdkUnknown(String)
}

extension ApplicationRestoreType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApplicationRestoreType] {
        return [
            .restoreFromCustomSnapshot,
            .restoreFromLatestSnapshot,
            .skipRestoreFromSnapshot,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .restoreFromCustomSnapshot: return "RESTORE_FROM_CUSTOM_SNAPSHOT"
        case .restoreFromLatestSnapshot: return "RESTORE_FROM_LATEST_SNAPSHOT"
        case .skipRestoreFromSnapshot: return "SKIP_RESTORE_FROM_SNAPSHOT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApplicationRestoreType(rawValue: rawValue) ?? ApplicationRestoreType.sdkUnknown(rawValue)
    }
}

extension ApplicationSnapshotConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case snapshotsEnabled = "SnapshotsEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotsEnabled = snapshotsEnabled {
            try encodeContainer.encode(snapshotsEnabled, forKey: .snapshotsEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .snapshotsEnabled)
        snapshotsEnabled = snapshotsEnabledDecoded
    }
}

extension ApplicationSnapshotConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationSnapshotConfiguration(snapshotsEnabled: \(String(describing: snapshotsEnabled)))"}
}

/// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
public struct ApplicationSnapshotConfiguration: Equatable {
    /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
    public let snapshotsEnabled: Bool?

    public init (
        snapshotsEnabled: Bool? = nil
    )
    {
        self.snapshotsEnabled = snapshotsEnabled
    }
}

extension ApplicationSnapshotConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case snapshotsEnabled = "SnapshotsEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotsEnabled = snapshotsEnabled {
            try encodeContainer.encode(snapshotsEnabled, forKey: .snapshotsEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .snapshotsEnabled)
        snapshotsEnabled = snapshotsEnabledDecoded
    }
}

extension ApplicationSnapshotConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationSnapshotConfigurationDescription(snapshotsEnabled: \(String(describing: snapshotsEnabled)))"}
}

/// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
public struct ApplicationSnapshotConfigurationDescription: Equatable {
    /// <p>Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
    public let snapshotsEnabled: Bool?

    public init (
        snapshotsEnabled: Bool? = nil
    )
    {
        self.snapshotsEnabled = snapshotsEnabled
    }
}

extension ApplicationSnapshotConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case snapshotsEnabledUpdate = "SnapshotsEnabledUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotsEnabledUpdate = snapshotsEnabledUpdate {
            try encodeContainer.encode(snapshotsEnabledUpdate, forKey: .snapshotsEnabledUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotsEnabledUpdateDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .snapshotsEnabledUpdate)
        snapshotsEnabledUpdate = snapshotsEnabledUpdateDecoded
    }
}

extension ApplicationSnapshotConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationSnapshotConfigurationUpdate(snapshotsEnabledUpdate: \(String(describing: snapshotsEnabledUpdate)))"}
}

/// <p>Describes updates to whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.</p>
public struct ApplicationSnapshotConfigurationUpdate: Equatable {
    /// <p>Describes updates to whether snapshots are enabled for an application.</p>
    public let snapshotsEnabledUpdate: Bool?

    public init (
        snapshotsEnabledUpdate: Bool? = nil
    )
    {
        self.snapshotsEnabledUpdate = snapshotsEnabledUpdate
    }
}

public enum ApplicationStatus {
    case autoscaling
    case deleting
    case forceStopping
    case maintenance
    case ready
    case rolledBack
    case rollingBack
    case running
    case starting
    case stopping
    case updating
    case sdkUnknown(String)
}

extension ApplicationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApplicationStatus] {
        return [
            .autoscaling,
            .deleting,
            .forceStopping,
            .maintenance,
            .ready,
            .rolledBack,
            .rollingBack,
            .running,
            .starting,
            .stopping,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .autoscaling: return "AUTOSCALING"
        case .deleting: return "DELETING"
        case .forceStopping: return "FORCE_STOPPING"
        case .maintenance: return "MAINTENANCE"
        case .ready: return "READY"
        case .rolledBack: return "ROLLED_BACK"
        case .rollingBack: return "ROLLING_BACK"
        case .running: return "RUNNING"
        case .starting: return "STARTING"
        case .stopping: return "STOPPING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApplicationStatus(rawValue: rawValue) ?? ApplicationStatus.sdkUnknown(rawValue)
    }
}

extension ApplicationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationMode = "ApplicationMode"
        case applicationName = "ApplicationName"
        case applicationStatus = "ApplicationStatus"
        case applicationVersionId = "ApplicationVersionId"
        case runtimeEnvironment = "RuntimeEnvironment"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationARN = applicationARN {
            try encodeContainer.encode(applicationARN, forKey: .applicationARN)
        }
        if let applicationMode = applicationMode {
            try encodeContainer.encode(applicationMode.rawValue, forKey: .applicationMode)
        }
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let applicationStatus = applicationStatus {
            try encodeContainer.encode(applicationStatus.rawValue, forKey: .applicationStatus)
        }
        if let applicationVersionId = applicationVersionId {
            try encodeContainer.encode(applicationVersionId, forKey: .applicationVersionId)
        }
        if let runtimeEnvironment = runtimeEnvironment {
            try encodeContainer.encode(runtimeEnvironment.rawValue, forKey: .runtimeEnvironment)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationStatusDecoded = try containerValues.decodeIfPresent(ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let runtimeEnvironmentDecoded = try containerValues.decodeIfPresent(RuntimeEnvironment.self, forKey: .runtimeEnvironment)
        runtimeEnvironment = runtimeEnvironmentDecoded
        let applicationModeDecoded = try containerValues.decodeIfPresent(ApplicationMode.self, forKey: .applicationMode)
        applicationMode = applicationModeDecoded
    }
}

extension ApplicationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationSummary(applicationARN: \(String(describing: applicationARN)), applicationMode: \(String(describing: applicationMode)), applicationName: \(String(describing: applicationName)), applicationStatus: \(String(describing: applicationStatus)), applicationVersionId: \(String(describing: applicationVersionId)), runtimeEnvironment: \(String(describing: runtimeEnvironment)))"}
}

/// <p>Provides application summary information, including the application Amazon Resource Name (ARN), name, and status.</p>
public struct ApplicationSummary: Equatable {
    /// <p>The ARN of the application.</p>
    public let applicationARN: String?
    /// <p>For a Kinesis Data Analytics for Apache Flink application, the mode is <code>STREAMING</code>. For a Kinesis Data Analytics Studio notebook, it is <code>INTERACTIVE</code>.</p>
    public let applicationMode: ApplicationMode?
    /// <p>The name of the application.</p>
    public let applicationName: String?
    /// <p>The status of the application.</p>
    public let applicationStatus: ApplicationStatus?
    /// <p>Provides the current application version.</p>
    public let applicationVersionId: Int?
    /// <p>The runtime environment for the application.</p>
    public let runtimeEnvironment: RuntimeEnvironment?

    public init (
        applicationARN: String? = nil,
        applicationMode: ApplicationMode? = nil,
        applicationName: String? = nil,
        applicationStatus: ApplicationStatus? = nil,
        applicationVersionId: Int? = nil,
        runtimeEnvironment: RuntimeEnvironment? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationMode = applicationMode
        self.applicationName = applicationName
        self.applicationStatus = applicationStatus
        self.applicationVersionId = applicationVersionId
        self.runtimeEnvironment = runtimeEnvironment
    }
}

extension ApplicationVersionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationStatus = "ApplicationStatus"
        case applicationVersionId = "ApplicationVersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationStatus = applicationStatus {
            try encodeContainer.encode(applicationStatus.rawValue, forKey: .applicationStatus)
        }
        if let applicationVersionId = applicationVersionId {
            try encodeContainer.encode(applicationVersionId, forKey: .applicationVersionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let applicationStatusDecoded = try containerValues.decodeIfPresent(ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
    }
}

extension ApplicationVersionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationVersionSummary(applicationStatus: \(String(describing: applicationStatus)), applicationVersionId: \(String(describing: applicationVersionId)))"}
}

/// <p>The summary of the application version.</p>
public struct ApplicationVersionSummary: Equatable {
    /// <p>The status of the application.</p>
    public let applicationStatus: ApplicationStatus?
    /// <p>The ID of the application version. Kinesis Data Analytics updates the <code>ApplicationVersionId</code> each time you update the application.</p>
    public let applicationVersionId: Int?

    public init (
        applicationStatus: ApplicationStatus? = nil,
        applicationVersionId: Int? = nil
    )
    {
        self.applicationStatus = applicationStatus
        self.applicationVersionId = applicationVersionId
    }
}

public enum ArtifactType {
    case dependencyJar
    case udf
    case sdkUnknown(String)
}

extension ArtifactType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ArtifactType] {
        return [
            .dependencyJar,
            .udf,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dependencyJar: return "DEPENDENCY_JAR"
        case .udf: return "UDF"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ArtifactType(rawValue: rawValue) ?? ArtifactType.sdkUnknown(rawValue)
    }
}

extension CSVMappingParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recordColumnDelimiter = "RecordColumnDelimiter"
        case recordRowDelimiter = "RecordRowDelimiter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordColumnDelimiter = recordColumnDelimiter {
            try encodeContainer.encode(recordColumnDelimiter, forKey: .recordColumnDelimiter)
        }
        if let recordRowDelimiter = recordRowDelimiter {
            try encodeContainer.encode(recordRowDelimiter, forKey: .recordRowDelimiter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordRowDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordRowDelimiter)
        recordRowDelimiter = recordRowDelimiterDecoded
        let recordColumnDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordColumnDelimiter)
        recordColumnDelimiter = recordColumnDelimiterDecoded
    }
}

extension CSVMappingParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CSVMappingParameters(recordColumnDelimiter: \(String(describing: recordColumnDelimiter)), recordRowDelimiter: \(String(describing: recordRowDelimiter)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, provides additional mapping information when the record
///       format uses delimiters, such as CSV. For example, the following sample records use CSV format,
///       where the records use the <i>'\n'</i> as the row delimiter and a comma (",") as
///       the column delimiter: </p>
///
///          <p>
///             <code>"name1", "address1"</code>
///          </p>
///          <p>
///             <code>"name2", "address2"</code>
///          </p>
public struct CSVMappingParameters: Equatable {
    /// <p>The column delimiter. For example, in a CSV format, a comma (",") is the typical column
    ///       delimiter.</p>
    public let recordColumnDelimiter: String?
    /// <p>The row delimiter. For example, in a CSV format, <i>'\n'</i> is the typical
    ///       row delimiter.</p>
    public let recordRowDelimiter: String?

    public init (
        recordColumnDelimiter: String? = nil,
        recordRowDelimiter: String? = nil
    )
    {
        self.recordColumnDelimiter = recordColumnDelimiter
        self.recordRowDelimiter = recordRowDelimiter
    }
}

extension CatalogConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case glueDataCatalogConfiguration = "GlueDataCatalogConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let glueDataCatalogConfiguration = glueDataCatalogConfiguration {
            try encodeContainer.encode(glueDataCatalogConfiguration, forKey: .glueDataCatalogConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let glueDataCatalogConfigurationDecoded = try containerValues.decodeIfPresent(GlueDataCatalogConfiguration.self, forKey: .glueDataCatalogConfiguration)
        glueDataCatalogConfiguration = glueDataCatalogConfigurationDecoded
    }
}

extension CatalogConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CatalogConfiguration(glueDataCatalogConfiguration: \(String(describing: glueDataCatalogConfiguration)))"}
}

/// <p>The configuration parameters for the default AWS Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.</p>
public struct CatalogConfiguration: Equatable {
    /// <p>The configuration parameters for the default AWS Glue database. You use this database for Apache Flink SQL queries and table API transforms that you write in a Kinesis Data Analytics Studio notebook.</p>
    public let glueDataCatalogConfiguration: GlueDataCatalogConfiguration?

    public init (
        glueDataCatalogConfiguration: GlueDataCatalogConfiguration? = nil
    )
    {
        self.glueDataCatalogConfiguration = glueDataCatalogConfiguration
    }
}

extension CatalogConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case glueDataCatalogConfigurationDescription = "GlueDataCatalogConfigurationDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let glueDataCatalogConfigurationDescription = glueDataCatalogConfigurationDescription {
            try encodeContainer.encode(glueDataCatalogConfigurationDescription, forKey: .glueDataCatalogConfigurationDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let glueDataCatalogConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(GlueDataCatalogConfigurationDescription.self, forKey: .glueDataCatalogConfigurationDescription)
        glueDataCatalogConfigurationDescription = glueDataCatalogConfigurationDescriptionDecoded
    }
}

extension CatalogConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CatalogConfigurationDescription(glueDataCatalogConfigurationDescription: \(String(describing: glueDataCatalogConfigurationDescription)))"}
}

/// <p>The configuration parameters for the default AWS Glue database. You use this database for Apache Flink SQL queries and table API transforms that you write in a Kinesis Data Analytics Studio notebook.</p>
public struct CatalogConfigurationDescription: Equatable {
    /// <p>The configuration parameters for the default AWS Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.</p>
    public let glueDataCatalogConfigurationDescription: GlueDataCatalogConfigurationDescription?

    public init (
        glueDataCatalogConfigurationDescription: GlueDataCatalogConfigurationDescription? = nil
    )
    {
        self.glueDataCatalogConfigurationDescription = glueDataCatalogConfigurationDescription
    }
}

extension CatalogConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case glueDataCatalogConfigurationUpdate = "GlueDataCatalogConfigurationUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let glueDataCatalogConfigurationUpdate = glueDataCatalogConfigurationUpdate {
            try encodeContainer.encode(glueDataCatalogConfigurationUpdate, forKey: .glueDataCatalogConfigurationUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let glueDataCatalogConfigurationUpdateDecoded = try containerValues.decodeIfPresent(GlueDataCatalogConfigurationUpdate.self, forKey: .glueDataCatalogConfigurationUpdate)
        glueDataCatalogConfigurationUpdate = glueDataCatalogConfigurationUpdateDecoded
    }
}

extension CatalogConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CatalogConfigurationUpdate(glueDataCatalogConfigurationUpdate: \(String(describing: glueDataCatalogConfigurationUpdate)))"}
}

/// <p>Updates to </p>
public struct CatalogConfigurationUpdate: Equatable {
    /// <p>Updates to the configuration parameters for the default AWS Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.</p>
    public let glueDataCatalogConfigurationUpdate: GlueDataCatalogConfigurationUpdate?

    public init (
        glueDataCatalogConfigurationUpdate: GlueDataCatalogConfigurationUpdate? = nil
    )
    {
        self.glueDataCatalogConfigurationUpdate = glueDataCatalogConfigurationUpdate
    }
}

extension CheckpointConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkpointInterval = "CheckpointInterval"
        case checkpointingEnabled = "CheckpointingEnabled"
        case configurationType = "ConfigurationType"
        case minPauseBetweenCheckpoints = "MinPauseBetweenCheckpoints"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkpointInterval = checkpointInterval {
            try encodeContainer.encode(checkpointInterval, forKey: .checkpointInterval)
        }
        if let checkpointingEnabled = checkpointingEnabled {
            try encodeContainer.encode(checkpointingEnabled, forKey: .checkpointingEnabled)
        }
        if let configurationType = configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let minPauseBetweenCheckpoints = minPauseBetweenCheckpoints {
            try encodeContainer.encode(minPauseBetweenCheckpoints, forKey: .minPauseBetweenCheckpoints)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(ConfigurationType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let checkpointingEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .checkpointingEnabled)
        checkpointingEnabled = checkpointingEnabledDecoded
        let checkpointIntervalDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .checkpointInterval)
        checkpointInterval = checkpointIntervalDecoded
        let minPauseBetweenCheckpointsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minPauseBetweenCheckpoints)
        minPauseBetweenCheckpoints = minPauseBetweenCheckpointsDecoded
    }
}

extension CheckpointConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckpointConfiguration(checkpointInterval: \(String(describing: checkpointInterval)), checkpointingEnabled: \(String(describing: checkpointingEnabled)), configurationType: \(String(describing: configurationType)), minPauseBetweenCheckpoints: \(String(describing: minPauseBetweenCheckpoints)))"}
}

/// <p>Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state for fault
///       tolerance.
///       For more information, see
///       <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/programming-model.html#checkpoints-for-fault-tolerance">
///         Checkpoints for Fault Tolerance</a> in the
///       <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink Documentation</a>.</p>
public struct CheckpointConfiguration: Equatable {
    /// <p>Describes the interval in milliseconds between checkpoint operations. </p>
    ///          <note>
    ///             <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    ///     the application will use a <code>CheckpointInterval</code> value of 60000, even if this value is set
    ///       to another value using this API or in application code.</p>
    ///          </note>
    public let checkpointInterval: Int?
    /// <p>Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.</p>
    ///          <note>
    ///             <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    ///     the application will use a <code>CheckpointingEnabled</code> value of <code>true</code>, even if this value
    ///       is set to another value using this API or in application code.</p>
    ///          </note>
    public let checkpointingEnabled: Bool?
    /// <p>Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior.
    ///     You must set this property to <code>CUSTOM</code> in order to set the
    ///       <code>CheckpointingEnabled</code>, <code>CheckpointInterval</code>, or <code>MinPauseBetweenCheckpoints</code> parameters.</p>
    ///          <note>
    ///             <p>If this value is set to <code>DEFAULT</code>, the application will use the following values, even if they are set to other values using APIs or
    ///     application code:</p>
    ///             <ul>
    ///                <li>
    ///                   <p>
    ///                      <b>CheckpointingEnabled:</b> true</p>
    ///                </li>
    ///                <li>
    ///                   <p>
    ///                      <b>CheckpointInterval:</b> 60000</p>
    ///                </li>
    ///                <li>
    ///                   <p>
    ///                      <b>MinPauseBetweenCheckpoints:</b> 5000</p>
    ///                </li>
    ///             </ul>
    ///          </note>
    public let configurationType: ConfigurationType?
    /// <p>Describes the minimum time in milliseconds after a checkpoint operation completes that a
    ///       new checkpoint operation can start. If a checkpoint operation takes longer than the
    ///         <code>CheckpointInterval</code>, the application otherwise performs continual checkpoint
    ///       operations. For more information, see <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/large_state_tuning.html#tuning-checkpointing"> Tuning Checkpointing</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
    ///         Documentation</a>.</p>
    ///          <note>
    ///             <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    ///     the application will use a <code>MinPauseBetweenCheckpoints</code> value of 5000, even if this value is set using this
    ///       API or in application code.</p>
    ///          </note>
    public let minPauseBetweenCheckpoints: Int?

    public init (
        checkpointInterval: Int? = nil,
        checkpointingEnabled: Bool? = nil,
        configurationType: ConfigurationType? = nil,
        minPauseBetweenCheckpoints: Int? = nil
    )
    {
        self.checkpointInterval = checkpointInterval
        self.checkpointingEnabled = checkpointingEnabled
        self.configurationType = configurationType
        self.minPauseBetweenCheckpoints = minPauseBetweenCheckpoints
    }
}

extension CheckpointConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkpointInterval = "CheckpointInterval"
        case checkpointingEnabled = "CheckpointingEnabled"
        case configurationType = "ConfigurationType"
        case minPauseBetweenCheckpoints = "MinPauseBetweenCheckpoints"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkpointInterval = checkpointInterval {
            try encodeContainer.encode(checkpointInterval, forKey: .checkpointInterval)
        }
        if let checkpointingEnabled = checkpointingEnabled {
            try encodeContainer.encode(checkpointingEnabled, forKey: .checkpointingEnabled)
        }
        if let configurationType = configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let minPauseBetweenCheckpoints = minPauseBetweenCheckpoints {
            try encodeContainer.encode(minPauseBetweenCheckpoints, forKey: .minPauseBetweenCheckpoints)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(ConfigurationType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let checkpointingEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .checkpointingEnabled)
        checkpointingEnabled = checkpointingEnabledDecoded
        let checkpointIntervalDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .checkpointInterval)
        checkpointInterval = checkpointIntervalDecoded
        let minPauseBetweenCheckpointsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minPauseBetweenCheckpoints)
        minPauseBetweenCheckpoints = minPauseBetweenCheckpointsDecoded
    }
}

extension CheckpointConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckpointConfigurationDescription(checkpointInterval: \(String(describing: checkpointInterval)), checkpointingEnabled: \(String(describing: checkpointingEnabled)), configurationType: \(String(describing: configurationType)), minPauseBetweenCheckpoints: \(String(describing: minPauseBetweenCheckpoints)))"}
}

/// <p>Describes checkpointing parameters for a Flink-based Kinesis Data Analytics application.</p>
public struct CheckpointConfigurationDescription: Equatable {
    /// <p>Describes the interval in milliseconds between checkpoint operations. </p>
    ///          <note>
    ///             <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    ///     the application will use a <code>CheckpointInterval</code> value of 60000, even if this value is set to another value
    ///       using this API or in application code.</p>
    ///          </note>
    public let checkpointInterval: Int?
    /// <p>Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.</p>
    ///          <note>
    ///             <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    ///     the application will use a <code>CheckpointingEnabled</code> value of <code>true</code>, even if this value is set to
    ///       another value using this API or in application code.</p>
    ///          </note>
    public let checkpointingEnabled: Bool?
    /// <p>Describes whether the application uses the default checkpointing behavior in Kinesis Data Analytics. </p>
    ///          <note>
    ///             <p>If this value is set to <code>DEFAULT</code>, the application will use the following values,
    ///       even if they are set to other values using APIs or
    ///     application code:</p>
    ///             <ul>
    ///                <li>
    ///                   <p>
    ///                      <b>CheckpointingEnabled:</b> true</p>
    ///                </li>
    ///                <li>
    ///                   <p>
    ///                      <b>CheckpointInterval:</b> 60000</p>
    ///                </li>
    ///                <li>
    ///                   <p>
    ///                      <b>MinPauseBetweenCheckpoints:</b> 5000</p>
    ///                </li>
    ///             </ul>
    ///          </note>
    public let configurationType: ConfigurationType?
    /// <p>Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation
    ///       can start. </p>
    ///          <note>
    ///             <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    ///     the application will use a <code>MinPauseBetweenCheckpoints</code> value of 5000, even if this value is set using this
    ///       API or in application code.</p>
    ///          </note>
    public let minPauseBetweenCheckpoints: Int?

    public init (
        checkpointInterval: Int? = nil,
        checkpointingEnabled: Bool? = nil,
        configurationType: ConfigurationType? = nil,
        minPauseBetweenCheckpoints: Int? = nil
    )
    {
        self.checkpointInterval = checkpointInterval
        self.checkpointingEnabled = checkpointingEnabled
        self.configurationType = configurationType
        self.minPauseBetweenCheckpoints = minPauseBetweenCheckpoints
    }
}

extension CheckpointConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkpointIntervalUpdate = "CheckpointIntervalUpdate"
        case checkpointingEnabledUpdate = "CheckpointingEnabledUpdate"
        case configurationTypeUpdate = "ConfigurationTypeUpdate"
        case minPauseBetweenCheckpointsUpdate = "MinPauseBetweenCheckpointsUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkpointIntervalUpdate = checkpointIntervalUpdate {
            try encodeContainer.encode(checkpointIntervalUpdate, forKey: .checkpointIntervalUpdate)
        }
        if let checkpointingEnabledUpdate = checkpointingEnabledUpdate {
            try encodeContainer.encode(checkpointingEnabledUpdate, forKey: .checkpointingEnabledUpdate)
        }
        if let configurationTypeUpdate = configurationTypeUpdate {
            try encodeContainer.encode(configurationTypeUpdate.rawValue, forKey: .configurationTypeUpdate)
        }
        if let minPauseBetweenCheckpointsUpdate = minPauseBetweenCheckpointsUpdate {
            try encodeContainer.encode(minPauseBetweenCheckpointsUpdate, forKey: .minPauseBetweenCheckpointsUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeUpdateDecoded = try containerValues.decodeIfPresent(ConfigurationType.self, forKey: .configurationTypeUpdate)
        configurationTypeUpdate = configurationTypeUpdateDecoded
        let checkpointingEnabledUpdateDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .checkpointingEnabledUpdate)
        checkpointingEnabledUpdate = checkpointingEnabledUpdateDecoded
        let checkpointIntervalUpdateDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .checkpointIntervalUpdate)
        checkpointIntervalUpdate = checkpointIntervalUpdateDecoded
        let minPauseBetweenCheckpointsUpdateDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minPauseBetweenCheckpointsUpdate)
        minPauseBetweenCheckpointsUpdate = minPauseBetweenCheckpointsUpdateDecoded
    }
}

extension CheckpointConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckpointConfigurationUpdate(checkpointIntervalUpdate: \(String(describing: checkpointIntervalUpdate)), checkpointingEnabledUpdate: \(String(describing: checkpointingEnabledUpdate)), configurationTypeUpdate: \(String(describing: configurationTypeUpdate)), minPauseBetweenCheckpointsUpdate: \(String(describing: minPauseBetweenCheckpointsUpdate)))"}
}

/// <p>Describes updates to the checkpointing parameters for a Flink-based Kinesis Data Analytics application.</p>
public struct CheckpointConfigurationUpdate: Equatable {
    /// <p>Describes updates to the interval in milliseconds between checkpoint operations.</p>
    ///          <note>
    ///             <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    ///     the application will use a <code>CheckpointInterval</code> value of 60000, even if this value is set to another value
    ///       using this API or in application code.</p>
    ///          </note>
    public let checkpointIntervalUpdate: Int?
    /// <p>Describes updates to whether checkpointing is enabled for an application.</p>
    ///          <note>
    ///             <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    ///     the application will use a <code>CheckpointingEnabled</code> value of <code>true</code>, even if this value is set to
    ///       another value using this API or in application code.</p>
    ///          </note>
    public let checkpointingEnabledUpdate: Bool?
    /// <p>Describes updates to whether the application uses the default checkpointing behavior of
    ///       Kinesis Data Analytics. You must set this property to <code>CUSTOM</code> in order to set the
    ///       <code>CheckpointingEnabled</code>, <code>CheckpointInterval</code>, or <code>MinPauseBetweenCheckpoints</code> parameters.
    ///       </p>
    ///          <note>
    ///             <p>If this value is set to <code>DEFAULT</code>, the application will use the following values, even if they are
    ///       set to other values using APIs or
    ///     application code:</p>
    ///             <ul>
    ///                <li>
    ///                   <p>
    ///                      <b>CheckpointingEnabled:</b> true</p>
    ///                </li>
    ///                <li>
    ///                   <p>
    ///                      <b>CheckpointInterval:</b> 60000</p>
    ///                </li>
    ///                <li>
    ///                   <p>
    ///                      <b>MinPauseBetweenCheckpoints:</b> 5000</p>
    ///                </li>
    ///             </ul>
    ///          </note>
    public let configurationTypeUpdate: ConfigurationType?
    /// <p>Describes updates to the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation
    ///       can start.</p>
    ///          <note>
    ///             <p>If <code>CheckpointConfiguration.ConfigurationType</code> is <code>DEFAULT</code>,
    ///     the application will use a <code>MinPauseBetweenCheckpoints</code> value of 5000, even if this value is set using this API or
    ///       in application code.</p>
    ///          </note>
    public let minPauseBetweenCheckpointsUpdate: Int?

    public init (
        checkpointIntervalUpdate: Int? = nil,
        checkpointingEnabledUpdate: Bool? = nil,
        configurationTypeUpdate: ConfigurationType? = nil,
        minPauseBetweenCheckpointsUpdate: Int? = nil
    )
    {
        self.checkpointIntervalUpdate = checkpointIntervalUpdate
        self.checkpointingEnabledUpdate = checkpointingEnabledUpdate
        self.configurationTypeUpdate = configurationTypeUpdate
        self.minPauseBetweenCheckpointsUpdate = minPauseBetweenCheckpointsUpdate
    }
}

extension CloudWatchLoggingOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logStreamARN = "LogStreamARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logStreamARN = logStreamARN {
            try encodeContainer.encode(logStreamARN, forKey: .logStreamARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logStreamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logStreamARN)
        logStreamARN = logStreamARNDecoded
    }
}

extension CloudWatchLoggingOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchLoggingOption(logStreamARN: \(String(describing: logStreamARN)))"}
}

/// <p>Provides a description of Amazon CloudWatch logging options, including the log stream
///       Amazon Resource Name (ARN). </p>
public struct CloudWatchLoggingOption: Equatable {
    /// <p>The ARN of the CloudWatch log to receive application messages.</p>
    public let logStreamARN: String?

    public init (
        logStreamARN: String? = nil
    )
    {
        self.logStreamARN = logStreamARN
    }
}

extension CloudWatchLoggingOptionDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
        case logStreamARN = "LogStreamARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLoggingOptionId = cloudWatchLoggingOptionId {
            try encodeContainer.encode(cloudWatchLoggingOptionId, forKey: .cloudWatchLoggingOptionId)
        }
        if let logStreamARN = logStreamARN {
            try encodeContainer.encode(logStreamARN, forKey: .logStreamARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLoggingOptionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLoggingOptionId)
        cloudWatchLoggingOptionId = cloudWatchLoggingOptionIdDecoded
        let logStreamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logStreamARN)
        logStreamARN = logStreamARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension CloudWatchLoggingOptionDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchLoggingOptionDescription(cloudWatchLoggingOptionId: \(String(describing: cloudWatchLoggingOptionId)), logStreamARN: \(String(describing: logStreamARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>Describes the Amazon CloudWatch logging option.</p>
public struct CloudWatchLoggingOptionDescription: Equatable {
    /// <p>The ID of the CloudWatch logging option description.</p>
    public let cloudWatchLoggingOptionId: String?
    /// <p>The Amazon Resource Name (ARN) of the CloudWatch log to receive application
    ///       messages.</p>
    public let logStreamARN: String?
    /// <p>The IAM ARN of the role to use to send application messages. </p>
    ///          <note>
    ///             <p>Provided for backward compatibility. Applications created with the current API version have an
    ///         application-level service execution role rather than a resource-level role.</p>
    ///          </note>
    public let roleARN: String?

    public init (
        cloudWatchLoggingOptionId: String? = nil,
        logStreamARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
        self.logStreamARN = logStreamARN
        self.roleARN = roleARN
    }
}

extension CloudWatchLoggingOptionUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
        case logStreamARNUpdate = "LogStreamARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLoggingOptionId = cloudWatchLoggingOptionId {
            try encodeContainer.encode(cloudWatchLoggingOptionId, forKey: .cloudWatchLoggingOptionId)
        }
        if let logStreamARNUpdate = logStreamARNUpdate {
            try encodeContainer.encode(logStreamARNUpdate, forKey: .logStreamARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLoggingOptionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLoggingOptionId)
        cloudWatchLoggingOptionId = cloudWatchLoggingOptionIdDecoded
        let logStreamARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logStreamARNUpdate)
        logStreamARNUpdate = logStreamARNUpdateDecoded
    }
}

extension CloudWatchLoggingOptionUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchLoggingOptionUpdate(cloudWatchLoggingOptionId: \(String(describing: cloudWatchLoggingOptionId)), logStreamARNUpdate: \(String(describing: logStreamARNUpdate)))"}
}

/// <p>Describes the Amazon CloudWatch logging option updates.</p>
public struct CloudWatchLoggingOptionUpdate: Equatable {
    /// <p>The ID of the CloudWatch logging option to update</p>
    public let cloudWatchLoggingOptionId: String?
    /// <p>The Amazon Resource Name (ARN) of the CloudWatch log to receive application
    ///       messages.</p>
    public let logStreamARNUpdate: String?

    public init (
        cloudWatchLoggingOptionId: String? = nil,
        logStreamARNUpdate: String? = nil
    )
    {
        self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
        self.logStreamARNUpdate = logStreamARNUpdate
    }
}

extension CodeContent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3ContentLocation = "S3ContentLocation"
        case textContent = "TextContent"
        case zipFileContent = "ZipFileContent"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3ContentLocation = s3ContentLocation {
            try encodeContainer.encode(s3ContentLocation, forKey: .s3ContentLocation)
        }
        if let textContent = textContent {
            try encodeContainer.encode(textContent, forKey: .textContent)
        }
        if let zipFileContent = zipFileContent {
            try encodeContainer.encode(zipFileContent.base64EncodedString(), forKey: .zipFileContent)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .textContent)
        textContent = textContentDecoded
        let zipFileContentDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .zipFileContent)
        zipFileContent = zipFileContentDecoded
        let s3ContentLocationDecoded = try containerValues.decodeIfPresent(S3ContentLocation.self, forKey: .s3ContentLocation)
        s3ContentLocation = s3ContentLocationDecoded
    }
}

extension CodeContent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeContent(s3ContentLocation: \(String(describing: s3ContentLocation)), textContent: \(String(describing: textContent)), zipFileContent: \(String(describing: zipFileContent)))"}
}

/// <p>Specifies either the application code, or the location of the application code, for a
///       Flink-based Kinesis Data Analytics application. </p>
public struct CodeContent: Equatable {
    /// <p>Information about the Amazon S3 bucket that contains the application code.</p>
    public let s3ContentLocation: S3ContentLocation?
    /// <p>The text-format code for a Flink-based Kinesis Data Analytics application.</p>
    public let textContent: String?
    /// <p>The zip-format code for a Flink-based Kinesis Data Analytics application.</p>
    public let zipFileContent: Data?

    public init (
        s3ContentLocation: S3ContentLocation? = nil,
        textContent: String? = nil,
        zipFileContent: Data? = nil
    )
    {
        self.s3ContentLocation = s3ContentLocation
        self.textContent = textContent
        self.zipFileContent = zipFileContent
    }
}

extension CodeContentDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeMD5 = "CodeMD5"
        case codeSize = "CodeSize"
        case s3ApplicationCodeLocationDescription = "S3ApplicationCodeLocationDescription"
        case textContent = "TextContent"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeMD5 = codeMD5 {
            try encodeContainer.encode(codeMD5, forKey: .codeMD5)
        }
        if let codeSize = codeSize {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let s3ApplicationCodeLocationDescription = s3ApplicationCodeLocationDescription {
            try encodeContainer.encode(s3ApplicationCodeLocationDescription, forKey: .s3ApplicationCodeLocationDescription)
        }
        if let textContent = textContent {
            try encodeContainer.encode(textContent, forKey: .textContent)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .textContent)
        textContent = textContentDecoded
        let codeMD5Decoded = try containerValues.decodeIfPresent(String.self, forKey: .codeMD5)
        codeMD5 = codeMD5Decoded
        let codeSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let s3ApplicationCodeLocationDescriptionDecoded = try containerValues.decodeIfPresent(S3ApplicationCodeLocationDescription.self, forKey: .s3ApplicationCodeLocationDescription)
        s3ApplicationCodeLocationDescription = s3ApplicationCodeLocationDescriptionDecoded
    }
}

extension CodeContentDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeContentDescription(codeMD5: \(String(describing: codeMD5)), codeSize: \(String(describing: codeSize)), s3ApplicationCodeLocationDescription: \(String(describing: s3ApplicationCodeLocationDescription)), textContent: \(String(describing: textContent)))"}
}

/// <p>Describes details about the code of a Kinesis Data Analytics application.</p>
public struct CodeContentDescription: Equatable {
    /// <p>The checksum that can be used to validate zip-format code.</p>
    public let codeMD5: String?
    /// <p>The size in bytes of the application code. Can be used to validate zip-format code.</p>
    public let codeSize: Int?
    /// <p>The S3 bucket Amazon Resource Name (ARN), file key, and object version of the application
    ///       code stored in Amazon S3.</p>
    public let s3ApplicationCodeLocationDescription: S3ApplicationCodeLocationDescription?
    /// <p>The text-format code</p>
    public let textContent: String?

    public init (
        codeMD5: String? = nil,
        codeSize: Int? = nil,
        s3ApplicationCodeLocationDescription: S3ApplicationCodeLocationDescription? = nil,
        textContent: String? = nil
    )
    {
        self.codeMD5 = codeMD5
        self.codeSize = codeSize
        self.s3ApplicationCodeLocationDescription = s3ApplicationCodeLocationDescription
        self.textContent = textContent
    }
}

public enum CodeContentType {
    case plaintext
    case zipfile
    case sdkUnknown(String)
}

extension CodeContentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CodeContentType] {
        return [
            .plaintext,
            .zipfile,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .plaintext: return "PLAINTEXT"
        case .zipfile: return "ZIPFILE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CodeContentType(rawValue: rawValue) ?? CodeContentType.sdkUnknown(rawValue)
    }
}

extension CodeContentUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3ContentLocationUpdate = "S3ContentLocationUpdate"
        case textContentUpdate = "TextContentUpdate"
        case zipFileContentUpdate = "ZipFileContentUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3ContentLocationUpdate = s3ContentLocationUpdate {
            try encodeContainer.encode(s3ContentLocationUpdate, forKey: .s3ContentLocationUpdate)
        }
        if let textContentUpdate = textContentUpdate {
            try encodeContainer.encode(textContentUpdate, forKey: .textContentUpdate)
        }
        if let zipFileContentUpdate = zipFileContentUpdate {
            try encodeContainer.encode(zipFileContentUpdate.base64EncodedString(), forKey: .zipFileContentUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textContentUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .textContentUpdate)
        textContentUpdate = textContentUpdateDecoded
        let zipFileContentUpdateDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .zipFileContentUpdate)
        zipFileContentUpdate = zipFileContentUpdateDecoded
        let s3ContentLocationUpdateDecoded = try containerValues.decodeIfPresent(S3ContentLocationUpdate.self, forKey: .s3ContentLocationUpdate)
        s3ContentLocationUpdate = s3ContentLocationUpdateDecoded
    }
}

extension CodeContentUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeContentUpdate(s3ContentLocationUpdate: \(String(describing: s3ContentLocationUpdate)), textContentUpdate: \(String(describing: textContentUpdate)), zipFileContentUpdate: \(String(describing: zipFileContentUpdate)))"}
}

/// <p>Describes an update to the code of an application. Not supported for Apache Zeppelin.</p>
public struct CodeContentUpdate: Equatable {
    /// <p>Describes an update to the location of code for an application.</p>
    public let s3ContentLocationUpdate: S3ContentLocationUpdate?
    /// <p>Describes an update to the text code for an application.</p>
    public let textContentUpdate: String?
    /// <p>Describes an update to the zipped code for an application.</p>
    public let zipFileContentUpdate: Data?

    public init (
        s3ContentLocationUpdate: S3ContentLocationUpdate? = nil,
        textContentUpdate: String? = nil,
        zipFileContentUpdate: Data? = nil
    )
    {
        self.s3ContentLocationUpdate = s3ContentLocationUpdate
        self.textContentUpdate = textContentUpdate
        self.zipFileContentUpdate = zipFileContentUpdate
    }
}

extension CodeValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeValidationException(message: \(String(describing: message)))"}
}

extension CodeValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CodeValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user-provided application code (query) is not valid. This can be a simple syntax
///       error.</p>
public struct CodeValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CodeValidationExceptionBody: Equatable {
    public let message: String?
}

extension CodeValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception thrown as a result of concurrent modifications to an application. This error can
///       be the result of attempting to modify an application without using the current application
///       ID.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ConfigurationType {
    case custom
    case `default`
    case sdkUnknown(String)
}

extension ConfigurationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfigurationType] {
        return [
            .custom,
            .default,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .custom: return "CUSTOM"
        case .default: return "DEFAULT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfigurationType(rawValue: rawValue) ?? ConfigurationType.sdkUnknown(rawValue)
    }
}

public struct CreateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "CreateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

extension CreateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationInput(applicationConfiguration: \(String(describing: applicationConfiguration)), applicationDescription: \(String(describing: applicationDescription)), applicationMode: \(String(describing: applicationMode)), applicationName: \(String(describing: applicationName)), cloudWatchLoggingOptions: \(String(describing: cloudWatchLoggingOptions)), runtimeEnvironment: \(String(describing: runtimeEnvironment)), serviceExecutionRole: \(String(describing: serviceExecutionRole)), tags: \(String(describing: tags)))"}
}

extension CreateApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationConfiguration = "ApplicationConfiguration"
        case applicationDescription = "ApplicationDescription"
        case applicationMode = "ApplicationMode"
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptions = "CloudWatchLoggingOptions"
        case runtimeEnvironment = "RuntimeEnvironment"
        case serviceExecutionRole = "ServiceExecutionRole"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfiguration = applicationConfiguration {
            try encodeContainer.encode(applicationConfiguration, forKey: .applicationConfiguration)
        }
        if let applicationDescription = applicationDescription {
            try encodeContainer.encode(applicationDescription, forKey: .applicationDescription)
        }
        if let applicationMode = applicationMode {
            try encodeContainer.encode(applicationMode.rawValue, forKey: .applicationMode)
        }
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let cloudWatchLoggingOptions = cloudWatchLoggingOptions {
            var cloudWatchLoggingOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchLoggingOptions)
            for cloudwatchloggingoptions0 in cloudWatchLoggingOptions {
                try cloudWatchLoggingOptionsContainer.encode(cloudwatchloggingoptions0)
            }
        }
        if let runtimeEnvironment = runtimeEnvironment {
            try encodeContainer.encode(runtimeEnvironment.rawValue, forKey: .runtimeEnvironment)
        }
        if let serviceExecutionRole = serviceExecutionRole {
            try encodeContainer.encode(serviceExecutionRole, forKey: .serviceExecutionRole)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInput: Equatable {
    /// <p>Use this parameter to configure the application.</p>
    public let applicationConfiguration: ApplicationConfiguration?
    /// <p>A summary description of the application.</p>
    public let applicationDescription: String?
    /// <p>Use the <code>STREAMING</code> mode to create a Kinesis Data Analytics Studio notebook. To create a Kinesis Data Analytics Studio notebook, use the
    ///     <code>INTERACTIVE</code> mode.</p>
    public let applicationMode: ApplicationMode?
    /// <p>The name of your application (for example, <code>sample-app</code>).</p>
    public let applicationName: String?
    /// <p>Use this parameter to configure an Amazon CloudWatch log stream to monitor application
    ///       configuration errors.
    ///       </p>
    public let cloudWatchLoggingOptions: [CloudWatchLoggingOption]?
    /// <p>The runtime environment for the application (<code>SQL-1_0</code>, <code>FLINK-1_6</code>, <code>FLINK-1_8</code>, or <code>FLINK-1_11</code>).</p>
    public let runtimeEnvironment: RuntimeEnvironment?
    /// <p>The IAM role used by the application to access Kinesis data streams, Kinesis Data Firehose
    ///       delivery streams, Amazon S3 objects, and other external resources.</p>
    public let serviceExecutionRole: String?
    /// <p>A list of one or more tags to assign to the application. A tag is a key-value pair that identifies an
    ///         application. Note that the maximum number of application tags includes system tags. The maximum number of
    ///         user-defined application tags is 50.
    ///         For more information, see
    ///         <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-tagging.html">Using Tagging</a>.</p>
    public let tags: [Tag]?

    public init (
        applicationConfiguration: ApplicationConfiguration? = nil,
        applicationDescription: String? = nil,
        applicationMode: ApplicationMode? = nil,
        applicationName: String? = nil,
        cloudWatchLoggingOptions: [CloudWatchLoggingOption]? = nil,
        runtimeEnvironment: RuntimeEnvironment? = nil,
        serviceExecutionRole: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.applicationConfiguration = applicationConfiguration
        self.applicationDescription = applicationDescription
        self.applicationMode = applicationMode
        self.applicationName = applicationName
        self.cloudWatchLoggingOptions = cloudWatchLoggingOptions
        self.runtimeEnvironment = runtimeEnvironment
        self.serviceExecutionRole = serviceExecutionRole
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Equatable {
    public let applicationName: String?
    public let applicationDescription: String?
    public let runtimeEnvironment: RuntimeEnvironment?
    public let serviceExecutionRole: String?
    public let applicationConfiguration: ApplicationConfiguration?
    public let cloudWatchLoggingOptions: [CloudWatchLoggingOption]?
    public let tags: [Tag]?
    public let applicationMode: ApplicationMode?
}

extension CreateApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationConfiguration = "ApplicationConfiguration"
        case applicationDescription = "ApplicationDescription"
        case applicationMode = "ApplicationMode"
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptions = "CloudWatchLoggingOptions"
        case runtimeEnvironment = "RuntimeEnvironment"
        case serviceExecutionRole = "ServiceExecutionRole"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationDescription)
        applicationDescription = applicationDescriptionDecoded
        let runtimeEnvironmentDecoded = try containerValues.decodeIfPresent(RuntimeEnvironment.self, forKey: .runtimeEnvironment)
        runtimeEnvironment = runtimeEnvironmentDecoded
        let serviceExecutionRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceExecutionRole)
        serviceExecutionRole = serviceExecutionRoleDecoded
        let applicationConfigurationDecoded = try containerValues.decodeIfPresent(ApplicationConfiguration.self, forKey: .applicationConfiguration)
        applicationConfiguration = applicationConfigurationDecoded
        let cloudWatchLoggingOptionsContainer = try containerValues.decodeIfPresent([CloudWatchLoggingOption?].self, forKey: .cloudWatchLoggingOptions)
        var cloudWatchLoggingOptionsDecoded0:[CloudWatchLoggingOption]? = nil
        if let cloudWatchLoggingOptionsContainer = cloudWatchLoggingOptionsContainer {
            cloudWatchLoggingOptionsDecoded0 = [CloudWatchLoggingOption]()
            for structure0 in cloudWatchLoggingOptionsContainer {
                if let structure0 = structure0 {
                    cloudWatchLoggingOptionsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchLoggingOptions = cloudWatchLoggingOptionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let applicationModeDecoded = try containerValues.decodeIfPresent(ApplicationMode.self, forKey: .applicationMode)
        applicationMode = applicationModeDecoded
    }
}

extension CreateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeValidationException" : self = .codeValidationException(try CodeValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationOutputError: Equatable {
    case codeValidationException(CodeValidationException)
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationOutputResponse(applicationDetail: \(String(describing: applicationDetail)))"}
}

extension CreateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationDetail = output.applicationDetail
        } else {
            self.applicationDetail = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Equatable {
    /// <p>In response to your <code>CreateApplication</code> request, Kinesis Data Analytics returns a
    ///       response with details of the application it created.</p>
    public let applicationDetail: ApplicationDetail?

    public init (
        applicationDetail: ApplicationDetail? = nil
    )
    {
        self.applicationDetail = applicationDetail
    }
}

struct CreateApplicationOutputResponseBody: Equatable {
    public let applicationDetail: ApplicationDetail?
}

extension CreateApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationDetail = "ApplicationDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDetailDecoded = try containerValues.decodeIfPresent(ApplicationDetail.self, forKey: .applicationDetail)
        applicationDetail = applicationDetailDecoded
    }
}

public struct CreateApplicationPresignedUrlInputBodyMiddleware: Middleware {
    public let id: String = "CreateApplicationPresignedUrlInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationPresignedUrlInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationPresignedUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationPresignedUrlInput>
    public typealias MOutput = OperationOutput<CreateApplicationPresignedUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationPresignedUrlOutputError>
}

extension CreateApplicationPresignedUrlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationPresignedUrlInput(applicationName: \(String(describing: applicationName)), sessionExpirationDurationInSeconds: \(String(describing: sessionExpirationDurationInSeconds)), urlType: \(String(describing: urlType)))"}
}

extension CreateApplicationPresignedUrlInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case sessionExpirationDurationInSeconds = "SessionExpirationDurationInSeconds"
        case urlType = "UrlType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let sessionExpirationDurationInSeconds = sessionExpirationDurationInSeconds {
            try encodeContainer.encode(sessionExpirationDurationInSeconds, forKey: .sessionExpirationDurationInSeconds)
        }
        if let urlType = urlType {
            try encodeContainer.encode(urlType.rawValue, forKey: .urlType)
        }
    }
}

public struct CreateApplicationPresignedUrlInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApplicationPresignedUrlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationPresignedUrlInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationPresignedUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationPresignedUrlInput>
    public typealias MOutput = OperationOutput<CreateApplicationPresignedUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationPresignedUrlOutputError>
}

public struct CreateApplicationPresignedUrlInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApplicationPresignedUrlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationPresignedUrlInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationPresignedUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationPresignedUrlInput>
    public typealias MOutput = OperationOutput<CreateApplicationPresignedUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationPresignedUrlOutputError>
}

public struct CreateApplicationPresignedUrlInput: Equatable {
    /// <p>The name of the application.</p>
    public let applicationName: String?
    /// <p>The duration in seconds for which the returned URL will be valid.</p>
    public let sessionExpirationDurationInSeconds: Int?
    /// <p>The type of the extension for which to create and return a URL. Currently, the only valid
    ///             extension URL type is <code>FLINK_DASHBOARD_URL</code>. </p>
    public let urlType: UrlType?

    public init (
        applicationName: String? = nil,
        sessionExpirationDurationInSeconds: Int? = nil,
        urlType: UrlType? = nil
    )
    {
        self.applicationName = applicationName
        self.sessionExpirationDurationInSeconds = sessionExpirationDurationInSeconds
        self.urlType = urlType
    }
}

struct CreateApplicationPresignedUrlInputBody: Equatable {
    public let applicationName: String?
    public let urlType: UrlType?
    public let sessionExpirationDurationInSeconds: Int?
}

extension CreateApplicationPresignedUrlInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case sessionExpirationDurationInSeconds = "SessionExpirationDurationInSeconds"
        case urlType = "UrlType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let urlTypeDecoded = try containerValues.decodeIfPresent(UrlType.self, forKey: .urlType)
        urlType = urlTypeDecoded
        let sessionExpirationDurationInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .sessionExpirationDurationInSeconds)
        sessionExpirationDurationInSeconds = sessionExpirationDurationInSecondsDecoded
    }
}

extension CreateApplicationPresignedUrlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationPresignedUrlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationPresignedUrlOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationPresignedUrlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationPresignedUrlOutputResponse(authorizedUrl: \(String(describing: authorizedUrl)))"}
}

extension CreateApplicationPresignedUrlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateApplicationPresignedUrlOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorizedUrl = output.authorizedUrl
        } else {
            self.authorizedUrl = nil
        }
    }
}

public struct CreateApplicationPresignedUrlOutputResponse: Equatable {
    /// <p>The URL of the extension.</p>
    public let authorizedUrl: String?

    public init (
        authorizedUrl: String? = nil
    )
    {
        self.authorizedUrl = authorizedUrl
    }
}

struct CreateApplicationPresignedUrlOutputResponseBody: Equatable {
    public let authorizedUrl: String?
}

extension CreateApplicationPresignedUrlOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizedUrl = "AuthorizedUrl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizedUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizedUrl)
        authorizedUrl = authorizedUrlDecoded
    }
}

public struct CreateApplicationSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "CreateApplicationSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationSnapshotInput>
    public typealias MOutput = OperationOutput<CreateApplicationSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationSnapshotOutputError>
}

extension CreateApplicationSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationSnapshotInput(applicationName: \(String(describing: applicationName)), snapshotName: \(String(describing: snapshotName)))"}
}

extension CreateApplicationSnapshotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case snapshotName = "SnapshotName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let snapshotName = snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
    }
}

public struct CreateApplicationSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApplicationSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationSnapshotInput>
    public typealias MOutput = OperationOutput<CreateApplicationSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationSnapshotOutputError>
}

public struct CreateApplicationSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApplicationSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationSnapshotInput>
    public typealias MOutput = OperationOutput<CreateApplicationSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationSnapshotOutputError>
}

public struct CreateApplicationSnapshotInput: Equatable {
    /// <p>The name of an existing application</p>
    public let applicationName: String?
    /// <p>An identifier for the application snapshot.</p>
    public let snapshotName: String?

    public init (
        applicationName: String? = nil,
        snapshotName: String? = nil
    )
    {
        self.applicationName = applicationName
        self.snapshotName = snapshotName
    }
}

struct CreateApplicationSnapshotInputBody: Equatable {
    public let applicationName: String?
    public let snapshotName: String?
}

extension CreateApplicationSnapshotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case snapshotName = "SnapshotName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
    }
}

extension CreateApplicationSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationSnapshotOutputError: Equatable {
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationSnapshotOutputResponse()"}
}

extension CreateApplicationSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateApplicationSnapshotOutputResponse: Equatable {

    public init() {}
}

struct CreateApplicationSnapshotOutputResponseBody: Equatable {
}

extension CreateApplicationSnapshotOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CustomArtifactConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactType = "ArtifactType"
        case mavenReference = "MavenReference"
        case s3ContentLocation = "S3ContentLocation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactType = artifactType {
            try encodeContainer.encode(artifactType.rawValue, forKey: .artifactType)
        }
        if let mavenReference = mavenReference {
            try encodeContainer.encode(mavenReference, forKey: .mavenReference)
        }
        if let s3ContentLocation = s3ContentLocation {
            try encodeContainer.encode(s3ContentLocation, forKey: .s3ContentLocation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactTypeDecoded = try containerValues.decodeIfPresent(ArtifactType.self, forKey: .artifactType)
        artifactType = artifactTypeDecoded
        let s3ContentLocationDecoded = try containerValues.decodeIfPresent(S3ContentLocation.self, forKey: .s3ContentLocation)
        s3ContentLocation = s3ContentLocationDecoded
        let mavenReferenceDecoded = try containerValues.decodeIfPresent(MavenReference.self, forKey: .mavenReference)
        mavenReference = mavenReferenceDecoded
    }
}

extension CustomArtifactConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomArtifactConfiguration(artifactType: \(String(describing: artifactType)), mavenReference: \(String(describing: mavenReference)), s3ContentLocation: \(String(describing: s3ContentLocation)))"}
}

/// <p>Specifies dependency JARs, as well as JAR files that contain user-defined functions (UDF).</p>
public struct CustomArtifactConfiguration: Equatable {
    /// <p>
    ///             <code>UDF</code> stands for user-defined functions. This type of artifact must be in an S3 bucket. A <code>DEPENDENCY_JAR</code> can be in either Maven or an S3 bucket.</p>
    public let artifactType: ArtifactType?
    /// <p>The parameters required to fully specify a Maven reference.</p>
    public let mavenReference: MavenReference?
    /// <p>For a Kinesis Data Analytics application provides a
    ///       description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket,
    ///       the name of the Amazon S3 object that contains the data, and the version number of the Amazon
    ///       S3 object that contains the data. </p>
    public let s3ContentLocation: S3ContentLocation?

    public init (
        artifactType: ArtifactType? = nil,
        mavenReference: MavenReference? = nil,
        s3ContentLocation: S3ContentLocation? = nil
    )
    {
        self.artifactType = artifactType
        self.mavenReference = mavenReference
        self.s3ContentLocation = s3ContentLocation
    }
}

extension CustomArtifactConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactType = "ArtifactType"
        case mavenReferenceDescription = "MavenReferenceDescription"
        case s3ContentLocationDescription = "S3ContentLocationDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactType = artifactType {
            try encodeContainer.encode(artifactType.rawValue, forKey: .artifactType)
        }
        if let mavenReferenceDescription = mavenReferenceDescription {
            try encodeContainer.encode(mavenReferenceDescription, forKey: .mavenReferenceDescription)
        }
        if let s3ContentLocationDescription = s3ContentLocationDescription {
            try encodeContainer.encode(s3ContentLocationDescription, forKey: .s3ContentLocationDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactTypeDecoded = try containerValues.decodeIfPresent(ArtifactType.self, forKey: .artifactType)
        artifactType = artifactTypeDecoded
        let s3ContentLocationDescriptionDecoded = try containerValues.decodeIfPresent(S3ContentLocation.self, forKey: .s3ContentLocationDescription)
        s3ContentLocationDescription = s3ContentLocationDescriptionDecoded
        let mavenReferenceDescriptionDecoded = try containerValues.decodeIfPresent(MavenReference.self, forKey: .mavenReferenceDescription)
        mavenReferenceDescription = mavenReferenceDescriptionDecoded
    }
}

extension CustomArtifactConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomArtifactConfigurationDescription(artifactType: \(String(describing: artifactType)), mavenReferenceDescription: \(String(describing: mavenReferenceDescription)), s3ContentLocationDescription: \(String(describing: s3ContentLocationDescription)))"}
}

/// <p>Specifies a dependency JAR or a JAR of user-defined functions.</p>
public struct CustomArtifactConfigurationDescription: Equatable {
    /// <p>
    ///             <code>UDF</code> stands for user-defined functions. This type of artifact must be in an S3 bucket. A <code>DEPENDENCY_JAR</code> can be in either Maven or an S3 bucket.</p>
    public let artifactType: ArtifactType?
    /// <p>The parameters that are required to specify a Maven dependency.</p>
    public let mavenReferenceDescription: MavenReference?
    /// <p>For a Kinesis Data Analytics application provides a
    ///       description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket,
    ///       the name of the Amazon S3 object that contains the data, and the version number of the Amazon
    ///       S3 object that contains the data. </p>
    public let s3ContentLocationDescription: S3ContentLocation?

    public init (
        artifactType: ArtifactType? = nil,
        mavenReferenceDescription: MavenReference? = nil,
        s3ContentLocationDescription: S3ContentLocation? = nil
    )
    {
        self.artifactType = artifactType
        self.mavenReferenceDescription = mavenReferenceDescription
        self.s3ContentLocationDescription = s3ContentLocationDescription
    }
}

public struct DeleteApplicationCloudWatchLoggingOptionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApplicationCloudWatchLoggingOptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationCloudWatchLoggingOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationCloudWatchLoggingOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationCloudWatchLoggingOptionInput>
    public typealias MOutput = OperationOutput<DeleteApplicationCloudWatchLoggingOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationCloudWatchLoggingOptionOutputError>
}

extension DeleteApplicationCloudWatchLoggingOptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationCloudWatchLoggingOptionInput(applicationName: \(String(describing: applicationName)), cloudWatchLoggingOptionId: \(String(describing: cloudWatchLoggingOptionId)), conditionalToken: \(String(describing: conditionalToken)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)))"}
}

extension DeleteApplicationCloudWatchLoggingOptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let cloudWatchLoggingOptionId = cloudWatchLoggingOptionId {
            try encodeContainer.encode(cloudWatchLoggingOptionId, forKey: .cloudWatchLoggingOptionId)
        }
        if let conditionalToken = conditionalToken {
            try encodeContainer.encode(conditionalToken, forKey: .conditionalToken)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
    }
}

public struct DeleteApplicationCloudWatchLoggingOptionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationCloudWatchLoggingOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationCloudWatchLoggingOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationCloudWatchLoggingOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationCloudWatchLoggingOptionInput>
    public typealias MOutput = OperationOutput<DeleteApplicationCloudWatchLoggingOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationCloudWatchLoggingOptionOutputError>
}

public struct DeleteApplicationCloudWatchLoggingOptionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationCloudWatchLoggingOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationCloudWatchLoggingOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationCloudWatchLoggingOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationCloudWatchLoggingOptionInput>
    public typealias MOutput = OperationOutput<DeleteApplicationCloudWatchLoggingOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationCloudWatchLoggingOptionOutputError>
}

public struct DeleteApplicationCloudWatchLoggingOptionInput: Equatable {
    /// <p>The application name.</p>
    public let applicationName: String?
    /// <p>The <code>CloudWatchLoggingOptionId</code> of the Amazon CloudWatch logging option to
    ///          delete. You can get the <code>CloudWatchLoggingOptionId</code> by using the <a>DescribeApplication</a> operation. </p>
    public let cloudWatchLoggingOptionId: String?
    /// <p>A value you use to implement strong concurrency for application updates. You must provide
    ///       the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You get the
    ///       application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the <code>ConditionalToken</code> parameter instead of
    ///         <code>CurrentApplicationVersionId</code>.</p>
    public let conditionalToken: String?
    /// <p>The version ID of the application. You must provide the
    ///         <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You can
    ///       retrieve the application version ID using <a>DescribeApplication</a>. For better
    ///       concurrency support, use the <code>ConditionalToken</code> parameter instead of
    ///         <code>CurrentApplicationVersionId</code>.</p>
    public let currentApplicationVersionId: Int?

    public init (
        applicationName: String? = nil,
        cloudWatchLoggingOptionId: String? = nil,
        conditionalToken: String? = nil,
        currentApplicationVersionId: Int? = nil
    )
    {
        self.applicationName = applicationName
        self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
        self.conditionalToken = conditionalToken
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

struct DeleteApplicationCloudWatchLoggingOptionInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let cloudWatchLoggingOptionId: String?
    public let conditionalToken: String?
}

extension DeleteApplicationCloudWatchLoggingOptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let cloudWatchLoggingOptionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLoggingOptionId)
        cloudWatchLoggingOptionId = cloudWatchLoggingOptionIdDecoded
        let conditionalTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conditionalToken)
        conditionalToken = conditionalTokenDecoded
    }
}

extension DeleteApplicationCloudWatchLoggingOptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationCloudWatchLoggingOptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationCloudWatchLoggingOptionOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationCloudWatchLoggingOptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationCloudWatchLoggingOptionOutputResponse(applicationARN: \(String(describing: applicationARN)), applicationVersionId: \(String(describing: applicationVersionId)), cloudWatchLoggingOptionDescriptions: \(String(describing: cloudWatchLoggingOptionDescriptions)))"}
}

extension DeleteApplicationCloudWatchLoggingOptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteApplicationCloudWatchLoggingOptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
            self.cloudWatchLoggingOptionDescriptions = output.cloudWatchLoggingOptionDescriptions
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
            self.cloudWatchLoggingOptionDescriptions = nil
        }
    }
}

public struct DeleteApplicationCloudWatchLoggingOptionOutputResponse: Equatable {
    /// <p>The application's Amazon Resource Name (ARN).</p>
    public let applicationARN: String?
    /// <p>The version ID of the application. Kinesis Data Analytics updates the
    ///         <code>ApplicationVersionId</code> each time you change the CloudWatch logging
    ///       options.</p>
    public let applicationVersionId: Int?
    /// <p>The descriptions of the remaining CloudWatch logging options for the application.</p>
    public let cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]?

    public init (
        applicationARN: String? = nil,
        applicationVersionId: Int? = nil,
        cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
        self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
    }
}

struct DeleteApplicationCloudWatchLoggingOptionOutputResponseBody: Equatable {
    public let applicationARN: String?
    public let applicationVersionId: Int?
    public let cloudWatchLoggingOptionDescriptions: [CloudWatchLoggingOptionDescription]?
}

extension DeleteApplicationCloudWatchLoggingOptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
        case cloudWatchLoggingOptionDescriptions = "CloudWatchLoggingOptionDescriptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let cloudWatchLoggingOptionDescriptionsContainer = try containerValues.decodeIfPresent([CloudWatchLoggingOptionDescription?].self, forKey: .cloudWatchLoggingOptionDescriptions)
        var cloudWatchLoggingOptionDescriptionsDecoded0:[CloudWatchLoggingOptionDescription]? = nil
        if let cloudWatchLoggingOptionDescriptionsContainer = cloudWatchLoggingOptionDescriptionsContainer {
            cloudWatchLoggingOptionDescriptionsDecoded0 = [CloudWatchLoggingOptionDescription]()
            for structure0 in cloudWatchLoggingOptionDescriptionsContainer {
                if let structure0 = structure0 {
                    cloudWatchLoggingOptionDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptionsDecoded0
    }
}

public struct DeleteApplicationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

extension DeleteApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationInput(applicationName: \(String(describing: applicationName)), createTimestamp: \(String(describing: createTimestamp)))"}
}

extension DeleteApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case createTimestamp = "CreateTimestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let createTimestamp = createTimestamp {
            try encodeContainer.encode(createTimestamp.timeIntervalSince1970, forKey: .createTimestamp)
        }
    }
}

public struct DeleteApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInput: Equatable {
    /// <p>The name of the application to delete.</p>
    public let applicationName: String?
    /// <p>Use the <code>DescribeApplication</code> operation to get this value.</p>
    public let createTimestamp: Date?

    public init (
        applicationName: String? = nil,
        createTimestamp: Date? = nil
    )
    {
        self.applicationName = applicationName
        self.createTimestamp = createTimestamp
    }
}

struct DeleteApplicationInputBody: Equatable {
    public let applicationName: String?
    public let createTimestamp: Date?
}

extension DeleteApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case createTimestamp = "CreateTimestamp"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let createTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
    }
}

public struct DeleteApplicationInputProcessingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputProcessingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInputProcessingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationInputProcessingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInputProcessingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationInputProcessingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationInputProcessingConfigurationOutputError>
}

extension DeleteApplicationInputProcessingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationInputProcessingConfigurationInput(applicationName: \(String(describing: applicationName)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), inputId: \(String(describing: inputId)))"}
}

extension DeleteApplicationInputProcessingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case inputId = "InputId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let inputId = inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
    }
}

public struct DeleteApplicationInputProcessingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputProcessingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInputProcessingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationInputProcessingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInputProcessingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationInputProcessingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationInputProcessingConfigurationOutputError>
}

public struct DeleteApplicationInputProcessingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputProcessingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInputProcessingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationInputProcessingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInputProcessingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationInputProcessingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationInputProcessingConfigurationOutputError>
}

public struct DeleteApplicationInputProcessingConfigurationInput: Equatable {
    /// <p>The name of the application.</p>
    public let applicationName: String?
    /// <p>The application version.
    ///       You can use the <a>DescribeApplication</a> operation to get the current application version.
    ///       If the version specified is not the current version, the
    ///       <code>ConcurrentModificationException</code> is returned.
    ///     </p>
    public let currentApplicationVersionId: Int?
    /// <p>The ID of the input configuration from which to delete the input processing
    ///       configuration. You can get a list of the input IDs for an application by using the <a>DescribeApplication</a> operation.</p>
    public let inputId: String?

    public init (
        applicationName: String? = nil,
        currentApplicationVersionId: Int? = nil,
        inputId: String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.inputId = inputId
    }
}

struct DeleteApplicationInputProcessingConfigurationInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let inputId: String?
}

extension DeleteApplicationInputProcessingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case inputId = "InputId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let inputIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputId)
        inputId = inputIdDecoded
    }
}

extension DeleteApplicationInputProcessingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationInputProcessingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationInputProcessingConfigurationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationInputProcessingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationInputProcessingConfigurationOutputResponse(applicationARN: \(String(describing: applicationARN)), applicationVersionId: \(String(describing: applicationVersionId)))"}
}

extension DeleteApplicationInputProcessingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteApplicationInputProcessingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
        }
    }
}

public struct DeleteApplicationInputProcessingConfigurationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationARN: String?
    /// <p>The current application version ID.</p>
    public let applicationVersionId: Int?

    public init (
        applicationARN: String? = nil,
        applicationVersionId: Int? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
    }
}

struct DeleteApplicationInputProcessingConfigurationOutputResponseBody: Equatable {
    public let applicationARN: String?
    public let applicationVersionId: Int?
}

extension DeleteApplicationInputProcessingConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
    }
}

extension DeleteApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

public struct DeleteApplicationOutputInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApplicationOutputInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationOutputInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputOutputError>
}

extension DeleteApplicationOutputInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationOutputInput(applicationName: \(String(describing: applicationName)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), outputId: \(String(describing: outputId)))"}
}

extension DeleteApplicationOutputInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case outputId = "OutputId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let outputId = outputId {
            try encodeContainer.encode(outputId, forKey: .outputId)
        }
    }
}

public struct DeleteApplicationOutputInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationOutputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationOutputInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputOutputError>
}

public struct DeleteApplicationOutputInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationOutputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationOutputInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputOutputError>
}

public struct DeleteApplicationOutputInput: Equatable {
    /// <p>The application name.</p>
    public let applicationName: String?
    /// <p>The application version.
    ///       You can use the <a>DescribeApplication</a> operation to get the current application version.
    ///       If the version specified is not the current version, the
    ///       <code>ConcurrentModificationException</code> is returned.
    ///     </p>
    public let currentApplicationVersionId: Int?
    /// <p>The ID of the configuration to delete. Each output configuration that is added to the
    ///       application (either when the application is created or later) using the <a>AddApplicationOutput</a> operation has a unique ID. You need to provide the ID to
    ///       uniquely identify the output configuration that you want to delete from the application
    ///       configuration. You can use the <a>DescribeApplication</a> operation to get the
    ///       specific <code>OutputId</code>. </p>
    public let outputId: String?

    public init (
        applicationName: String? = nil,
        currentApplicationVersionId: Int? = nil,
        outputId: String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.outputId = outputId
    }
}

struct DeleteApplicationOutputInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let outputId: String?
}

extension DeleteApplicationOutputInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case outputId = "OutputId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let outputIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputId)
        outputId = outputIdDecoded
    }
}

extension DeleteApplicationOutputOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationOutputOutputResponse(applicationARN: \(String(describing: applicationARN)), applicationVersionId: \(String(describing: applicationVersionId)))"}
}

extension DeleteApplicationOutputOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteApplicationOutputOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
        }
    }
}

public struct DeleteApplicationOutputOutputResponse: Equatable {
    /// <p>The application Amazon Resource Name (ARN).</p>
    public let applicationARN: String?
    /// <p>The current application version ID.</p>
    public let applicationVersionId: Int?

    public init (
        applicationARN: String? = nil,
        applicationVersionId: Int? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
    }
}

struct DeleteApplicationOutputOutputResponseBody: Equatable {
    public let applicationARN: String?
    public let applicationVersionId: Int?
}

extension DeleteApplicationOutputOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
    }
}

extension DeleteApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationOutputResponse()"}
}

extension DeleteApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationOutputResponse: Equatable {

    public init() {}
}

struct DeleteApplicationOutputResponseBody: Equatable {
}

extension DeleteApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteApplicationReferenceDataSourceInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApplicationReferenceDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationReferenceDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationReferenceDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationReferenceDataSourceInput>
    public typealias MOutput = OperationOutput<DeleteApplicationReferenceDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationReferenceDataSourceOutputError>
}

extension DeleteApplicationReferenceDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationReferenceDataSourceInput(applicationName: \(String(describing: applicationName)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), referenceId: \(String(describing: referenceId)))"}
}

extension DeleteApplicationReferenceDataSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case referenceId = "ReferenceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
    }
}

public struct DeleteApplicationReferenceDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationReferenceDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationReferenceDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationReferenceDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationReferenceDataSourceInput>
    public typealias MOutput = OperationOutput<DeleteApplicationReferenceDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationReferenceDataSourceOutputError>
}

public struct DeleteApplicationReferenceDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationReferenceDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationReferenceDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationReferenceDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationReferenceDataSourceInput>
    public typealias MOutput = OperationOutput<DeleteApplicationReferenceDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationReferenceDataSourceOutputError>
}

public struct DeleteApplicationReferenceDataSourceInput: Equatable {
    /// <p>The name of an existing application.</p>
    public let applicationName: String?
    /// <p>The current application version.
    ///       You can use the <a>DescribeApplication</a> operation to get the current application version.
    ///       If the version specified
    ///       is not the current version, the <code>ConcurrentModificationException</code> is returned.</p>
    public let currentApplicationVersionId: Int?
    /// <p>The ID of the reference data source. When you add a reference data source to your
    ///       application using the <a>AddApplicationReferenceDataSource</a>, Kinesis Data Analytics assigns an ID.
    ///       You can use the <a>DescribeApplication</a> operation to
    ///       get the reference ID. </p>
    public let referenceId: String?

    public init (
        applicationName: String? = nil,
        currentApplicationVersionId: Int? = nil,
        referenceId: String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.referenceId = referenceId
    }
}

struct DeleteApplicationReferenceDataSourceInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let referenceId: String?
}

extension DeleteApplicationReferenceDataSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case referenceId = "ReferenceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
    }
}

extension DeleteApplicationReferenceDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationReferenceDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationReferenceDataSourceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationReferenceDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationReferenceDataSourceOutputResponse(applicationARN: \(String(describing: applicationARN)), applicationVersionId: \(String(describing: applicationVersionId)))"}
}

extension DeleteApplicationReferenceDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteApplicationReferenceDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
        }
    }
}

public struct DeleteApplicationReferenceDataSourceOutputResponse: Equatable {
    /// <p>The application Amazon Resource Name (ARN).</p>
    public let applicationARN: String?
    /// <p>The updated version ID of the application.</p>
    public let applicationVersionId: Int?

    public init (
        applicationARN: String? = nil,
        applicationVersionId: Int? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
    }
}

struct DeleteApplicationReferenceDataSourceOutputResponseBody: Equatable {
    public let applicationARN: String?
    public let applicationVersionId: Int?
}

extension DeleteApplicationReferenceDataSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
    }
}

public struct DeleteApplicationSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApplicationSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteApplicationSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationSnapshotOutputError>
}

extension DeleteApplicationSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationSnapshotInput(applicationName: \(String(describing: applicationName)), snapshotCreationTimestamp: \(String(describing: snapshotCreationTimestamp)), snapshotName: \(String(describing: snapshotName)))"}
}

extension DeleteApplicationSnapshotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case snapshotCreationTimestamp = "SnapshotCreationTimestamp"
        case snapshotName = "SnapshotName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let snapshotCreationTimestamp = snapshotCreationTimestamp {
            try encodeContainer.encode(snapshotCreationTimestamp.timeIntervalSince1970, forKey: .snapshotCreationTimestamp)
        }
        if let snapshotName = snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
    }
}

public struct DeleteApplicationSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteApplicationSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationSnapshotOutputError>
}

public struct DeleteApplicationSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationSnapshotInput>
    public typealias MOutput = OperationOutput<DeleteApplicationSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationSnapshotOutputError>
}

public struct DeleteApplicationSnapshotInput: Equatable {
    /// <p>The name of an existing application.</p>
    public let applicationName: String?
    /// <p>The creation timestamp of the application snapshot to delete. You can retrieve this value
    ///       using
    ///       or .</p>
    public let snapshotCreationTimestamp: Date?
    /// <p>The identifier for the snapshot delete.</p>
    public let snapshotName: String?

    public init (
        applicationName: String? = nil,
        snapshotCreationTimestamp: Date? = nil,
        snapshotName: String? = nil
    )
    {
        self.applicationName = applicationName
        self.snapshotCreationTimestamp = snapshotCreationTimestamp
        self.snapshotName = snapshotName
    }
}

struct DeleteApplicationSnapshotInputBody: Equatable {
    public let applicationName: String?
    public let snapshotName: String?
    public let snapshotCreationTimestamp: Date?
}

extension DeleteApplicationSnapshotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case snapshotCreationTimestamp = "SnapshotCreationTimestamp"
        case snapshotName = "SnapshotName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let snapshotCreationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .snapshotCreationTimestamp)
        snapshotCreationTimestamp = snapshotCreationTimestampDecoded
    }
}

extension DeleteApplicationSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationSnapshotOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationSnapshotOutputResponse()"}
}

extension DeleteApplicationSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationSnapshotOutputResponse: Equatable {

    public init() {}
}

struct DeleteApplicationSnapshotOutputResponseBody: Equatable {
}

extension DeleteApplicationSnapshotOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteApplicationVpcConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApplicationVpcConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationVpcConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationVpcConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationVpcConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationVpcConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationVpcConfigurationOutputError>
}

extension DeleteApplicationVpcConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationVpcConfigurationInput(applicationName: \(String(describing: applicationName)), conditionalToken: \(String(describing: conditionalToken)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), vpcConfigurationId: \(String(describing: vpcConfigurationId)))"}
}

extension DeleteApplicationVpcConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case vpcConfigurationId = "VpcConfigurationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let conditionalToken = conditionalToken {
            try encodeContainer.encode(conditionalToken, forKey: .conditionalToken)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let vpcConfigurationId = vpcConfigurationId {
            try encodeContainer.encode(vpcConfigurationId, forKey: .vpcConfigurationId)
        }
    }
}

public struct DeleteApplicationVpcConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationVpcConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationVpcConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationVpcConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationVpcConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationVpcConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationVpcConfigurationOutputError>
}

public struct DeleteApplicationVpcConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationVpcConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationVpcConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationVpcConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationVpcConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationVpcConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationVpcConfigurationOutputError>
}

public struct DeleteApplicationVpcConfigurationInput: Equatable {
    /// <p>The name of an existing application.</p>
    public let applicationName: String?
    /// <p>A value you use to implement strong concurrency for application updates. You must provide
    ///       the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You get the
    ///       application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the <code>ConditionalToken</code> parameter instead of
    ///         <code>CurrentApplicationVersionId</code>.</p>
    public let conditionalToken: String?
    /// <p>The current application version ID. You must provide the
    ///         <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You can
    ///       retrieve the application version ID using <a>DescribeApplication</a>. For better
    ///       concurrency support, use the <code>ConditionalToken</code> parameter instead of
    ///         <code>CurrentApplicationVersionId</code>.</p>
    public let currentApplicationVersionId: Int?
    /// <p>The ID of the VPC configuration to delete.</p>
    public let vpcConfigurationId: String?

    public init (
        applicationName: String? = nil,
        conditionalToken: String? = nil,
        currentApplicationVersionId: Int? = nil,
        vpcConfigurationId: String? = nil
    )
    {
        self.applicationName = applicationName
        self.conditionalToken = conditionalToken
        self.currentApplicationVersionId = currentApplicationVersionId
        self.vpcConfigurationId = vpcConfigurationId
    }
}

struct DeleteApplicationVpcConfigurationInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let vpcConfigurationId: String?
    public let conditionalToken: String?
}

extension DeleteApplicationVpcConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case vpcConfigurationId = "VpcConfigurationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let vpcConfigurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcConfigurationId)
        vpcConfigurationId = vpcConfigurationIdDecoded
        let conditionalTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conditionalToken)
        conditionalToken = conditionalTokenDecoded
    }
}

extension DeleteApplicationVpcConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationVpcConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationVpcConfigurationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationVpcConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationVpcConfigurationOutputResponse(applicationARN: \(String(describing: applicationARN)), applicationVersionId: \(String(describing: applicationVersionId)))"}
}

extension DeleteApplicationVpcConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteApplicationVpcConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationARN = output.applicationARN
            self.applicationVersionId = output.applicationVersionId
        } else {
            self.applicationARN = nil
            self.applicationVersionId = nil
        }
    }
}

public struct DeleteApplicationVpcConfigurationOutputResponse: Equatable {
    /// <p>The ARN of the Kinesis Data Analytics application.</p>
    public let applicationARN: String?
    /// <p>The updated version ID of the application.</p>
    public let applicationVersionId: Int?

    public init (
        applicationARN: String? = nil,
        applicationVersionId: Int? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationVersionId = applicationVersionId
    }
}

struct DeleteApplicationVpcConfigurationOutputResponseBody: Equatable {
    public let applicationARN: String?
    public let applicationVersionId: Int?
}

extension DeleteApplicationVpcConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationVersionId = "ApplicationVersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
    }
}

extension DeployAsApplicationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3ContentLocation = "S3ContentLocation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3ContentLocation = s3ContentLocation {
            try encodeContainer.encode(s3ContentLocation, forKey: .s3ContentLocation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ContentLocationDecoded = try containerValues.decodeIfPresent(S3ContentBaseLocation.self, forKey: .s3ContentLocation)
        s3ContentLocation = s3ContentLocationDecoded
    }
}

extension DeployAsApplicationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeployAsApplicationConfiguration(s3ContentLocation: \(String(describing: s3ContentLocation)))"}
}

/// <p>The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state..</p>
public struct DeployAsApplicationConfiguration: Equatable {
    /// <p>The description of an Amazon S3 object that contains the Amazon Data Analytics application, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.
    ///     </p>
    public let s3ContentLocation: S3ContentBaseLocation?

    public init (
        s3ContentLocation: S3ContentBaseLocation? = nil
    )
    {
        self.s3ContentLocation = s3ContentLocation
    }
}

extension DeployAsApplicationConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3ContentLocationDescription = "S3ContentLocationDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3ContentLocationDescription = s3ContentLocationDescription {
            try encodeContainer.encode(s3ContentLocationDescription, forKey: .s3ContentLocationDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ContentLocationDescriptionDecoded = try containerValues.decodeIfPresent(S3ContentBaseLocationDescription.self, forKey: .s3ContentLocationDescription)
        s3ContentLocationDescription = s3ContentLocationDescriptionDecoded
    }
}

extension DeployAsApplicationConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeployAsApplicationConfigurationDescription(s3ContentLocationDescription: \(String(describing: s3ContentLocationDescription)))"}
}

/// <p>The configuration information required to deploy an Amazon Data Analytics Studio notebook as an application with durable state.</p>
public struct DeployAsApplicationConfigurationDescription: Equatable {
    /// <p>The location that holds the data required to specify an Amazon Data Analytics application.</p>
    public let s3ContentLocationDescription: S3ContentBaseLocationDescription?

    public init (
        s3ContentLocationDescription: S3ContentBaseLocationDescription? = nil
    )
    {
        self.s3ContentLocationDescription = s3ContentLocationDescription
    }
}

extension DeployAsApplicationConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3ContentLocationUpdate = "S3ContentLocationUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3ContentLocationUpdate = s3ContentLocationUpdate {
            try encodeContainer.encode(s3ContentLocationUpdate, forKey: .s3ContentLocationUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ContentLocationUpdateDecoded = try containerValues.decodeIfPresent(S3ContentBaseLocationUpdate.self, forKey: .s3ContentLocationUpdate)
        s3ContentLocationUpdate = s3ContentLocationUpdateDecoded
    }
}

extension DeployAsApplicationConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeployAsApplicationConfigurationUpdate(s3ContentLocationUpdate: \(String(describing: s3ContentLocationUpdate)))"}
}

/// <p>Updates to the configuration information required to deploy an Amazon Data Analytics Studio notebook as an application with durable state..</p>
public struct DeployAsApplicationConfigurationUpdate: Equatable {
    /// <p>Updates to the location that holds the data required to specify an Amazon Data Analytics application.</p>
    public let s3ContentLocationUpdate: S3ContentBaseLocationUpdate?

    public init (
        s3ContentLocationUpdate: S3ContentBaseLocationUpdate? = nil
    )
    {
        self.s3ContentLocationUpdate = s3ContentLocationUpdate
    }
}

public struct DescribeApplicationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationInput>
    public typealias MOutput = OperationOutput<DescribeApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationOutputError>
}

extension DescribeApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationInput(applicationName: \(String(describing: applicationName)), includeAdditionalDetails: \(String(describing: includeAdditionalDetails)))"}
}

extension DescribeApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case includeAdditionalDetails = "IncludeAdditionalDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let includeAdditionalDetails = includeAdditionalDetails {
            try encodeContainer.encode(includeAdditionalDetails, forKey: .includeAdditionalDetails)
        }
    }
}

public struct DescribeApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationInput>
    public typealias MOutput = OperationOutput<DescribeApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationOutputError>
}

public struct DescribeApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationInput>
    public typealias MOutput = OperationOutput<DescribeApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationOutputError>
}

public struct DescribeApplicationInput: Equatable {
    /// <p>The name of the application.</p>
    public let applicationName: String?
    /// <p>Displays verbose information about a Kinesis Data Analytics application, including the application's job plan.</p>
    public let includeAdditionalDetails: Bool?

    public init (
        applicationName: String? = nil,
        includeAdditionalDetails: Bool? = nil
    )
    {
        self.applicationName = applicationName
        self.includeAdditionalDetails = includeAdditionalDetails
    }
}

struct DescribeApplicationInputBody: Equatable {
    public let applicationName: String?
    public let includeAdditionalDetails: Bool?
}

extension DescribeApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case includeAdditionalDetails = "IncludeAdditionalDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let includeAdditionalDetailsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeAdditionalDetails)
        includeAdditionalDetails = includeAdditionalDetailsDecoded
    }
}

extension DescribeApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeApplicationOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationOutputResponse(applicationDetail: \(String(describing: applicationDetail)))"}
}

extension DescribeApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationDetail = output.applicationDetail
        } else {
            self.applicationDetail = nil
        }
    }
}

public struct DescribeApplicationOutputResponse: Equatable {
    /// <p>Provides a description of the application, such as the application's Amazon Resource Name
    ///       (ARN), status, and latest version.</p>
    public let applicationDetail: ApplicationDetail?

    public init (
        applicationDetail: ApplicationDetail? = nil
    )
    {
        self.applicationDetail = applicationDetail
    }
}

struct DescribeApplicationOutputResponseBody: Equatable {
    public let applicationDetail: ApplicationDetail?
}

extension DescribeApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationDetail = "ApplicationDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDetailDecoded = try containerValues.decodeIfPresent(ApplicationDetail.self, forKey: .applicationDetail)
        applicationDetail = applicationDetailDecoded
    }
}

public struct DescribeApplicationSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "DescribeApplicationSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationSnapshotInput>
    public typealias MOutput = OperationOutput<DescribeApplicationSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationSnapshotOutputError>
}

extension DescribeApplicationSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationSnapshotInput(applicationName: \(String(describing: applicationName)), snapshotName: \(String(describing: snapshotName)))"}
}

extension DescribeApplicationSnapshotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case snapshotName = "SnapshotName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let snapshotName = snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
    }
}

public struct DescribeApplicationSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeApplicationSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationSnapshotInput>
    public typealias MOutput = OperationOutput<DescribeApplicationSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationSnapshotOutputError>
}

public struct DescribeApplicationSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeApplicationSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationSnapshotInput>
    public typealias MOutput = OperationOutput<DescribeApplicationSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationSnapshotOutputError>
}

public struct DescribeApplicationSnapshotInput: Equatable {
    /// <p>The name of an existing application.</p>
    public let applicationName: String?
    /// <p>The identifier of an application snapshot. You can retrieve this value using
    ///       .</p>
    public let snapshotName: String?

    public init (
        applicationName: String? = nil,
        snapshotName: String? = nil
    )
    {
        self.applicationName = applicationName
        self.snapshotName = snapshotName
    }
}

struct DescribeApplicationSnapshotInputBody: Equatable {
    public let applicationName: String?
    public let snapshotName: String?
}

extension DescribeApplicationSnapshotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case snapshotName = "SnapshotName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
    }
}

extension DescribeApplicationSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeApplicationSnapshotOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationSnapshotOutputResponse(snapshotDetails: \(String(describing: snapshotDetails)))"}
}

extension DescribeApplicationSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeApplicationSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.snapshotDetails = output.snapshotDetails
        } else {
            self.snapshotDetails = nil
        }
    }
}

public struct DescribeApplicationSnapshotOutputResponse: Equatable {
    /// <p>An object containing information about the application snapshot.</p>
    public let snapshotDetails: SnapshotDetails?

    public init (
        snapshotDetails: SnapshotDetails? = nil
    )
    {
        self.snapshotDetails = snapshotDetails
    }
}

struct DescribeApplicationSnapshotOutputResponseBody: Equatable {
    public let snapshotDetails: SnapshotDetails?
}

extension DescribeApplicationSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshotDetails = "SnapshotDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDetailsDecoded = try containerValues.decodeIfPresent(SnapshotDetails.self, forKey: .snapshotDetails)
        snapshotDetails = snapshotDetailsDecoded
    }
}

public struct DescribeApplicationVersionInputBodyMiddleware: Middleware {
    public let id: String = "DescribeApplicationVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationVersionInput>
    public typealias MOutput = OperationOutput<DescribeApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationVersionOutputError>
}

extension DescribeApplicationVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationVersionInput(applicationName: \(String(describing: applicationName)), applicationVersionId: \(String(describing: applicationVersionId)))"}
}

extension DescribeApplicationVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case applicationVersionId = "ApplicationVersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let applicationVersionId = applicationVersionId {
            try encodeContainer.encode(applicationVersionId, forKey: .applicationVersionId)
        }
    }
}

public struct DescribeApplicationVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeApplicationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationVersionInput>
    public typealias MOutput = OperationOutput<DescribeApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationVersionOutputError>
}

public struct DescribeApplicationVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeApplicationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationVersionInput>
    public typealias MOutput = OperationOutput<DescribeApplicationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationVersionOutputError>
}

public struct DescribeApplicationVersionInput: Equatable {
    /// <p>The name of the application for which you want to get the version description.</p>
    public let applicationName: String?
    /// <p>The ID of the application version for which you want to get the description.</p>
    public let applicationVersionId: Int?

    public init (
        applicationName: String? = nil,
        applicationVersionId: Int? = nil
    )
    {
        self.applicationName = applicationName
        self.applicationVersionId = applicationVersionId
    }
}

struct DescribeApplicationVersionInputBody: Equatable {
    public let applicationName: String?
    public let applicationVersionId: Int?
}

extension DescribeApplicationVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case applicationVersionId = "ApplicationVersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
    }
}

extension DescribeApplicationVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeApplicationVersionOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationVersionOutputResponse(applicationVersionDetail: \(String(describing: applicationVersionDetail)))"}
}

extension DescribeApplicationVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeApplicationVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationVersionDetail = output.applicationVersionDetail
        } else {
            self.applicationVersionDetail = nil
        }
    }
}

public struct DescribeApplicationVersionOutputResponse: Equatable {
    /// <p>Describes the application, including the application Amazon Resource Name (ARN), status,
    ///       latest version, and input and output configurations.</p>
    public let applicationVersionDetail: ApplicationDetail?

    public init (
        applicationVersionDetail: ApplicationDetail? = nil
    )
    {
        self.applicationVersionDetail = applicationVersionDetail
    }
}

struct DescribeApplicationVersionOutputResponseBody: Equatable {
    public let applicationVersionDetail: ApplicationDetail?
}

extension DescribeApplicationVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationVersionDetail = "ApplicationVersionDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationVersionDetailDecoded = try containerValues.decodeIfPresent(ApplicationDetail.self, forKey: .applicationVersionDetail)
        applicationVersionDetail = applicationVersionDetailDecoded
    }
}

extension DestinationSchema: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recordFormatType = "RecordFormatType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordFormatType = recordFormatType {
            try encodeContainer.encode(recordFormatType.rawValue, forKey: .recordFormatType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordFormatTypeDecoded = try containerValues.decodeIfPresent(RecordFormatType.self, forKey: .recordFormatType)
        recordFormatType = recordFormatTypeDecoded
    }
}

extension DestinationSchema: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DestinationSchema(recordFormatType: \(String(describing: recordFormatType)))"}
}

/// <p>Describes the data format when records are written to the destination in a SQL-based Kinesis Data Analytics application. </p>
public struct DestinationSchema: Equatable {
    /// <p>Specifies the format of the records on the output stream.</p>
    public let recordFormatType: RecordFormatType?

    public init (
        recordFormatType: RecordFormatType? = nil
    )
    {
        self.recordFormatType = recordFormatType
    }
}

public struct DiscoverInputSchemaInputBodyMiddleware: Middleware {
    public let id: String = "DiscoverInputSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DiscoverInputSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DiscoverInputSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DiscoverInputSchemaInput>
    public typealias MOutput = OperationOutput<DiscoverInputSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DiscoverInputSchemaOutputError>
}

extension DiscoverInputSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DiscoverInputSchemaInput(inputProcessingConfiguration: \(String(describing: inputProcessingConfiguration)), inputStartingPositionConfiguration: \(String(describing: inputStartingPositionConfiguration)), resourceARN: \(String(describing: resourceARN)), s3Configuration: \(String(describing: s3Configuration)), serviceExecutionRole: \(String(describing: serviceExecutionRole)))"}
}

extension DiscoverInputSchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputProcessingConfiguration = "InputProcessingConfiguration"
        case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
        case resourceARN = "ResourceARN"
        case s3Configuration = "S3Configuration"
        case serviceExecutionRole = "ServiceExecutionRole"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputProcessingConfiguration = inputProcessingConfiguration {
            try encodeContainer.encode(inputProcessingConfiguration, forKey: .inputProcessingConfiguration)
        }
        if let inputStartingPositionConfiguration = inputStartingPositionConfiguration {
            try encodeContainer.encode(inputStartingPositionConfiguration, forKey: .inputStartingPositionConfiguration)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let s3Configuration = s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
        if let serviceExecutionRole = serviceExecutionRole {
            try encodeContainer.encode(serviceExecutionRole, forKey: .serviceExecutionRole)
        }
    }
}

public struct DiscoverInputSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "DiscoverInputSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DiscoverInputSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DiscoverInputSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DiscoverInputSchemaInput>
    public typealias MOutput = OperationOutput<DiscoverInputSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DiscoverInputSchemaOutputError>
}

public struct DiscoverInputSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "DiscoverInputSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DiscoverInputSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<DiscoverInputSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DiscoverInputSchemaInput>
    public typealias MOutput = OperationOutput<DiscoverInputSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DiscoverInputSchemaOutputError>
}

public struct DiscoverInputSchemaInput: Equatable {
    /// <p>The <a>InputProcessingConfiguration</a> to use to preprocess the records
    ///       before discovering the schema of the records.</p>
    public let inputProcessingConfiguration: InputProcessingConfiguration?
    /// <p>The point at which you want Kinesis Data Analytics to start reading records from the
    ///       specified streaming source discovery purposes.</p>
    public let inputStartingPositionConfiguration: InputStartingPositionConfiguration?
    /// <p>The Amazon Resource Name (ARN) of the streaming source.</p>
    public let resourceARN: String?
    /// <p>Specify this parameter to discover a schema from data in an Amazon S3
    ///       object.</p>
    public let s3Configuration: S3Configuration?
    /// <p>The ARN of the role that is used to access the streaming source.</p>
    public let serviceExecutionRole: String?

    public init (
        inputProcessingConfiguration: InputProcessingConfiguration? = nil,
        inputStartingPositionConfiguration: InputStartingPositionConfiguration? = nil,
        resourceARN: String? = nil,
        s3Configuration: S3Configuration? = nil,
        serviceExecutionRole: String? = nil
    )
    {
        self.inputProcessingConfiguration = inputProcessingConfiguration
        self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
        self.resourceARN = resourceARN
        self.s3Configuration = s3Configuration
        self.serviceExecutionRole = serviceExecutionRole
    }
}

struct DiscoverInputSchemaInputBody: Equatable {
    public let resourceARN: String?
    public let serviceExecutionRole: String?
    public let inputStartingPositionConfiguration: InputStartingPositionConfiguration?
    public let s3Configuration: S3Configuration?
    public let inputProcessingConfiguration: InputProcessingConfiguration?
}

extension DiscoverInputSchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inputProcessingConfiguration = "InputProcessingConfiguration"
        case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
        case resourceARN = "ResourceARN"
        case s3Configuration = "S3Configuration"
        case serviceExecutionRole = "ServiceExecutionRole"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let serviceExecutionRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceExecutionRole)
        serviceExecutionRole = serviceExecutionRoleDecoded
        let inputStartingPositionConfigurationDecoded = try containerValues.decodeIfPresent(InputStartingPositionConfiguration.self, forKey: .inputStartingPositionConfiguration)
        inputStartingPositionConfiguration = inputStartingPositionConfigurationDecoded
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(S3Configuration.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
        let inputProcessingConfigurationDecoded = try containerValues.decodeIfPresent(InputProcessingConfiguration.self, forKey: .inputProcessingConfiguration)
        inputProcessingConfiguration = inputProcessingConfigurationDecoded
    }
}

extension DiscoverInputSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DiscoverInputSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceProvisionedThroughputExceededException" : self = .resourceProvisionedThroughputExceededException(try ResourceProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnableToDetectSchemaException" : self = .unableToDetectSchemaException(try UnableToDetectSchemaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DiscoverInputSchemaOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceProvisionedThroughputExceededException(ResourceProvisionedThroughputExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unableToDetectSchemaException(UnableToDetectSchemaException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DiscoverInputSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DiscoverInputSchemaOutputResponse(inputSchema: \(String(describing: inputSchema)), parsedInputRecords: \(String(describing: parsedInputRecords)), processedInputRecords: \(String(describing: processedInputRecords)), rawInputRecords: \(String(describing: rawInputRecords)))"}
}

extension DiscoverInputSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DiscoverInputSchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.inputSchema = output.inputSchema
            self.parsedInputRecords = output.parsedInputRecords
            self.processedInputRecords = output.processedInputRecords
            self.rawInputRecords = output.rawInputRecords
        } else {
            self.inputSchema = nil
            self.parsedInputRecords = nil
            self.processedInputRecords = nil
            self.rawInputRecords = nil
        }
    }
}

public struct DiscoverInputSchemaOutputResponse: Equatable {
    /// <p>The schema inferred from the streaming source. It identifies the format of the data in the
    ///       streaming source and how each data element maps to corresponding columns in the in-application
    ///       stream that you can create.</p>
    public let inputSchema: SourceSchema?
    /// <p>An array of elements, where each element corresponds to a row in a stream record
    ///       (a stream record can have more than one row).</p>
    public let parsedInputRecords: [[String]]?
    /// <p>The stream data that was modified by the processor specified in the
    ///         <code>InputProcessingConfiguration</code> parameter.</p>
    public let processedInputRecords: [String]?
    /// <p>The raw stream data that was sampled to infer the schema.</p>
    public let rawInputRecords: [String]?

    public init (
        inputSchema: SourceSchema? = nil,
        parsedInputRecords: [[String]]? = nil,
        processedInputRecords: [String]? = nil,
        rawInputRecords: [String]? = nil
    )
    {
        self.inputSchema = inputSchema
        self.parsedInputRecords = parsedInputRecords
        self.processedInputRecords = processedInputRecords
        self.rawInputRecords = rawInputRecords
    }
}

struct DiscoverInputSchemaOutputResponseBody: Equatable {
    public let inputSchema: SourceSchema?
    public let parsedInputRecords: [[String]]?
    public let processedInputRecords: [String]?
    public let rawInputRecords: [String]?
}

extension DiscoverInputSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inputSchema = "InputSchema"
        case parsedInputRecords = "ParsedInputRecords"
        case processedInputRecords = "ProcessedInputRecords"
        case rawInputRecords = "RawInputRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSchemaDecoded = try containerValues.decodeIfPresent(SourceSchema.self, forKey: .inputSchema)
        inputSchema = inputSchemaDecoded
        let parsedInputRecordsContainer = try containerValues.decodeIfPresent([[String?]?].self, forKey: .parsedInputRecords)
        var parsedInputRecordsDecoded0:[[String]]? = nil
        if let parsedInputRecordsContainer = parsedInputRecordsContainer {
            parsedInputRecordsDecoded0 = [[String]]()
            for list0 in parsedInputRecordsContainer {
                var list0Decoded0: [String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    parsedInputRecordsDecoded0?.append(list0Decoded0)
                }
            }
        }
        parsedInputRecords = parsedInputRecordsDecoded0
        let processedInputRecordsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .processedInputRecords)
        var processedInputRecordsDecoded0:[String]? = nil
        if let processedInputRecordsContainer = processedInputRecordsContainer {
            processedInputRecordsDecoded0 = [String]()
            for string0 in processedInputRecordsContainer {
                if let string0 = string0 {
                    processedInputRecordsDecoded0?.append(string0)
                }
            }
        }
        processedInputRecords = processedInputRecordsDecoded0
        let rawInputRecordsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rawInputRecords)
        var rawInputRecordsDecoded0:[String]? = nil
        if let rawInputRecordsContainer = rawInputRecordsContainer {
            rawInputRecordsDecoded0 = [String]()
            for string0 in rawInputRecordsContainer {
                if let string0 = string0 {
                    rawInputRecordsDecoded0?.append(string0)
                }
            }
        }
        rawInputRecords = rawInputRecordsDecoded0
    }
}

extension EnvironmentProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case propertyGroups = "PropertyGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let propertyGroups = propertyGroups {
            var propertyGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyGroups)
            for propertygroups0 in propertyGroups {
                try propertyGroupsContainer.encode(propertygroups0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyGroupsContainer = try containerValues.decodeIfPresent([PropertyGroup?].self, forKey: .propertyGroups)
        var propertyGroupsDecoded0:[PropertyGroup]? = nil
        if let propertyGroupsContainer = propertyGroupsContainer {
            propertyGroupsDecoded0 = [PropertyGroup]()
            for structure0 in propertyGroupsContainer {
                if let structure0 = structure0 {
                    propertyGroupsDecoded0?.append(structure0)
                }
            }
        }
        propertyGroups = propertyGroupsDecoded0
    }
}

extension EnvironmentProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentProperties(propertyGroups: \(String(describing: propertyGroups)))"}
}

/// <p>Describes execution properties for a Flink-based Kinesis Data Analytics application.</p>
public struct EnvironmentProperties: Equatable {
    /// <p>Describes the execution property groups.</p>
    public let propertyGroups: [PropertyGroup]?

    public init (
        propertyGroups: [PropertyGroup]? = nil
    )
    {
        self.propertyGroups = propertyGroups
    }
}

extension EnvironmentPropertyDescriptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case propertyGroupDescriptions = "PropertyGroupDescriptions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let propertyGroupDescriptions = propertyGroupDescriptions {
            var propertyGroupDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyGroupDescriptions)
            for propertygroups0 in propertyGroupDescriptions {
                try propertyGroupDescriptionsContainer.encode(propertygroups0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyGroupDescriptionsContainer = try containerValues.decodeIfPresent([PropertyGroup?].self, forKey: .propertyGroupDescriptions)
        var propertyGroupDescriptionsDecoded0:[PropertyGroup]? = nil
        if let propertyGroupDescriptionsContainer = propertyGroupDescriptionsContainer {
            propertyGroupDescriptionsDecoded0 = [PropertyGroup]()
            for structure0 in propertyGroupDescriptionsContainer {
                if let structure0 = structure0 {
                    propertyGroupDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        propertyGroupDescriptions = propertyGroupDescriptionsDecoded0
    }
}

extension EnvironmentPropertyDescriptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentPropertyDescriptions(propertyGroupDescriptions: \(String(describing: propertyGroupDescriptions)))"}
}

/// <p>Describes the execution properties for an Apache Flink runtime.</p>
public struct EnvironmentPropertyDescriptions: Equatable {
    /// <p>Describes the execution property groups.</p>
    public let propertyGroupDescriptions: [PropertyGroup]?

    public init (
        propertyGroupDescriptions: [PropertyGroup]? = nil
    )
    {
        self.propertyGroupDescriptions = propertyGroupDescriptions
    }
}

extension EnvironmentPropertyUpdates: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case propertyGroups = "PropertyGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let propertyGroups = propertyGroups {
            var propertyGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyGroups)
            for propertygroups0 in propertyGroups {
                try propertyGroupsContainer.encode(propertygroups0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyGroupsContainer = try containerValues.decodeIfPresent([PropertyGroup?].self, forKey: .propertyGroups)
        var propertyGroupsDecoded0:[PropertyGroup]? = nil
        if let propertyGroupsContainer = propertyGroupsContainer {
            propertyGroupsDecoded0 = [PropertyGroup]()
            for structure0 in propertyGroupsContainer {
                if let structure0 = structure0 {
                    propertyGroupsDecoded0?.append(structure0)
                }
            }
        }
        propertyGroups = propertyGroupsDecoded0
    }
}

extension EnvironmentPropertyUpdates: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentPropertyUpdates(propertyGroups: \(String(describing: propertyGroups)))"}
}

/// <p>Describes updates to the execution property groups for a Flink-based Kinesis Data Analytics application or a Studio notebook.</p>
public struct EnvironmentPropertyUpdates: Equatable {
    /// <p>Describes updates to the execution property groups.</p>
    public let propertyGroups: [PropertyGroup]?

    public init (
        propertyGroups: [PropertyGroup]? = nil
    )
    {
        self.propertyGroups = propertyGroups
    }
}

extension FlinkApplicationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkpointConfiguration = "CheckpointConfiguration"
        case monitoringConfiguration = "MonitoringConfiguration"
        case parallelismConfiguration = "ParallelismConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkpointConfiguration = checkpointConfiguration {
            try encodeContainer.encode(checkpointConfiguration, forKey: .checkpointConfiguration)
        }
        if let monitoringConfiguration = monitoringConfiguration {
            try encodeContainer.encode(monitoringConfiguration, forKey: .monitoringConfiguration)
        }
        if let parallelismConfiguration = parallelismConfiguration {
            try encodeContainer.encode(parallelismConfiguration, forKey: .parallelismConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkpointConfigurationDecoded = try containerValues.decodeIfPresent(CheckpointConfiguration.self, forKey: .checkpointConfiguration)
        checkpointConfiguration = checkpointConfigurationDecoded
        let monitoringConfigurationDecoded = try containerValues.decodeIfPresent(MonitoringConfiguration.self, forKey: .monitoringConfiguration)
        monitoringConfiguration = monitoringConfigurationDecoded
        let parallelismConfigurationDecoded = try containerValues.decodeIfPresent(ParallelismConfiguration.self, forKey: .parallelismConfiguration)
        parallelismConfiguration = parallelismConfigurationDecoded
    }
}

extension FlinkApplicationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlinkApplicationConfiguration(checkpointConfiguration: \(String(describing: checkpointConfiguration)), monitoringConfiguration: \(String(describing: monitoringConfiguration)), parallelismConfiguration: \(String(describing: parallelismConfiguration)))"}
}

/// <p>Describes configuration parameters for a Flink-based Kinesis Data Analytics application or a Studio notebook.</p>
public struct FlinkApplicationConfiguration: Equatable {
    /// <p>Describes an application's checkpointing configuration. Checkpointing is the
    ///       process of persisting application state for fault tolerance.
    ///       For more information, see
    ///       <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/programming-model.html#checkpoints-for-fault-tolerance">
    ///         Checkpoints for Fault Tolerance</a> in the
    ///       <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink Documentation</a>. </p>
    public let checkpointConfiguration: CheckpointConfiguration?
    /// <p>Describes configuration parameters for Amazon CloudWatch logging for an
    ///       application.</p>
    public let monitoringConfiguration: MonitoringConfiguration?
    /// <p>Describes parameters for how an application executes multiple tasks simultaneously.</p>
    public let parallelismConfiguration: ParallelismConfiguration?

    public init (
        checkpointConfiguration: CheckpointConfiguration? = nil,
        monitoringConfiguration: MonitoringConfiguration? = nil,
        parallelismConfiguration: ParallelismConfiguration? = nil
    )
    {
        self.checkpointConfiguration = checkpointConfiguration
        self.monitoringConfiguration = monitoringConfiguration
        self.parallelismConfiguration = parallelismConfiguration
    }
}

extension FlinkApplicationConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkpointConfigurationDescription = "CheckpointConfigurationDescription"
        case jobPlanDescription = "JobPlanDescription"
        case monitoringConfigurationDescription = "MonitoringConfigurationDescription"
        case parallelismConfigurationDescription = "ParallelismConfigurationDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkpointConfigurationDescription = checkpointConfigurationDescription {
            try encodeContainer.encode(checkpointConfigurationDescription, forKey: .checkpointConfigurationDescription)
        }
        if let jobPlanDescription = jobPlanDescription {
            try encodeContainer.encode(jobPlanDescription, forKey: .jobPlanDescription)
        }
        if let monitoringConfigurationDescription = monitoringConfigurationDescription {
            try encodeContainer.encode(monitoringConfigurationDescription, forKey: .monitoringConfigurationDescription)
        }
        if let parallelismConfigurationDescription = parallelismConfigurationDescription {
            try encodeContainer.encode(parallelismConfigurationDescription, forKey: .parallelismConfigurationDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkpointConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(CheckpointConfigurationDescription.self, forKey: .checkpointConfigurationDescription)
        checkpointConfigurationDescription = checkpointConfigurationDescriptionDecoded
        let monitoringConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(MonitoringConfigurationDescription.self, forKey: .monitoringConfigurationDescription)
        monitoringConfigurationDescription = monitoringConfigurationDescriptionDecoded
        let parallelismConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(ParallelismConfigurationDescription.self, forKey: .parallelismConfigurationDescription)
        parallelismConfigurationDescription = parallelismConfigurationDescriptionDecoded
        let jobPlanDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobPlanDescription)
        jobPlanDescription = jobPlanDescriptionDecoded
    }
}

extension FlinkApplicationConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlinkApplicationConfigurationDescription(checkpointConfigurationDescription: \(String(describing: checkpointConfigurationDescription)), jobPlanDescription: \(String(describing: jobPlanDescription)), monitoringConfigurationDescription: \(String(describing: monitoringConfigurationDescription)), parallelismConfigurationDescription: \(String(describing: parallelismConfigurationDescription)))"}
}

/// <p>Describes configuration parameters for a Flink-based Kinesis Data Analytics application.</p>
public struct FlinkApplicationConfigurationDescription: Equatable {
    /// <p>Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state
    ///       for fault tolerance.</p>
    public let checkpointConfigurationDescription: CheckpointConfigurationDescription?
    /// <p>The job plan for an application. For more information about the job plan, see <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/internals/job_scheduling.html">Jobs and Scheduling</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
    ///         Documentation</a>. To retrieve the job plan for the application, use the <a>DescribeApplicationRequest$IncludeAdditionalDetails</a> parameter of the <a>DescribeApplication</a> operation.</p>
    public let jobPlanDescription: String?
    /// <p>Describes configuration parameters for Amazon CloudWatch logging for an
    ///       application.</p>
    public let monitoringConfigurationDescription: MonitoringConfigurationDescription?
    /// <p>Describes parameters for how an application executes multiple tasks simultaneously.</p>
    public let parallelismConfigurationDescription: ParallelismConfigurationDescription?

    public init (
        checkpointConfigurationDescription: CheckpointConfigurationDescription? = nil,
        jobPlanDescription: String? = nil,
        monitoringConfigurationDescription: MonitoringConfigurationDescription? = nil,
        parallelismConfigurationDescription: ParallelismConfigurationDescription? = nil
    )
    {
        self.checkpointConfigurationDescription = checkpointConfigurationDescription
        self.jobPlanDescription = jobPlanDescription
        self.monitoringConfigurationDescription = monitoringConfigurationDescription
        self.parallelismConfigurationDescription = parallelismConfigurationDescription
    }
}

extension FlinkApplicationConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkpointConfigurationUpdate = "CheckpointConfigurationUpdate"
        case monitoringConfigurationUpdate = "MonitoringConfigurationUpdate"
        case parallelismConfigurationUpdate = "ParallelismConfigurationUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkpointConfigurationUpdate = checkpointConfigurationUpdate {
            try encodeContainer.encode(checkpointConfigurationUpdate, forKey: .checkpointConfigurationUpdate)
        }
        if let monitoringConfigurationUpdate = monitoringConfigurationUpdate {
            try encodeContainer.encode(monitoringConfigurationUpdate, forKey: .monitoringConfigurationUpdate)
        }
        if let parallelismConfigurationUpdate = parallelismConfigurationUpdate {
            try encodeContainer.encode(parallelismConfigurationUpdate, forKey: .parallelismConfigurationUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkpointConfigurationUpdateDecoded = try containerValues.decodeIfPresent(CheckpointConfigurationUpdate.self, forKey: .checkpointConfigurationUpdate)
        checkpointConfigurationUpdate = checkpointConfigurationUpdateDecoded
        let monitoringConfigurationUpdateDecoded = try containerValues.decodeIfPresent(MonitoringConfigurationUpdate.self, forKey: .monitoringConfigurationUpdate)
        monitoringConfigurationUpdate = monitoringConfigurationUpdateDecoded
        let parallelismConfigurationUpdateDecoded = try containerValues.decodeIfPresent(ParallelismConfigurationUpdate.self, forKey: .parallelismConfigurationUpdate)
        parallelismConfigurationUpdate = parallelismConfigurationUpdateDecoded
    }
}

extension FlinkApplicationConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlinkApplicationConfigurationUpdate(checkpointConfigurationUpdate: \(String(describing: checkpointConfigurationUpdate)), monitoringConfigurationUpdate: \(String(describing: monitoringConfigurationUpdate)), parallelismConfigurationUpdate: \(String(describing: parallelismConfigurationUpdate)))"}
}

/// <p>Describes updates to the configuration parameters for a Flink-based Kinesis Data Analytics application.</p>
public struct FlinkApplicationConfigurationUpdate: Equatable {
    /// <p>Describes updates to an application's checkpointing configuration. Checkpointing is the process of persisting
    ///       application state for fault tolerance.</p>
    public let checkpointConfigurationUpdate: CheckpointConfigurationUpdate?
    /// <p>Describes updates to the configuration parameters for Amazon CloudWatch logging for an
    ///       application.</p>
    public let monitoringConfigurationUpdate: MonitoringConfigurationUpdate?
    /// <p>Describes updates to the parameters for how an application executes multiple tasks simultaneously.</p>
    public let parallelismConfigurationUpdate: ParallelismConfigurationUpdate?

    public init (
        checkpointConfigurationUpdate: CheckpointConfigurationUpdate? = nil,
        monitoringConfigurationUpdate: MonitoringConfigurationUpdate? = nil,
        parallelismConfigurationUpdate: ParallelismConfigurationUpdate? = nil
    )
    {
        self.checkpointConfigurationUpdate = checkpointConfigurationUpdate
        self.monitoringConfigurationUpdate = monitoringConfigurationUpdate
        self.parallelismConfigurationUpdate = parallelismConfigurationUpdate
    }
}

extension FlinkRunConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowNonRestoredState = "AllowNonRestoredState"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowNonRestoredState = allowNonRestoredState {
            try encodeContainer.encode(allowNonRestoredState, forKey: .allowNonRestoredState)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowNonRestoredStateDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowNonRestoredState)
        allowNonRestoredState = allowNonRestoredStateDecoded
    }
}

extension FlinkRunConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlinkRunConfiguration(allowNonRestoredState: \(String(describing: allowNonRestoredState)))"}
}

/// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
public struct FlinkRunConfiguration: Equatable {
    /// <p>When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot
    ///        be mapped to the new program.
    ///      This will happen if the program is updated between snapshots to remove stateful parameters, and
    ///      state data in the snapshot no longer
    ///      corresponds to valid application data. For more information, see
    ///      <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/savepoints.html#allowing-non-restored-state">
    ///        Allowing Non-Restored State</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
    ///          documentation</a>.</p>
    ///          <note>
    ///             <p>This value defaults to <code>false</code>. If you update your application without
    ///      specifying this parameter, <code>AllowNonRestoredState</code> will be set to <code>false</code>,
    ///      even if it was previously set to <code>true</code>.</p>
    ///          </note>
    public let allowNonRestoredState: Bool?

    public init (
        allowNonRestoredState: Bool? = nil
    )
    {
        self.allowNonRestoredState = allowNonRestoredState
    }
}

extension GlueDataCatalogConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseARN = "DatabaseARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseARN = databaseARN {
            try encodeContainer.encode(databaseARN, forKey: .databaseARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseARN)
        databaseARN = databaseARNDecoded
    }
}

extension GlueDataCatalogConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlueDataCatalogConfiguration(databaseARN: \(String(describing: databaseARN)))"}
}

/// <p>The configuration of the Glue Data Catalog that you use for Apache Flink SQL queries and table API transforms that you write in an application.</p>
public struct GlueDataCatalogConfiguration: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the database.</p>
    public let databaseARN: String?

    public init (
        databaseARN: String? = nil
    )
    {
        self.databaseARN = databaseARN
    }
}

extension GlueDataCatalogConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseARN = "DatabaseARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseARN = databaseARN {
            try encodeContainer.encode(databaseARN, forKey: .databaseARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseARN)
        databaseARN = databaseARNDecoded
    }
}

extension GlueDataCatalogConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlueDataCatalogConfigurationDescription(databaseARN: \(String(describing: databaseARN)))"}
}

/// <p>The configuration of the Glue Data Catalog that you use for Apache Flink SQL queries and table API transforms that you write in an application.</p>
public struct GlueDataCatalogConfigurationDescription: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the database.</p>
    public let databaseARN: String?

    public init (
        databaseARN: String? = nil
    )
    {
        self.databaseARN = databaseARN
    }
}

extension GlueDataCatalogConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseARNUpdate = "DatabaseARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseARNUpdate = databaseARNUpdate {
            try encodeContainer.encode(databaseARNUpdate, forKey: .databaseARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseARNUpdate)
        databaseARNUpdate = databaseARNUpdateDecoded
    }
}

extension GlueDataCatalogConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlueDataCatalogConfigurationUpdate(databaseARNUpdate: \(String(describing: databaseARNUpdate)))"}
}

/// <p>Updates to the configuration of the Glue Data Catalog that you use for SQL queries that you write in a Kinesis Data Analytics Studio notebook.</p>
public struct GlueDataCatalogConfigurationUpdate: Equatable {
    /// <p>The updated Amazon Resource Name (ARN) of the database.</p>
    public let databaseARNUpdate: String?

    public init (
        databaseARNUpdate: String? = nil
    )
    {
        self.databaseARNUpdate = databaseARNUpdate
    }
}

extension Input: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputParallelism = "InputParallelism"
        case inputProcessingConfiguration = "InputProcessingConfiguration"
        case inputSchema = "InputSchema"
        case kinesisFirehoseInput = "KinesisFirehoseInput"
        case kinesisStreamsInput = "KinesisStreamsInput"
        case namePrefix = "NamePrefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputParallelism = inputParallelism {
            try encodeContainer.encode(inputParallelism, forKey: .inputParallelism)
        }
        if let inputProcessingConfiguration = inputProcessingConfiguration {
            try encodeContainer.encode(inputProcessingConfiguration, forKey: .inputProcessingConfiguration)
        }
        if let inputSchema = inputSchema {
            try encodeContainer.encode(inputSchema, forKey: .inputSchema)
        }
        if let kinesisFirehoseInput = kinesisFirehoseInput {
            try encodeContainer.encode(kinesisFirehoseInput, forKey: .kinesisFirehoseInput)
        }
        if let kinesisStreamsInput = kinesisStreamsInput {
            try encodeContainer.encode(kinesisStreamsInput, forKey: .kinesisStreamsInput)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let inputProcessingConfigurationDecoded = try containerValues.decodeIfPresent(InputProcessingConfiguration.self, forKey: .inputProcessingConfiguration)
        inputProcessingConfiguration = inputProcessingConfigurationDecoded
        let kinesisStreamsInputDecoded = try containerValues.decodeIfPresent(KinesisStreamsInput.self, forKey: .kinesisStreamsInput)
        kinesisStreamsInput = kinesisStreamsInputDecoded
        let kinesisFirehoseInputDecoded = try containerValues.decodeIfPresent(KinesisFirehoseInput.self, forKey: .kinesisFirehoseInput)
        kinesisFirehoseInput = kinesisFirehoseInputDecoded
        let inputParallelismDecoded = try containerValues.decodeIfPresent(InputParallelism.self, forKey: .inputParallelism)
        inputParallelism = inputParallelismDecoded
        let inputSchemaDecoded = try containerValues.decodeIfPresent(SourceSchema.self, forKey: .inputSchema)
        inputSchema = inputSchemaDecoded
    }
}

extension Input: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Input(inputParallelism: \(String(describing: inputParallelism)), inputProcessingConfiguration: \(String(describing: inputProcessingConfiguration)), inputSchema: \(String(describing: inputSchema)), kinesisFirehoseInput: \(String(describing: kinesisFirehoseInput)), kinesisStreamsInput: \(String(describing: kinesisStreamsInput)), namePrefix: \(String(describing: namePrefix)))"}
}

/// <p>When you configure the application input for a SQL-based Kinesis Data Analytics application, you specify the streaming source, the in-application stream
///       name that is created,
///       and the mapping between the two. </p>
public struct Input: Equatable {
    /// <p>Describes the number of in-application streams to create. </p>
    public let inputParallelism: InputParallelism?
    /// <p>The <a>InputProcessingConfiguration</a> for the input. An input processor transforms records as they are received
    ///       from the stream, before the application's SQL code executes. Currently, the only input processing configuration available is
    ///       <a>InputLambdaProcessor</a>. </p>
    public let inputProcessingConfiguration: InputProcessingConfiguration?
    /// <p>Describes the format of the data in the streaming source, and how each data element maps
    ///       to corresponding columns in the in-application stream that is being created.</p>
    ///          <p>Also used to describe the format of the reference data source.</p>
    public let inputSchema: SourceSchema?
    /// <p>If the streaming source is an Amazon Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.</p>
    public let kinesisFirehoseInput: KinesisFirehoseInput?
    /// <p>If the streaming source is an Amazon Kinesis data stream, identifies the stream's Amazon Resource Name (ARN). </p>
    public let kinesisStreamsInput: KinesisStreamsInput?
    /// <p>The name prefix to use when creating an in-application stream. Suppose that you specify a
    ///       prefix "<code>MyInApplicationStream</code>." Kinesis Data Analytics then creates one or more
    ///       (as per the <code>InputParallelism</code> count you specified) in-application streams with the
    ///       names "<code>MyInApplicationStream_001</code>," "<code>MyInApplicationStream_002</code>," and
    ///       so on. </p>
    public let namePrefix: String?

    public init (
        inputParallelism: InputParallelism? = nil,
        inputProcessingConfiguration: InputProcessingConfiguration? = nil,
        inputSchema: SourceSchema? = nil,
        kinesisFirehoseInput: KinesisFirehoseInput? = nil,
        kinesisStreamsInput: KinesisStreamsInput? = nil,
        namePrefix: String? = nil
    )
    {
        self.inputParallelism = inputParallelism
        self.inputProcessingConfiguration = inputProcessingConfiguration
        self.inputSchema = inputSchema
        self.kinesisFirehoseInput = kinesisFirehoseInput
        self.kinesisStreamsInput = kinesisStreamsInput
        self.namePrefix = namePrefix
    }
}

extension InputDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inAppStreamNames = "InAppStreamNames"
        case inputId = "InputId"
        case inputParallelism = "InputParallelism"
        case inputProcessingConfigurationDescription = "InputProcessingConfigurationDescription"
        case inputSchema = "InputSchema"
        case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
        case kinesisFirehoseInputDescription = "KinesisFirehoseInputDescription"
        case kinesisStreamsInputDescription = "KinesisStreamsInputDescription"
        case namePrefix = "NamePrefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inAppStreamNames = inAppStreamNames {
            var inAppStreamNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inAppStreamNames)
            for inappstreamnames0 in inAppStreamNames {
                try inAppStreamNamesContainer.encode(inappstreamnames0)
            }
        }
        if let inputId = inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
        if let inputParallelism = inputParallelism {
            try encodeContainer.encode(inputParallelism, forKey: .inputParallelism)
        }
        if let inputProcessingConfigurationDescription = inputProcessingConfigurationDescription {
            try encodeContainer.encode(inputProcessingConfigurationDescription, forKey: .inputProcessingConfigurationDescription)
        }
        if let inputSchema = inputSchema {
            try encodeContainer.encode(inputSchema, forKey: .inputSchema)
        }
        if let inputStartingPositionConfiguration = inputStartingPositionConfiguration {
            try encodeContainer.encode(inputStartingPositionConfiguration, forKey: .inputStartingPositionConfiguration)
        }
        if let kinesisFirehoseInputDescription = kinesisFirehoseInputDescription {
            try encodeContainer.encode(kinesisFirehoseInputDescription, forKey: .kinesisFirehoseInputDescription)
        }
        if let kinesisStreamsInputDescription = kinesisStreamsInputDescription {
            try encodeContainer.encode(kinesisStreamsInputDescription, forKey: .kinesisStreamsInputDescription)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputId)
        inputId = inputIdDecoded
        let namePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let inAppStreamNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .inAppStreamNames)
        var inAppStreamNamesDecoded0:[String]? = nil
        if let inAppStreamNamesContainer = inAppStreamNamesContainer {
            inAppStreamNamesDecoded0 = [String]()
            for string0 in inAppStreamNamesContainer {
                if let string0 = string0 {
                    inAppStreamNamesDecoded0?.append(string0)
                }
            }
        }
        inAppStreamNames = inAppStreamNamesDecoded0
        let inputProcessingConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(InputProcessingConfigurationDescription.self, forKey: .inputProcessingConfigurationDescription)
        inputProcessingConfigurationDescription = inputProcessingConfigurationDescriptionDecoded
        let kinesisStreamsInputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisStreamsInputDescription.self, forKey: .kinesisStreamsInputDescription)
        kinesisStreamsInputDescription = kinesisStreamsInputDescriptionDecoded
        let kinesisFirehoseInputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisFirehoseInputDescription.self, forKey: .kinesisFirehoseInputDescription)
        kinesisFirehoseInputDescription = kinesisFirehoseInputDescriptionDecoded
        let inputSchemaDecoded = try containerValues.decodeIfPresent(SourceSchema.self, forKey: .inputSchema)
        inputSchema = inputSchemaDecoded
        let inputParallelismDecoded = try containerValues.decodeIfPresent(InputParallelism.self, forKey: .inputParallelism)
        inputParallelism = inputParallelismDecoded
        let inputStartingPositionConfigurationDecoded = try containerValues.decodeIfPresent(InputStartingPositionConfiguration.self, forKey: .inputStartingPositionConfiguration)
        inputStartingPositionConfiguration = inputStartingPositionConfigurationDecoded
    }
}

extension InputDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputDescription(inAppStreamNames: \(String(describing: inAppStreamNames)), inputId: \(String(describing: inputId)), inputParallelism: \(String(describing: inputParallelism)), inputProcessingConfigurationDescription: \(String(describing: inputProcessingConfigurationDescription)), inputSchema: \(String(describing: inputSchema)), inputStartingPositionConfiguration: \(String(describing: inputStartingPositionConfiguration)), kinesisFirehoseInputDescription: \(String(describing: kinesisFirehoseInputDescription)), kinesisStreamsInputDescription: \(String(describing: kinesisStreamsInputDescription)), namePrefix: \(String(describing: namePrefix)))"}
}

/// <p>Describes the application input configuration for a SQL-based Kinesis Data Analytics application. </p>
public struct InputDescription: Equatable {
    /// <p>Returns the in-application stream names that are mapped to the stream source. </p>
    public let inAppStreamNames: [String]?
    /// <p>The input ID that is associated with the application input. This is the ID that Kinesis Data Analytics assigns to each input
    ///       configuration that you add to your application. </p>
    public let inputId: String?
    /// <p>Describes the configured parallelism (number of in-application streams mapped to the streaming source). </p>
    public let inputParallelism: InputParallelism?
    /// <p>The description of the preprocessor that executes on records in this input before the application's code is run. </p>
    public let inputProcessingConfigurationDescription: InputProcessingConfigurationDescription?
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns
    ///       in the in-application stream that is being created. </p>
    public let inputSchema: SourceSchema?
    /// <p>The point at which the application is configured to read from the input stream.</p>
    public let inputStartingPositionConfiguration: InputStartingPositionConfiguration?
    /// <p>If a Kinesis Data Firehose delivery stream is configured as a streaming source, provides the delivery stream's ARN. </p>
    public let kinesisFirehoseInputDescription: KinesisFirehoseInputDescription?
    /// <p>If a Kinesis data stream is configured as a streaming source, provides the Kinesis data
    ///       stream's Amazon Resource Name (ARN). </p>
    public let kinesisStreamsInputDescription: KinesisStreamsInputDescription?
    /// <p>The in-application name prefix.</p>
    public let namePrefix: String?

    public init (
        inAppStreamNames: [String]? = nil,
        inputId: String? = nil,
        inputParallelism: InputParallelism? = nil,
        inputProcessingConfigurationDescription: InputProcessingConfigurationDescription? = nil,
        inputSchema: SourceSchema? = nil,
        inputStartingPositionConfiguration: InputStartingPositionConfiguration? = nil,
        kinesisFirehoseInputDescription: KinesisFirehoseInputDescription? = nil,
        kinesisStreamsInputDescription: KinesisStreamsInputDescription? = nil,
        namePrefix: String? = nil
    )
    {
        self.inAppStreamNames = inAppStreamNames
        self.inputId = inputId
        self.inputParallelism = inputParallelism
        self.inputProcessingConfigurationDescription = inputProcessingConfigurationDescription
        self.inputSchema = inputSchema
        self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
        self.kinesisFirehoseInputDescription = kinesisFirehoseInputDescription
        self.kinesisStreamsInputDescription = kinesisStreamsInputDescription
        self.namePrefix = namePrefix
    }
}

extension InputLambdaProcessor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension InputLambdaProcessor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputLambdaProcessor(resourceARN: \(String(describing: resourceARN)))"}
}

/// <p>An object that contains the Amazon Resource Name (ARN) of the AWS Lambda function that is
///       used to preprocess records in the stream in a SQL-based Kinesis Data Analytics application. </p>
public struct InputLambdaProcessor: Equatable {
    /// <p>The ARN of the AWS Lambda function that operates on records in the stream.</p>
    ///          <note>
    ///             <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: AWS Lambda</a>
    ///             </p>
    ///          </note>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

extension InputLambdaProcessorDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension InputLambdaProcessorDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputLambdaProcessorDescription(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, an object that contains the
///       Amazon Resource Name (ARN) of the AWS Lambda function that is used to preprocess records in
///       the stream.</p>
public struct InputLambdaProcessorDescription: Equatable {
    /// <p>The ARN of the AWS Lambda function that is used to preprocess the records in the
    ///       stream.</p>
    ///          <note>
    ///             <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: AWS Lambda</a>
    ///             </p>
    ///          </note>
    public let resourceARN: String?
    /// <p>The ARN of the IAM role that is used to access the AWS Lambda function.</p>
    ///          <note>
    ///             <p>Provided for backward compatibility. Applications that are created with the current API
    ///         version have an application-level service execution role rather than a resource-level
    ///         role.</p>
    ///          </note>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension InputLambdaProcessorUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
    }
}

extension InputLambdaProcessorUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputLambdaProcessorUpdate(resourceARNUpdate: \(String(describing: resourceARNUpdate)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, represents an update to the
///         <a>InputLambdaProcessor</a> that is used to preprocess the records in the
///       stream.</p>
public struct InputLambdaProcessorUpdate: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the new AWS Lambda function that is used to preprocess
    ///       the records in the stream.</p>
    ///          <note>
    ///             <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: AWS Lambda</a>
    ///             </p>
    ///          </note>
    public let resourceARNUpdate: String?

    public init (
        resourceARNUpdate: String? = nil
    )
    {
        self.resourceARNUpdate = resourceARNUpdate
    }
}

extension InputParallelism: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case count = "Count"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .count)
        count = countDecoded
    }
}

extension InputParallelism: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputParallelism(count: \(String(describing: count)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes the number of
///       in-application streams to create for a given streaming source. </p>
public struct InputParallelism: Equatable {
    /// <p>The number of in-application streams to create.</p>
    public let count: Int?

    public init (
        count: Int? = nil
    )
    {
        self.count = count
    }
}

extension InputParallelismUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case countUpdate = "CountUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countUpdate = countUpdate {
            try encodeContainer.encode(countUpdate, forKey: .countUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countUpdateDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .countUpdate)
        countUpdate = countUpdateDecoded
    }
}

extension InputParallelismUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputParallelismUpdate(countUpdate: \(String(describing: countUpdate)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, provides updates to the
///       parallelism count.</p>
public struct InputParallelismUpdate: Equatable {
    /// <p>The number of in-application streams to create for the specified streaming source.</p>
    public let countUpdate: Int?

    public init (
        countUpdate: Int? = nil
    )
    {
        self.countUpdate = countUpdate
    }
}

extension InputProcessingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputLambdaProcessor = "InputLambdaProcessor"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputLambdaProcessor = inputLambdaProcessor {
            try encodeContainer.encode(inputLambdaProcessor, forKey: .inputLambdaProcessor)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputLambdaProcessorDecoded = try containerValues.decodeIfPresent(InputLambdaProcessor.self, forKey: .inputLambdaProcessor)
        inputLambdaProcessor = inputLambdaProcessorDecoded
    }
}

extension InputProcessingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputProcessingConfiguration(inputLambdaProcessor: \(String(describing: inputLambdaProcessor)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes a processor that is
///       used to preprocess the records in the stream before being processed by your application code.
///       Currently, the only input processor available is <a href="https://docs.aws.amazon.com/lambda/">AWS Lambda</a>.</p>
public struct InputProcessingConfiguration: Equatable {
    /// <p>The <a>InputLambdaProcessor</a> that is used to preprocess the records
    ///       in the stream before being processed by your application code.</p>
    public let inputLambdaProcessor: InputLambdaProcessor?

    public init (
        inputLambdaProcessor: InputLambdaProcessor? = nil
    )
    {
        self.inputLambdaProcessor = inputLambdaProcessor
    }
}

extension InputProcessingConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputLambdaProcessorDescription = "InputLambdaProcessorDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputLambdaProcessorDescription = inputLambdaProcessorDescription {
            try encodeContainer.encode(inputLambdaProcessorDescription, forKey: .inputLambdaProcessorDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputLambdaProcessorDescriptionDecoded = try containerValues.decodeIfPresent(InputLambdaProcessorDescription.self, forKey: .inputLambdaProcessorDescription)
        inputLambdaProcessorDescription = inputLambdaProcessorDescriptionDecoded
    }
}

extension InputProcessingConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputProcessingConfigurationDescription(inputLambdaProcessorDescription: \(String(describing: inputLambdaProcessorDescription)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, provides the configuration
///         information about an input processor. Currently, the only input processor available is <a href="https://docs.aws.amazon.com/lambda/">AWS Lambda</a>.</p>
public struct InputProcessingConfigurationDescription: Equatable {
    /// <p>Provides configuration information about the associated <a>InputLambdaProcessorDescription</a>
    ///          </p>
    public let inputLambdaProcessorDescription: InputLambdaProcessorDescription?

    public init (
        inputLambdaProcessorDescription: InputLambdaProcessorDescription? = nil
    )
    {
        self.inputLambdaProcessorDescription = inputLambdaProcessorDescription
    }
}

extension InputProcessingConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputLambdaProcessorUpdate = "InputLambdaProcessorUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputLambdaProcessorUpdate = inputLambdaProcessorUpdate {
            try encodeContainer.encode(inputLambdaProcessorUpdate, forKey: .inputLambdaProcessorUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputLambdaProcessorUpdateDecoded = try containerValues.decodeIfPresent(InputLambdaProcessorUpdate.self, forKey: .inputLambdaProcessorUpdate)
        inputLambdaProcessorUpdate = inputLambdaProcessorUpdateDecoded
    }
}

extension InputProcessingConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputProcessingConfigurationUpdate(inputLambdaProcessorUpdate: \(String(describing: inputLambdaProcessorUpdate)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes updates to an <a>InputProcessingConfiguration</a>.</p>
public struct InputProcessingConfigurationUpdate: Equatable {
    /// <p>Provides update information for an <a>InputLambdaProcessor</a>.</p>
    public let inputLambdaProcessorUpdate: InputLambdaProcessorUpdate?

    public init (
        inputLambdaProcessorUpdate: InputLambdaProcessorUpdate? = nil
    )
    {
        self.inputLambdaProcessorUpdate = inputLambdaProcessorUpdate
    }
}

extension InputSchemaUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recordColumnUpdates = "RecordColumnUpdates"
        case recordEncodingUpdate = "RecordEncodingUpdate"
        case recordFormatUpdate = "RecordFormatUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordColumnUpdates = recordColumnUpdates {
            var recordColumnUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordColumnUpdates)
            for recordcolumns0 in recordColumnUpdates {
                try recordColumnUpdatesContainer.encode(recordcolumns0)
            }
        }
        if let recordEncodingUpdate = recordEncodingUpdate {
            try encodeContainer.encode(recordEncodingUpdate, forKey: .recordEncodingUpdate)
        }
        if let recordFormatUpdate = recordFormatUpdate {
            try encodeContainer.encode(recordFormatUpdate, forKey: .recordFormatUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordFormatUpdateDecoded = try containerValues.decodeIfPresent(RecordFormat.self, forKey: .recordFormatUpdate)
        recordFormatUpdate = recordFormatUpdateDecoded
        let recordEncodingUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordEncodingUpdate)
        recordEncodingUpdate = recordEncodingUpdateDecoded
        let recordColumnUpdatesContainer = try containerValues.decodeIfPresent([RecordColumn?].self, forKey: .recordColumnUpdates)
        var recordColumnUpdatesDecoded0:[RecordColumn]? = nil
        if let recordColumnUpdatesContainer = recordColumnUpdatesContainer {
            recordColumnUpdatesDecoded0 = [RecordColumn]()
            for structure0 in recordColumnUpdatesContainer {
                if let structure0 = structure0 {
                    recordColumnUpdatesDecoded0?.append(structure0)
                }
            }
        }
        recordColumnUpdates = recordColumnUpdatesDecoded0
    }
}

extension InputSchemaUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputSchemaUpdate(recordColumnUpdates: \(String(describing: recordColumnUpdates)), recordEncodingUpdate: \(String(describing: recordEncodingUpdate)), recordFormatUpdate: \(String(describing: recordFormatUpdate)))"}
}

/// <p>Describes updates for an SQL-based Kinesis Data Analytics application's input
///       schema.</p>
public struct InputSchemaUpdate: Equatable {
    /// <p>A list of <code>RecordColumn</code> objects. Each object describes the mapping
    ///       of the streaming source element to the corresponding column in the in-application stream.</p>
    public let recordColumnUpdates: [RecordColumn]?
    /// <p>Specifies the encoding of the records in the streaming source; for example, UTF-8.</p>
    public let recordEncodingUpdate: String?
    /// <p>Specifies the format of the records on the streaming source.</p>
    public let recordFormatUpdate: RecordFormat?

    public init (
        recordColumnUpdates: [RecordColumn]? = nil,
        recordEncodingUpdate: String? = nil,
        recordFormatUpdate: RecordFormat? = nil
    )
    {
        self.recordColumnUpdates = recordColumnUpdates
        self.recordEncodingUpdate = recordEncodingUpdate
        self.recordFormatUpdate = recordFormatUpdate
    }
}

public enum InputStartingPosition {
    case lastStoppedPoint
    case now
    case trimHorizon
    case sdkUnknown(String)
}

extension InputStartingPosition : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InputStartingPosition] {
        return [
            .lastStoppedPoint,
            .now,
            .trimHorizon,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lastStoppedPoint: return "LAST_STOPPED_POINT"
        case .now: return "NOW"
        case .trimHorizon: return "TRIM_HORIZON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InputStartingPosition(rawValue: rawValue) ?? InputStartingPosition.sdkUnknown(rawValue)
    }
}

extension InputStartingPositionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputStartingPosition = "InputStartingPosition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputStartingPosition = inputStartingPosition {
            try encodeContainer.encode(inputStartingPosition.rawValue, forKey: .inputStartingPosition)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputStartingPositionDecoded = try containerValues.decodeIfPresent(InputStartingPosition.self, forKey: .inputStartingPosition)
        inputStartingPosition = inputStartingPositionDecoded
    }
}

extension InputStartingPositionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputStartingPositionConfiguration(inputStartingPosition: \(String(describing: inputStartingPosition)))"}
}

/// <p>Describes the point at which the application reads from
///       the streaming source.</p>
public struct InputStartingPositionConfiguration: Equatable {
    /// <p>The starting position on the stream.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NOW</code> - Start reading just after the most recent record in the stream, and
    ///           start at the request timestamp that the customer issued.</p>
    ///
    ///
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TRIM_HORIZON</code> - Start reading at the last untrimmed record in the stream,
    ///           which is the oldest record available in the stream. This option is not available
    ///           for an Amazon Kinesis Data Firehose delivery stream.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LAST_STOPPED_POINT</code> - Resume reading from where the application last stopped reading.</p>
    ///             </li>
    ///          </ul>
    public let inputStartingPosition: InputStartingPosition?

    public init (
        inputStartingPosition: InputStartingPosition? = nil
    )
    {
        self.inputStartingPosition = inputStartingPosition
    }
}

extension InputUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputId = "InputId"
        case inputParallelismUpdate = "InputParallelismUpdate"
        case inputProcessingConfigurationUpdate = "InputProcessingConfigurationUpdate"
        case inputSchemaUpdate = "InputSchemaUpdate"
        case kinesisFirehoseInputUpdate = "KinesisFirehoseInputUpdate"
        case kinesisStreamsInputUpdate = "KinesisStreamsInputUpdate"
        case namePrefixUpdate = "NamePrefixUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputId = inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
        if let inputParallelismUpdate = inputParallelismUpdate {
            try encodeContainer.encode(inputParallelismUpdate, forKey: .inputParallelismUpdate)
        }
        if let inputProcessingConfigurationUpdate = inputProcessingConfigurationUpdate {
            try encodeContainer.encode(inputProcessingConfigurationUpdate, forKey: .inputProcessingConfigurationUpdate)
        }
        if let inputSchemaUpdate = inputSchemaUpdate {
            try encodeContainer.encode(inputSchemaUpdate, forKey: .inputSchemaUpdate)
        }
        if let kinesisFirehoseInputUpdate = kinesisFirehoseInputUpdate {
            try encodeContainer.encode(kinesisFirehoseInputUpdate, forKey: .kinesisFirehoseInputUpdate)
        }
        if let kinesisStreamsInputUpdate = kinesisStreamsInputUpdate {
            try encodeContainer.encode(kinesisStreamsInputUpdate, forKey: .kinesisStreamsInputUpdate)
        }
        if let namePrefixUpdate = namePrefixUpdate {
            try encodeContainer.encode(namePrefixUpdate, forKey: .namePrefixUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputId)
        inputId = inputIdDecoded
        let namePrefixUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namePrefixUpdate)
        namePrefixUpdate = namePrefixUpdateDecoded
        let inputProcessingConfigurationUpdateDecoded = try containerValues.decodeIfPresent(InputProcessingConfigurationUpdate.self, forKey: .inputProcessingConfigurationUpdate)
        inputProcessingConfigurationUpdate = inputProcessingConfigurationUpdateDecoded
        let kinesisStreamsInputUpdateDecoded = try containerValues.decodeIfPresent(KinesisStreamsInputUpdate.self, forKey: .kinesisStreamsInputUpdate)
        kinesisStreamsInputUpdate = kinesisStreamsInputUpdateDecoded
        let kinesisFirehoseInputUpdateDecoded = try containerValues.decodeIfPresent(KinesisFirehoseInputUpdate.self, forKey: .kinesisFirehoseInputUpdate)
        kinesisFirehoseInputUpdate = kinesisFirehoseInputUpdateDecoded
        let inputSchemaUpdateDecoded = try containerValues.decodeIfPresent(InputSchemaUpdate.self, forKey: .inputSchemaUpdate)
        inputSchemaUpdate = inputSchemaUpdateDecoded
        let inputParallelismUpdateDecoded = try containerValues.decodeIfPresent(InputParallelismUpdate.self, forKey: .inputParallelismUpdate)
        inputParallelismUpdate = inputParallelismUpdateDecoded
    }
}

extension InputUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputUpdate(inputId: \(String(describing: inputId)), inputParallelismUpdate: \(String(describing: inputParallelismUpdate)), inputProcessingConfigurationUpdate: \(String(describing: inputProcessingConfigurationUpdate)), inputSchemaUpdate: \(String(describing: inputSchemaUpdate)), kinesisFirehoseInputUpdate: \(String(describing: kinesisFirehoseInputUpdate)), kinesisStreamsInputUpdate: \(String(describing: kinesisStreamsInputUpdate)), namePrefixUpdate: \(String(describing: namePrefixUpdate)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes updates to a
///       specific input configuration (identified by the <code>InputId</code> of an application). </p>
public struct InputUpdate: Equatable {
    /// <p>The input ID of the application input to be updated.</p>
    public let inputId: String?
    /// <p>Describes the parallelism updates (the number of in-application streams Kinesis Data Analytics creates for the specific streaming source).</p>
    public let inputParallelismUpdate: InputParallelismUpdate?
    /// <p>Describes updates to an <a>InputProcessingConfiguration</a>.</p>
    public let inputProcessingConfigurationUpdate: InputProcessingConfigurationUpdate?
    /// <p>Describes the data format on the streaming source, and
    ///       how record elements on the streaming source map to columns of the in-application stream that is created.</p>
    public let inputSchemaUpdate: InputSchemaUpdate?
    /// <p>If a Kinesis Data Firehose delivery stream is the streaming source to be
    ///       updated, provides an updated stream ARN.</p>
    public let kinesisFirehoseInputUpdate: KinesisFirehoseInputUpdate?
    /// <p>If a Kinesis data stream is the streaming source to be updated, provides an
    ///       updated stream Amazon Resource Name (ARN).</p>
    public let kinesisStreamsInputUpdate: KinesisStreamsInputUpdate?
    /// <p>The name prefix for in-application streams that Kinesis Data Analytics creates for the
    ///       specific streaming source.</p>
    public let namePrefixUpdate: String?

    public init (
        inputId: String? = nil,
        inputParallelismUpdate: InputParallelismUpdate? = nil,
        inputProcessingConfigurationUpdate: InputProcessingConfigurationUpdate? = nil,
        inputSchemaUpdate: InputSchemaUpdate? = nil,
        kinesisFirehoseInputUpdate: KinesisFirehoseInputUpdate? = nil,
        kinesisStreamsInputUpdate: KinesisStreamsInputUpdate? = nil,
        namePrefixUpdate: String? = nil
    )
    {
        self.inputId = inputId
        self.inputParallelismUpdate = inputParallelismUpdate
        self.inputProcessingConfigurationUpdate = inputProcessingConfigurationUpdate
        self.inputSchemaUpdate = inputSchemaUpdate
        self.kinesisFirehoseInputUpdate = kinesisFirehoseInputUpdate
        self.kinesisStreamsInputUpdate = kinesisStreamsInputUpdate
        self.namePrefixUpdate = namePrefixUpdate
    }
}

extension InvalidApplicationConfigurationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidApplicationConfigurationException(message: \(String(describing: message)))"}
}

extension InvalidApplicationConfigurationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidApplicationConfigurationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user-provided application configuration is not valid.</p>
public struct InvalidApplicationConfigurationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApplicationConfigurationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidApplicationConfigurationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArgumentException(message: \(String(describing: message)))"}
}

extension InvalidArgumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified input parameter value is not valid.</p>
public struct InvalidArgumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Equatable {
    public let message: String?
}

extension InvalidArgumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request JSON is not valid for the operation.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension JSONMappingParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recordRowPath = "RecordRowPath"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordRowPath = recordRowPath {
            try encodeContainer.encode(recordRowPath, forKey: .recordRowPath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordRowPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordRowPath)
        recordRowPath = recordRowPathDecoded
    }
}

extension JSONMappingParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JSONMappingParameters(recordRowPath: \(String(describing: recordRowPath)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, provides additional mapping
///       information when JSON is the record format on the streaming source.</p>
public struct JSONMappingParameters: Equatable {
    /// <p>The path to the top-level parent that contains the records.</p>
    public let recordRowPath: String?

    public init (
        recordRowPath: String? = nil
    )
    {
        self.recordRowPath = recordRowPath
    }
}

extension KinesisFirehoseInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension KinesisFirehoseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseInput(resourceARN: \(String(describing: resourceARN)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, identifies a Kinesis Data
///       Firehose delivery stream as the streaming source. You provide the delivery stream's Amazon
///       Resource Name (ARN).</p>
public struct KinesisFirehoseInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

extension KinesisFirehoseInputDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisFirehoseInputDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseInputDescription(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>Describes the Amazon Kinesis Data Firehose delivery stream that is configured as the streaming source
///       in the application input configuration. </p>
public struct KinesisFirehoseInputDescription: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
    public let resourceARN: String?
    /// <p>The ARN of the IAM role that Kinesis Data Analytics assumes to access the stream.</p>
    ///          <note>
    ///             <p>Provided for backward compatibility. Applications that are created with the current API
    ///         version have an application-level service execution role rather than a resource-level
    ///         role.</p>
    ///          </note>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension KinesisFirehoseInputUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
    }
}

extension KinesisFirehoseInputUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseInputUpdate(resourceARNUpdate: \(String(describing: resourceARNUpdate)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, when updating application
///       input configuration, provides information about a Kinesis Data Firehose delivery stream as the
///       streaming source.</p>
public struct KinesisFirehoseInputUpdate: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the input delivery stream to read.</p>
    public let resourceARNUpdate: String?

    public init (
        resourceARNUpdate: String? = nil
    )
    {
        self.resourceARNUpdate = resourceARNUpdate
    }
}

extension KinesisFirehoseOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension KinesisFirehoseOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseOutput(resourceARN: \(String(describing: resourceARN)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, when configuring application
///       output, identifies a Kinesis Data Firehose delivery stream as the destination. You provide the
///       stream Amazon Resource Name (ARN) of the delivery stream. </p>
public struct KinesisFirehoseOutput: Equatable {
    /// <p>The ARN of the destination delivery stream to write to.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

extension KinesisFirehoseOutputDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisFirehoseOutputDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseOutputDescription(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application's output, describes the Kinesis
///       Data Firehose delivery stream that is configured as its destination.</p>
public struct KinesisFirehoseOutputDescription: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
    public let resourceARN: String?
    /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to access the
    ///       stream.</p>
    ///          <note>
    ///             <p>Provided for backward compatibility. Applications that are created with the current API
    ///         version have an application-level service execution role rather than a resource-level
    ///         role.</p>
    ///          </note>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension KinesisFirehoseOutputUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
    }
}

extension KinesisFirehoseOutputUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseOutputUpdate(resourceARNUpdate: \(String(describing: resourceARNUpdate)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, when updating an output
///       configuration using the <a>UpdateApplication</a> operation, provides information
///       about a Kinesis Data Firehose delivery stream that is configured as the destination.</p>
public struct KinesisFirehoseOutputUpdate: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream to write to. </p>
    public let resourceARNUpdate: String?

    public init (
        resourceARNUpdate: String? = nil
    )
    {
        self.resourceARNUpdate = resourceARNUpdate
    }
}

extension KinesisStreamsInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension KinesisStreamsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisStreamsInput(resourceARN: \(String(describing: resourceARN)))"}
}

/// <p> Identifies a Kinesis data stream as the streaming source. You provide the
///       stream's Amazon Resource Name (ARN).</p>
public struct KinesisStreamsInput: Equatable {
    /// <p>The ARN of the input Kinesis data stream to read.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

extension KinesisStreamsInputDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisStreamsInputDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisStreamsInputDescription(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes the Kinesis data
///       stream that is configured as the streaming source in the application input configuration. </p>
public struct KinesisStreamsInputDescription: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
    public let resourceARN: String?
    /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to access the
    ///       stream.</p>
    ///          <note>
    ///             <p>Provided for backward compatibility. Applications that are created with the current API
    ///         version have an application-level service execution role rather than a resource-level
    ///         role.</p>
    ///          </note>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension KinesisStreamsInputUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
    }
}

extension KinesisStreamsInputUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisStreamsInputUpdate(resourceARNUpdate: \(String(describing: resourceARNUpdate)))"}
}

/// <p>When you update the input configuration for a SQL-based Kinesis Data Analytics application, provides information about a
///       Kinesis stream as the streaming
///       source.</p>
public struct KinesisStreamsInputUpdate: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the input Kinesis data stream to read.</p>
    public let resourceARNUpdate: String?

    public init (
        resourceARNUpdate: String? = nil
    )
    {
        self.resourceARNUpdate = resourceARNUpdate
    }
}

extension KinesisStreamsOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension KinesisStreamsOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisStreamsOutput(resourceARN: \(String(describing: resourceARN)))"}
}

/// <p>When you configure a SQL-based Kinesis Data Analytics application's output,
///       identifies a Kinesis data stream as the destination. You provide the stream Amazon Resource
///       Name (ARN). </p>
public struct KinesisStreamsOutput: Equatable {
    /// <p>The ARN of the destination Kinesis data stream to write to.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

extension KinesisStreamsOutputDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisStreamsOutputDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisStreamsOutputDescription(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>For an SQL-based Kinesis Data Analytics application's output, describes the Kinesis
///       data stream that is configured as its destination. </p>
public struct KinesisStreamsOutputDescription: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream.</p>
    public let resourceARN: String?
    /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to access the
    ///       stream.</p>
    ///          <note>
    ///             <p>Provided for backward compatibility. Applications that are created with the current API
    ///         version have an application-level service execution role rather than a resource-level
    ///         role.</p>
    ///          </note>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension KinesisStreamsOutputUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
    }
}

extension KinesisStreamsOutputUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisStreamsOutputUpdate(resourceARNUpdate: \(String(describing: resourceARNUpdate)))"}
}

/// <p>When you update a SQL-based Kinesis Data Analytics application's output
///       configuration using the <a>UpdateApplication</a> operation, provides information
///       about a Kinesis data stream that is configured as the destination.</p>
public struct KinesisStreamsOutputUpdate: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream where you want to write the
    ///       output.</p>
    public let resourceARNUpdate: String?

    public init (
        resourceARNUpdate: String? = nil
    )
    {
        self.resourceARNUpdate = resourceARNUpdate
    }
}

extension LambdaOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension LambdaOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaOutput(resourceARN: \(String(describing: resourceARN)))"}
}

/// <p>When you configure a SQL-based Kinesis Data Analytics application's output,
///       identifies an AWS Lambda function as the destination. You provide the function Amazon Resource
///       Name (ARN) of the Lambda function. </p>
public struct LambdaOutput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the destination Lambda function to write to.</p>
    ///          <note>
    ///             <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: AWS Lambda</a>
    ///             </p>
    ///          </note>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

extension LambdaOutputDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension LambdaOutputDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaOutputDescription(resourceARN: \(String(describing: resourceARN)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application's output, describes the AWS
///       Lambda function that is configured as its destination. </p>
public struct LambdaOutputDescription: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the destination Lambda function.</p>
    public let resourceARN: String?
    /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to write to the destination
    ///       function.</p>
    ///          <note>
    ///             <p>Provided for backward compatibility. Applications that are created with the current API
    ///         version have an application-level service execution role rather than a resource-level
    ///         role.</p>
    ///          </note>
    public let roleARN: String?

    public init (
        resourceARN: String? = nil,
        roleARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
        self.roleARN = roleARN
    }
}

extension LambdaOutputUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
    }
}

extension LambdaOutputUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaOutputUpdate(resourceARNUpdate: \(String(describing: resourceARNUpdate)))"}
}

/// <p>When you update an SQL-based Kinesis Data Analytics application's output
///       configuration using the <a>UpdateApplication</a> operation, provides information
///       about an AWS Lambda function that is configured as the destination.</p>
public struct LambdaOutputUpdate: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the destination AWS Lambda function.</p>
    ///          <note>
    ///             <p>To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-lambda">Example ARNs: AWS Lambda</a>
    ///             </p>
    ///          </note>
    public let resourceARNUpdate: String?

    public init (
        resourceARNUpdate: String? = nil
    )
    {
        self.resourceARNUpdate = resourceARNUpdate
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of allowed resources has been exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListApplicationSnapshotsInputBodyMiddleware: Middleware {
    public let id: String = "ListApplicationSnapshotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationSnapshotsInput>
    public typealias MOutput = OperationOutput<ListApplicationSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationSnapshotsOutputError>
}

extension ListApplicationSnapshotsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationSnapshotsInput(applicationName: \(String(describing: applicationName)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationSnapshotsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListApplicationSnapshotsInputHeadersMiddleware: Middleware {
    public let id: String = "ListApplicationSnapshotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationSnapshotsInput>
    public typealias MOutput = OperationOutput<ListApplicationSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationSnapshotsOutputError>
}

public struct ListApplicationSnapshotsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListApplicationSnapshotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationSnapshotsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationSnapshotsInput>
    public typealias MOutput = OperationOutput<ListApplicationSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationSnapshotsOutputError>
}

public struct ListApplicationSnapshotsInput: Equatable {
    /// <p>The name of an existing application.</p>
    public let applicationName: String?
    /// <p>The maximum number of application snapshots to list.</p>
    public let limit: Int?
    /// <p>Use this parameter if you receive a <code>NextToken</code> response in a previous request that indicates that there is more
    ///       output available. Set it to the value of the previous call's <code>NextToken</code> response to indicate where the output should
    ///       continue from. </p>
    public let nextToken: String?

    public init (
        applicationName: String? = nil,
        limit: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.applicationName = applicationName
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListApplicationSnapshotsInputBody: Equatable {
    public let applicationName: String?
    public let limit: Int?
    public let nextToken: String?
}

extension ListApplicationSnapshotsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationSnapshotsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationSnapshotsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationSnapshotsOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationSnapshotsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationSnapshotsOutputResponse(nextToken: \(String(describing: nextToken)), snapshotSummaries: \(String(describing: snapshotSummaries)))"}
}

extension ListApplicationSnapshotsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListApplicationSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.snapshotSummaries = output.snapshotSummaries
        } else {
            self.nextToken = nil
            self.snapshotSummaries = nil
        }
    }
}

public struct ListApplicationSnapshotsOutputResponse: Equatable {
    /// <p>The token for the next set of results, or <code>null</code> if there are no additional results.</p>
    public let nextToken: String?
    /// <p>A collection of objects containing information about the application snapshots.</p>
    public let snapshotSummaries: [SnapshotDetails]?

    public init (
        nextToken: String? = nil,
        snapshotSummaries: [SnapshotDetails]? = nil
    )
    {
        self.nextToken = nextToken
        self.snapshotSummaries = snapshotSummaries
    }
}

struct ListApplicationSnapshotsOutputResponseBody: Equatable {
    public let snapshotSummaries: [SnapshotDetails]?
    public let nextToken: String?
}

extension ListApplicationSnapshotsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case snapshotSummaries = "SnapshotSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotSummariesContainer = try containerValues.decodeIfPresent([SnapshotDetails?].self, forKey: .snapshotSummaries)
        var snapshotSummariesDecoded0:[SnapshotDetails]? = nil
        if let snapshotSummariesContainer = snapshotSummariesContainer {
            snapshotSummariesDecoded0 = [SnapshotDetails]()
            for structure0 in snapshotSummariesContainer {
                if let structure0 = structure0 {
                    snapshotSummariesDecoded0?.append(structure0)
                }
            }
        }
        snapshotSummaries = snapshotSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListApplicationVersionsInputBodyMiddleware: Middleware {
    public let id: String = "ListApplicationVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationVersionsInput>
    public typealias MOutput = OperationOutput<ListApplicationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationVersionsOutputError>
}

extension ListApplicationVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationVersionsInput(applicationName: \(String(describing: applicationName)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListApplicationVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListApplicationVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationVersionsInput>
    public typealias MOutput = OperationOutput<ListApplicationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationVersionsOutputError>
}

public struct ListApplicationVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListApplicationVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationVersionsInput>
    public typealias MOutput = OperationOutput<ListApplicationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationVersionsOutputError>
}

public struct ListApplicationVersionsInput: Equatable {
    /// <p>The name of the application for which you want to list all versions.</p>
    public let applicationName: String?
    /// <p>The maximum number of versions to list in this invocation of the operation.</p>
    public let limit: Int?
    /// <p>If a previous invocation of this operation returned a pagination token, pass it into this value to retrieve the next set of results. For more information about pagination, see
    ///       <a href="https://docs.aws.amazon.com/cli/latest/userguide/pagination.html">Using the AWS Command Line Interface's Pagination Options</a>.</p>
    public let nextToken: String?

    public init (
        applicationName: String? = nil,
        limit: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.applicationName = applicationName
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListApplicationVersionsInputBody: Equatable {
    public let applicationName: String?
    public let limit: Int?
    public let nextToken: String?
}

extension ListApplicationVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationVersionsOutputError: Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationVersionsOutputResponse(applicationVersionSummaries: \(String(describing: applicationVersionSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListApplicationVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationVersionSummaries = output.applicationVersionSummaries
            self.nextToken = output.nextToken
        } else {
            self.applicationVersionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationVersionsOutputResponse: Equatable {
    /// <p>A list of the application versions and the associated configuration summaries. The list includes application versions that were rolled back.</p>
    ///          <p>To get the complete description of a specific application version, invoke the <a>DescribeApplicationVersion</a> operation.</p>
    public let applicationVersionSummaries: [ApplicationVersionSummary]?
    /// <p>The pagination token for the next set of results, or <code>null</code> if there are no additional results.
    ///       To retrieve the next set of items, pass this token into a subsequent invocation of this operation. For more information about pagination, see
    ///       <a href="https://docs.aws.amazon.com/cli/latest/userguide/pagination.html">Using the AWS Command Line Interface's Pagination Options</a>.</p>
    public let nextToken: String?

    public init (
        applicationVersionSummaries: [ApplicationVersionSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.applicationVersionSummaries = applicationVersionSummaries
        self.nextToken = nextToken
    }
}

struct ListApplicationVersionsOutputResponseBody: Equatable {
    public let applicationVersionSummaries: [ApplicationVersionSummary]?
    public let nextToken: String?
}

extension ListApplicationVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationVersionSummaries = "ApplicationVersionSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationVersionSummariesContainer = try containerValues.decodeIfPresent([ApplicationVersionSummary?].self, forKey: .applicationVersionSummaries)
        var applicationVersionSummariesDecoded0:[ApplicationVersionSummary]? = nil
        if let applicationVersionSummariesContainer = applicationVersionSummariesContainer {
            applicationVersionSummariesDecoded0 = [ApplicationVersionSummary]()
            for structure0 in applicationVersionSummariesContainer {
                if let structure0 = structure0 {
                    applicationVersionSummariesDecoded0?.append(structure0)
                }
            }
        }
        applicationVersionSummaries = applicationVersionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListApplicationsInputBodyMiddleware: Middleware {
    public let id: String = "ListApplicationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

extension ListApplicationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationsInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListApplicationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInput: Equatable {
    /// <p>The maximum number of applications to list.</p>
    public let limit: Int?
    /// <p>If a previous command returned a pagination token,
    ///       pass it into this value to retrieve the next set of results.
    ///       For more information about pagination, see
    ///       <a href="https://docs.aws.amazon.com/cli/latest/userguide/pagination.html">Using the AWS Command Line Interface's Pagination Options</a>.</p>
    public let nextToken: String?

    public init (
        limit: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Equatable {
    public let limit: Int?
    public let nextToken: String?
}

extension ListApplicationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationsOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationsOutputResponse(applicationSummaries: \(String(describing: applicationSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationSummaries = output.applicationSummaries
            self.nextToken = output.nextToken
        } else {
            self.applicationSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutputResponse: Equatable {
    /// <p>A list of <code>ApplicationSummary</code> objects.</p>
    public let applicationSummaries: [ApplicationSummary]?
    /// <p>The pagination token for the next set of results, or <code>null</code> if there are no additional results.
    ///       Pass this token into a subsequent command to retrieve the next set of items
    ///       For more information about pagination, see
    ///       <a href="https://docs.aws.amazon.com/cli/latest/userguide/pagination.html">Using the AWS Command Line Interface's Pagination Options</a>.</p>
    public let nextToken: String?

    public init (
        applicationSummaries: [ApplicationSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.applicationSummaries = applicationSummaries
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputResponseBody: Equatable {
    public let applicationSummaries: [ApplicationSummary]?
    public let nextToken: String?
}

extension ListApplicationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationSummaries = "ApplicationSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationSummariesContainer = try containerValues.decodeIfPresent([ApplicationSummary?].self, forKey: .applicationSummaries)
        var applicationSummariesDecoded0:[ApplicationSummary]? = nil
        if let applicationSummariesContainer = applicationSummariesContainer {
            applicationSummariesDecoded0 = [ApplicationSummary]()
            for structure0 in applicationSummariesContainer {
                if let structure0 = structure0 {
                    applicationSummariesDecoded0?.append(structure0)
                }
            }
        }
        applicationSummaries = applicationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the application for which to retrieve tags.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The key-value tags assigned to the application.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum LogLevel {
    case debug
    case error
    case info
    case warn
    case sdkUnknown(String)
}

extension LogLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LogLevel] {
        return [
            .debug,
            .error,
            .info,
            .warn,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .debug: return "DEBUG"
        case .error: return "ERROR"
        case .info: return "INFO"
        case .warn: return "WARN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LogLevel(rawValue: rawValue) ?? LogLevel.sdkUnknown(rawValue)
    }
}

extension MappingParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cSVMappingParameters = "CSVMappingParameters"
        case jSONMappingParameters = "JSONMappingParameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cSVMappingParameters = cSVMappingParameters {
            try encodeContainer.encode(cSVMappingParameters, forKey: .cSVMappingParameters)
        }
        if let jSONMappingParameters = jSONMappingParameters {
            try encodeContainer.encode(jSONMappingParameters, forKey: .jSONMappingParameters)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jSONMappingParametersDecoded = try containerValues.decodeIfPresent(JSONMappingParameters.self, forKey: .jSONMappingParameters)
        jSONMappingParameters = jSONMappingParametersDecoded
        let cSVMappingParametersDecoded = try containerValues.decodeIfPresent(CSVMappingParameters.self, forKey: .cSVMappingParameters)
        cSVMappingParameters = cSVMappingParametersDecoded
    }
}

extension MappingParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MappingParameters(cSVMappingParameters: \(String(describing: cSVMappingParameters)), jSONMappingParameters: \(String(describing: jSONMappingParameters)))"}
}

/// <p>When you configure a SQL-based Kinesis Data Analytics application's input at the
///       time of creating or updating an application, provides additional mapping information specific
///       to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the
///       streaming source.</p>
public struct MappingParameters: Equatable {
    /// <p>Provides additional mapping information when the record format uses delimiters
    ///       (for example, CSV).</p>
    public let cSVMappingParameters: CSVMappingParameters?
    /// <p>Provides additional mapping information when JSON is the record format on the streaming source.</p>
    public let jSONMappingParameters: JSONMappingParameters?

    public init (
        cSVMappingParameters: CSVMappingParameters? = nil,
        jSONMappingParameters: JSONMappingParameters? = nil
    )
    {
        self.cSVMappingParameters = cSVMappingParameters
        self.jSONMappingParameters = jSONMappingParameters
    }
}

extension MavenReference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactId = "ArtifactId"
        case groupId = "GroupId"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactId = artifactId {
            try encodeContainer.encode(artifactId, forKey: .artifactId)
        }
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let artifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .artifactId)
        artifactId = artifactIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension MavenReference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MavenReference(artifactId: \(String(describing: artifactId)), groupId: \(String(describing: groupId)), version: \(String(describing: version)))"}
}

/// <p>The information required to specify a Maven reference. You can use Maven references to specify dependency JAR files.</p>
public struct MavenReference: Equatable {
    /// <p>The artifact ID of the Maven reference.</p>
    public let artifactId: String?
    /// <p>The group ID of the Maven reference.</p>
    public let groupId: String?
    /// <p>The version of the Maven reference.</p>
    public let version: String?

    public init (
        artifactId: String? = nil,
        groupId: String? = nil,
        version: String? = nil
    )
    {
        self.artifactId = artifactId
        self.groupId = groupId
        self.version = version
    }
}

public enum MetricsLevel {
    case application
    case `operator`
    case parallelism
    case task
    case sdkUnknown(String)
}

extension MetricsLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MetricsLevel] {
        return [
            .application,
            .operator,
            .parallelism,
            .task,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .application: return "APPLICATION"
        case .operator: return "OPERATOR"
        case .parallelism: return "PARALLELISM"
        case .task: return "TASK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MetricsLevel(rawValue: rawValue) ?? MetricsLevel.sdkUnknown(rawValue)
    }
}

extension MonitoringConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationType = "ConfigurationType"
        case logLevel = "LogLevel"
        case metricsLevel = "MetricsLevel"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationType = configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let metricsLevel = metricsLevel {
            try encodeContainer.encode(metricsLevel.rawValue, forKey: .metricsLevel)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(ConfigurationType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let metricsLevelDecoded = try containerValues.decodeIfPresent(MetricsLevel.self, forKey: .metricsLevel)
        metricsLevel = metricsLevelDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension MonitoringConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MonitoringConfiguration(configurationType: \(String(describing: configurationType)), logLevel: \(String(describing: logLevel)), metricsLevel: \(String(describing: metricsLevel)))"}
}

/// <p>Describes configuration parameters for Amazon CloudWatch logging for an application. For more information about CloudWatch logging, see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/monitoring-overview.html">Monitoring</a>.</p>
public struct MonitoringConfiguration: Equatable {
    /// <p>Describes whether to use the default CloudWatch logging configuration for an application.
    ///     You must set this property to <code>CUSTOM</code> in order to set the <code>LogLevel</code> or
    ///     <code>MetricsLevel</code> parameters.</p>
    public let configurationType: ConfigurationType?
    /// <p>Describes the verbosity of the CloudWatch Logs for an application.</p>
    public let logLevel: LogLevel?
    /// <p>Describes the granularity of the CloudWatch Logs for an application. The <code>Parallelism</code>
    ///     level is not recommended for applications with a Parallelism over 64 due to excessive costs.</p>
    public let metricsLevel: MetricsLevel?

    public init (
        configurationType: ConfigurationType? = nil,
        logLevel: LogLevel? = nil,
        metricsLevel: MetricsLevel? = nil
    )
    {
        self.configurationType = configurationType
        self.logLevel = logLevel
        self.metricsLevel = metricsLevel
    }
}

extension MonitoringConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationType = "ConfigurationType"
        case logLevel = "LogLevel"
        case metricsLevel = "MetricsLevel"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationType = configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let metricsLevel = metricsLevel {
            try encodeContainer.encode(metricsLevel.rawValue, forKey: .metricsLevel)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(ConfigurationType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let metricsLevelDecoded = try containerValues.decodeIfPresent(MetricsLevel.self, forKey: .metricsLevel)
        metricsLevel = metricsLevelDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension MonitoringConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MonitoringConfigurationDescription(configurationType: \(String(describing: configurationType)), logLevel: \(String(describing: logLevel)), metricsLevel: \(String(describing: metricsLevel)))"}
}

/// <p>Describes configuration parameters for CloudWatch logging for an application.</p>
public struct MonitoringConfigurationDescription: Equatable {
    /// <p>Describes whether to use the default CloudWatch logging configuration for an application.</p>
    public let configurationType: ConfigurationType?
    /// <p>Describes the verbosity of the CloudWatch Logs for an application.</p>
    public let logLevel: LogLevel?
    /// <p>Describes the granularity of the CloudWatch Logs for an application.</p>
    public let metricsLevel: MetricsLevel?

    public init (
        configurationType: ConfigurationType? = nil,
        logLevel: LogLevel? = nil,
        metricsLevel: MetricsLevel? = nil
    )
    {
        self.configurationType = configurationType
        self.logLevel = logLevel
        self.metricsLevel = metricsLevel
    }
}

extension MonitoringConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationTypeUpdate = "ConfigurationTypeUpdate"
        case logLevelUpdate = "LogLevelUpdate"
        case metricsLevelUpdate = "MetricsLevelUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationTypeUpdate = configurationTypeUpdate {
            try encodeContainer.encode(configurationTypeUpdate.rawValue, forKey: .configurationTypeUpdate)
        }
        if let logLevelUpdate = logLevelUpdate {
            try encodeContainer.encode(logLevelUpdate.rawValue, forKey: .logLevelUpdate)
        }
        if let metricsLevelUpdate = metricsLevelUpdate {
            try encodeContainer.encode(metricsLevelUpdate.rawValue, forKey: .metricsLevelUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeUpdateDecoded = try containerValues.decodeIfPresent(ConfigurationType.self, forKey: .configurationTypeUpdate)
        configurationTypeUpdate = configurationTypeUpdateDecoded
        let metricsLevelUpdateDecoded = try containerValues.decodeIfPresent(MetricsLevel.self, forKey: .metricsLevelUpdate)
        metricsLevelUpdate = metricsLevelUpdateDecoded
        let logLevelUpdateDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevelUpdate)
        logLevelUpdate = logLevelUpdateDecoded
    }
}

extension MonitoringConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MonitoringConfigurationUpdate(configurationTypeUpdate: \(String(describing: configurationTypeUpdate)), logLevelUpdate: \(String(describing: logLevelUpdate)), metricsLevelUpdate: \(String(describing: metricsLevelUpdate)))"}
}

/// <p>Describes updates to configuration parameters for Amazon CloudWatch logging for an application.</p>
public struct MonitoringConfigurationUpdate: Equatable {
    /// <p>Describes updates to whether to use the default CloudWatch logging configuration for
    ///       an application. You must set this property to <code>CUSTOM</code> in order to set the <code>LogLevel</code> or
    ///     <code>MetricsLevel</code> parameters.</p>
    public let configurationTypeUpdate: ConfigurationType?
    /// <p>Describes updates to the verbosity of the CloudWatch Logs for an application.</p>
    public let logLevelUpdate: LogLevel?
    /// <p>Describes updates to the granularity of the CloudWatch Logs for an application. The <code>Parallelism</code>
    ///       level is not recommended for applications with a Parallelism over 64 due to excessive costs.</p>
    public let metricsLevelUpdate: MetricsLevel?

    public init (
        configurationTypeUpdate: ConfigurationType? = nil,
        logLevelUpdate: LogLevel? = nil,
        metricsLevelUpdate: MetricsLevel? = nil
    )
    {
        self.configurationTypeUpdate = configurationTypeUpdate
        self.logLevelUpdate = logLevelUpdate
        self.metricsLevelUpdate = metricsLevelUpdate
    }
}

extension Output: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationSchema = "DestinationSchema"
        case kinesisFirehoseOutput = "KinesisFirehoseOutput"
        case kinesisStreamsOutput = "KinesisStreamsOutput"
        case lambdaOutput = "LambdaOutput"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationSchema = destinationSchema {
            try encodeContainer.encode(destinationSchema, forKey: .destinationSchema)
        }
        if let kinesisFirehoseOutput = kinesisFirehoseOutput {
            try encodeContainer.encode(kinesisFirehoseOutput, forKey: .kinesisFirehoseOutput)
        }
        if let kinesisStreamsOutput = kinesisStreamsOutput {
            try encodeContainer.encode(kinesisStreamsOutput, forKey: .kinesisStreamsOutput)
        }
        if let lambdaOutput = lambdaOutput {
            try encodeContainer.encode(lambdaOutput, forKey: .lambdaOutput)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let kinesisStreamsOutputDecoded = try containerValues.decodeIfPresent(KinesisStreamsOutput.self, forKey: .kinesisStreamsOutput)
        kinesisStreamsOutput = kinesisStreamsOutputDecoded
        let kinesisFirehoseOutputDecoded = try containerValues.decodeIfPresent(KinesisFirehoseOutput.self, forKey: .kinesisFirehoseOutput)
        kinesisFirehoseOutput = kinesisFirehoseOutputDecoded
        let lambdaOutputDecoded = try containerValues.decodeIfPresent(LambdaOutput.self, forKey: .lambdaOutput)
        lambdaOutput = lambdaOutputDecoded
        let destinationSchemaDecoded = try containerValues.decodeIfPresent(DestinationSchema.self, forKey: .destinationSchema)
        destinationSchema = destinationSchemaDecoded
    }
}

extension Output: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Output(destinationSchema: \(String(describing: destinationSchema)), kinesisFirehoseOutput: \(String(describing: kinesisFirehoseOutput)), kinesisStreamsOutput: \(String(describing: kinesisStreamsOutput)), lambdaOutput: \(String(describing: lambdaOutput)), name: \(String(describing: name)))"}
}

/// <p> Describes a SQL-based Kinesis Data Analytics application's output configuration,
///       in which you identify an in-application stream and a destination where you want the
///       in-application stream data to be written. The destination can be a Kinesis data stream or a
///       Kinesis Data Firehose delivery stream. </p>
///
///          <p></p>
public struct Output: Equatable {
    /// <p>Describes the data format when records are written to the destination.
    ///       </p>
    public let destinationSchema: DestinationSchema?
    /// <p>Identifies a Kinesis Data Firehose delivery stream as the destination.</p>
    public let kinesisFirehoseOutput: KinesisFirehoseOutput?
    /// <p>Identifies a Kinesis data stream
    ///       as the destination.</p>
    public let kinesisStreamsOutput: KinesisStreamsOutput?
    /// <p>Identifies an AWS Lambda function as the destination.</p>
    public let lambdaOutput: LambdaOutput?
    /// <p>The name of the in-application stream.</p>
    public let name: String?

    public init (
        destinationSchema: DestinationSchema? = nil,
        kinesisFirehoseOutput: KinesisFirehoseOutput? = nil,
        kinesisStreamsOutput: KinesisStreamsOutput? = nil,
        lambdaOutput: LambdaOutput? = nil,
        name: String? = nil
    )
    {
        self.destinationSchema = destinationSchema
        self.kinesisFirehoseOutput = kinesisFirehoseOutput
        self.kinesisStreamsOutput = kinesisStreamsOutput
        self.lambdaOutput = lambdaOutput
        self.name = name
    }
}

extension OutputDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationSchema = "DestinationSchema"
        case kinesisFirehoseOutputDescription = "KinesisFirehoseOutputDescription"
        case kinesisStreamsOutputDescription = "KinesisStreamsOutputDescription"
        case lambdaOutputDescription = "LambdaOutputDescription"
        case name = "Name"
        case outputId = "OutputId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationSchema = destinationSchema {
            try encodeContainer.encode(destinationSchema, forKey: .destinationSchema)
        }
        if let kinesisFirehoseOutputDescription = kinesisFirehoseOutputDescription {
            try encodeContainer.encode(kinesisFirehoseOutputDescription, forKey: .kinesisFirehoseOutputDescription)
        }
        if let kinesisStreamsOutputDescription = kinesisStreamsOutputDescription {
            try encodeContainer.encode(kinesisStreamsOutputDescription, forKey: .kinesisStreamsOutputDescription)
        }
        if let lambdaOutputDescription = lambdaOutputDescription {
            try encodeContainer.encode(lambdaOutputDescription, forKey: .lambdaOutputDescription)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputId = outputId {
            try encodeContainer.encode(outputId, forKey: .outputId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputId)
        outputId = outputIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let kinesisStreamsOutputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisStreamsOutputDescription.self, forKey: .kinesisStreamsOutputDescription)
        kinesisStreamsOutputDescription = kinesisStreamsOutputDescriptionDecoded
        let kinesisFirehoseOutputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisFirehoseOutputDescription.self, forKey: .kinesisFirehoseOutputDescription)
        kinesisFirehoseOutputDescription = kinesisFirehoseOutputDescriptionDecoded
        let lambdaOutputDescriptionDecoded = try containerValues.decodeIfPresent(LambdaOutputDescription.self, forKey: .lambdaOutputDescription)
        lambdaOutputDescription = lambdaOutputDescriptionDecoded
        let destinationSchemaDecoded = try containerValues.decodeIfPresent(DestinationSchema.self, forKey: .destinationSchema)
        destinationSchema = destinationSchemaDecoded
    }
}

extension OutputDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputDescription(destinationSchema: \(String(describing: destinationSchema)), kinesisFirehoseOutputDescription: \(String(describing: kinesisFirehoseOutputDescription)), kinesisStreamsOutputDescription: \(String(describing: kinesisStreamsOutputDescription)), lambdaOutputDescription: \(String(describing: lambdaOutputDescription)), name: \(String(describing: name)), outputId: \(String(describing: outputId)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes the application
///       output configuration, which includes the in-application stream name and the destination where
///       the stream data is written. The destination can be a Kinesis data stream or a Kinesis Data
///       Firehose delivery stream. </p>
public struct OutputDescription: Equatable {
    /// <p>The data format used for writing data to the destination.</p>
    public let destinationSchema: DestinationSchema?
    /// <p>Describes the Kinesis Data Firehose delivery stream that is configured as the destination
    ///       where output is written.</p>
    public let kinesisFirehoseOutputDescription: KinesisFirehoseOutputDescription?
    /// <p>Describes the Kinesis data stream that is configured as the destination where output is
    ///       written.</p>
    public let kinesisStreamsOutputDescription: KinesisStreamsOutputDescription?
    /// <p>Describes the Lambda function that is configured as the destination where output is
    ///       written.</p>
    public let lambdaOutputDescription: LambdaOutputDescription?
    /// <p>The name of the in-application stream that is configured as output.</p>
    public let name: String?
    /// <p>A unique identifier for the output configuration.</p>
    public let outputId: String?

    public init (
        destinationSchema: DestinationSchema? = nil,
        kinesisFirehoseOutputDescription: KinesisFirehoseOutputDescription? = nil,
        kinesisStreamsOutputDescription: KinesisStreamsOutputDescription? = nil,
        lambdaOutputDescription: LambdaOutputDescription? = nil,
        name: String? = nil,
        outputId: String? = nil
    )
    {
        self.destinationSchema = destinationSchema
        self.kinesisFirehoseOutputDescription = kinesisFirehoseOutputDescription
        self.kinesisStreamsOutputDescription = kinesisStreamsOutputDescription
        self.lambdaOutputDescription = lambdaOutputDescription
        self.name = name
        self.outputId = outputId
    }
}

extension OutputUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationSchemaUpdate = "DestinationSchemaUpdate"
        case kinesisFirehoseOutputUpdate = "KinesisFirehoseOutputUpdate"
        case kinesisStreamsOutputUpdate = "KinesisStreamsOutputUpdate"
        case lambdaOutputUpdate = "LambdaOutputUpdate"
        case nameUpdate = "NameUpdate"
        case outputId = "OutputId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationSchemaUpdate = destinationSchemaUpdate {
            try encodeContainer.encode(destinationSchemaUpdate, forKey: .destinationSchemaUpdate)
        }
        if let kinesisFirehoseOutputUpdate = kinesisFirehoseOutputUpdate {
            try encodeContainer.encode(kinesisFirehoseOutputUpdate, forKey: .kinesisFirehoseOutputUpdate)
        }
        if let kinesisStreamsOutputUpdate = kinesisStreamsOutputUpdate {
            try encodeContainer.encode(kinesisStreamsOutputUpdate, forKey: .kinesisStreamsOutputUpdate)
        }
        if let lambdaOutputUpdate = lambdaOutputUpdate {
            try encodeContainer.encode(lambdaOutputUpdate, forKey: .lambdaOutputUpdate)
        }
        if let nameUpdate = nameUpdate {
            try encodeContainer.encode(nameUpdate, forKey: .nameUpdate)
        }
        if let outputId = outputId {
            try encodeContainer.encode(outputId, forKey: .outputId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputId)
        outputId = outputIdDecoded
        let nameUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nameUpdate)
        nameUpdate = nameUpdateDecoded
        let kinesisStreamsOutputUpdateDecoded = try containerValues.decodeIfPresent(KinesisStreamsOutputUpdate.self, forKey: .kinesisStreamsOutputUpdate)
        kinesisStreamsOutputUpdate = kinesisStreamsOutputUpdateDecoded
        let kinesisFirehoseOutputUpdateDecoded = try containerValues.decodeIfPresent(KinesisFirehoseOutputUpdate.self, forKey: .kinesisFirehoseOutputUpdate)
        kinesisFirehoseOutputUpdate = kinesisFirehoseOutputUpdateDecoded
        let lambdaOutputUpdateDecoded = try containerValues.decodeIfPresent(LambdaOutputUpdate.self, forKey: .lambdaOutputUpdate)
        lambdaOutputUpdate = lambdaOutputUpdateDecoded
        let destinationSchemaUpdateDecoded = try containerValues.decodeIfPresent(DestinationSchema.self, forKey: .destinationSchemaUpdate)
        destinationSchemaUpdate = destinationSchemaUpdateDecoded
    }
}

extension OutputUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputUpdate(destinationSchemaUpdate: \(String(describing: destinationSchemaUpdate)), kinesisFirehoseOutputUpdate: \(String(describing: kinesisFirehoseOutputUpdate)), kinesisStreamsOutputUpdate: \(String(describing: kinesisStreamsOutputUpdate)), lambdaOutputUpdate: \(String(describing: lambdaOutputUpdate)), nameUpdate: \(String(describing: nameUpdate)), outputId: \(String(describing: outputId)))"}
}

/// <p> For a SQL-based Kinesis Data Analytics application, describes updates to the
///       output configuration identified by the <code>OutputId</code>. </p>
public struct OutputUpdate: Equatable {
    /// <p>Describes the data format when records are written to the destination.
    ///       </p>
    public let destinationSchemaUpdate: DestinationSchema?
    /// <p>Describes a Kinesis Data Firehose delivery stream as the destination for the
    ///       output.</p>
    public let kinesisFirehoseOutputUpdate: KinesisFirehoseOutputUpdate?
    /// <p>Describes a Kinesis data stream as the destination for the output.</p>
    public let kinesisStreamsOutputUpdate: KinesisStreamsOutputUpdate?
    /// <p>Describes an AWS Lambda function as the destination for the output.</p>
    public let lambdaOutputUpdate: LambdaOutputUpdate?
    /// <p>If you want to specify a different in-application stream
    ///       for this output configuration, use this field to
    ///       specify the new in-application stream name.</p>
    public let nameUpdate: String?
    /// <p>Identifies the specific output configuration that you want to update.</p>
    public let outputId: String?

    public init (
        destinationSchemaUpdate: DestinationSchema? = nil,
        kinesisFirehoseOutputUpdate: KinesisFirehoseOutputUpdate? = nil,
        kinesisStreamsOutputUpdate: KinesisStreamsOutputUpdate? = nil,
        lambdaOutputUpdate: LambdaOutputUpdate? = nil,
        nameUpdate: String? = nil,
        outputId: String? = nil
    )
    {
        self.destinationSchemaUpdate = destinationSchemaUpdate
        self.kinesisFirehoseOutputUpdate = kinesisFirehoseOutputUpdate
        self.kinesisStreamsOutputUpdate = kinesisStreamsOutputUpdate
        self.lambdaOutputUpdate = lambdaOutputUpdate
        self.nameUpdate = nameUpdate
        self.outputId = outputId
    }
}

extension ParallelismConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingEnabled = "AutoScalingEnabled"
        case configurationType = "ConfigurationType"
        case parallelism = "Parallelism"
        case parallelismPerKPU = "ParallelismPerKPU"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingEnabled = autoScalingEnabled {
            try encodeContainer.encode(autoScalingEnabled, forKey: .autoScalingEnabled)
        }
        if let configurationType = configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let parallelism = parallelism {
            try encodeContainer.encode(parallelism, forKey: .parallelism)
        }
        if let parallelismPerKPU = parallelismPerKPU {
            try encodeContainer.encode(parallelismPerKPU, forKey: .parallelismPerKPU)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(ConfigurationType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let parallelismDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelism)
        parallelism = parallelismDecoded
        let parallelismPerKPUDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelismPerKPU)
        parallelismPerKPU = parallelismPerKPUDecoded
        let autoScalingEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoScalingEnabled)
        autoScalingEnabled = autoScalingEnabledDecoded
    }
}

extension ParallelismConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParallelismConfiguration(autoScalingEnabled: \(String(describing: autoScalingEnabled)), configurationType: \(String(describing: configurationType)), parallelism: \(String(describing: parallelism)), parallelismPerKPU: \(String(describing: parallelismPerKPU)))"}
}

/// <p>Describes parameters for how a Flink-based Kinesis Data Analytics application
///       executes multiple tasks simultaneously. For more information about parallelism,
///       see <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/dev/parallel.html">Parallel Execution</a> in the <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/">Apache Flink
///         Documentation</a>.</p>
public struct ParallelismConfiguration: Equatable {
    /// <p>Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.</p>
    public let autoScalingEnabled: Bool?
    /// <p>Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. You must set this property to <code>CUSTOM</code>
    ///     in order to change your application's <code>AutoScalingEnabled</code>, <code>Parallelism</code>, or <code>ParallelismPerKPU</code> properties.</p>
    public let configurationType: ConfigurationType?
    /// <p>Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform. If <code>AutoScalingEnabled</code>
    ///       is set to True, Kinesis Data Analytics increases the <code>CurrentParallelism</code> value in response to application
    ///     load. The service can increase the <code>CurrentParallelism</code> value up to the maximum parallelism, which is
    ///       <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
    ///     The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If
    ///     application load is reduced, the service can
    ///     reduce the <code>CurrentParallelism</code> value down to the <code>Parallelism</code> setting.</p>
    public let parallelism: Int?
    /// <p>Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit
    ///       (KPU) used by the application. For more
    ///       information about KPUs, see <a href="http://aws.amazon.com/kinesis/data-analytics/pricing/">Amazon Kinesis Data Analytics Pricing</a>.</p>
    public let parallelismPerKPU: Int?

    public init (
        autoScalingEnabled: Bool? = nil,
        configurationType: ConfigurationType? = nil,
        parallelism: Int? = nil,
        parallelismPerKPU: Int? = nil
    )
    {
        self.autoScalingEnabled = autoScalingEnabled
        self.configurationType = configurationType
        self.parallelism = parallelism
        self.parallelismPerKPU = parallelismPerKPU
    }
}

extension ParallelismConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingEnabled = "AutoScalingEnabled"
        case configurationType = "ConfigurationType"
        case currentParallelism = "CurrentParallelism"
        case parallelism = "Parallelism"
        case parallelismPerKPU = "ParallelismPerKPU"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingEnabled = autoScalingEnabled {
            try encodeContainer.encode(autoScalingEnabled, forKey: .autoScalingEnabled)
        }
        if let configurationType = configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let currentParallelism = currentParallelism {
            try encodeContainer.encode(currentParallelism, forKey: .currentParallelism)
        }
        if let parallelism = parallelism {
            try encodeContainer.encode(parallelism, forKey: .parallelism)
        }
        if let parallelismPerKPU = parallelismPerKPU {
            try encodeContainer.encode(parallelismPerKPU, forKey: .parallelismPerKPU)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(ConfigurationType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let parallelismDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelism)
        parallelism = parallelismDecoded
        let parallelismPerKPUDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelismPerKPU)
        parallelismPerKPU = parallelismPerKPUDecoded
        let currentParallelismDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentParallelism)
        currentParallelism = currentParallelismDecoded
        let autoScalingEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoScalingEnabled)
        autoScalingEnabled = autoScalingEnabledDecoded
    }
}

extension ParallelismConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParallelismConfigurationDescription(autoScalingEnabled: \(String(describing: autoScalingEnabled)), configurationType: \(String(describing: configurationType)), currentParallelism: \(String(describing: currentParallelism)), parallelism: \(String(describing: parallelism)), parallelismPerKPU: \(String(describing: parallelismPerKPU)))"}
}

/// <p>Describes parameters for how a Flink-based Kinesis Data Analytics application
///       executes multiple tasks simultaneously.</p>
public struct ParallelismConfigurationDescription: Equatable {
    /// <p>Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.</p>
    public let autoScalingEnabled: Bool?
    /// <p>Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. </p>
    public let configurationType: ConfigurationType?
    /// <p>Describes the current number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
    ///       If <code>AutoScalingEnabled</code> is set to True, Kinesis Data Analytics can increase this value in response to application
    ///     load. The service can increase this value up to the maximum parallelism, which is <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
    ///     The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can reduce
    ///     the <code>CurrentParallelism</code> value down to the <code>Parallelism</code> setting.</p>
    public let currentParallelism: Int?
    /// <p>Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
    ///       If <code>AutoScalingEnabled</code> is set to True, then Kinesis Data Analytics can increase the <code>CurrentParallelism</code> value in response to application
    ///     load. The service can increase <code>CurrentParallelism</code> up to the maximum parallelism, which is <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
    ///     The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service can
    ///     reduce the <code>CurrentParallelism</code> value down to the <code>Parallelism</code> setting.</p>
    public let parallelism: Int?
    /// <p>Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per
    ///       Kinesis Processing Unit (KPU) used by the application.</p>
    public let parallelismPerKPU: Int?

    public init (
        autoScalingEnabled: Bool? = nil,
        configurationType: ConfigurationType? = nil,
        currentParallelism: Int? = nil,
        parallelism: Int? = nil,
        parallelismPerKPU: Int? = nil
    )
    {
        self.autoScalingEnabled = autoScalingEnabled
        self.configurationType = configurationType
        self.currentParallelism = currentParallelism
        self.parallelism = parallelism
        self.parallelismPerKPU = parallelismPerKPU
    }
}

extension ParallelismConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingEnabledUpdate = "AutoScalingEnabledUpdate"
        case configurationTypeUpdate = "ConfigurationTypeUpdate"
        case parallelismPerKPUUpdate = "ParallelismPerKPUUpdate"
        case parallelismUpdate = "ParallelismUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingEnabledUpdate = autoScalingEnabledUpdate {
            try encodeContainer.encode(autoScalingEnabledUpdate, forKey: .autoScalingEnabledUpdate)
        }
        if let configurationTypeUpdate = configurationTypeUpdate {
            try encodeContainer.encode(configurationTypeUpdate.rawValue, forKey: .configurationTypeUpdate)
        }
        if let parallelismPerKPUUpdate = parallelismPerKPUUpdate {
            try encodeContainer.encode(parallelismPerKPUUpdate, forKey: .parallelismPerKPUUpdate)
        }
        if let parallelismUpdate = parallelismUpdate {
            try encodeContainer.encode(parallelismUpdate, forKey: .parallelismUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeUpdateDecoded = try containerValues.decodeIfPresent(ConfigurationType.self, forKey: .configurationTypeUpdate)
        configurationTypeUpdate = configurationTypeUpdateDecoded
        let parallelismUpdateDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelismUpdate)
        parallelismUpdate = parallelismUpdateDecoded
        let parallelismPerKPUUpdateDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelismPerKPUUpdate)
        parallelismPerKPUUpdate = parallelismPerKPUUpdateDecoded
        let autoScalingEnabledUpdateDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoScalingEnabledUpdate)
        autoScalingEnabledUpdate = autoScalingEnabledUpdateDecoded
    }
}

extension ParallelismConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParallelismConfigurationUpdate(autoScalingEnabledUpdate: \(String(describing: autoScalingEnabledUpdate)), configurationTypeUpdate: \(String(describing: configurationTypeUpdate)), parallelismPerKPUUpdate: \(String(describing: parallelismPerKPUUpdate)), parallelismUpdate: \(String(describing: parallelismUpdate)))"}
}

/// <p>Describes updates to parameters for how an application executes multiple tasks simultaneously.</p>
public struct ParallelismConfigurationUpdate: Equatable {
    /// <p>Describes updates to whether the Kinesis Data Analytics service can increase the parallelism of a Flink-based Kinesis Data Analytics application in response to increased throughput.</p>
    public let autoScalingEnabledUpdate: Bool?
    /// <p>Describes updates to whether the application uses the default parallelism for the Kinesis Data Analytics service, or if a custom parallelism is used.
    ///     You must set this property to <code>CUSTOM</code>
    ///     in order to change your application's <code>AutoScalingEnabled</code>, <code>Parallelism</code>, or <code>ParallelismPerKPU</code> properties.</p>
    public let configurationTypeUpdate: ConfigurationType?
    /// <p>Describes updates to the number of parallel tasks an application can perform per Kinesis Processing Unit (KPU) used by the application.</p>
    public let parallelismPerKPUUpdate: Int?
    /// <p>Describes updates to the initial number of parallel tasks an application can perform. If <code>AutoScalingEnabled</code> is set to True, then
    ///       Kinesis Data Analytics can increase the <code>CurrentParallelism</code> value in response to application
    ///     load. The service can increase <code>CurrentParallelism</code> up to the maximum parallelism, which is <code>ParalellismPerKPU</code> times the maximum KPUs for the application.
    ///     The maximum KPUs for an application is 32 by default, and can be increased by requesting a limit increase. If application load is reduced, the service will
    ///     reduce <code>CurrentParallelism</code> down to the <code>Parallelism</code> setting.</p>
    public let parallelismUpdate: Int?

    public init (
        autoScalingEnabledUpdate: Bool? = nil,
        configurationTypeUpdate: ConfigurationType? = nil,
        parallelismPerKPUUpdate: Int? = nil,
        parallelismUpdate: Int? = nil
    )
    {
        self.autoScalingEnabledUpdate = autoScalingEnabledUpdate
        self.configurationTypeUpdate = configurationTypeUpdate
        self.parallelismPerKPUUpdate = parallelismPerKPUUpdate
        self.parallelismUpdate = parallelismUpdate
    }
}

extension PropertyGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case propertyGroupId = "PropertyGroupId"
        case propertyMap = "PropertyMap"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let propertyGroupId = propertyGroupId {
            try encodeContainer.encode(propertyGroupId, forKey: .propertyGroupId)
        }
        if let propertyMap = propertyMap {
            var propertyMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .propertyMap)
            for (dictKey0, propertymap0) in propertyMap {
                try propertyMapContainer.encode(propertymap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .propertyGroupId)
        propertyGroupId = propertyGroupIdDecoded
        let propertyMapContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .propertyMap)
        var propertyMapDecoded0: [String:String]? = nil
        if let propertyMapContainer = propertyMapContainer {
            propertyMapDecoded0 = [String:String]()
            for (key0, propertyvalue0) in propertyMapContainer {
                if let propertyvalue0 = propertyvalue0 {
                    propertyMapDecoded0?[key0] = propertyvalue0
                }
            }
        }
        propertyMap = propertyMapDecoded0
    }
}

extension PropertyGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PropertyGroup(propertyGroupId: \(String(describing: propertyGroupId)), propertyMap: \(String(describing: propertyMap)))"}
}

/// <p>Property key-value pairs passed into an application.</p>
public struct PropertyGroup: Equatable {
    /// <p>Describes the key of an application execution property key-value pair.</p>
    public let propertyGroupId: String?
    /// <p>Describes the value of an application execution property key-value pair.</p>
    public let propertyMap: [String:String]?

    public init (
        propertyGroupId: String? = nil,
        propertyMap: [String:String]? = nil
    )
    {
        self.propertyGroupId = propertyGroupId
        self.propertyMap = propertyMap
    }
}

extension RecordColumn: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mapping = "Mapping"
        case name = "Name"
        case sqlType = "SqlType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mapping = mapping {
            try encodeContainer.encode(mapping, forKey: .mapping)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sqlType = sqlType {
            try encodeContainer.encode(sqlType, forKey: .sqlType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let mappingDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mapping)
        mapping = mappingDecoded
        let sqlTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sqlType)
        sqlType = sqlTypeDecoded
    }
}

extension RecordColumn: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecordColumn(mapping: \(String(describing: mapping)), name: \(String(describing: name)), sqlType: \(String(describing: sqlType)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes the mapping of each
///       data element in the streaming source to the corresponding column in the in-application
///       stream.</p>
///          <p>Also used to describe the format of the reference data source.</p>
public struct RecordColumn: Equatable {
    /// <p>A reference to the data element in the streaming input or the reference data
    ///       source.</p>
    public let mapping: String?
    /// <p>The name of the column that is created in the in-application input stream or reference
    ///       table.</p>
    public let name: String?
    /// <p>The type of column created in the in-application input stream or reference table.</p>
    public let sqlType: String?

    public init (
        mapping: String? = nil,
        name: String? = nil,
        sqlType: String? = nil
    )
    {
        self.mapping = mapping
        self.name = name
        self.sqlType = sqlType
    }
}

extension RecordFormat: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mappingParameters = "MappingParameters"
        case recordFormatType = "RecordFormatType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mappingParameters = mappingParameters {
            try encodeContainer.encode(mappingParameters, forKey: .mappingParameters)
        }
        if let recordFormatType = recordFormatType {
            try encodeContainer.encode(recordFormatType.rawValue, forKey: .recordFormatType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordFormatTypeDecoded = try containerValues.decodeIfPresent(RecordFormatType.self, forKey: .recordFormatType)
        recordFormatType = recordFormatTypeDecoded
        let mappingParametersDecoded = try containerValues.decodeIfPresent(MappingParameters.self, forKey: .mappingParameters)
        mappingParameters = mappingParametersDecoded
    }
}

extension RecordFormat: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecordFormat(mappingParameters: \(String(describing: mappingParameters)), recordFormatType: \(String(describing: recordFormatType)))"}
}

/// <p> For a SQL-based Kinesis Data Analytics application, describes the record format
///       and relevant mapping information that should be applied to schematize the records on the
///       stream. </p>
public struct RecordFormat: Equatable {
    /// <p>When you configure application input at the time of creating or updating an application,
    ///       provides additional mapping information specific to the record format (such as JSON, CSV, or
    ///       record fields delimited by some delimiter) on the streaming source.</p>
    public let mappingParameters: MappingParameters?
    /// <p>The type of record format.</p>
    public let recordFormatType: RecordFormatType?

    public init (
        mappingParameters: MappingParameters? = nil,
        recordFormatType: RecordFormatType? = nil
    )
    {
        self.mappingParameters = mappingParameters
        self.recordFormatType = recordFormatType
    }
}

public enum RecordFormatType {
    case csv
    case json
    case sdkUnknown(String)
}

extension RecordFormatType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RecordFormatType] {
        return [
            .csv,
            .json,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case .json: return "JSON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RecordFormatType(rawValue: rawValue) ?? RecordFormatType.sdkUnknown(rawValue)
    }
}

extension ReferenceDataSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case referenceSchema = "ReferenceSchema"
        case s3ReferenceDataSource = "S3ReferenceDataSource"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referenceSchema = referenceSchema {
            try encodeContainer.encode(referenceSchema, forKey: .referenceSchema)
        }
        if let s3ReferenceDataSource = s3ReferenceDataSource {
            try encodeContainer.encode(s3ReferenceDataSource, forKey: .s3ReferenceDataSource)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let s3ReferenceDataSourceDecoded = try containerValues.decodeIfPresent(S3ReferenceDataSource.self, forKey: .s3ReferenceDataSource)
        s3ReferenceDataSource = s3ReferenceDataSourceDecoded
        let referenceSchemaDecoded = try containerValues.decodeIfPresent(SourceSchema.self, forKey: .referenceSchema)
        referenceSchema = referenceSchemaDecoded
    }
}

extension ReferenceDataSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReferenceDataSource(referenceSchema: \(String(describing: referenceSchema)), s3ReferenceDataSource: \(String(describing: s3ReferenceDataSource)), tableName: \(String(describing: tableName)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes the reference data
///       source by providing the source information (Amazon S3 bucket name and object key name), the
///       resulting in-application table name that is created, and the necessary schema to map the data
///       elements in the Amazon S3 object to the in-application table.</p>
public struct ReferenceDataSource: Equatable {
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.</p>
    public let referenceSchema: SourceSchema?
    /// <p>Identifies the S3 bucket and object that contains the reference data.
    ///
    ///       A Kinesis Data Analytics application loads reference data only once. If the data changes, you call the <a>UpdateApplication</a> operation to trigger reloading of data into your application. </p>
    public let s3ReferenceDataSource: S3ReferenceDataSource?
    /// <p>The name of the in-application table to create.</p>
    public let tableName: String?

    public init (
        referenceSchema: SourceSchema? = nil,
        s3ReferenceDataSource: S3ReferenceDataSource? = nil,
        tableName: String? = nil
    )
    {
        self.referenceSchema = referenceSchema
        self.s3ReferenceDataSource = s3ReferenceDataSource
        self.tableName = tableName
    }
}

extension ReferenceDataSourceDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case referenceId = "ReferenceId"
        case referenceSchema = "ReferenceSchema"
        case s3ReferenceDataSourceDescription = "S3ReferenceDataSourceDescription"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let referenceSchema = referenceSchema {
            try encodeContainer.encode(referenceSchema, forKey: .referenceSchema)
        }
        if let s3ReferenceDataSourceDescription = s3ReferenceDataSourceDescription {
            try encodeContainer.encode(s3ReferenceDataSourceDescription, forKey: .s3ReferenceDataSourceDescription)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let s3ReferenceDataSourceDescriptionDecoded = try containerValues.decodeIfPresent(S3ReferenceDataSourceDescription.self, forKey: .s3ReferenceDataSourceDescription)
        s3ReferenceDataSourceDescription = s3ReferenceDataSourceDescriptionDecoded
        let referenceSchemaDecoded = try containerValues.decodeIfPresent(SourceSchema.self, forKey: .referenceSchema)
        referenceSchema = referenceSchemaDecoded
    }
}

extension ReferenceDataSourceDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReferenceDataSourceDescription(referenceId: \(String(describing: referenceId)), referenceSchema: \(String(describing: referenceSchema)), s3ReferenceDataSourceDescription: \(String(describing: s3ReferenceDataSourceDescription)), tableName: \(String(describing: tableName)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes the reference data
///       source configured for an application.</p>
public struct ReferenceDataSourceDescription: Equatable {
    /// <p>The ID of the reference data source. This is the ID that Kinesis Data Analytics assigns
    ///       when you add the reference data source to your application using the <a>CreateApplication</a> or <a>UpdateApplication</a> operation.</p>
    public let referenceId: String?
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.</p>
    public let referenceSchema: SourceSchema?
    /// <p>Provides the Amazon S3 bucket name, the object key name that contains the reference data. </p>
    public let s3ReferenceDataSourceDescription: S3ReferenceDataSourceDescription?
    /// <p>The in-application table name created by the specific reference data source configuration.</p>
    public let tableName: String?

    public init (
        referenceId: String? = nil,
        referenceSchema: SourceSchema? = nil,
        s3ReferenceDataSourceDescription: S3ReferenceDataSourceDescription? = nil,
        tableName: String? = nil
    )
    {
        self.referenceId = referenceId
        self.referenceSchema = referenceSchema
        self.s3ReferenceDataSourceDescription = s3ReferenceDataSourceDescription
        self.tableName = tableName
    }
}

extension ReferenceDataSourceUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case referenceId = "ReferenceId"
        case referenceSchemaUpdate = "ReferenceSchemaUpdate"
        case s3ReferenceDataSourceUpdate = "S3ReferenceDataSourceUpdate"
        case tableNameUpdate = "TableNameUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let referenceSchemaUpdate = referenceSchemaUpdate {
            try encodeContainer.encode(referenceSchemaUpdate, forKey: .referenceSchemaUpdate)
        }
        if let s3ReferenceDataSourceUpdate = s3ReferenceDataSourceUpdate {
            try encodeContainer.encode(s3ReferenceDataSourceUpdate, forKey: .s3ReferenceDataSourceUpdate)
        }
        if let tableNameUpdate = tableNameUpdate {
            try encodeContainer.encode(tableNameUpdate, forKey: .tableNameUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let tableNameUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableNameUpdate)
        tableNameUpdate = tableNameUpdateDecoded
        let s3ReferenceDataSourceUpdateDecoded = try containerValues.decodeIfPresent(S3ReferenceDataSourceUpdate.self, forKey: .s3ReferenceDataSourceUpdate)
        s3ReferenceDataSourceUpdate = s3ReferenceDataSourceUpdateDecoded
        let referenceSchemaUpdateDecoded = try containerValues.decodeIfPresent(SourceSchema.self, forKey: .referenceSchemaUpdate)
        referenceSchemaUpdate = referenceSchemaUpdateDecoded
    }
}

extension ReferenceDataSourceUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReferenceDataSourceUpdate(referenceId: \(String(describing: referenceId)), referenceSchemaUpdate: \(String(describing: referenceSchemaUpdate)), s3ReferenceDataSourceUpdate: \(String(describing: s3ReferenceDataSourceUpdate)), tableNameUpdate: \(String(describing: tableNameUpdate)))"}
}

/// <p>When you update a reference data source configuration for a
///        SQL-based Kinesis Data Analytics application, this object provides all the updated values
///       (such as the source bucket name and object key name), the in-application table name that is created,
///       and updated mapping information that maps the data in the Amazon S3 object to the in-application
///       reference table that is created.</p>
public struct ReferenceDataSourceUpdate: Equatable {
    /// <p>The ID of the reference data source that is being updated. You can use the <a>DescribeApplication</a> operation to get this value.</p>
    public let referenceId: String?
    /// <p>Describes the format of the data in the streaming source, and how each data element maps to
    ///       corresponding columns created in the in-application stream. </p>
    public let referenceSchemaUpdate: SourceSchema?
    /// <p>Describes the S3 bucket name, object key name, and IAM role that Kinesis Data Analytics can assume to read the
    ///       Amazon S3 object on your behalf and populate the in-application reference table.</p>
    public let s3ReferenceDataSourceUpdate: S3ReferenceDataSourceUpdate?
    /// <p>The in-application table name that is created by this update.</p>
    public let tableNameUpdate: String?

    public init (
        referenceId: String? = nil,
        referenceSchemaUpdate: SourceSchema? = nil,
        s3ReferenceDataSourceUpdate: S3ReferenceDataSourceUpdate? = nil,
        tableNameUpdate: String? = nil
    )
    {
        self.referenceId = referenceId
        self.referenceSchemaUpdate = referenceSchemaUpdate
        self.s3ReferenceDataSourceUpdate = s3ReferenceDataSourceUpdate
        self.tableNameUpdate = tableNameUpdate
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The application is not available for this operation.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Specified application can't be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceProvisionedThroughputExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceProvisionedThroughputExceededException(message: \(String(describing: message)))"}
}

extension ResourceProvisionedThroughputExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceProvisionedThroughputExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Discovery failed to get a record from the streaming source because of the Kinesis
///       Streams <code>ProvisionedThroughputExceededException</code>. For more information, see <a href="http://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetRecords.html">GetRecords</a> in the Amazon Kinesis Streams API Reference.</p>
public struct ResourceProvisionedThroughputExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceProvisionedThroughputExceededExceptionBody: Equatable {
    public let message: String?
}

extension ResourceProvisionedThroughputExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RollbackApplicationInputBodyMiddleware: Middleware {
    public let id: String = "RollbackApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RollbackApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<RollbackApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RollbackApplicationInput>
    public typealias MOutput = OperationOutput<RollbackApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RollbackApplicationOutputError>
}

extension RollbackApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RollbackApplicationInput(applicationName: \(String(describing: applicationName)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)))"}
}

extension RollbackApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
    }
}

public struct RollbackApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "RollbackApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RollbackApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<RollbackApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RollbackApplicationInput>
    public typealias MOutput = OperationOutput<RollbackApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RollbackApplicationOutputError>
}

public struct RollbackApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "RollbackApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RollbackApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<RollbackApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RollbackApplicationInput>
    public typealias MOutput = OperationOutput<RollbackApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RollbackApplicationOutputError>
}

public struct RollbackApplicationInput: Equatable {
    /// <p>The name of the application.</p>
    public let applicationName: String?
    /// <p>The current application version ID. You can retrieve the application version ID using
    ///             <a>DescribeApplication</a>.</p>
    public let currentApplicationVersionId: Int?

    public init (
        applicationName: String? = nil,
        currentApplicationVersionId: Int? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

struct RollbackApplicationInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
}

extension RollbackApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
    }
}

extension RollbackApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RollbackApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RollbackApplicationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RollbackApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RollbackApplicationOutputResponse(applicationDetail: \(String(describing: applicationDetail)))"}
}

extension RollbackApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RollbackApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationDetail = output.applicationDetail
        } else {
            self.applicationDetail = nil
        }
    }
}

public struct RollbackApplicationOutputResponse: Equatable {
    /// <p>Describes the application, including the application Amazon Resource Name (ARN), status,
    ///       latest version, and input and output configurations.</p>
    public let applicationDetail: ApplicationDetail?

    public init (
        applicationDetail: ApplicationDetail? = nil
    )
    {
        self.applicationDetail = applicationDetail
    }
}

struct RollbackApplicationOutputResponseBody: Equatable {
    public let applicationDetail: ApplicationDetail?
}

extension RollbackApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationDetail = "ApplicationDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDetailDecoded = try containerValues.decodeIfPresent(ApplicationDetail.self, forKey: .applicationDetail)
        applicationDetail = applicationDetailDecoded
    }
}

extension RunConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationRestoreConfiguration = "ApplicationRestoreConfiguration"
        case flinkRunConfiguration = "FlinkRunConfiguration"
        case sqlRunConfigurations = "SqlRunConfigurations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationRestoreConfiguration = applicationRestoreConfiguration {
            try encodeContainer.encode(applicationRestoreConfiguration, forKey: .applicationRestoreConfiguration)
        }
        if let flinkRunConfiguration = flinkRunConfiguration {
            try encodeContainer.encode(flinkRunConfiguration, forKey: .flinkRunConfiguration)
        }
        if let sqlRunConfigurations = sqlRunConfigurations {
            var sqlRunConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sqlRunConfigurations)
            for sqlrunconfigurations0 in sqlRunConfigurations {
                try sqlRunConfigurationsContainer.encode(sqlrunconfigurations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flinkRunConfigurationDecoded = try containerValues.decodeIfPresent(FlinkRunConfiguration.self, forKey: .flinkRunConfiguration)
        flinkRunConfiguration = flinkRunConfigurationDecoded
        let sqlRunConfigurationsContainer = try containerValues.decodeIfPresent([SqlRunConfiguration?].self, forKey: .sqlRunConfigurations)
        var sqlRunConfigurationsDecoded0:[SqlRunConfiguration]? = nil
        if let sqlRunConfigurationsContainer = sqlRunConfigurationsContainer {
            sqlRunConfigurationsDecoded0 = [SqlRunConfiguration]()
            for structure0 in sqlRunConfigurationsContainer {
                if let structure0 = structure0 {
                    sqlRunConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sqlRunConfigurations = sqlRunConfigurationsDecoded0
        let applicationRestoreConfigurationDecoded = try containerValues.decodeIfPresent(ApplicationRestoreConfiguration.self, forKey: .applicationRestoreConfiguration)
        applicationRestoreConfiguration = applicationRestoreConfigurationDecoded
    }
}

extension RunConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RunConfiguration(applicationRestoreConfiguration: \(String(describing: applicationRestoreConfiguration)), flinkRunConfiguration: \(String(describing: flinkRunConfiguration)), sqlRunConfigurations: \(String(describing: sqlRunConfigurations)))"}
}

/// <p>Describes the starting parameters for an Kinesis Data Analytics application.</p>
public struct RunConfiguration: Equatable {
    /// <p>Describes the restore behavior of a restarting application.</p>
    public let applicationRestoreConfiguration: ApplicationRestoreConfiguration?
    /// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
    public let flinkRunConfiguration: FlinkRunConfiguration?
    /// <p>Describes the starting parameters for a SQL-based Kinesis Data Analytics application
    ///       application.</p>
    public let sqlRunConfigurations: [SqlRunConfiguration]?

    public init (
        applicationRestoreConfiguration: ApplicationRestoreConfiguration? = nil,
        flinkRunConfiguration: FlinkRunConfiguration? = nil,
        sqlRunConfigurations: [SqlRunConfiguration]? = nil
    )
    {
        self.applicationRestoreConfiguration = applicationRestoreConfiguration
        self.flinkRunConfiguration = flinkRunConfiguration
        self.sqlRunConfigurations = sqlRunConfigurations
    }
}

extension RunConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationRestoreConfigurationDescription = "ApplicationRestoreConfigurationDescription"
        case flinkRunConfigurationDescription = "FlinkRunConfigurationDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationRestoreConfigurationDescription = applicationRestoreConfigurationDescription {
            try encodeContainer.encode(applicationRestoreConfigurationDescription, forKey: .applicationRestoreConfigurationDescription)
        }
        if let flinkRunConfigurationDescription = flinkRunConfigurationDescription {
            try encodeContainer.encode(flinkRunConfigurationDescription, forKey: .flinkRunConfigurationDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationRestoreConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(ApplicationRestoreConfiguration.self, forKey: .applicationRestoreConfigurationDescription)
        applicationRestoreConfigurationDescription = applicationRestoreConfigurationDescriptionDecoded
        let flinkRunConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(FlinkRunConfiguration.self, forKey: .flinkRunConfigurationDescription)
        flinkRunConfigurationDescription = flinkRunConfigurationDescriptionDecoded
    }
}

extension RunConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RunConfigurationDescription(applicationRestoreConfigurationDescription: \(String(describing: applicationRestoreConfigurationDescription)), flinkRunConfigurationDescription: \(String(describing: flinkRunConfigurationDescription)))"}
}

/// <p>Describes the starting properties for a Kinesis Data Analytics application.</p>
public struct RunConfigurationDescription: Equatable {
    /// <p>Describes the restore behavior of a restarting application.</p>
    public let applicationRestoreConfigurationDescription: ApplicationRestoreConfiguration?
    /// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
    public let flinkRunConfigurationDescription: FlinkRunConfiguration?

    public init (
        applicationRestoreConfigurationDescription: ApplicationRestoreConfiguration? = nil,
        flinkRunConfigurationDescription: FlinkRunConfiguration? = nil
    )
    {
        self.applicationRestoreConfigurationDescription = applicationRestoreConfigurationDescription
        self.flinkRunConfigurationDescription = flinkRunConfigurationDescription
    }
}

extension RunConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationRestoreConfiguration = "ApplicationRestoreConfiguration"
        case flinkRunConfiguration = "FlinkRunConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationRestoreConfiguration = applicationRestoreConfiguration {
            try encodeContainer.encode(applicationRestoreConfiguration, forKey: .applicationRestoreConfiguration)
        }
        if let flinkRunConfiguration = flinkRunConfiguration {
            try encodeContainer.encode(flinkRunConfiguration, forKey: .flinkRunConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flinkRunConfigurationDecoded = try containerValues.decodeIfPresent(FlinkRunConfiguration.self, forKey: .flinkRunConfiguration)
        flinkRunConfiguration = flinkRunConfigurationDecoded
        let applicationRestoreConfigurationDecoded = try containerValues.decodeIfPresent(ApplicationRestoreConfiguration.self, forKey: .applicationRestoreConfiguration)
        applicationRestoreConfiguration = applicationRestoreConfigurationDecoded
    }
}

extension RunConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RunConfigurationUpdate(applicationRestoreConfiguration: \(String(describing: applicationRestoreConfiguration)), flinkRunConfiguration: \(String(describing: flinkRunConfiguration)))"}
}

/// <p>Describes the updates to the starting parameters for a Kinesis Data Analytics application.</p>
public struct RunConfigurationUpdate: Equatable {
    /// <p>Describes updates to the restore behavior of a restarting application.</p>
    public let applicationRestoreConfiguration: ApplicationRestoreConfiguration?
    /// <p>Describes the starting parameters for a Flink-based Kinesis Data Analytics application.</p>
    public let flinkRunConfiguration: FlinkRunConfiguration?

    public init (
        applicationRestoreConfiguration: ApplicationRestoreConfiguration? = nil,
        flinkRunConfiguration: FlinkRunConfiguration? = nil
    )
    {
        self.applicationRestoreConfiguration = applicationRestoreConfiguration
        self.flinkRunConfiguration = flinkRunConfiguration
    }
}

public enum RuntimeEnvironment {
    case flink111
    case flink16
    case flink18
    case sql10
    case zeppelinFlink10
    case sdkUnknown(String)
}

extension RuntimeEnvironment : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RuntimeEnvironment] {
        return [
            .flink111,
            .flink16,
            .flink18,
            .sql10,
            .zeppelinFlink10,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .flink111: return "FLINK-1_11"
        case .flink16: return "FLINK-1_6"
        case .flink18: return "FLINK-1_8"
        case .sql10: return "SQL-1_0"
        case .zeppelinFlink10: return "ZEPPELIN-FLINK-1_0"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RuntimeEnvironment(rawValue: rawValue) ?? RuntimeEnvironment.sdkUnknown(rawValue)
    }
}

extension S3ApplicationCodeLocationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketARN = "BucketARN"
        case fileKey = "FileKey"
        case objectVersion = "ObjectVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARN = bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
        if let fileKey = fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
        if let objectVersion = objectVersion {
            try encodeContainer.encode(objectVersion, forKey: .objectVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
        let objectVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectVersion)
        objectVersion = objectVersionDecoded
    }
}

extension S3ApplicationCodeLocationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ApplicationCodeLocationDescription(bucketARN: \(String(describing: bucketARN)), fileKey: \(String(describing: fileKey)), objectVersion: \(String(describing: objectVersion)))"}
}

/// <p>Describes the location of an application's code stored in an S3 bucket.</p>
public struct S3ApplicationCodeLocationDescription: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the S3 bucket containing the application code.</p>
    public let bucketARN: String?
    /// <p>The file key for the object containing the application code.</p>
    public let fileKey: String?
    /// <p>The version of the object containing the application code.</p>
    public let objectVersion: String?

    public init (
        bucketARN: String? = nil,
        fileKey: String? = nil,
        objectVersion: String? = nil
    )
    {
        self.bucketARN = bucketARN
        self.fileKey = fileKey
        self.objectVersion = objectVersion
    }
}

extension S3Configuration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketARN = "BucketARN"
        case fileKey = "FileKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARN = bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
        if let fileKey = fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
    }
}

extension S3Configuration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Configuration(bucketARN: \(String(describing: bucketARN)), fileKey: \(String(describing: fileKey)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, provides a description of an
///       Amazon S3 data source, including the Amazon Resource Name (ARN) of the S3 bucket and the name
///       of the Amazon S3 object that contains the data.</p>
public struct S3Configuration: Equatable {
    /// <p>The ARN of the S3 bucket that contains the data.</p>
    public let bucketARN: String?
    /// <p>The name of the object that contains the data.</p>
    public let fileKey: String?

    public init (
        bucketARN: String? = nil,
        fileKey: String? = nil
    )
    {
        self.bucketARN = bucketARN
        self.fileKey = fileKey
    }
}

extension S3ContentBaseLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case basePath = "BasePath"
        case bucketARN = "BucketARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basePath = basePath {
            try encodeContainer.encode(basePath, forKey: .basePath)
        }
        if let bucketARN = bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let basePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .basePath)
        basePath = basePathDecoded
    }
}

extension S3ContentBaseLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ContentBaseLocation(basePath: \(String(describing: basePath)), bucketARN: \(String(describing: bucketARN)))"}
}

/// <p>The S3 bucket that holds the application information.</p>
public struct S3ContentBaseLocation: Equatable {
    /// <p>The base path for the S3 bucket.</p>
    public let basePath: String?
    /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
    public let bucketARN: String?

    public init (
        basePath: String? = nil,
        bucketARN: String? = nil
    )
    {
        self.basePath = basePath
        self.bucketARN = bucketARN
    }
}

extension S3ContentBaseLocationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case basePath = "BasePath"
        case bucketARN = "BucketARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basePath = basePath {
            try encodeContainer.encode(basePath, forKey: .basePath)
        }
        if let bucketARN = bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let basePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .basePath)
        basePath = basePathDecoded
    }
}

extension S3ContentBaseLocationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ContentBaseLocationDescription(basePath: \(String(describing: basePath)), bucketARN: \(String(describing: bucketARN)))"}
}

/// <p>The description of the S3 base location that holds the application.</p>
public struct S3ContentBaseLocationDescription: Equatable {
    /// <p>The base path for the S3 bucket.</p>
    public let basePath: String?
    /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
    public let bucketARN: String?

    public init (
        basePath: String? = nil,
        bucketARN: String? = nil
    )
    {
        self.basePath = basePath
        self.bucketARN = bucketARN
    }
}

extension S3ContentBaseLocationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case basePathUpdate = "BasePathUpdate"
        case bucketARNUpdate = "BucketARNUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basePathUpdate = basePathUpdate {
            try encodeContainer.encode(basePathUpdate, forKey: .basePathUpdate)
        }
        if let bucketARNUpdate = bucketARNUpdate {
            try encodeContainer.encode(bucketARNUpdate, forKey: .bucketARNUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketARNUpdate)
        bucketARNUpdate = bucketARNUpdateDecoded
        let basePathUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .basePathUpdate)
        basePathUpdate = basePathUpdateDecoded
    }
}

extension S3ContentBaseLocationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ContentBaseLocationUpdate(basePathUpdate: \(String(describing: basePathUpdate)), bucketARNUpdate: \(String(describing: bucketARNUpdate)))"}
}

/// <p>The information required to update the S3 base location that holds the application.</p>
public struct S3ContentBaseLocationUpdate: Equatable {
    /// <p>The updated S3 bucket path.</p>
    public let basePathUpdate: String?
    /// <p>The updated Amazon Resource Name (ARN) of the S3 bucket.</p>
    public let bucketARNUpdate: String?

    public init (
        basePathUpdate: String? = nil,
        bucketARNUpdate: String? = nil
    )
    {
        self.basePathUpdate = basePathUpdate
        self.bucketARNUpdate = bucketARNUpdate
    }
}

extension S3ContentLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketARN = "BucketARN"
        case fileKey = "FileKey"
        case objectVersion = "ObjectVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARN = bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
        if let fileKey = fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
        if let objectVersion = objectVersion {
            try encodeContainer.encode(objectVersion, forKey: .objectVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
        let objectVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectVersion)
        objectVersion = objectVersionDecoded
    }
}

extension S3ContentLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ContentLocation(bucketARN: \(String(describing: bucketARN)), fileKey: \(String(describing: fileKey)), objectVersion: \(String(describing: objectVersion)))"}
}

/// <p>For a Kinesis Data Analytics application provides a
///       description of an Amazon S3 object, including the Amazon Resource Name (ARN) of the S3 bucket,
///       the name of the Amazon S3 object that contains the data, and the version number of the Amazon
///       S3 object that contains the data. </p>
public struct S3ContentLocation: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the S3 bucket containing the application code.</p>
    public let bucketARN: String?
    /// <p>The file key for the object containing the application code.</p>
    public let fileKey: String?
    /// <p>The version of the object containing the application code.</p>
    public let objectVersion: String?

    public init (
        bucketARN: String? = nil,
        fileKey: String? = nil,
        objectVersion: String? = nil
    )
    {
        self.bucketARN = bucketARN
        self.fileKey = fileKey
        self.objectVersion = objectVersion
    }
}

extension S3ContentLocationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketARNUpdate = "BucketARNUpdate"
        case fileKeyUpdate = "FileKeyUpdate"
        case objectVersionUpdate = "ObjectVersionUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARNUpdate = bucketARNUpdate {
            try encodeContainer.encode(bucketARNUpdate, forKey: .bucketARNUpdate)
        }
        if let fileKeyUpdate = fileKeyUpdate {
            try encodeContainer.encode(fileKeyUpdate, forKey: .fileKeyUpdate)
        }
        if let objectVersionUpdate = objectVersionUpdate {
            try encodeContainer.encode(objectVersionUpdate, forKey: .objectVersionUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketARNUpdate)
        bucketARNUpdate = bucketARNUpdateDecoded
        let fileKeyUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileKeyUpdate)
        fileKeyUpdate = fileKeyUpdateDecoded
        let objectVersionUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectVersionUpdate)
        objectVersionUpdate = objectVersionUpdateDecoded
    }
}

extension S3ContentLocationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ContentLocationUpdate(bucketARNUpdate: \(String(describing: bucketARNUpdate)), fileKeyUpdate: \(String(describing: fileKeyUpdate)), objectVersionUpdate: \(String(describing: objectVersionUpdate)))"}
}

/// <p>Describes an update for the Amazon S3 code content location for an application.</p>
public struct S3ContentLocationUpdate: Equatable {
    /// <p>The new Amazon Resource Name (ARN) for the S3 bucket containing the application code.</p>
    public let bucketARNUpdate: String?
    /// <p>The new file key for the object containing the application code.</p>
    public let fileKeyUpdate: String?
    /// <p>The new version of the object containing the application code.</p>
    public let objectVersionUpdate: String?

    public init (
        bucketARNUpdate: String? = nil,
        fileKeyUpdate: String? = nil,
        objectVersionUpdate: String? = nil
    )
    {
        self.bucketARNUpdate = bucketARNUpdate
        self.fileKeyUpdate = fileKeyUpdate
        self.objectVersionUpdate = objectVersionUpdate
    }
}

extension S3ReferenceDataSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketARN = "BucketARN"
        case fileKey = "FileKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARN = bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
        if let fileKey = fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
    }
}

extension S3ReferenceDataSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ReferenceDataSource(bucketARN: \(String(describing: bucketARN)), fileKey: \(String(describing: fileKey)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, identifies the Amazon S3
///       bucket and object that contains the reference data.</p>
///
///          <p>A Kinesis Data Analytics application loads reference data only once. If the data changes, you call the <a>UpdateApplication</a>
///         operation to trigger reloading of data into your application. </p>
public struct S3ReferenceDataSource: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
    public let bucketARN: String?
    /// <p>The object key name containing the reference data.</p>
    public let fileKey: String?

    public init (
        bucketARN: String? = nil,
        fileKey: String? = nil
    )
    {
        self.bucketARN = bucketARN
        self.fileKey = fileKey
    }
}

extension S3ReferenceDataSourceDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketARN = "BucketARN"
        case fileKey = "FileKey"
        case referenceRoleARN = "ReferenceRoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARN = bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
        if let fileKey = fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
        if let referenceRoleARN = referenceRoleARN {
            try encodeContainer.encode(referenceRoleARN, forKey: .referenceRoleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
        let referenceRoleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .referenceRoleARN)
        referenceRoleARN = referenceRoleARNDecoded
    }
}

extension S3ReferenceDataSourceDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ReferenceDataSourceDescription(bucketARN: \(String(describing: bucketARN)), fileKey: \(String(describing: fileKey)), referenceRoleARN: \(String(describing: referenceRoleARN)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, provides the bucket name and
///       object key name that stores the reference data.</p>
public struct S3ReferenceDataSourceDescription: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
    public let bucketARN: String?
    /// <p>Amazon S3 object key name.</p>
    public let fileKey: String?
    /// <p>The ARN of the IAM role that Kinesis Data Analytics can assume to read the Amazon S3
    ///       object on your behalf to populate the in-application reference table. </p>
    ///          <note>
    ///             <p>Provided for backward compatibility. Applications that are created with the current API
    ///         version have an application-level service execution role rather than a resource-level
    ///         role.</p>
    ///          </note>
    public let referenceRoleARN: String?

    public init (
        bucketARN: String? = nil,
        fileKey: String? = nil,
        referenceRoleARN: String? = nil
    )
    {
        self.bucketARN = bucketARN
        self.fileKey = fileKey
        self.referenceRoleARN = referenceRoleARN
    }
}

extension S3ReferenceDataSourceUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketARNUpdate = "BucketARNUpdate"
        case fileKeyUpdate = "FileKeyUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARNUpdate = bucketARNUpdate {
            try encodeContainer.encode(bucketARNUpdate, forKey: .bucketARNUpdate)
        }
        if let fileKeyUpdate = fileKeyUpdate {
            try encodeContainer.encode(fileKeyUpdate, forKey: .fileKeyUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketARNUpdate)
        bucketARNUpdate = bucketARNUpdateDecoded
        let fileKeyUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileKeyUpdate)
        fileKeyUpdate = fileKeyUpdateDecoded
    }
}

extension S3ReferenceDataSourceUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ReferenceDataSourceUpdate(bucketARNUpdate: \(String(describing: bucketARNUpdate)), fileKeyUpdate: \(String(describing: fileKeyUpdate)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes the Amazon S3 bucket
///       name and object key name for an in-application reference table. </p>
public struct S3ReferenceDataSourceUpdate: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
    public let bucketARNUpdate: String?
    /// <p>The object key name.</p>
    public let fileKeyUpdate: String?

    public init (
        bucketARNUpdate: String? = nil,
        fileKeyUpdate: String? = nil
    )
    {
        self.bucketARNUpdate = bucketARNUpdate
        self.fileKeyUpdate = fileKeyUpdate
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service cannot complete the request.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationVersionId = "ApplicationVersionId"
        case snapshotCreationTimestamp = "SnapshotCreationTimestamp"
        case snapshotName = "SnapshotName"
        case snapshotStatus = "SnapshotStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationVersionId = applicationVersionId {
            try encodeContainer.encode(applicationVersionId, forKey: .applicationVersionId)
        }
        if let snapshotCreationTimestamp = snapshotCreationTimestamp {
            try encodeContainer.encode(snapshotCreationTimestamp.timeIntervalSince1970, forKey: .snapshotCreationTimestamp)
        }
        if let snapshotName = snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let snapshotStatus = snapshotStatus {
            try encodeContainer.encode(snapshotStatus.rawValue, forKey: .snapshotStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let snapshotStatusDecoded = try containerValues.decodeIfPresent(SnapshotStatus.self, forKey: .snapshotStatus)
        snapshotStatus = snapshotStatusDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
        let snapshotCreationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .snapshotCreationTimestamp)
        snapshotCreationTimestamp = snapshotCreationTimestampDecoded
    }
}

extension SnapshotDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnapshotDetails(applicationVersionId: \(String(describing: applicationVersionId)), snapshotCreationTimestamp: \(String(describing: snapshotCreationTimestamp)), snapshotName: \(String(describing: snapshotName)), snapshotStatus: \(String(describing: snapshotStatus)))"}
}

/// <p>Provides details about a snapshot of application state.</p>
public struct SnapshotDetails: Equatable {
    /// <p>The current application version ID when the snapshot was created.</p>
    public let applicationVersionId: Int?
    /// <p>The timestamp of the application snapshot.</p>
    public let snapshotCreationTimestamp: Date?
    /// <p>The identifier for the application snapshot.</p>
    public let snapshotName: String?
    /// <p>The status of the application snapshot.</p>
    public let snapshotStatus: SnapshotStatus?

    public init (
        applicationVersionId: Int? = nil,
        snapshotCreationTimestamp: Date? = nil,
        snapshotName: String? = nil,
        snapshotStatus: SnapshotStatus? = nil
    )
    {
        self.applicationVersionId = applicationVersionId
        self.snapshotCreationTimestamp = snapshotCreationTimestamp
        self.snapshotName = snapshotName
        self.snapshotStatus = snapshotStatus
    }
}

public enum SnapshotStatus {
    case creating
    case deleting
    case failed
    case ready
    case sdkUnknown(String)
}

extension SnapshotStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SnapshotStatus] {
        return [
            .creating,
            .deleting,
            .failed,
            .ready,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .ready: return "READY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SnapshotStatus(rawValue: rawValue) ?? SnapshotStatus.sdkUnknown(rawValue)
    }
}

extension SourceSchema: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recordColumns = "RecordColumns"
        case recordEncoding = "RecordEncoding"
        case recordFormat = "RecordFormat"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordColumns = recordColumns {
            var recordColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordColumns)
            for recordcolumns0 in recordColumns {
                try recordColumnsContainer.encode(recordcolumns0)
            }
        }
        if let recordEncoding = recordEncoding {
            try encodeContainer.encode(recordEncoding, forKey: .recordEncoding)
        }
        if let recordFormat = recordFormat {
            try encodeContainer.encode(recordFormat, forKey: .recordFormat)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordFormatDecoded = try containerValues.decodeIfPresent(RecordFormat.self, forKey: .recordFormat)
        recordFormat = recordFormatDecoded
        let recordEncodingDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordEncoding)
        recordEncoding = recordEncodingDecoded
        let recordColumnsContainer = try containerValues.decodeIfPresent([RecordColumn?].self, forKey: .recordColumns)
        var recordColumnsDecoded0:[RecordColumn]? = nil
        if let recordColumnsContainer = recordColumnsContainer {
            recordColumnsDecoded0 = [RecordColumn]()
            for structure0 in recordColumnsContainer {
                if let structure0 = structure0 {
                    recordColumnsDecoded0?.append(structure0)
                }
            }
        }
        recordColumns = recordColumnsDecoded0
    }
}

extension SourceSchema: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceSchema(recordColumns: \(String(describing: recordColumns)), recordEncoding: \(String(describing: recordEncoding)), recordFormat: \(String(describing: recordFormat)))"}
}

/// <p>For a SQL-based Kinesis Data Analytics application, describes the format of the
///       data in the streaming source, and how each data element maps to corresponding columns created
///       in the in-application stream. </p>
public struct SourceSchema: Equatable {
    /// <p>A list of <code>RecordColumn</code> objects. </p>
    public let recordColumns: [RecordColumn]?
    /// <p>Specifies the encoding of the records in the streaming source. For example, UTF-8.</p>
    public let recordEncoding: String?
    /// <p>Specifies the format of the records on the streaming source.</p>
    public let recordFormat: RecordFormat?

    public init (
        recordColumns: [RecordColumn]? = nil,
        recordEncoding: String? = nil,
        recordFormat: RecordFormat? = nil
    )
    {
        self.recordColumns = recordColumns
        self.recordEncoding = recordEncoding
        self.recordFormat = recordFormat
    }
}

extension SqlApplicationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputs = "Inputs"
        case outputs = "Outputs"
        case referenceDataSources = "ReferenceDataSources"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputs = inputs {
            var inputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputs)
            for inputs0 in inputs {
                try inputsContainer.encode(inputs0)
            }
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for outputs0 in outputs {
                try outputsContainer.encode(outputs0)
            }
        }
        if let referenceDataSources = referenceDataSources {
            var referenceDataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceDataSources)
            for referencedatasources0 in referenceDataSources {
                try referenceDataSourcesContainer.encode(referencedatasources0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputsContainer = try containerValues.decodeIfPresent([Input?].self, forKey: .inputs)
        var inputsDecoded0:[Input]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [Input]()
            for structure0 in inputsContainer {
                if let structure0 = structure0 {
                    inputsDecoded0?.append(structure0)
                }
            }
        }
        inputs = inputsDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([Output?].self, forKey: .outputs)
        var outputsDecoded0:[Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let referenceDataSourcesContainer = try containerValues.decodeIfPresent([ReferenceDataSource?].self, forKey: .referenceDataSources)
        var referenceDataSourcesDecoded0:[ReferenceDataSource]? = nil
        if let referenceDataSourcesContainer = referenceDataSourcesContainer {
            referenceDataSourcesDecoded0 = [ReferenceDataSource]()
            for structure0 in referenceDataSourcesContainer {
                if let structure0 = structure0 {
                    referenceDataSourcesDecoded0?.append(structure0)
                }
            }
        }
        referenceDataSources = referenceDataSourcesDecoded0
    }
}

extension SqlApplicationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqlApplicationConfiguration(inputs: \(String(describing: inputs)), outputs: \(String(describing: outputs)), referenceDataSources: \(String(describing: referenceDataSources)))"}
}

/// <p>Describes the inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.</p>
public struct SqlApplicationConfiguration: Equatable {
    /// <p>The array of <a>Input</a> objects describing the input streams used by the
    ///       application.</p>
    public let inputs: [Input]?
    /// <p>The array of <a>Output</a> objects describing the destination streams used by
    ///       the application.</p>
    public let outputs: [Output]?
    /// <p>The array of <a>ReferenceDataSource</a> objects describing the reference data
    ///       sources used by the application.</p>
    public let referenceDataSources: [ReferenceDataSource]?

    public init (
        inputs: [Input]? = nil,
        outputs: [Output]? = nil,
        referenceDataSources: [ReferenceDataSource]? = nil
    )
    {
        self.inputs = inputs
        self.outputs = outputs
        self.referenceDataSources = referenceDataSources
    }
}

extension SqlApplicationConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputDescriptions = "InputDescriptions"
        case outputDescriptions = "OutputDescriptions"
        case referenceDataSourceDescriptions = "ReferenceDataSourceDescriptions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputDescriptions = inputDescriptions {
            var inputDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputDescriptions)
            for inputdescriptions0 in inputDescriptions {
                try inputDescriptionsContainer.encode(inputdescriptions0)
            }
        }
        if let outputDescriptions = outputDescriptions {
            var outputDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputDescriptions)
            for outputdescriptions0 in outputDescriptions {
                try outputDescriptionsContainer.encode(outputdescriptions0)
            }
        }
        if let referenceDataSourceDescriptions = referenceDataSourceDescriptions {
            var referenceDataSourceDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceDataSourceDescriptions)
            for referencedatasourcedescriptions0 in referenceDataSourceDescriptions {
                try referenceDataSourceDescriptionsContainer.encode(referencedatasourcedescriptions0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDescriptionsContainer = try containerValues.decodeIfPresent([InputDescription?].self, forKey: .inputDescriptions)
        var inputDescriptionsDecoded0:[InputDescription]? = nil
        if let inputDescriptionsContainer = inputDescriptionsContainer {
            inputDescriptionsDecoded0 = [InputDescription]()
            for structure0 in inputDescriptionsContainer {
                if let structure0 = structure0 {
                    inputDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        inputDescriptions = inputDescriptionsDecoded0
        let outputDescriptionsContainer = try containerValues.decodeIfPresent([OutputDescription?].self, forKey: .outputDescriptions)
        var outputDescriptionsDecoded0:[OutputDescription]? = nil
        if let outputDescriptionsContainer = outputDescriptionsContainer {
            outputDescriptionsDecoded0 = [OutputDescription]()
            for structure0 in outputDescriptionsContainer {
                if let structure0 = structure0 {
                    outputDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        outputDescriptions = outputDescriptionsDecoded0
        let referenceDataSourceDescriptionsContainer = try containerValues.decodeIfPresent([ReferenceDataSourceDescription?].self, forKey: .referenceDataSourceDescriptions)
        var referenceDataSourceDescriptionsDecoded0:[ReferenceDataSourceDescription]? = nil
        if let referenceDataSourceDescriptionsContainer = referenceDataSourceDescriptionsContainer {
            referenceDataSourceDescriptionsDecoded0 = [ReferenceDataSourceDescription]()
            for structure0 in referenceDataSourceDescriptionsContainer {
                if let structure0 = structure0 {
                    referenceDataSourceDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        referenceDataSourceDescriptions = referenceDataSourceDescriptionsDecoded0
    }
}

extension SqlApplicationConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqlApplicationConfigurationDescription(inputDescriptions: \(String(describing: inputDescriptions)), outputDescriptions: \(String(describing: outputDescriptions)), referenceDataSourceDescriptions: \(String(describing: referenceDataSourceDescriptions)))"}
}

/// <p>Describes the inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.</p>
public struct SqlApplicationConfigurationDescription: Equatable {
    /// <p>The array of <a>InputDescription</a> objects describing the input streams used
    ///       by the application.</p>
    public let inputDescriptions: [InputDescription]?
    /// <p>The array of <a>OutputDescription</a> objects describing the destination
    ///       streams used by the application.</p>
    public let outputDescriptions: [OutputDescription]?
    /// <p>The array of <a>ReferenceDataSourceDescription</a> objects describing the
    ///       reference data sources used by the application.</p>
    public let referenceDataSourceDescriptions: [ReferenceDataSourceDescription]?

    public init (
        inputDescriptions: [InputDescription]? = nil,
        outputDescriptions: [OutputDescription]? = nil,
        referenceDataSourceDescriptions: [ReferenceDataSourceDescription]? = nil
    )
    {
        self.inputDescriptions = inputDescriptions
        self.outputDescriptions = outputDescriptions
        self.referenceDataSourceDescriptions = referenceDataSourceDescriptions
    }
}

extension SqlApplicationConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputUpdates = "InputUpdates"
        case outputUpdates = "OutputUpdates"
        case referenceDataSourceUpdates = "ReferenceDataSourceUpdates"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputUpdates = inputUpdates {
            var inputUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputUpdates)
            for inputupdates0 in inputUpdates {
                try inputUpdatesContainer.encode(inputupdates0)
            }
        }
        if let outputUpdates = outputUpdates {
            var outputUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputUpdates)
            for outputupdates0 in outputUpdates {
                try outputUpdatesContainer.encode(outputupdates0)
            }
        }
        if let referenceDataSourceUpdates = referenceDataSourceUpdates {
            var referenceDataSourceUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceDataSourceUpdates)
            for referencedatasourceupdates0 in referenceDataSourceUpdates {
                try referenceDataSourceUpdatesContainer.encode(referencedatasourceupdates0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputUpdatesContainer = try containerValues.decodeIfPresent([InputUpdate?].self, forKey: .inputUpdates)
        var inputUpdatesDecoded0:[InputUpdate]? = nil
        if let inputUpdatesContainer = inputUpdatesContainer {
            inputUpdatesDecoded0 = [InputUpdate]()
            for structure0 in inputUpdatesContainer {
                if let structure0 = structure0 {
                    inputUpdatesDecoded0?.append(structure0)
                }
            }
        }
        inputUpdates = inputUpdatesDecoded0
        let outputUpdatesContainer = try containerValues.decodeIfPresent([OutputUpdate?].self, forKey: .outputUpdates)
        var outputUpdatesDecoded0:[OutputUpdate]? = nil
        if let outputUpdatesContainer = outputUpdatesContainer {
            outputUpdatesDecoded0 = [OutputUpdate]()
            for structure0 in outputUpdatesContainer {
                if let structure0 = structure0 {
                    outputUpdatesDecoded0?.append(structure0)
                }
            }
        }
        outputUpdates = outputUpdatesDecoded0
        let referenceDataSourceUpdatesContainer = try containerValues.decodeIfPresent([ReferenceDataSourceUpdate?].self, forKey: .referenceDataSourceUpdates)
        var referenceDataSourceUpdatesDecoded0:[ReferenceDataSourceUpdate]? = nil
        if let referenceDataSourceUpdatesContainer = referenceDataSourceUpdatesContainer {
            referenceDataSourceUpdatesDecoded0 = [ReferenceDataSourceUpdate]()
            for structure0 in referenceDataSourceUpdatesContainer {
                if let structure0 = structure0 {
                    referenceDataSourceUpdatesDecoded0?.append(structure0)
                }
            }
        }
        referenceDataSourceUpdates = referenceDataSourceUpdatesDecoded0
    }
}

extension SqlApplicationConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqlApplicationConfigurationUpdate(inputUpdates: \(String(describing: inputUpdates)), outputUpdates: \(String(describing: outputUpdates)), referenceDataSourceUpdates: \(String(describing: referenceDataSourceUpdates)))"}
}

/// <p>Describes updates to the input streams, destination streams, and reference data sources
///       for a SQL-based Kinesis Data Analytics application.</p>
public struct SqlApplicationConfigurationUpdate: Equatable {
    /// <p>The array of <a>InputUpdate</a> objects describing the new input streams used
    ///       by the application.</p>
    public let inputUpdates: [InputUpdate]?
    /// <p>The array of <a>OutputUpdate</a> objects describing the new destination streams
    ///       used by the application.</p>
    public let outputUpdates: [OutputUpdate]?
    /// <p>The array of <a>ReferenceDataSourceUpdate</a> objects describing the new
    ///       reference data sources used by the application.</p>
    public let referenceDataSourceUpdates: [ReferenceDataSourceUpdate]?

    public init (
        inputUpdates: [InputUpdate]? = nil,
        outputUpdates: [OutputUpdate]? = nil,
        referenceDataSourceUpdates: [ReferenceDataSourceUpdate]? = nil
    )
    {
        self.inputUpdates = inputUpdates
        self.outputUpdates = outputUpdates
        self.referenceDataSourceUpdates = referenceDataSourceUpdates
    }
}

extension SqlRunConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputId = "InputId"
        case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputId = inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
        if let inputStartingPositionConfiguration = inputStartingPositionConfiguration {
            try encodeContainer.encode(inputStartingPositionConfiguration, forKey: .inputStartingPositionConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputId)
        inputId = inputIdDecoded
        let inputStartingPositionConfigurationDecoded = try containerValues.decodeIfPresent(InputStartingPositionConfiguration.self, forKey: .inputStartingPositionConfiguration)
        inputStartingPositionConfiguration = inputStartingPositionConfigurationDecoded
    }
}

extension SqlRunConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqlRunConfiguration(inputId: \(String(describing: inputId)), inputStartingPositionConfiguration: \(String(describing: inputStartingPositionConfiguration)))"}
}

/// <p>Describes the starting parameters for a SQL-based Kinesis Data Analytics application.</p>
public struct SqlRunConfiguration: Equatable {
    /// <p>The input source ID. You can get this ID by calling the <a>DescribeApplication</a> operation. </p>
    public let inputId: String?
    /// <p>The point at which you want the application to start processing records from the streaming
    ///       source. </p>
    public let inputStartingPositionConfiguration: InputStartingPositionConfiguration?

    public init (
        inputId: String? = nil,
        inputStartingPositionConfiguration: InputStartingPositionConfiguration? = nil
    )
    {
        self.inputId = inputId
        self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
    }
}

public struct StartApplicationInputBodyMiddleware: Middleware {
    public let id: String = "StartApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartApplicationInput>
    public typealias MOutput = OperationOutput<StartApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartApplicationOutputError>
}

extension StartApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartApplicationInput(applicationName: \(String(describing: applicationName)), runConfiguration: \(String(describing: runConfiguration)))"}
}

extension StartApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case runConfiguration = "RunConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let runConfiguration = runConfiguration {
            try encodeContainer.encode(runConfiguration, forKey: .runConfiguration)
        }
    }
}

public struct StartApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "StartApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartApplicationInput>
    public typealias MOutput = OperationOutput<StartApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartApplicationOutputError>
}

public struct StartApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "StartApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartApplicationInput>
    public typealias MOutput = OperationOutput<StartApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartApplicationOutputError>
}

public struct StartApplicationInput: Equatable {
    /// <p>The name of the application.</p>
    public let applicationName: String?
    /// <p>Identifies the run configuration (start parameters) of a Kinesis Data Analytics application.</p>
    public let runConfiguration: RunConfiguration?

    public init (
        applicationName: String? = nil,
        runConfiguration: RunConfiguration? = nil
    )
    {
        self.applicationName = applicationName
        self.runConfiguration = runConfiguration
    }
}

struct StartApplicationInputBody: Equatable {
    public let applicationName: String?
    public let runConfiguration: RunConfiguration?
}

extension StartApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case runConfiguration = "RunConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let runConfigurationDecoded = try containerValues.decodeIfPresent(RunConfiguration.self, forKey: .runConfiguration)
        runConfiguration = runConfigurationDecoded
    }
}

extension StartApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartApplicationOutputError: Equatable {
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartApplicationOutputResponse()"}
}

extension StartApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartApplicationOutputResponse: Equatable {

    public init() {}
}

struct StartApplicationOutputResponseBody: Equatable {
}

extension StartApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StopApplicationInputBodyMiddleware: Middleware {
    public let id: String = "StopApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopApplicationInput>
    public typealias MOutput = OperationOutput<StopApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopApplicationOutputError>
}

extension StopApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopApplicationInput(applicationName: \(String(describing: applicationName)), force: \(String(describing: force)))"}
}

extension StopApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case force = "Force"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let force = force {
            try encodeContainer.encode(force, forKey: .force)
        }
    }
}

public struct StopApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "StopApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopApplicationInput>
    public typealias MOutput = OperationOutput<StopApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopApplicationOutputError>
}

public struct StopApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "StopApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopApplicationInput>
    public typealias MOutput = OperationOutput<StopApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopApplicationOutputError>
}

public struct StopApplicationInput: Equatable {
    /// <p>The name of the running application to stop.</p>
    public let applicationName: String?
    /// <p>Set to <code>true</code> to force the application to stop. If you set <code>Force</code>
    ///           to <code>true</code>, Kinesis Data Analytics stops the application without taking a snapshot.
    ///       </p>
    ///           <note>
    ///             <p>Force-stopping your application may lead to data loss or duplication.
    ///               To prevent data loss or duplicate processing of data during application restarts,
    ///               we recommend you to take frequent snapshots of your application.</p>
    ///          </note>
    ///          <p>You can only force stop a Flink-based Kinesis Data Analytics application. You can't force stop a SQL-based Kinesis Data Analytics application.</p>
    ///          <p>The application must be in the
    ///           <code>STARTING</code>, <code>UPDATING</code>, <code>STOPPING</code>, <code>AUTOSCALING</code>, or
    ///           <code>RUNNING</code> status. </p>
    public let force: Bool?

    public init (
        applicationName: String? = nil,
        force: Bool? = nil
    )
    {
        self.applicationName = applicationName
        self.force = force
    }
}

struct StopApplicationInputBody: Equatable {
    public let applicationName: String?
    public let force: Bool?
}

extension StopApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationName = "ApplicationName"
        case force = "Force"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let forceDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension StopApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopApplicationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopApplicationOutputResponse()"}
}

extension StopApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopApplicationOutputResponse: Equatable {

    public init() {}
}

struct StopApplicationOutputResponseBody: Equatable {
}

extension StopApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A key-value pair (the value is optional) that you can define and assign to AWS resources.
///         If you specify a tag that already exists, the tag value is replaced with the value that you
///         specify in the request. Note that
///         the maximum number of application tags includes system tags. The maximum number of user-defined
///         application tags is 50.
///       For more information, see
///         <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-tagging.html">Using Tagging</a>.</p>
public struct Tag: Equatable {
    /// <p>The key of the key-value tag.</p>
    public let key: String?
    /// <p>The value of the key-value tag. The value is optional.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the application to assign the tags.</p>
    public let resourceARN: String?
    /// <p>The key-value tags to assign to the application.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Application created with too many tags, or too many tags added to an application. Note that the maximum
///         number of application tags includes system tags. The maximum number of user-defined application tags is 50.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnableToDetectSchemaException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnableToDetectSchemaException(message: \(String(describing: message)), processedInputRecords: \(String(describing: processedInputRecords)), rawInputRecords: \(String(describing: rawInputRecords)))"}
}

extension UnableToDetectSchemaException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnableToDetectSchemaExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.processedInputRecords = output.processedInputRecords
            self.rawInputRecords = output.rawInputRecords
        } else {
            self.message = nil
            self.processedInputRecords = nil
            self.rawInputRecords = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The data format is not valid. Kinesis Data Analytics cannot detect the schema for
///       the given streaming source.</p>
public struct UnableToDetectSchemaException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>Stream data that was modified by the processor specified in the <code>InputProcessingConfiguration</code> parameter. </p>
    public var processedInputRecords: [String]?
    /// <p>Raw stream data that was sampled to infer the schema.</p>
    public var rawInputRecords: [String]?

    public init (
        message: String? = nil,
        processedInputRecords: [String]? = nil,
        rawInputRecords: [String]? = nil
    )
    {
        self.message = message
        self.processedInputRecords = processedInputRecords
        self.rawInputRecords = rawInputRecords
    }
}

struct UnableToDetectSchemaExceptionBody: Equatable {
    public let message: String?
    public let rawInputRecords: [String]?
    public let processedInputRecords: [String]?
}

extension UnableToDetectSchemaExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case processedInputRecords = "ProcessedInputRecords"
        case rawInputRecords = "RawInputRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let rawInputRecordsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rawInputRecords)
        var rawInputRecordsDecoded0:[String]? = nil
        if let rawInputRecordsContainer = rawInputRecordsContainer {
            rawInputRecordsDecoded0 = [String]()
            for string0 in rawInputRecordsContainer {
                if let string0 = string0 {
                    rawInputRecordsDecoded0?.append(string0)
                }
            }
        }
        rawInputRecords = rawInputRecordsDecoded0
        let processedInputRecordsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .processedInputRecords)
        var processedInputRecordsDecoded0:[String]? = nil
        if let processedInputRecordsContainer = processedInputRecordsContainer {
            processedInputRecordsDecoded0 = [String]()
            for string0 in processedInputRecordsContainer {
                if let string0 = string0 {
                    processedInputRecordsDecoded0?.append(string0)
                }
            }
        }
        processedInputRecords = processedInputRecordsDecoded0
    }
}

extension UnsupportedOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedOperationException(message: \(String(describing: message)))"}
}

extension UnsupportedOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because a specified parameter is not supported or a specified resource is not valid for this
///       operation. </p>
public struct UnsupportedOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the Kinesis Data Analytics application from which to remove the tags.</p>
    public let resourceARN: String?
    /// <p>A list of keys of tags to remove from the specified application.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

extension UpdateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationInput(applicationConfigurationUpdate: \(String(describing: applicationConfigurationUpdate)), applicationName: \(String(describing: applicationName)), cloudWatchLoggingOptionUpdates: \(String(describing: cloudWatchLoggingOptionUpdates)), conditionalToken: \(String(describing: conditionalToken)), currentApplicationVersionId: \(String(describing: currentApplicationVersionId)), runConfigurationUpdate: \(String(describing: runConfigurationUpdate)), serviceExecutionRoleUpdate: \(String(describing: serviceExecutionRoleUpdate)))"}
}

extension UpdateApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationConfigurationUpdate = "ApplicationConfigurationUpdate"
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptionUpdates = "CloudWatchLoggingOptionUpdates"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case runConfigurationUpdate = "RunConfigurationUpdate"
        case serviceExecutionRoleUpdate = "ServiceExecutionRoleUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfigurationUpdate = applicationConfigurationUpdate {
            try encodeContainer.encode(applicationConfigurationUpdate, forKey: .applicationConfigurationUpdate)
        }
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let cloudWatchLoggingOptionUpdates = cloudWatchLoggingOptionUpdates {
            var cloudWatchLoggingOptionUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchLoggingOptionUpdates)
            for cloudwatchloggingoptionupdates0 in cloudWatchLoggingOptionUpdates {
                try cloudWatchLoggingOptionUpdatesContainer.encode(cloudwatchloggingoptionupdates0)
            }
        }
        if let conditionalToken = conditionalToken {
            try encodeContainer.encode(conditionalToken, forKey: .conditionalToken)
        }
        if let currentApplicationVersionId = currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let runConfigurationUpdate = runConfigurationUpdate {
            try encodeContainer.encode(runConfigurationUpdate, forKey: .runConfigurationUpdate)
        }
        if let serviceExecutionRoleUpdate = serviceExecutionRoleUpdate {
            try encodeContainer.encode(serviceExecutionRoleUpdate, forKey: .serviceExecutionRoleUpdate)
        }
    }
}

public struct UpdateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInput: Equatable {
    /// <p>Describes application configuration updates.</p>
    public let applicationConfigurationUpdate: ApplicationConfigurationUpdate?
    /// <p>The name of the application to update.</p>
    public let applicationName: String?
    /// <p>Describes application Amazon CloudWatch logging option updates. You can only update
    ///       existing CloudWatch logging options with this action. To add a new CloudWatch logging option,
    ///       use <a>AddApplicationCloudWatchLoggingOption</a>.</p>
    public let cloudWatchLoggingOptionUpdates: [CloudWatchLoggingOptionUpdate]?
    /// <p>A value you use to implement strong concurrency for application updates. You must
    ///       provide the <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>. You
    ///       get the application's current <code>ConditionalToken</code> using <a>DescribeApplication</a>. For better concurrency support, use the
    ///         <code>ConditionalToken</code> parameter instead of
    ///       <code>CurrentApplicationVersionId</code>.</p>
    public let conditionalToken: String?
    /// <p>The current application version ID. You must provide the
    ///         <code>CurrentApplicationVersionId</code> or the <code>ConditionalToken</code>.You can
    ///       retrieve the application version ID using <a>DescribeApplication</a>. For better
    ///       concurrency support, use the <code>ConditionalToken</code> parameter instead of
    ///         <code>CurrentApplicationVersionId</code>.</p>
    public let currentApplicationVersionId: Int?
    /// <p>Describes updates to the application's starting parameters.</p>
    public let runConfigurationUpdate: RunConfigurationUpdate?
    /// <p>Describes updates to the service execution role.</p>
    public let serviceExecutionRoleUpdate: String?

    public init (
        applicationConfigurationUpdate: ApplicationConfigurationUpdate? = nil,
        applicationName: String? = nil,
        cloudWatchLoggingOptionUpdates: [CloudWatchLoggingOptionUpdate]? = nil,
        conditionalToken: String? = nil,
        currentApplicationVersionId: Int? = nil,
        runConfigurationUpdate: RunConfigurationUpdate? = nil,
        serviceExecutionRoleUpdate: String? = nil
    )
    {
        self.applicationConfigurationUpdate = applicationConfigurationUpdate
        self.applicationName = applicationName
        self.cloudWatchLoggingOptionUpdates = cloudWatchLoggingOptionUpdates
        self.conditionalToken = conditionalToken
        self.currentApplicationVersionId = currentApplicationVersionId
        self.runConfigurationUpdate = runConfigurationUpdate
        self.serviceExecutionRoleUpdate = serviceExecutionRoleUpdate
    }
}

struct UpdateApplicationInputBody: Equatable {
    public let applicationName: String?
    public let currentApplicationVersionId: Int?
    public let applicationConfigurationUpdate: ApplicationConfigurationUpdate?
    public let serviceExecutionRoleUpdate: String?
    public let runConfigurationUpdate: RunConfigurationUpdate?
    public let cloudWatchLoggingOptionUpdates: [CloudWatchLoggingOptionUpdate]?
    public let conditionalToken: String?
}

extension UpdateApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationConfigurationUpdate = "ApplicationConfigurationUpdate"
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptionUpdates = "CloudWatchLoggingOptionUpdates"
        case conditionalToken = "ConditionalToken"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case runConfigurationUpdate = "RunConfigurationUpdate"
        case serviceExecutionRoleUpdate = "ServiceExecutionRoleUpdate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let applicationConfigurationUpdateDecoded = try containerValues.decodeIfPresent(ApplicationConfigurationUpdate.self, forKey: .applicationConfigurationUpdate)
        applicationConfigurationUpdate = applicationConfigurationUpdateDecoded
        let serviceExecutionRoleUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceExecutionRoleUpdate)
        serviceExecutionRoleUpdate = serviceExecutionRoleUpdateDecoded
        let runConfigurationUpdateDecoded = try containerValues.decodeIfPresent(RunConfigurationUpdate.self, forKey: .runConfigurationUpdate)
        runConfigurationUpdate = runConfigurationUpdateDecoded
        let cloudWatchLoggingOptionUpdatesContainer = try containerValues.decodeIfPresent([CloudWatchLoggingOptionUpdate?].self, forKey: .cloudWatchLoggingOptionUpdates)
        var cloudWatchLoggingOptionUpdatesDecoded0:[CloudWatchLoggingOptionUpdate]? = nil
        if let cloudWatchLoggingOptionUpdatesContainer = cloudWatchLoggingOptionUpdatesContainer {
            cloudWatchLoggingOptionUpdatesDecoded0 = [CloudWatchLoggingOptionUpdate]()
            for structure0 in cloudWatchLoggingOptionUpdatesContainer {
                if let structure0 = structure0 {
                    cloudWatchLoggingOptionUpdatesDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchLoggingOptionUpdates = cloudWatchLoggingOptionUpdatesDecoded0
        let conditionalTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conditionalToken)
        conditionalToken = conditionalTokenDecoded
    }
}

public struct UpdateApplicationMaintenanceConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApplicationMaintenanceConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationMaintenanceConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationMaintenanceConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationMaintenanceConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationMaintenanceConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationMaintenanceConfigurationOutputError>
}

extension UpdateApplicationMaintenanceConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationMaintenanceConfigurationInput(applicationMaintenanceConfigurationUpdate: \(String(describing: applicationMaintenanceConfigurationUpdate)), applicationName: \(String(describing: applicationName)))"}
}

extension UpdateApplicationMaintenanceConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationMaintenanceConfigurationUpdate = "ApplicationMaintenanceConfigurationUpdate"
        case applicationName = "ApplicationName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationMaintenanceConfigurationUpdate = applicationMaintenanceConfigurationUpdate {
            try encodeContainer.encode(applicationMaintenanceConfigurationUpdate, forKey: .applicationMaintenanceConfigurationUpdate)
        }
        if let applicationName = applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
    }
}

public struct UpdateApplicationMaintenanceConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApplicationMaintenanceConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationMaintenanceConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationMaintenanceConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationMaintenanceConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationMaintenanceConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationMaintenanceConfigurationOutputError>
}

public struct UpdateApplicationMaintenanceConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApplicationMaintenanceConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationMaintenanceConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationMaintenanceConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationMaintenanceConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationMaintenanceConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationMaintenanceConfigurationOutputError>
}

public struct UpdateApplicationMaintenanceConfigurationInput: Equatable {
    /// <p>Describes the application maintenance configuration update.</p>
    public let applicationMaintenanceConfigurationUpdate: ApplicationMaintenanceConfigurationUpdate?
    /// <p>The name of the application for which you want to update the maintenance configuration.</p>
    public let applicationName: String?

    public init (
        applicationMaintenanceConfigurationUpdate: ApplicationMaintenanceConfigurationUpdate? = nil,
        applicationName: String? = nil
    )
    {
        self.applicationMaintenanceConfigurationUpdate = applicationMaintenanceConfigurationUpdate
        self.applicationName = applicationName
    }
}

struct UpdateApplicationMaintenanceConfigurationInputBody: Equatable {
    public let applicationName: String?
    public let applicationMaintenanceConfigurationUpdate: ApplicationMaintenanceConfigurationUpdate?
}

extension UpdateApplicationMaintenanceConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationMaintenanceConfigurationUpdate = "ApplicationMaintenanceConfigurationUpdate"
        case applicationName = "ApplicationName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationMaintenanceConfigurationUpdateDecoded = try containerValues.decodeIfPresent(ApplicationMaintenanceConfigurationUpdate.self, forKey: .applicationMaintenanceConfigurationUpdate)
        applicationMaintenanceConfigurationUpdate = applicationMaintenanceConfigurationUpdateDecoded
    }
}

extension UpdateApplicationMaintenanceConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationMaintenanceConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationMaintenanceConfigurationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationMaintenanceConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationMaintenanceConfigurationOutputResponse(applicationARN: \(String(describing: applicationARN)), applicationMaintenanceConfigurationDescription: \(String(describing: applicationMaintenanceConfigurationDescription)))"}
}

extension UpdateApplicationMaintenanceConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateApplicationMaintenanceConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationARN = output.applicationARN
            self.applicationMaintenanceConfigurationDescription = output.applicationMaintenanceConfigurationDescription
        } else {
            self.applicationARN = nil
            self.applicationMaintenanceConfigurationDescription = nil
        }
    }
}

public struct UpdateApplicationMaintenanceConfigurationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let applicationARN: String?
    /// <p>The application maintenance configuration description after the update.</p>
    public let applicationMaintenanceConfigurationDescription: ApplicationMaintenanceConfigurationDescription?

    public init (
        applicationARN: String? = nil,
        applicationMaintenanceConfigurationDescription: ApplicationMaintenanceConfigurationDescription? = nil
    )
    {
        self.applicationARN = applicationARN
        self.applicationMaintenanceConfigurationDescription = applicationMaintenanceConfigurationDescription
    }
}

struct UpdateApplicationMaintenanceConfigurationOutputResponseBody: Equatable {
    public let applicationARN: String?
    public let applicationMaintenanceConfigurationDescription: ApplicationMaintenanceConfigurationDescription?
}

extension UpdateApplicationMaintenanceConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationMaintenanceConfigurationDescription = "ApplicationMaintenanceConfigurationDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationMaintenanceConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(ApplicationMaintenanceConfigurationDescription.self, forKey: .applicationMaintenanceConfigurationDescription)
        applicationMaintenanceConfigurationDescription = applicationMaintenanceConfigurationDescriptionDecoded
    }
}

extension UpdateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeValidationException" : self = .codeValidationException(try CodeValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationOutputError: Equatable {
    case codeValidationException(CodeValidationException)
    case concurrentModificationException(ConcurrentModificationException)
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationOutputResponse(applicationDetail: \(String(describing: applicationDetail)))"}
}

extension UpdateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.applicationDetail = output.applicationDetail
        } else {
            self.applicationDetail = nil
        }
    }
}

public struct UpdateApplicationOutputResponse: Equatable {
    /// <p>Describes application updates.</p>
    public let applicationDetail: ApplicationDetail?

    public init (
        applicationDetail: ApplicationDetail? = nil
    )
    {
        self.applicationDetail = applicationDetail
    }
}

struct UpdateApplicationOutputResponseBody: Equatable {
    public let applicationDetail: ApplicationDetail?
}

extension UpdateApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationDetail = "ApplicationDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDetailDecoded = try containerValues.decodeIfPresent(ApplicationDetail.self, forKey: .applicationDetail)
        applicationDetail = applicationDetailDecoded
    }
}

public enum UrlType {
    case flinkDashboardUrl
    case zeppelinUiUrl
    case sdkUnknown(String)
}

extension UrlType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UrlType] {
        return [
            .flinkDashboardUrl,
            .zeppelinUiUrl,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .flinkDashboardUrl: return "FLINK_DASHBOARD_URL"
        case .zeppelinUiUrl: return "ZEPPELIN_UI_URL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UrlType(rawValue: rawValue) ?? UrlType.sdkUnknown(rawValue)
    }
}

extension VpcConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension VpcConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcConfiguration(securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)))"}
}

/// <p>Describes the parameters of a VPC used by the application.</p>
public struct VpcConfiguration: Equatable {
    /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html">SecurityGroup</a>
    ///         IDs used by the VPC configuration.</p>
    public let securityGroupIds: [String]?
    /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html">Subnet</a> IDs
    ///         used by the VPC configuration.</p>
    public let subnetIds: [String]?

    public init (
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
    }
}

extension VpcConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcConfigurationId = "VpcConfigurationId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcConfigurationId = vpcConfigurationId {
            try encodeContainer.encode(vpcConfigurationId, forKey: .vpcConfigurationId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConfigurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcConfigurationId)
        vpcConfigurationId = vpcConfigurationIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension VpcConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcConfigurationDescription(securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)), vpcConfigurationId: \(String(describing: vpcConfigurationId)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Describes the parameters of a VPC used by the application.</p>
public struct VpcConfigurationDescription: Equatable {
    /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html">SecurityGroup</a>
    ///         IDs used by the VPC configuration.</p>
    public let securityGroupIds: [String]?
    /// <p>The array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html">Subnet</a>
    ///         IDs used by the VPC configuration.</p>
    public let subnetIds: [String]?
    /// <p>The ID of the VPC configuration.</p>
    public let vpcConfigurationId: String?
    /// <p>The ID of the associated VPC.</p>
    public let vpcId: String?

    public init (
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil,
        vpcConfigurationId: String? = nil,
        vpcId: String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcConfigurationId = vpcConfigurationId
        self.vpcId = vpcId
    }
}

extension VpcConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIdUpdates = "SecurityGroupIdUpdates"
        case subnetIdUpdates = "SubnetIdUpdates"
        case vpcConfigurationId = "VpcConfigurationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIdUpdates = securityGroupIdUpdates {
            var securityGroupIdUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIdUpdates)
            for securitygroupids0 in securityGroupIdUpdates {
                try securityGroupIdUpdatesContainer.encode(securitygroupids0)
            }
        }
        if let subnetIdUpdates = subnetIdUpdates {
            var subnetIdUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIdUpdates)
            for subnetids0 in subnetIdUpdates {
                try subnetIdUpdatesContainer.encode(subnetids0)
            }
        }
        if let vpcConfigurationId = vpcConfigurationId {
            try encodeContainer.encode(vpcConfigurationId, forKey: .vpcConfigurationId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConfigurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcConfigurationId)
        vpcConfigurationId = vpcConfigurationIdDecoded
        let subnetIdUpdatesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIdUpdates)
        var subnetIdUpdatesDecoded0:[String]? = nil
        if let subnetIdUpdatesContainer = subnetIdUpdatesContainer {
            subnetIdUpdatesDecoded0 = [String]()
            for string0 in subnetIdUpdatesContainer {
                if let string0 = string0 {
                    subnetIdUpdatesDecoded0?.append(string0)
                }
            }
        }
        subnetIdUpdates = subnetIdUpdatesDecoded0
        let securityGroupIdUpdatesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIdUpdates)
        var securityGroupIdUpdatesDecoded0:[String]? = nil
        if let securityGroupIdUpdatesContainer = securityGroupIdUpdatesContainer {
            securityGroupIdUpdatesDecoded0 = [String]()
            for string0 in securityGroupIdUpdatesContainer {
                if let string0 = string0 {
                    securityGroupIdUpdatesDecoded0?.append(string0)
                }
            }
        }
        securityGroupIdUpdates = securityGroupIdUpdatesDecoded0
    }
}

extension VpcConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcConfigurationUpdate(securityGroupIdUpdates: \(String(describing: securityGroupIdUpdates)), subnetIdUpdates: \(String(describing: subnetIdUpdates)), vpcConfigurationId: \(String(describing: vpcConfigurationId)))"}
}

/// <p>Describes updates to the VPC configuration used by the application.</p>
public struct VpcConfigurationUpdate: Equatable {
    /// <p>Describes updates to the array of
    ///         <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SecurityGroup.html">SecurityGroup</a> IDs used by the VPC configuration.</p>
    public let securityGroupIdUpdates: [String]?
    /// <p>Describes updates to the array of <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Subnet.html">Subnet</a>
    ///         IDs
    ///         used by the VPC configuration.</p>
    public let subnetIdUpdates: [String]?
    /// <p>Describes an update to the ID of the VPC configuration.</p>
    public let vpcConfigurationId: String?

    public init (
        securityGroupIdUpdates: [String]? = nil,
        subnetIdUpdates: [String]? = nil,
        vpcConfigurationId: String? = nil
    )
    {
        self.securityGroupIdUpdates = securityGroupIdUpdates
        self.subnetIdUpdates = subnetIdUpdates
        self.vpcConfigurationId = vpcConfigurationId
    }
}

extension ZeppelinApplicationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogConfiguration = "CatalogConfiguration"
        case customArtifactsConfiguration = "CustomArtifactsConfiguration"
        case deployAsApplicationConfiguration = "DeployAsApplicationConfiguration"
        case monitoringConfiguration = "MonitoringConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogConfiguration = catalogConfiguration {
            try encodeContainer.encode(catalogConfiguration, forKey: .catalogConfiguration)
        }
        if let customArtifactsConfiguration = customArtifactsConfiguration {
            var customArtifactsConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customArtifactsConfiguration)
            for customartifactsconfigurationlist0 in customArtifactsConfiguration {
                try customArtifactsConfigurationContainer.encode(customartifactsconfigurationlist0)
            }
        }
        if let deployAsApplicationConfiguration = deployAsApplicationConfiguration {
            try encodeContainer.encode(deployAsApplicationConfiguration, forKey: .deployAsApplicationConfiguration)
        }
        if let monitoringConfiguration = monitoringConfiguration {
            try encodeContainer.encode(monitoringConfiguration, forKey: .monitoringConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringConfigurationDecoded = try containerValues.decodeIfPresent(ZeppelinMonitoringConfiguration.self, forKey: .monitoringConfiguration)
        monitoringConfiguration = monitoringConfigurationDecoded
        let catalogConfigurationDecoded = try containerValues.decodeIfPresent(CatalogConfiguration.self, forKey: .catalogConfiguration)
        catalogConfiguration = catalogConfigurationDecoded
        let deployAsApplicationConfigurationDecoded = try containerValues.decodeIfPresent(DeployAsApplicationConfiguration.self, forKey: .deployAsApplicationConfiguration)
        deployAsApplicationConfiguration = deployAsApplicationConfigurationDecoded
        let customArtifactsConfigurationContainer = try containerValues.decodeIfPresent([CustomArtifactConfiguration?].self, forKey: .customArtifactsConfiguration)
        var customArtifactsConfigurationDecoded0:[CustomArtifactConfiguration]? = nil
        if let customArtifactsConfigurationContainer = customArtifactsConfigurationContainer {
            customArtifactsConfigurationDecoded0 = [CustomArtifactConfiguration]()
            for structure0 in customArtifactsConfigurationContainer {
                if let structure0 = structure0 {
                    customArtifactsConfigurationDecoded0?.append(structure0)
                }
            }
        }
        customArtifactsConfiguration = customArtifactsConfigurationDecoded0
    }
}

extension ZeppelinApplicationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ZeppelinApplicationConfiguration(catalogConfiguration: \(String(describing: catalogConfiguration)), customArtifactsConfiguration: \(String(describing: customArtifactsConfiguration)), deployAsApplicationConfiguration: \(String(describing: deployAsApplicationConfiguration)), monitoringConfiguration: \(String(describing: monitoringConfiguration)))"}
}

/// <p>The configuration of a Kinesis Data Analytics Studio notebook.</p>
public struct ZeppelinApplicationConfiguration: Equatable {
    /// <p>The AWS Glue Data Catalog that you use in queries in a Kinesis Data Analytics Studio notebook.</p>
    public let catalogConfiguration: CatalogConfiguration?
    /// <p>Custom artifacts are dependency JARs and user-defined functions (UDF).</p>
    public let customArtifactsConfiguration: [CustomArtifactConfiguration]?
    /// <p>The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state..</p>
    public let deployAsApplicationConfiguration: DeployAsApplicationConfiguration?
    /// <p>The monitoring configuration of a Kinesis Data Analytics Studio notebook.</p>
    public let monitoringConfiguration: ZeppelinMonitoringConfiguration?

    public init (
        catalogConfiguration: CatalogConfiguration? = nil,
        customArtifactsConfiguration: [CustomArtifactConfiguration]? = nil,
        deployAsApplicationConfiguration: DeployAsApplicationConfiguration? = nil,
        monitoringConfiguration: ZeppelinMonitoringConfiguration? = nil
    )
    {
        self.catalogConfiguration = catalogConfiguration
        self.customArtifactsConfiguration = customArtifactsConfiguration
        self.deployAsApplicationConfiguration = deployAsApplicationConfiguration
        self.monitoringConfiguration = monitoringConfiguration
    }
}

extension ZeppelinApplicationConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogConfigurationDescription = "CatalogConfigurationDescription"
        case customArtifactsConfigurationDescription = "CustomArtifactsConfigurationDescription"
        case deployAsApplicationConfigurationDescription = "DeployAsApplicationConfigurationDescription"
        case monitoringConfigurationDescription = "MonitoringConfigurationDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogConfigurationDescription = catalogConfigurationDescription {
            try encodeContainer.encode(catalogConfigurationDescription, forKey: .catalogConfigurationDescription)
        }
        if let customArtifactsConfigurationDescription = customArtifactsConfigurationDescription {
            var customArtifactsConfigurationDescriptionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customArtifactsConfigurationDescription)
            for customartifactsconfigurationdescriptionlist0 in customArtifactsConfigurationDescription {
                try customArtifactsConfigurationDescriptionContainer.encode(customartifactsconfigurationdescriptionlist0)
            }
        }
        if let deployAsApplicationConfigurationDescription = deployAsApplicationConfigurationDescription {
            try encodeContainer.encode(deployAsApplicationConfigurationDescription, forKey: .deployAsApplicationConfigurationDescription)
        }
        if let monitoringConfigurationDescription = monitoringConfigurationDescription {
            try encodeContainer.encode(monitoringConfigurationDescription, forKey: .monitoringConfigurationDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(ZeppelinMonitoringConfigurationDescription.self, forKey: .monitoringConfigurationDescription)
        monitoringConfigurationDescription = monitoringConfigurationDescriptionDecoded
        let catalogConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(CatalogConfigurationDescription.self, forKey: .catalogConfigurationDescription)
        catalogConfigurationDescription = catalogConfigurationDescriptionDecoded
        let deployAsApplicationConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(DeployAsApplicationConfigurationDescription.self, forKey: .deployAsApplicationConfigurationDescription)
        deployAsApplicationConfigurationDescription = deployAsApplicationConfigurationDescriptionDecoded
        let customArtifactsConfigurationDescriptionContainer = try containerValues.decodeIfPresent([CustomArtifactConfigurationDescription?].self, forKey: .customArtifactsConfigurationDescription)
        var customArtifactsConfigurationDescriptionDecoded0:[CustomArtifactConfigurationDescription]? = nil
        if let customArtifactsConfigurationDescriptionContainer = customArtifactsConfigurationDescriptionContainer {
            customArtifactsConfigurationDescriptionDecoded0 = [CustomArtifactConfigurationDescription]()
            for structure0 in customArtifactsConfigurationDescriptionContainer {
                if let structure0 = structure0 {
                    customArtifactsConfigurationDescriptionDecoded0?.append(structure0)
                }
            }
        }
        customArtifactsConfigurationDescription = customArtifactsConfigurationDescriptionDecoded0
    }
}

extension ZeppelinApplicationConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ZeppelinApplicationConfigurationDescription(catalogConfigurationDescription: \(String(describing: catalogConfigurationDescription)), customArtifactsConfigurationDescription: \(String(describing: customArtifactsConfigurationDescription)), deployAsApplicationConfigurationDescription: \(String(describing: deployAsApplicationConfigurationDescription)), monitoringConfigurationDescription: \(String(describing: monitoringConfigurationDescription)))"}
}

/// <p>The configuration of a Kinesis Data Analytics Studio notebook.</p>
public struct ZeppelinApplicationConfigurationDescription: Equatable {
    /// <p>The AWS Glue Data Catalog that is associated with the Kinesis Data Analytics Studio notebook.</p>
    public let catalogConfigurationDescription: CatalogConfigurationDescription?
    /// <p>Custom artifacts are dependency JARs and user-defined functions (UDF).</p>
    public let customArtifactsConfigurationDescription: [CustomArtifactConfigurationDescription]?
    /// <p>The parameters required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state..</p>
    public let deployAsApplicationConfigurationDescription: DeployAsApplicationConfigurationDescription?
    /// <p>The monitoring configuration of a Kinesis Data Analytics Studio notebook.</p>
    public let monitoringConfigurationDescription: ZeppelinMonitoringConfigurationDescription?

    public init (
        catalogConfigurationDescription: CatalogConfigurationDescription? = nil,
        customArtifactsConfigurationDescription: [CustomArtifactConfigurationDescription]? = nil,
        deployAsApplicationConfigurationDescription: DeployAsApplicationConfigurationDescription? = nil,
        monitoringConfigurationDescription: ZeppelinMonitoringConfigurationDescription? = nil
    )
    {
        self.catalogConfigurationDescription = catalogConfigurationDescription
        self.customArtifactsConfigurationDescription = customArtifactsConfigurationDescription
        self.deployAsApplicationConfigurationDescription = deployAsApplicationConfigurationDescription
        self.monitoringConfigurationDescription = monitoringConfigurationDescription
    }
}

extension ZeppelinApplicationConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogConfigurationUpdate = "CatalogConfigurationUpdate"
        case customArtifactsConfigurationUpdate = "CustomArtifactsConfigurationUpdate"
        case deployAsApplicationConfigurationUpdate = "DeployAsApplicationConfigurationUpdate"
        case monitoringConfigurationUpdate = "MonitoringConfigurationUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogConfigurationUpdate = catalogConfigurationUpdate {
            try encodeContainer.encode(catalogConfigurationUpdate, forKey: .catalogConfigurationUpdate)
        }
        if let customArtifactsConfigurationUpdate = customArtifactsConfigurationUpdate {
            var customArtifactsConfigurationUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customArtifactsConfigurationUpdate)
            for customartifactsconfigurationlist0 in customArtifactsConfigurationUpdate {
                try customArtifactsConfigurationUpdateContainer.encode(customartifactsconfigurationlist0)
            }
        }
        if let deployAsApplicationConfigurationUpdate = deployAsApplicationConfigurationUpdate {
            try encodeContainer.encode(deployAsApplicationConfigurationUpdate, forKey: .deployAsApplicationConfigurationUpdate)
        }
        if let monitoringConfigurationUpdate = monitoringConfigurationUpdate {
            try encodeContainer.encode(monitoringConfigurationUpdate, forKey: .monitoringConfigurationUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringConfigurationUpdateDecoded = try containerValues.decodeIfPresent(ZeppelinMonitoringConfigurationUpdate.self, forKey: .monitoringConfigurationUpdate)
        monitoringConfigurationUpdate = monitoringConfigurationUpdateDecoded
        let catalogConfigurationUpdateDecoded = try containerValues.decodeIfPresent(CatalogConfigurationUpdate.self, forKey: .catalogConfigurationUpdate)
        catalogConfigurationUpdate = catalogConfigurationUpdateDecoded
        let deployAsApplicationConfigurationUpdateDecoded = try containerValues.decodeIfPresent(DeployAsApplicationConfigurationUpdate.self, forKey: .deployAsApplicationConfigurationUpdate)
        deployAsApplicationConfigurationUpdate = deployAsApplicationConfigurationUpdateDecoded
        let customArtifactsConfigurationUpdateContainer = try containerValues.decodeIfPresent([CustomArtifactConfiguration?].self, forKey: .customArtifactsConfigurationUpdate)
        var customArtifactsConfigurationUpdateDecoded0:[CustomArtifactConfiguration]? = nil
        if let customArtifactsConfigurationUpdateContainer = customArtifactsConfigurationUpdateContainer {
            customArtifactsConfigurationUpdateDecoded0 = [CustomArtifactConfiguration]()
            for structure0 in customArtifactsConfigurationUpdateContainer {
                if let structure0 = structure0 {
                    customArtifactsConfigurationUpdateDecoded0?.append(structure0)
                }
            }
        }
        customArtifactsConfigurationUpdate = customArtifactsConfigurationUpdateDecoded0
    }
}

extension ZeppelinApplicationConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ZeppelinApplicationConfigurationUpdate(catalogConfigurationUpdate: \(String(describing: catalogConfigurationUpdate)), customArtifactsConfigurationUpdate: \(String(describing: customArtifactsConfigurationUpdate)), deployAsApplicationConfigurationUpdate: \(String(describing: deployAsApplicationConfigurationUpdate)), monitoringConfigurationUpdate: \(String(describing: monitoringConfigurationUpdate)))"}
}

/// <p>Updates to the configuration of Kinesis Data Analytics Studio notebook.</p>
public struct ZeppelinApplicationConfigurationUpdate: Equatable {
    /// <p>Updates to the configuration of the AWS Glue Data Catalog that is associated with the Kinesis Data Analytics Studio notebook.</p>
    public let catalogConfigurationUpdate: CatalogConfigurationUpdate?
    /// <p>Updates to the customer artifacts. Custom artifacts are dependency JAR files and user-defined functions (UDF).</p>
    public let customArtifactsConfigurationUpdate: [CustomArtifactConfiguration]?
    /// <p>Updates to the configuration information required to deploy an Amazon Data Analytics Studio notebook as an application with durable state..</p>
    public let deployAsApplicationConfigurationUpdate: DeployAsApplicationConfigurationUpdate?
    /// <p>Updates to the monitoring configuration of a Kinesis Data Analytics Studio notebook.</p>
    public let monitoringConfigurationUpdate: ZeppelinMonitoringConfigurationUpdate?

    public init (
        catalogConfigurationUpdate: CatalogConfigurationUpdate? = nil,
        customArtifactsConfigurationUpdate: [CustomArtifactConfiguration]? = nil,
        deployAsApplicationConfigurationUpdate: DeployAsApplicationConfigurationUpdate? = nil,
        monitoringConfigurationUpdate: ZeppelinMonitoringConfigurationUpdate? = nil
    )
    {
        self.catalogConfigurationUpdate = catalogConfigurationUpdate
        self.customArtifactsConfigurationUpdate = customArtifactsConfigurationUpdate
        self.deployAsApplicationConfigurationUpdate = deployAsApplicationConfigurationUpdate
        self.monitoringConfigurationUpdate = monitoringConfigurationUpdate
    }
}

extension ZeppelinMonitoringConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension ZeppelinMonitoringConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ZeppelinMonitoringConfiguration(logLevel: \(String(describing: logLevel)))"}
}

/// <p>Describes configuration parameters for Amazon CloudWatch logging for a Kinesis Data Analytics Studio notebook. For more information about CloudWatch logging, see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/monitoring-overview.html">Monitoring</a>.</p>
public struct ZeppelinMonitoringConfiguration: Equatable {
    /// <p>The verbosity of the CloudWatch Logs for an application.</p>
    public let logLevel: LogLevel?

    public init (
        logLevel: LogLevel? = nil
    )
    {
        self.logLevel = logLevel
    }
}

extension ZeppelinMonitoringConfigurationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension ZeppelinMonitoringConfigurationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ZeppelinMonitoringConfigurationDescription(logLevel: \(String(describing: logLevel)))"}
}

/// <p>The monitoring configuration for Apache Zeppelin within a Kinesis Data Analytics Studio notebook.</p>
public struct ZeppelinMonitoringConfigurationDescription: Equatable {
    /// <p>Describes the verbosity of the CloudWatch Logs for an application.</p>
    public let logLevel: LogLevel?

    public init (
        logLevel: LogLevel? = nil
    )
    {
        self.logLevel = logLevel
    }
}

extension ZeppelinMonitoringConfigurationUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logLevelUpdate = "LogLevelUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevelUpdate = logLevelUpdate {
            try encodeContainer.encode(logLevelUpdate.rawValue, forKey: .logLevelUpdate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logLevelUpdateDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevelUpdate)
        logLevelUpdate = logLevelUpdateDecoded
    }
}

extension ZeppelinMonitoringConfigurationUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ZeppelinMonitoringConfigurationUpdate(logLevelUpdate: \(String(describing: logLevelUpdate)))"}
}

/// <p>Updates to the monitoring configuration for Apache Zeppelin within a Kinesis Data Analytics Studio notebook.</p>
public struct ZeppelinMonitoringConfigurationUpdate: Equatable {
    /// <p>Updates to the logging level for Apache Zeppelin within a Kinesis Data Analytics Studio notebook.</p>
    public let logLevelUpdate: LogLevel?

    public init (
        logLevelUpdate: LogLevel? = nil
    )
    {
        self.logLevelUpdate = logLevelUpdate
    }
}
