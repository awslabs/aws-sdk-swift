// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AssociateTeamMemberInputBodyMiddleware: Middleware {
    public let id: String = "AssociateTeamMemberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateTeamMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateTeamMemberInput>
    public typealias MOutput = OperationOutput<AssociateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateTeamMemberOutputError>
}

extension AssociateTeamMemberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateTeamMemberInput(clientRequestToken: \(String(describing: clientRequestToken)), projectId: \(String(describing: projectId)), projectRole: \(String(describing: projectRole)), remoteAccessAllowed: \(String(describing: remoteAccessAllowed)), userArn: \(String(describing: userArn)))"}
}

extension AssociateTeamMemberInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case projectId
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let projectRole = projectRole {
            try encodeContainer.encode(projectRole, forKey: .projectRole)
        }
        if remoteAccessAllowed != false {
            try encodeContainer.encode(remoteAccessAllowed, forKey: .remoteAccessAllowed)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct AssociateTeamMemberInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateTeamMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateTeamMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateTeamMemberInput>
    public typealias MOutput = OperationOutput<AssociateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateTeamMemberOutputError>
}

public struct AssociateTeamMemberInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateTeamMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateTeamMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateTeamMemberInput>
    public typealias MOutput = OperationOutput<AssociateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateTeamMemberOutputError>
}

public struct AssociateTeamMemberInput: Equatable {
    /// <p>A user- or system-generated token that identifies the entity that requested the team
    ///       member association to the project. This token can be used to repeat the request.</p>
    public let clientRequestToken: String?
    /// <p>The ID of the project to which you will add the IAM user.</p>
    public let projectId: String?
    /// <p>The AWS CodeStar project role that will apply to this user. This role determines what actions
    ///       a user can take in an AWS CodeStar project.</p>
    public let projectRole: String?
    /// <p>Whether the team member is allowed to use an SSH public/private key pair to remotely
    ///       access project resources, for example Amazon EC2 instances.</p>
    public let remoteAccessAllowed: Bool
    /// <p>The Amazon Resource Name (ARN) for the IAM user you want to add to the AWS CodeStar
    ///       project.</p>
    public let userArn: String?

    public init (
        clientRequestToken: String? = nil,
        projectId: String? = nil,
        projectRole: String? = nil,
        remoteAccessAllowed: Bool = false,
        userArn: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.projectId = projectId
        self.projectRole = projectRole
        self.remoteAccessAllowed = remoteAccessAllowed
        self.userArn = userArn
    }
}

struct AssociateTeamMemberInputBody: Equatable {
    public let projectId: String?
    public let clientRequestToken: String?
    public let userArn: String?
    public let projectRole: String?
    public let remoteAccessAllowed: Bool
}

extension AssociateTeamMemberInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case projectId
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let projectRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectRole)
        projectRole = projectRoleDecoded
        let remoteAccessAllowedDecoded = try containerValues.decode(Bool.self, forKey: .remoteAccessAllowed)
        remoteAccessAllowed = remoteAccessAllowedDecoded
    }
}

extension AssociateTeamMemberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateTeamMemberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectConfigurationException" : self = .projectConfigurationException(try ProjectConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TeamMemberAlreadyAssociatedException" : self = .teamMemberAlreadyAssociatedException(try TeamMemberAlreadyAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateTeamMemberOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case limitExceededException(LimitExceededException)
    case projectConfigurationException(ProjectConfigurationException)
    case projectNotFoundException(ProjectNotFoundException)
    case teamMemberAlreadyAssociatedException(TeamMemberAlreadyAssociatedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateTeamMemberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateTeamMemberOutputResponse(clientRequestToken: \(String(describing: clientRequestToken)))"}
}

extension AssociateTeamMemberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateTeamMemberOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientRequestToken = output.clientRequestToken
        } else {
            self.clientRequestToken = nil
        }
    }
}

public struct AssociateTeamMemberOutputResponse: Equatable {
    /// <p>The user- or system-generated token from the initial request that can be used to repeat
    ///       the request.</p>
    public let clientRequestToken: String?

    public init (
        clientRequestToken: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
    }
}

struct AssociateTeamMemberOutputResponseBody: Equatable {
    public let clientRequestToken: String?
}

extension AssociateTeamMemberOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension Code: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination
        case source
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(CodeSource.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(CodeDestination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension Code: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Code(destination: \(String(describing: destination)), source: \(String(describing: source)))"}
}

/// <p>Location and destination information about the source code files provided with the
///       project request. The source code is uploaded to the new project source repository after
///       project creation.</p>
public struct Code: Equatable {
    /// <p>The repository to be created in AWS CodeStar. Valid values are AWS CodeCommit or GitHub. After AWS CodeStar provisions the new repository, the
    ///       source code files provided with the project request are placed in the repository.</p>
    public let destination: CodeDestination?
    /// <p>The location where the source code files provided with the project request are
    ///       stored. AWS CodeStar retrieves the files during project creation.</p>
    public let source: CodeSource?

    public init (
        destination: CodeDestination? = nil,
        source: CodeSource? = nil
    )
    {
        self.destination = destination
        self.source = source
    }
}

extension CodeCommitCodeDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CodeCommitCodeDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeCommitCodeDestination(name: \(String(describing: name)))"}
}

/// <p>Information about the AWS CodeCommit repository to be created in AWS CodeStar. This is where the source code files provided
///       with the project request will be uploaded after project creation.</p>
public struct CodeCommitCodeDestination: Equatable {
    /// <p>The name of the AWS CodeCommit repository to be created in AWS CodeStar.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension CodeDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeCommit
        case gitHub
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeCommit = codeCommit {
            try encodeContainer.encode(codeCommit, forKey: .codeCommit)
        }
        if let gitHub = gitHub {
            try encodeContainer.encode(gitHub, forKey: .gitHub)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeCommitDecoded = try containerValues.decodeIfPresent(CodeCommitCodeDestination.self, forKey: .codeCommit)
        codeCommit = codeCommitDecoded
        let gitHubDecoded = try containerValues.decodeIfPresent(GitHubCodeDestination.self, forKey: .gitHub)
        gitHub = gitHubDecoded
    }
}

extension CodeDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeDestination(codeCommit: \(String(describing: codeCommit)), gitHub: \(String(describing: gitHub)))"}
}

/// <p>The repository to be created in AWS CodeStar. Valid values are AWS CodeCommit or GitHub. After AWS CodeStar provisions the new repository, the
///       source code files provided with the project request are placed in the repository.</p>
public struct CodeDestination: Equatable {
    /// <p>Information about the AWS CodeCommit repository to be created in AWS CodeStar. This is where the source code files provided
    ///       with the project request will be uploaded after project creation.</p>
    public let codeCommit: CodeCommitCodeDestination?
    /// <p>Information about the GitHub repository to be created in AWS CodeStar. This is where the source code files provided with the
    ///       project request will be uploaded after project creation.</p>
    public let gitHub: GitHubCodeDestination?

    public init (
        codeCommit: CodeCommitCodeDestination? = nil,
        gitHub: GitHubCodeDestination? = nil
    )
    {
        self.codeCommit = codeCommit
        self.gitHub = gitHub
    }
}

extension CodeSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension CodeSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeSource(s3: \(String(describing: s3)))"}
}

/// <p>The location where the source code files provided with the project request are
///       stored. AWS CodeStar retrieves the files during project creation.</p>
public struct CodeSource: Equatable {
    /// <p>Information about the Amazon S3 location where the source code files provided with the
    ///       project request are stored. </p>
    public let s3: S3Location?

    public init (
        s3: S3Location? = nil
    )
    {
        self.s3 = s3
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Another modification is being made. That modification must complete before you can make
///       your change.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateProjectInputBodyMiddleware: Middleware {
    public let id: String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

extension CreateProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProjectInput(clientRequestToken: \(String(describing: clientRequestToken)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), sourceCode: \(String(describing: sourceCode)), tags: \(String(describing: tags)), toolchain: \(String(describing: toolchain)))"}
}

extension CreateProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case description
        case id
        case name
        case sourceCode
        case tags
        case toolchain
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceCode = sourceCode {
            var sourceCodeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceCode)
            for sourcecode0 in sourceCode {
                try sourceCodeContainer.encode(sourcecode0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let toolchain = toolchain {
            try encodeContainer.encode(toolchain, forKey: .toolchain)
        }
    }
}

public struct CreateProjectInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

public struct CreateProjectInput: Equatable {
    /// <p>A user- or system-generated token that identifies the entity that requested project
    ///       creation. This token can be used to repeat the request.</p>
    public let clientRequestToken: String?
    /// <p>The description of the project, if any.</p>
    public let description: String?
    /// <p>The ID of the project to be created in AWS CodeStar.</p>
    public let id: String?
    /// <p>The display name for the project to be created in AWS CodeStar.</p>
    public let name: String?
    /// <p>A list of the Code objects submitted with the project request. If this
    ///       parameter is specified, the request must also include the toolchain parameter.</p>
    public let sourceCode: [Code]?
    /// <p>The tags created for the project.</p>
    public let tags: [String:String]?
    /// <p>The name of the toolchain template file submitted with the project request. If
    ///       this parameter is specified, the request must also include the sourceCode parameter.</p>
    public let toolchain: Toolchain?

    public init (
        clientRequestToken: String? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        sourceCode: [Code]? = nil,
        tags: [String:String]? = nil,
        toolchain: Toolchain? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.id = id
        self.name = name
        self.sourceCode = sourceCode
        self.tags = tags
        self.toolchain = toolchain
    }
}

struct CreateProjectInputBody: Equatable {
    public let name: String?
    public let id: String?
    public let description: String?
    public let clientRequestToken: String?
    public let sourceCode: [Code]?
    public let toolchain: Toolchain?
    public let tags: [String:String]?
}

extension CreateProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case description
        case id
        case name
        case sourceCode
        case tags
        case toolchain
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let sourceCodeContainer = try containerValues.decodeIfPresent([Code?].self, forKey: .sourceCode)
        var sourceCodeDecoded0:[Code]? = nil
        if let sourceCodeContainer = sourceCodeContainer {
            sourceCodeDecoded0 = [Code]()
            for structure0 in sourceCodeContainer {
                if let structure0 = structure0 {
                    sourceCodeDecoded0?.append(structure0)
                }
            }
        }
        sourceCode = sourceCodeDecoded0
        let toolchainDecoded = try containerValues.decodeIfPresent(Toolchain.self, forKey: .toolchain)
        toolchain = toolchainDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectAlreadyExistsException" : self = .projectAlreadyExistsException(try ProjectAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectConfigurationException" : self = .projectConfigurationException(try ProjectConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectCreationFailedException" : self = .projectCreationFailedException(try ProjectCreationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProjectOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case limitExceededException(LimitExceededException)
    case projectAlreadyExistsException(ProjectAlreadyExistsException)
    case projectConfigurationException(ProjectConfigurationException)
    case projectCreationFailedException(ProjectCreationFailedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProjectOutputResponse(arn: \(String(describing: arn)), clientRequestToken: \(String(describing: clientRequestToken)), id: \(String(describing: id)), projectTemplateId: \(String(describing: projectTemplateId)))"}
}

extension CreateProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.id = output.id
            self.projectTemplateId = output.projectTemplateId
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.id = nil
            self.projectTemplateId = nil
        }
    }
}

public struct CreateProjectOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the created project.</p>
    public let arn: String?
    /// <p>A user- or system-generated token that identifies the entity that requested project
    ///       creation.</p>
    public let clientRequestToken: String?
    /// <p>The ID of the project.</p>
    public let id: String?
    /// <p>Reserved for future use.</p>
    public let projectTemplateId: String?

    public init (
        arn: String? = nil,
        clientRequestToken: String? = nil,
        id: String? = nil,
        projectTemplateId: String? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.id = id
        self.projectTemplateId = projectTemplateId
    }
}

struct CreateProjectOutputResponseBody: Equatable {
    public let id: String?
    public let arn: String?
    public let clientRequestToken: String?
    public let projectTemplateId: String?
}

extension CreateProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case clientRequestToken
        case id
        case projectTemplateId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let projectTemplateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectTemplateId)
        projectTemplateId = projectTemplateIdDecoded
    }
}

public struct CreateUserProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateUserProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserProfileInput>
    public typealias MOutput = OperationOutput<CreateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserProfileOutputError>
}

extension CreateUserProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserProfileInput(displayName: \(String(describing: displayName)), emailAddress: \(String(describing: emailAddress)), sshPublicKey: \(String(describing: sshPublicKey)), userArn: \(String(describing: userArn)))"}
}

extension CreateUserProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct CreateUserProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserProfileInput>
    public typealias MOutput = OperationOutput<CreateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserProfileOutputError>
}

public struct CreateUserProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserProfileInput>
    public typealias MOutput = OperationOutput<CreateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserProfileOutputError>
}

public struct CreateUserProfileInput: Equatable {
    /// <p>The name that will be displayed as the friendly name for the user in AWS CodeStar. </p>
    public let displayName: String?
    /// <p>The email address that will be displayed as part of the user's profile in
    ///       AWS CodeStar.</p>
    public let emailAddress: String?
    /// <p>The SSH public key associated with the user in AWS CodeStar. If a project owner allows the
    ///       user remote access to project resources, this public key will be used along with the user's
    ///       private key for SSH access.</p>
    public let sshPublicKey: String?
    /// <p>The Amazon Resource Name (ARN) of the user in IAM.</p>
    public let userArn: String?

    public init (
        displayName: String? = nil,
        emailAddress: String? = nil,
        sshPublicKey: String? = nil,
        userArn: String? = nil
    )
    {
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct CreateUserProfileInputBody: Equatable {
    public let userArn: String?
    public let displayName: String?
    public let emailAddress: String?
    public let sshPublicKey: String?
}

extension CreateUserProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension CreateUserProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "UserProfileAlreadyExistsException" : self = .userProfileAlreadyExistsException(try UserProfileAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserProfileOutputError: Equatable {
    case userProfileAlreadyExistsException(UserProfileAlreadyExistsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserProfileOutputResponse(createdTimestamp: \(String(describing: createdTimestamp)), displayName: \(String(describing: displayName)), emailAddress: \(String(describing: emailAddress)), lastModifiedTimestamp: \(String(describing: lastModifiedTimestamp)), sshPublicKey: \(String(describing: sshPublicKey)), userArn: \(String(describing: userArn)))"}
}

extension CreateUserProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUserProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdTimestamp = output.createdTimestamp
            self.displayName = output.displayName
            self.emailAddress = output.emailAddress
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.sshPublicKey = output.sshPublicKey
            self.userArn = output.userArn
        } else {
            self.createdTimestamp = nil
            self.displayName = nil
            self.emailAddress = nil
            self.lastModifiedTimestamp = nil
            self.sshPublicKey = nil
            self.userArn = nil
        }
    }
}

public struct CreateUserProfileOutputResponse: Equatable {
    /// <p>The date the user profile was created, in timestamp format.</p>
    public let createdTimestamp: Date?
    /// <p>The name that is displayed as the friendly name for the user in AWS CodeStar.</p>
    public let displayName: String?
    /// <p>The email address that is displayed as part of the user's profile in AWS CodeStar.</p>
    public let emailAddress: String?
    /// <p>The date the user profile was last modified, in timestamp format.</p>
    public let lastModifiedTimestamp: Date?
    /// <p>The SSH public key associated with the user in AWS CodeStar. This is the public portion of the
    ///       public/private keypair the user can use to access project resources if a project owner allows
    ///       the user remote access to those resources.</p>
    public let sshPublicKey: String?
    /// <p>The Amazon Resource Name (ARN) of the user in IAM.</p>
    public let userArn: String?

    public init (
        createdTimestamp: Date? = nil,
        displayName: String? = nil,
        emailAddress: String? = nil,
        lastModifiedTimestamp: Date? = nil,
        sshPublicKey: String? = nil,
        userArn: String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct CreateUserProfileOutputResponseBody: Equatable {
    public let userArn: String?
    public let displayName: String?
    public let emailAddress: String?
    public let sshPublicKey: String?
    public let createdTimestamp: Date?
    public let lastModifiedTimestamp: Date?
}

extension CreateUserProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdTimestamp
        case displayName
        case emailAddress
        case lastModifiedTimestamp
        case sshPublicKey
        case userArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

public struct DeleteProjectInputBodyMiddleware: Middleware {
    public let id: String = "DeleteProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

extension DeleteProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProjectInput(clientRequestToken: \(String(describing: clientRequestToken)), deleteStack: \(String(describing: deleteStack)), id: \(String(describing: id)))"}
}

extension DeleteProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case deleteStack
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if deleteStack != false {
            try encodeContainer.encode(deleteStack, forKey: .deleteStack)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteProjectInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInput: Equatable {
    /// <p>A user- or system-generated token that identifies the entity that requested project
    ///       deletion. This token can be used to repeat the request. </p>
    public let clientRequestToken: String?
    /// <p>Whether to send a delete request for the primary stack in AWS CloudFormation originally
    ///       used to generate the project and its resources. This option will delete all AWS resources for
    ///       the project (except for any buckets in Amazon S3) as well as deleting the project itself.
    ///       Recommended for most use cases.</p>
    public let deleteStack: Bool
    /// <p>The ID of the project to be deleted in AWS CodeStar.</p>
    public let id: String?

    public init (
        clientRequestToken: String? = nil,
        deleteStack: Bool = false,
        id: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.deleteStack = deleteStack
        self.id = id
    }
}

struct DeleteProjectInputBody: Equatable {
    public let id: String?
    public let clientRequestToken: String?
    public let deleteStack: Bool
}

extension DeleteProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case deleteStack
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let deleteStackDecoded = try containerValues.decode(Bool.self, forKey: .deleteStack)
        deleteStack = deleteStackDecoded
    }
}

extension DeleteProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProjectOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProjectOutputResponse(projectArn: \(String(describing: projectArn)), stackId: \(String(describing: stackId)))"}
}

extension DeleteProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.projectArn = output.projectArn
            self.stackId = output.stackId
        } else {
            self.projectArn = nil
            self.stackId = nil
        }
    }
}

public struct DeleteProjectOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the deleted project.</p>
    public let projectArn: String?
    /// <p>The ID of the primary stack in AWS CloudFormation that will be deleted as part of
    ///       deleting the project and its resources.</p>
    public let stackId: String?

    public init (
        projectArn: String? = nil,
        stackId: String? = nil
    )
    {
        self.projectArn = projectArn
        self.stackId = stackId
    }
}

struct DeleteProjectOutputResponseBody: Equatable {
    public let stackId: String?
    public let projectArn: String?
}

extension DeleteProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case projectArn
        case stackId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

public struct DeleteUserProfileInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUserProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserProfileInput>
    public typealias MOutput = OperationOutput<DeleteUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserProfileOutputError>
}

extension DeleteUserProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserProfileInput(userArn: \(String(describing: userArn)))"}
}

extension DeleteUserProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct DeleteUserProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserProfileInput>
    public typealias MOutput = OperationOutput<DeleteUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserProfileOutputError>
}

public struct DeleteUserProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserProfileInput>
    public typealias MOutput = OperationOutput<DeleteUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserProfileOutputError>
}

public struct DeleteUserProfileInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the user to delete from AWS CodeStar.</p>
    public let userArn: String?

    public init (
        userArn: String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct DeleteUserProfileInputBody: Equatable {
    public let userArn: String?
}

extension DeleteUserProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension DeleteUserProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserProfileOutputError: Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserProfileOutputResponse(userArn: \(String(describing: userArn)))"}
}

extension DeleteUserProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteUserProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userArn = output.userArn
        } else {
            self.userArn = nil
        }
    }
}

public struct DeleteUserProfileOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the user deleted from AWS CodeStar.</p>
    public let userArn: String?

    public init (
        userArn: String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct DeleteUserProfileOutputResponseBody: Equatable {
    public let userArn: String?
}

extension DeleteUserProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

public struct DescribeProjectInputBodyMiddleware: Middleware {
    public let id: String = "DescribeProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProjectOutputError>
}

extension DescribeProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProjectInput(id: \(String(describing: id)))"}
}

extension DescribeProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DescribeProjectInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInput: Equatable {
    /// <p>The ID of the project.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeProjectInputBody: Equatable {
    public let id: String?
}

extension DescribeProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectConfigurationException" : self = .projectConfigurationException(try ProjectConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProjectOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case projectConfigurationException(ProjectConfigurationException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProjectOutputResponse(arn: \(String(describing: arn)), clientRequestToken: \(String(describing: clientRequestToken)), createdTimeStamp: \(String(describing: createdTimeStamp)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), projectTemplateId: \(String(describing: projectTemplateId)), stackId: \(String(describing: stackId)), status: \(String(describing: status)))"}
}

extension DescribeProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdTimeStamp = output.createdTimeStamp
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.projectTemplateId = output.projectTemplateId
            self.stackId = output.stackId
            self.status = output.status
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdTimeStamp = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.projectTemplateId = nil
            self.stackId = nil
            self.status = nil
        }
    }
}

public struct DescribeProjectOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the project.</p>
    public let arn: String?
    /// <p>A user- or system-generated token that identifies the entity that requested project
    ///       creation. </p>
    public let clientRequestToken: String?
    /// <p>The date and time the project was created, in timestamp format.</p>
    public let createdTimeStamp: Date?
    /// <p>The description of the project, if any.</p>
    public let description: String?
    /// <p>The ID of the project.</p>
    public let id: String?
    /// <p>The display name for the project.</p>
    public let name: String?
    /// <p>The ID for the AWS CodeStar project template used to create the project.</p>
    public let projectTemplateId: String?
    /// <p>The ID of the primary stack in AWS CloudFormation used to generate resources for the
    ///       project.</p>
    public let stackId: String?
    /// <p>The project creation or deletion status.</p>
    public let status: ProjectStatus?

    public init (
        arn: String? = nil,
        clientRequestToken: String? = nil,
        createdTimeStamp: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        projectTemplateId: String? = nil,
        stackId: String? = nil,
        status: ProjectStatus? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdTimeStamp = createdTimeStamp
        self.description = description
        self.id = id
        self.name = name
        self.projectTemplateId = projectTemplateId
        self.stackId = stackId
        self.status = status
    }
}

struct DescribeProjectOutputResponseBody: Equatable {
    public let name: String?
    public let id: String?
    public let arn: String?
    public let description: String?
    public let clientRequestToken: String?
    public let createdTimeStamp: Date?
    public let stackId: String?
    public let projectTemplateId: String?
    public let status: ProjectStatus?
}

extension DescribeProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case clientRequestToken
        case createdTimeStamp
        case description
        case id
        case name
        case projectTemplateId
        case stackId
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let createdTimeStampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimeStamp)
        createdTimeStamp = createdTimeStampDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let projectTemplateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectTemplateId)
        projectTemplateId = projectTemplateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProjectStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DescribeUserProfileInputBodyMiddleware: Middleware {
    public let id: String = "DescribeUserProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserProfileInput>
    public typealias MOutput = OperationOutput<DescribeUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserProfileOutputError>
}

extension DescribeUserProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserProfileInput(userArn: \(String(describing: userArn)))"}
}

extension DescribeUserProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct DescribeUserProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserProfileInput>
    public typealias MOutput = OperationOutput<DescribeUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserProfileOutputError>
}

public struct DescribeUserProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserProfileInput>
    public typealias MOutput = OperationOutput<DescribeUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserProfileOutputError>
}

public struct DescribeUserProfileInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the user.</p>
    public let userArn: String?

    public init (
        userArn: String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct DescribeUserProfileInputBody: Equatable {
    public let userArn: String?
}

extension DescribeUserProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension DescribeUserProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "UserProfileNotFoundException" : self = .userProfileNotFoundException(try UserProfileNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserProfileOutputError: Equatable {
    case userProfileNotFoundException(UserProfileNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserProfileOutputResponse(createdTimestamp: \(String(describing: createdTimestamp)), displayName: \(String(describing: displayName)), emailAddress: \(String(describing: emailAddress)), lastModifiedTimestamp: \(String(describing: lastModifiedTimestamp)), sshPublicKey: \(String(describing: sshPublicKey)), userArn: \(String(describing: userArn)))"}
}

extension DescribeUserProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUserProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdTimestamp = output.createdTimestamp
            self.displayName = output.displayName
            self.emailAddress = output.emailAddress
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.sshPublicKey = output.sshPublicKey
            self.userArn = output.userArn
        } else {
            self.createdTimestamp = nil
            self.displayName = nil
            self.emailAddress = nil
            self.lastModifiedTimestamp = nil
            self.sshPublicKey = nil
            self.userArn = nil
        }
    }
}

public struct DescribeUserProfileOutputResponse: Equatable {
    /// <p>The date and time when the user profile was created in AWS CodeStar, in timestamp
    ///       format.</p>
    public let createdTimestamp: Date?
    /// <p>The display name shown for the user in AWS CodeStar projects. For example, this could be set
    ///       to both first and last name ("Mary Major") or a single name ("Mary"). The display name is also
    ///       used to generate the initial icon associated with the user in AWS CodeStar projects. If spaces are
    ///       included in the display name, the first character that appears after the space will be used as
    ///       the second character in the user initial icon. The initial icon displays a maximum of two
    ///       characters, so a display name with more than one space (for example "Mary Jane Major") would
    ///       generate an initial icon using the first character and the first character after the space
    ///       ("MJ", not "MM").</p>
    public let displayName: String?
    /// <p>The email address for the user. Optional.</p>
    public let emailAddress: String?
    /// <p>The date and time when the user profile was last modified, in timestamp
    ///       format.</p>
    public let lastModifiedTimestamp: Date?
    /// <p>The SSH public key associated with the user. This SSH public key is associated with the
    ///       user profile, and can be used in conjunction with the associated private key for access to
    ///       project resources, such as Amazon EC2 instances, if a project owner grants remote access to
    ///       those resources.</p>
    public let sshPublicKey: String?
    /// <p>The Amazon Resource Name (ARN) of the user.</p>
    public let userArn: String?

    public init (
        createdTimestamp: Date? = nil,
        displayName: String? = nil,
        emailAddress: String? = nil,
        lastModifiedTimestamp: Date? = nil,
        sshPublicKey: String? = nil,
        userArn: String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct DescribeUserProfileOutputResponseBody: Equatable {
    public let userArn: String?
    public let displayName: String?
    public let emailAddress: String?
    public let sshPublicKey: String?
    public let createdTimestamp: Date?
    public let lastModifiedTimestamp: Date?
}

extension DescribeUserProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdTimestamp
        case displayName
        case emailAddress
        case lastModifiedTimestamp
        case sshPublicKey
        case userArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

public struct DisassociateTeamMemberInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateTeamMemberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateTeamMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateTeamMemberInput>
    public typealias MOutput = OperationOutput<DisassociateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateTeamMemberOutputError>
}

extension DisassociateTeamMemberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateTeamMemberInput(projectId: \(String(describing: projectId)), userArn: \(String(describing: userArn)))"}
}

extension DisassociateTeamMemberInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case projectId
        case userArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct DisassociateTeamMemberInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateTeamMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateTeamMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateTeamMemberInput>
    public typealias MOutput = OperationOutput<DisassociateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateTeamMemberOutputError>
}

public struct DisassociateTeamMemberInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateTeamMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateTeamMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateTeamMemberInput>
    public typealias MOutput = OperationOutput<DisassociateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateTeamMemberOutputError>
}

public struct DisassociateTeamMemberInput: Equatable {
    /// <p>The ID of the AWS CodeStar project from which you want to remove a team member.</p>
    public let projectId: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM user or group whom you want to remove from
    ///       the project.</p>
    public let userArn: String?

    public init (
        projectId: String? = nil,
        userArn: String? = nil
    )
    {
        self.projectId = projectId
        self.userArn = userArn
    }
}

struct DisassociateTeamMemberInputBody: Equatable {
    public let projectId: String?
    public let userArn: String?
}

extension DisassociateTeamMemberInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case projectId
        case userArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension DisassociateTeamMemberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateTeamMemberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateTeamMemberOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateTeamMemberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateTeamMemberOutputResponse()"}
}

extension DisassociateTeamMemberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateTeamMemberOutputResponse: Equatable {

    public init() {}
}

struct DisassociateTeamMemberOutputResponseBody: Equatable {
}

extension DisassociateTeamMemberOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GitHubCodeDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case issuesEnabled
        case name
        case owner
        case privateRepository
        case token
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if issuesEnabled != false {
            try encodeContainer.encode(issuesEnabled, forKey: .issuesEnabled)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if privateRepository != false {
            try encodeContainer.encode(privateRepository, forKey: .privateRepository)
        }
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let privateRepositoryDecoded = try containerValues.decode(Bool.self, forKey: .privateRepository)
        privateRepository = privateRepositoryDecoded
        let issuesEnabledDecoded = try containerValues.decode(Bool.self, forKey: .issuesEnabled)
        issuesEnabled = issuesEnabledDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension GitHubCodeDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GitHubCodeDestination(description: \(String(describing: description)), issuesEnabled: \(String(describing: issuesEnabled)), name: \(String(describing: name)), owner: \(String(describing: owner)), privateRepository: \(String(describing: privateRepository)), token: \(String(describing: token)), type: \(String(describing: type)))"}
}

/// <p>Information about the GitHub repository to be created in AWS CodeStar. This is where the source code files provided with the
///       project request will be uploaded after project creation.</p>
public struct GitHubCodeDestination: Equatable {
    /// <p>Description for the GitHub repository to be created in AWS CodeStar. This description displays in
    ///       GitHub after the repository is created.</p>
    public let description: String?
    /// <p>Whether to enable issues for the GitHub repository.</p>
    public let issuesEnabled: Bool
    /// <p>Name of the GitHub repository to be created in AWS CodeStar.</p>
    public let name: String?
    /// <p>The GitHub username for the owner of the GitHub repository to be created in AWS CodeStar. If this repository should
    ///       be owned by a GitHub organization, provide its name.</p>
    public let owner: String?
    /// <p>Whether the GitHub repository is to be a private repository.</p>
    public let privateRepository: Bool
    /// <p>The GitHub user's personal access token for the GitHub repository.</p>
    public let token: String?
    /// <p>The type of GitHub repository to be created in AWS CodeStar. Valid values are User or Organization.</p>
    public let type: String?

    public init (
        description: String? = nil,
        issuesEnabled: Bool = false,
        name: String? = nil,
        owner: String? = nil,
        privateRepository: Bool = false,
        token: String? = nil,
        type: String? = nil
    )
    {
        self.description = description
        self.issuesEnabled = issuesEnabled
        self.name = name
        self.owner = owner
        self.privateRepository = privateRepository
        self.token = token
        self.type = type
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The next token is not valid.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidServiceRoleException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidServiceRoleException(message: \(String(describing: message)))"}
}

extension InvalidServiceRoleException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidServiceRoleExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service role is not valid.</p>
public struct InvalidServiceRoleException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidServiceRoleExceptionBody: Equatable {
    public let message: String?
}

extension InvalidServiceRoleExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource limit has been exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListProjectsInputBodyMiddleware: Middleware {
    public let id: String = "ListProjectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

extension ListProjectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProjectsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListProjectsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

public struct ListProjectsInput: Equatable {
    /// <p>The maximum amount of data that can be contained in a single set of results.</p>
    public let maxResults: Int
    /// <p>The continuation token to be used to return the next set of results, if the results
    ///       cannot be returned in one response.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int
}

extension ListProjectsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListProjectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectsOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectsOutputResponse(nextToken: \(String(describing: nextToken)), projects: \(String(describing: projects)))"}
}

extension ListProjectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListProjectsOutputResponse: Equatable {
    /// <p>The continuation token to use when requesting the next set of results, if there are
    ///       more results to be returned.</p>
    public let nextToken: String?
    /// <p>A list of projects.</p>
    public let projects: [ProjectSummary]?

    public init (
        nextToken: String? = nil,
        projects: [ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Equatable {
    public let projects: [ProjectSummary]?
    public let nextToken: String?
}

extension ListProjectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case projects
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([ProjectSummary?].self, forKey: .projects)
        var projectsDecoded0:[ProjectSummary]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [ProjectSummary]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourcesInputBodyMiddleware: Middleware {
    public let id: String = "ListResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesInput>
    public typealias MOutput = OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesOutputError>
}

extension ListResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourcesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), projectId: \(String(describing: projectId)))"}
}

extension ListResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case projectId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }
}

public struct ListResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesInput>
    public typealias MOutput = OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesOutputError>
}

public struct ListResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesInput>
    public typealias MOutput = OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesOutputError>
}

public struct ListResourcesInput: Equatable {
    /// <p>The maximum amount of data that can be contained in a single set of results.</p>
    public let maxResults: Int
    /// <p>The continuation token for the next set of results, if the results cannot be returned
    ///       in one response.</p>
    public let nextToken: String?
    /// <p>The ID of the project.</p>
    public let projectId: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        projectId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

struct ListResourcesInputBody: Equatable {
    public let projectId: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case projectId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourcesOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourcesOutputResponse(nextToken: \(String(describing: nextToken)), resources: \(String(describing: resources)))"}
}

extension ListResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListResourcesOutputResponse: Equatable {
    /// <p>The continuation token to use when requesting the next set of results, if there are
    ///       more results to be returned.</p>
    public let nextToken: String?
    /// <p>An array of resources associated with the project. </p>
    public let resources: [Resource]?

    public init (
        nextToken: String? = nil,
        resources: [Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListResourcesOutputResponseBody: Equatable {
    public let resources: [Resource]?
    public let nextToken: String?
}

extension ListResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case resources
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForProjectInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForProjectInput>
    public typealias MOutput = OperationOutput<ListTagsForProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForProjectOutputError>
}

extension ListTagsForProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForProjectInput(id: \(String(describing: id)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTagsForProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTagsForProjectInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForProjectInput>
    public typealias MOutput = OperationOutput<ListTagsForProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForProjectOutputError>
}

public struct ListTagsForProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForProjectInput>
    public typealias MOutput = OperationOutput<ListTagsForProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForProjectOutputError>
}

public struct ListTagsForProjectInput: Equatable {
    /// <p>The ID of the project to get tags for.</p>
    public let id: String?
    /// <p>Reserved for future use.</p>
    public let maxResults: Int
    /// <p>Reserved for future use.</p>
    public let nextToken: String?

    public init (
        id: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTagsForProjectInputBody: Equatable {
    public let id: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListTagsForProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForProjectOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForProjectOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForProjectOutputResponse: Equatable {
    /// <p>Reserved for future use.</p>
    public let nextToken: String?
    /// <p>The tags for the project.</p>
    public let tags: [String:String]?

    public init (
        nextToken: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForProjectOutputResponseBody: Equatable {
    public let tags: [String:String]?
    public let nextToken: String?
}

extension ListTagsForProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTeamMembersInputBodyMiddleware: Middleware {
    public let id: String = "ListTeamMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTeamMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTeamMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTeamMembersInput>
    public typealias MOutput = OperationOutput<ListTeamMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTeamMembersOutputError>
}

extension ListTeamMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTeamMembersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), projectId: \(String(describing: projectId)))"}
}

extension ListTeamMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case projectId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }
}

public struct ListTeamMembersInputHeadersMiddleware: Middleware {
    public let id: String = "ListTeamMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTeamMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTeamMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTeamMembersInput>
    public typealias MOutput = OperationOutput<ListTeamMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTeamMembersOutputError>
}

public struct ListTeamMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTeamMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTeamMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTeamMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTeamMembersInput>
    public typealias MOutput = OperationOutput<ListTeamMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTeamMembersOutputError>
}

public struct ListTeamMembersInput: Equatable {
    /// <p>The maximum number of team members you want returned in a response.</p>
    public let maxResults: Int
    /// <p>The continuation token for the next set of results, if the results cannot be returned
    ///       in one response.</p>
    public let nextToken: String?
    /// <p>The ID of the project for which you want to list team members.</p>
    public let projectId: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        projectId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

struct ListTeamMembersInputBody: Equatable {
    public let projectId: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListTeamMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case projectId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTeamMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTeamMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTeamMembersOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTeamMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTeamMembersOutputResponse(nextToken: \(String(describing: nextToken)), teamMembers: \(String(describing: teamMembers)))"}
}

extension ListTeamMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTeamMembersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.teamMembers = output.teamMembers
        } else {
            self.nextToken = nil
            self.teamMembers = nil
        }
    }
}

public struct ListTeamMembersOutputResponse: Equatable {
    /// <p>The continuation token to use when requesting the next set of results, if there are
    ///       more results to be returned.</p>
    public let nextToken: String?
    /// <p>A list of team member objects for the project.</p>
    public let teamMembers: [TeamMember]?

    public init (
        nextToken: String? = nil,
        teamMembers: [TeamMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.teamMembers = teamMembers
    }
}

struct ListTeamMembersOutputResponseBody: Equatable {
    public let teamMembers: [TeamMember]?
    public let nextToken: String?
}

extension ListTeamMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case teamMembers
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamMembersContainer = try containerValues.decodeIfPresent([TeamMember?].self, forKey: .teamMembers)
        var teamMembersDecoded0:[TeamMember]? = nil
        if let teamMembersContainer = teamMembersContainer {
            teamMembersDecoded0 = [TeamMember]()
            for structure0 in teamMembersContainer {
                if let structure0 = structure0 {
                    teamMembersDecoded0?.append(structure0)
                }
            }
        }
        teamMembers = teamMembersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListUserProfilesInputBodyMiddleware: Middleware {
    public let id: String = "ListUserProfilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserProfilesInput>
    public typealias MOutput = OperationOutput<ListUserProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserProfilesOutputError>
}

extension ListUserProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUserProfilesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListUserProfilesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListUserProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "ListUserProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserProfilesInput>
    public typealias MOutput = OperationOutput<ListUserProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserProfilesOutputError>
}

public struct ListUserProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUserProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserProfilesInput>
    public typealias MOutput = OperationOutput<ListUserProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserProfilesOutputError>
}

public struct ListUserProfilesInput: Equatable {
    /// <p>The maximum number of results to return in a response.</p>
    public let maxResults: Int
    /// <p>The continuation token for the next set of results, if the results cannot be returned
    ///       in one response.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserProfilesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int
}

extension ListUserProfilesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListUserProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUserProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUserProfilesOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUserProfilesOutputResponse(nextToken: \(String(describing: nextToken)), userProfiles: \(String(describing: userProfiles)))"}
}

extension ListUserProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUserProfilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.userProfiles = output.userProfiles
        } else {
            self.nextToken = nil
            self.userProfiles = nil
        }
    }
}

public struct ListUserProfilesOutputResponse: Equatable {
    /// <p>The continuation token to use when requesting the next set of results, if there are
    ///       more results to be returned.</p>
    public let nextToken: String?
    /// <p>All the user profiles configured in AWS CodeStar for an AWS account.</p>
    public let userProfiles: [UserProfileSummary]?

    public init (
        nextToken: String? = nil,
        userProfiles: [UserProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userProfiles = userProfiles
    }
}

struct ListUserProfilesOutputResponseBody: Equatable {
    public let userProfiles: [UserProfileSummary]?
    public let nextToken: String?
}

extension ListUserProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case userProfiles
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userProfilesContainer = try containerValues.decodeIfPresent([UserProfileSummary?].self, forKey: .userProfiles)
        var userProfilesDecoded0:[UserProfileSummary]? = nil
        if let userProfilesContainer = userProfilesContainer {
            userProfilesDecoded0 = [UserProfileSummary]()
            for structure0 in userProfilesContainer {
                if let structure0 = structure0 {
                    userProfilesDecoded0?.append(structure0)
                }
            }
        }
        userProfiles = userProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ProjectAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ProjectAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ProjectAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An AWS CodeStar project with the same ID already exists in this region for the AWS account.
///       AWS CodeStar project IDs must be unique within a region for the AWS account.</p>
public struct ProjectAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ProjectAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ProjectAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProjectConfigurationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectConfigurationException(message: \(String(describing: message)))"}
}

extension ProjectConfigurationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ProjectConfigurationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Project configuration information is required but not specified.</p>
public struct ProjectConfigurationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ProjectConfigurationExceptionBody: Equatable {
    public let message: String?
}

extension ProjectConfigurationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProjectCreationFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectCreationFailedException(message: \(String(describing: message)))"}
}

extension ProjectCreationFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ProjectCreationFailedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The project creation request was valid, but a nonspecific exception or error occurred
///       during project creation. The project could not be created in AWS CodeStar.</p>
public struct ProjectCreationFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ProjectCreationFailedExceptionBody: Equatable {
    public let message: String?
}

extension ProjectCreationFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProjectNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectNotFoundException(message: \(String(describing: message)))"}
}

extension ProjectNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ProjectNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified AWS CodeStar project was not found.</p>
public struct ProjectNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ProjectNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ProjectNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProjectStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reason
        case state
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ProjectStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectStatus(reason: \(String(describing: reason)), state: \(String(describing: state)))"}
}

/// <p>An indication of whether a project creation or deletion is failed or
///       successful.</p>
public struct ProjectStatus: Equatable {
    /// <p>In the case of a project creation or deletion failure, a reason for the
    ///       failure.</p>
    public let reason: String?
    /// <p>The phase of completion for a project creation or deletion.</p>
    public let state: String?

    public init (
        reason: String? = nil,
        state: String? = nil
    )
    {
        self.reason = reason
        self.state = state
    }
}

extension ProjectSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case projectArn
        case projectId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension ProjectSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectSummary(projectArn: \(String(describing: projectArn)), projectId: \(String(describing: projectId)))"}
}

/// <p>Information about the metadata for a project.</p>
public struct ProjectSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the project.</p>
    public let projectArn: String?
    /// <p>The ID of the project.</p>
    public let projectId: String?

    public init (
        projectArn: String? = nil,
        projectId: String? = nil
    )
    {
        self.projectArn = projectArn
        self.projectId = projectId
    }
}

extension Resource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension Resource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Resource(id: \(String(describing: id)))"}
}

/// <p>Information about a resource for a project.</p>
public struct Resource: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

extension S3Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketKey
        case bucketName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketKey = bucketKey {
            try encodeContainer.encode(bucketKey, forKey: .bucketKey)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketKey)
        bucketKey = bucketKeyDecoded
    }
}

extension S3Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Location(bucketKey: \(String(describing: bucketKey)), bucketName: \(String(describing: bucketName)))"}
}

/// <p>The Amazon S3 location where the source code files provided with the project
///       request are stored.</p>
public struct S3Location: Equatable {
    /// <p>The Amazon S3 object key where the source code files provided with the project
    ///       request are stored.</p>
    public let bucketKey: String?
    /// <p>The Amazon S3 bucket name where the source code files provided with the project
    ///       request are stored.</p>
    public let bucketName: String?

    public init (
        bucketKey: String? = nil,
        bucketName: String? = nil
    )
    {
        self.bucketKey = bucketKey
        self.bucketName = bucketName
    }
}

public struct TagProjectInputBodyMiddleware: Middleware {
    public let id: String = "TagProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<TagProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagProjectInput>
    public typealias MOutput = OperationOutput<TagProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagProjectOutputError>
}

extension TagProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagProjectInput(id: \(String(describing: id)), tags: \(String(describing: tags)))"}
}

extension TagProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagProjectInputHeadersMiddleware: Middleware {
    public let id: String = "TagProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<TagProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagProjectInput>
    public typealias MOutput = OperationOutput<TagProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagProjectOutputError>
}

public struct TagProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "TagProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<TagProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagProjectInput>
    public typealias MOutput = OperationOutput<TagProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagProjectOutputError>
}

public struct TagProjectInput: Equatable {
    /// <p>The ID of the project you want to add a tag to.</p>
    public let id: String?
    /// <p>The tags you want to add to the project.</p>
    public let tags: [String:String]?

    public init (
        id: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.id = id
        self.tags = tags
    }
}

struct TagProjectInputBody: Equatable {
    public let id: String?
    public let tags: [String:String]?
}

extension TagProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagProjectOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagProjectOutputResponse(tags: \(String(describing: tags)))"}
}

extension TagProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct TagProjectOutputResponse: Equatable {
    /// <p>The tags for the project.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct TagProjectOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension TagProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TeamMember: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectRole = projectRole {
            try encodeContainer.encode(projectRole, forKey: .projectRole)
        }
        if remoteAccessAllowed != false {
            try encodeContainer.encode(remoteAccessAllowed, forKey: .remoteAccessAllowed)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let projectRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectRole)
        projectRole = projectRoleDecoded
        let remoteAccessAllowedDecoded = try containerValues.decode(Bool.self, forKey: .remoteAccessAllowed)
        remoteAccessAllowed = remoteAccessAllowedDecoded
    }
}

extension TeamMember: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TeamMember(projectRole: \(String(describing: projectRole)), remoteAccessAllowed: \(String(describing: remoteAccessAllowed)), userArn: \(String(describing: userArn)))"}
}

/// <p>Information about a team member in a project.</p>
public struct TeamMember: Equatable {
    /// <p>The role assigned to the user in the project. Project roles have different levels of
    ///       access. For more information, see <a href="http://docs.aws.amazon.com/codestar/latest/userguide/working-with-teams.html">Working with
    ///         Teams</a> in the <i>AWS CodeStar User Guide</i>. </p>
    public let projectRole: String?
    /// <p>Whether the user is allowed to remotely access project resources using an SSH
    ///       public/private key pair.</p>
    public let remoteAccessAllowed: Bool
    /// <p>The Amazon Resource Name (ARN) of the user in IAM.</p>
    public let userArn: String?

    public init (
        projectRole: String? = nil,
        remoteAccessAllowed: Bool = false,
        userArn: String? = nil
    )
    {
        self.projectRole = projectRole
        self.remoteAccessAllowed = remoteAccessAllowed
        self.userArn = userArn
    }
}

extension TeamMemberAlreadyAssociatedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TeamMemberAlreadyAssociatedException(message: \(String(describing: message)))"}
}

extension TeamMemberAlreadyAssociatedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TeamMemberAlreadyAssociatedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The team member is already associated with a role in this project.</p>
public struct TeamMemberAlreadyAssociatedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TeamMemberAlreadyAssociatedExceptionBody: Equatable {
    public let message: String?
}

extension TeamMemberAlreadyAssociatedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TeamMemberNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TeamMemberNotFoundException(message: \(String(describing: message)))"}
}

extension TeamMemberNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TeamMemberNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified team member was not found.</p>
public struct TeamMemberNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TeamMemberNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension TeamMemberNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Toolchain: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn
        case source
        case stackParameters
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let stackParameters = stackParameters {
            var stackParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .stackParameters)
            for (dictKey0, templateparametermap0) in stackParameters {
                try stackParametersContainer.encode(templateparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(ToolchainSource.self, forKey: .source)
        source = sourceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let stackParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stackParameters)
        var stackParametersDecoded0: [String:String]? = nil
        if let stackParametersContainer = stackParametersContainer {
            stackParametersDecoded0 = [String:String]()
            for (key0, templateparametervalue0) in stackParametersContainer {
                if let templateparametervalue0 = templateparametervalue0 {
                    stackParametersDecoded0?[key0] = templateparametervalue0
                }
            }
        }
        stackParameters = stackParametersDecoded0
    }
}

extension Toolchain: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Toolchain(roleArn: \(String(describing: roleArn)), source: \(String(describing: source)), stackParameters: \(String(describing: stackParameters)))"}
}

/// <p>The toolchain template file provided with the project request. AWS CodeStar uses
///       the template to provision the toolchain stack in AWS CloudFormation.</p>
public struct Toolchain: Equatable {
    /// <p>The service role ARN for AWS CodeStar to use for the toolchain template during stack
    ///       provisioning.</p>
    public let roleArn: String?
    /// <p>The Amazon S3 location where the toolchain template file provided with the
    ///       project request is stored. AWS CodeStar retrieves the file during project creation.</p>
    public let source: ToolchainSource?
    /// <p>The list of parameter overrides to be passed into the toolchain template during stack
    ///       provisioning, if any.</p>
    public let stackParameters: [String:String]?

    public init (
        roleArn: String? = nil,
        source: ToolchainSource? = nil,
        stackParameters: [String:String]? = nil
    )
    {
        self.roleArn = roleArn
        self.source = source
        self.stackParameters = stackParameters
    }
}

extension ToolchainSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension ToolchainSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ToolchainSource(s3: \(String(describing: s3)))"}
}

/// <p>The Amazon S3 location where the toolchain template file provided with the
///       project request is stored. AWS CodeStar retrieves the file during project creation.</p>
public struct ToolchainSource: Equatable {
    /// <p>The Amazon S3 bucket where the toolchain template file provided with the project
    ///       request is stored.</p>
    public let s3: S3Location?

    public init (
        s3: S3Location? = nil
    )
    {
        self.s3 = s3
    }
}

public struct UntagProjectInputBodyMiddleware: Middleware {
    public let id: String = "UntagProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagProjectInput>
    public typealias MOutput = OperationOutput<UntagProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagProjectOutputError>
}

extension UntagProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagProjectInput(id: \(String(describing: id)), tags: \(String(describing: tags)))"}
}

extension UntagProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagkeys0 in tags {
                try tagsContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UntagProjectInputHeadersMiddleware: Middleware {
    public let id: String = "UntagProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagProjectInput>
    public typealias MOutput = OperationOutput<UntagProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagProjectOutputError>
}

public struct UntagProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagProjectInput>
    public typealias MOutput = OperationOutput<UntagProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagProjectOutputError>
}

public struct UntagProjectInput: Equatable {
    /// <p>The ID of the project to remove tags from.</p>
    public let id: String?
    /// <p>The tags to remove from the project.</p>
    public let tags: [String]?

    public init (
        id: String? = nil,
        tags: [String]? = nil
    )
    {
        self.id = id
        self.tags = tags
    }
}

struct UntagProjectInputBody: Equatable {
    public let id: String?
    public let tags: [String]?
}

extension UntagProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tags)
        var tagsDecoded0:[String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String]()
            for string0 in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?.append(string0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UntagProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagProjectOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagProjectOutputResponse()"}
}

extension UntagProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagProjectOutputResponse: Equatable {

    public init() {}
}

struct UntagProjectOutputResponseBody: Equatable {
}

extension UntagProjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateProjectInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

extension UpdateProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProjectInput(description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

extension UpdateProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case id
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateProjectInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInput: Equatable {
    /// <p>The description of the project, if any.</p>
    public let description: String?
    /// <p>The ID of the project you want to update.</p>
    public let id: String?
    /// <p>The name of the project you want to update.</p>
    public let name: String?

    public init (
        description: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct UpdateProjectInputBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
}

extension UpdateProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case id
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProjectOutputError: Equatable {
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProjectOutputResponse()"}
}

extension UpdateProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateProjectOutputResponse: Equatable {

    public init() {}
}

struct UpdateProjectOutputResponseBody: Equatable {
}

extension UpdateProjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateTeamMemberInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTeamMemberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTeamMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTeamMemberInput>
    public typealias MOutput = OperationOutput<UpdateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTeamMemberOutputError>
}

extension UpdateTeamMemberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTeamMemberInput(projectId: \(String(describing: projectId)), projectRole: \(String(describing: projectRole)), remoteAccessAllowed: \(String(describing: remoteAccessAllowed)), userArn: \(String(describing: userArn)))"}
}

extension UpdateTeamMemberInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case projectId
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let projectRole = projectRole {
            try encodeContainer.encode(projectRole, forKey: .projectRole)
        }
        if remoteAccessAllowed != false {
            try encodeContainer.encode(remoteAccessAllowed, forKey: .remoteAccessAllowed)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct UpdateTeamMemberInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTeamMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTeamMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTeamMemberInput>
    public typealias MOutput = OperationOutput<UpdateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTeamMemberOutputError>
}

public struct UpdateTeamMemberInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTeamMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTeamMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTeamMemberInput>
    public typealias MOutput = OperationOutput<UpdateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTeamMemberOutputError>
}

public struct UpdateTeamMemberInput: Equatable {
    /// <p>The ID of the project.</p>
    public let projectId: String?
    /// <p>The role assigned to the user in the project. Project roles have different levels of
    ///       access. For more information, see <a href="http://docs.aws.amazon.com/codestar/latest/userguide/working-with-teams.html">Working with
    ///         Teams</a> in the <i>AWS CodeStar User Guide</i>.</p>
    public let projectRole: String?
    /// <p>Whether a team member is allowed to remotely access project resources using the SSH
    ///       public key associated with the user's profile. Even if this is set to True, the user must
    ///       associate a public key with their profile before the user can access resources.</p>
    public let remoteAccessAllowed: Bool
    /// <p>The Amazon Resource Name (ARN) of the user for whom you want to change team membership
    ///       attributes.</p>
    public let userArn: String?

    public init (
        projectId: String? = nil,
        projectRole: String? = nil,
        remoteAccessAllowed: Bool = false,
        userArn: String? = nil
    )
    {
        self.projectId = projectId
        self.projectRole = projectRole
        self.remoteAccessAllowed = remoteAccessAllowed
        self.userArn = userArn
    }
}

struct UpdateTeamMemberInputBody: Equatable {
    public let projectId: String?
    public let userArn: String?
    public let projectRole: String?
    public let remoteAccessAllowed: Bool
}

extension UpdateTeamMemberInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case projectId
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let projectRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectRole)
        projectRole = projectRoleDecoded
        let remoteAccessAllowedDecoded = try containerValues.decode(Bool.self, forKey: .remoteAccessAllowed)
        remoteAccessAllowed = remoteAccessAllowedDecoded
    }
}

extension UpdateTeamMemberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTeamMemberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectConfigurationException" : self = .projectConfigurationException(try ProjectConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TeamMemberNotFoundException" : self = .teamMemberNotFoundException(try TeamMemberNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTeamMemberOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case limitExceededException(LimitExceededException)
    case projectConfigurationException(ProjectConfigurationException)
    case projectNotFoundException(ProjectNotFoundException)
    case teamMemberNotFoundException(TeamMemberNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTeamMemberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTeamMemberOutputResponse(projectRole: \(String(describing: projectRole)), remoteAccessAllowed: \(String(describing: remoteAccessAllowed)), userArn: \(String(describing: userArn)))"}
}

extension UpdateTeamMemberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateTeamMemberOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.projectRole = output.projectRole
            self.remoteAccessAllowed = output.remoteAccessAllowed
            self.userArn = output.userArn
        } else {
            self.projectRole = nil
            self.remoteAccessAllowed = false
            self.userArn = nil
        }
    }
}

public struct UpdateTeamMemberOutputResponse: Equatable {
    /// <p>The project role granted to the user.</p>
    public let projectRole: String?
    /// <p>Whether a team member is allowed to remotely access project resources using the SSH
    ///       public key associated with the user's profile.</p>
    public let remoteAccessAllowed: Bool
    /// <p>The Amazon Resource Name (ARN) of the user whose team membership attributes were
    ///       updated.</p>
    public let userArn: String?

    public init (
        projectRole: String? = nil,
        remoteAccessAllowed: Bool = false,
        userArn: String? = nil
    )
    {
        self.projectRole = projectRole
        self.remoteAccessAllowed = remoteAccessAllowed
        self.userArn = userArn
    }
}

struct UpdateTeamMemberOutputResponseBody: Equatable {
    public let userArn: String?
    public let projectRole: String?
    public let remoteAccessAllowed: Bool
}

extension UpdateTeamMemberOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let projectRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectRole)
        projectRole = projectRoleDecoded
        let remoteAccessAllowedDecoded = try containerValues.decode(Bool.self, forKey: .remoteAccessAllowed)
        remoteAccessAllowed = remoteAccessAllowedDecoded
    }
}

public struct UpdateUserProfileInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserProfileInput>
    public typealias MOutput = OperationOutput<UpdateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserProfileOutputError>
}

extension UpdateUserProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserProfileInput(displayName: \(String(describing: displayName)), emailAddress: \(String(describing: emailAddress)), sshPublicKey: \(String(describing: sshPublicKey)), userArn: \(String(describing: userArn)))"}
}

extension UpdateUserProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct UpdateUserProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserProfileInput>
    public typealias MOutput = OperationOutput<UpdateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserProfileOutputError>
}

public struct UpdateUserProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserProfileInput>
    public typealias MOutput = OperationOutput<UpdateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserProfileOutputError>
}

public struct UpdateUserProfileInput: Equatable {
    /// <p>The name that is displayed as the friendly name for the user in AWS CodeStar.</p>
    public let displayName: String?
    /// <p>The email address that is displayed as part of the user's profile in AWS
    ///       CodeStar.</p>
    public let emailAddress: String?
    /// <p>The SSH public key associated with the user in AWS CodeStar. If a project owner allows the
    ///       user remote access to project resources, this public key will be used along with the user's
    ///       private key for SSH access.</p>
    public let sshPublicKey: String?
    /// <p>The name that will be displayed as the friendly name for the user in AWS
    ///       CodeStar.</p>
    public let userArn: String?

    public init (
        displayName: String? = nil,
        emailAddress: String? = nil,
        sshPublicKey: String? = nil,
        userArn: String? = nil
    )
    {
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct UpdateUserProfileInputBody: Equatable {
    public let userArn: String?
    public let displayName: String?
    public let emailAddress: String?
    public let sshPublicKey: String?
}

extension UpdateUserProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension UpdateUserProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "UserProfileNotFoundException" : self = .userProfileNotFoundException(try UserProfileNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserProfileOutputError: Equatable {
    case userProfileNotFoundException(UserProfileNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserProfileOutputResponse(createdTimestamp: \(String(describing: createdTimestamp)), displayName: \(String(describing: displayName)), emailAddress: \(String(describing: emailAddress)), lastModifiedTimestamp: \(String(describing: lastModifiedTimestamp)), sshPublicKey: \(String(describing: sshPublicKey)), userArn: \(String(describing: userArn)))"}
}

extension UpdateUserProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateUserProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdTimestamp = output.createdTimestamp
            self.displayName = output.displayName
            self.emailAddress = output.emailAddress
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.sshPublicKey = output.sshPublicKey
            self.userArn = output.userArn
        } else {
            self.createdTimestamp = nil
            self.displayName = nil
            self.emailAddress = nil
            self.lastModifiedTimestamp = nil
            self.sshPublicKey = nil
            self.userArn = nil
        }
    }
}

public struct UpdateUserProfileOutputResponse: Equatable {
    /// <p>The date the user profile was created, in timestamp format.</p>
    public let createdTimestamp: Date?
    /// <p>The name that is displayed as the friendly name for the user in AWS CodeStar.</p>
    public let displayName: String?
    /// <p>The email address that is displayed as part of the user's profile in AWS
    ///       CodeStar.</p>
    public let emailAddress: String?
    /// <p>The date the user profile was last modified, in timestamp format.</p>
    public let lastModifiedTimestamp: Date?
    /// <p>The SSH public key associated with the user in AWS CodeStar. This is the public portion of the
    ///       public/private keypair the user can use to access project resources if a project owner allows
    ///       the user remote access to those resources.</p>
    public let sshPublicKey: String?
    /// <p>The Amazon Resource Name (ARN) of the user in IAM.</p>
    public let userArn: String?

    public init (
        createdTimestamp: Date? = nil,
        displayName: String? = nil,
        emailAddress: String? = nil,
        lastModifiedTimestamp: Date? = nil,
        sshPublicKey: String? = nil,
        userArn: String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct UpdateUserProfileOutputResponseBody: Equatable {
    public let userArn: String?
    public let displayName: String?
    public let emailAddress: String?
    public let sshPublicKey: String?
    public let createdTimestamp: Date?
    public let lastModifiedTimestamp: Date?
}

extension UpdateUserProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdTimestamp
        case displayName
        case emailAddress
        case lastModifiedTimestamp
        case sshPublicKey
        case userArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

extension UserProfileAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserProfileAlreadyExistsException(message: \(String(describing: message)))"}
}

extension UserProfileAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UserProfileAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A user profile with that name already exists in this region for the AWS account. AWS
///       CodeStar user profile names must be unique within a region for the AWS account. </p>
public struct UserProfileAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UserProfileAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension UserProfileAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UserProfileNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserProfileNotFoundException(message: \(String(describing: message)))"}
}

extension UserProfileNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UserProfileNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user profile was not found.</p>
public struct UserProfileNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UserProfileNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension UserProfileNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UserProfileSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension UserProfileSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserProfileSummary(displayName: \(String(describing: displayName)), emailAddress: \(String(describing: emailAddress)), sshPublicKey: \(String(describing: sshPublicKey)), userArn: \(String(describing: userArn)))"}
}

/// <p>Information about a user's profile in AWS CodeStar.</p>
public struct UserProfileSummary: Equatable {
    /// <p>The display name of a user in AWS CodeStar. For example, this could be set to both first and
    ///       last name ("Mary Major") or a single name ("Mary"). The display name is also used to generate
    ///       the initial icon associated with the user in AWS CodeStar projects. If spaces are included in the
    ///       display name, the first character that appears after the space will be used as the second
    ///       character in the user initial icon. The initial icon displays a maximum of two characters, so
    ///       a display name with more than one space (for example "Mary Jane Major") would generate an
    ///       initial icon using the first character and the first character after the space ("MJ", not
    ///       "MM").</p>
    public let displayName: String?
    /// <p>The email address associated with the user.</p>
    public let emailAddress: String?
    /// <p>The SSH public key associated with the user in AWS CodeStar. If a project owner allows the
    ///       user remote access to project resources, this public key will be used along with the user's
    ///       private key for SSH access.</p>
    public let sshPublicKey: String?
    /// <p>The Amazon Resource Name (ARN) of the user in IAM.</p>
    public let userArn: String?

    public init (
        displayName: String? = nil,
        emailAddress: String? = nil,
        sshPublicKey: String? = nil,
        userArn: String? = nil
    )
    {
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified input is either not valid, or it could not be validated.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
