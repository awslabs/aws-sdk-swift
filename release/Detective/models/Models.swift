// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptInvitationInputBodyMiddleware: Middleware {
    public let id: String = "AcceptInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptInvitationInput>
    public typealias MOutput = OperationOutput<AcceptInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptInvitationOutputError>
}

extension AcceptInvitationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptInvitationInput(graphArn: \(String(describing: graphArn)))"}
}

extension AcceptInvitationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

public struct AcceptInvitationInputHeadersMiddleware: Middleware {
    public let id: String = "AcceptInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptInvitationInput>
    public typealias MOutput = OperationOutput<AcceptInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptInvitationOutputError>
}

public struct AcceptInvitationInputQueryItemMiddleware: Middleware {
    public let id: String = "AcceptInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptInvitationInput>
    public typealias MOutput = OperationOutput<AcceptInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptInvitationOutputError>
}

public struct AcceptInvitationInput: Equatable {
    /// <p>The ARN of the behavior graph that the member account is accepting the invitation
    ///          for.</p>
    ///          <p>The member account status in the behavior graph must be <code>INVITED</code>.</p>
    public let graphArn: String?

    public init (
        graphArn: String? = nil
    )
    {
        self.graphArn = graphArn
    }
}

struct AcceptInvitationInputBody: Equatable {
    public let graphArn: String?
}

extension AcceptInvitationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case graphArn = "GraphArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
    }
}

extension AcceptInvitationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptInvitationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptInvitationOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptInvitationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptInvitationOutputResponse()"}
}

extension AcceptInvitationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AcceptInvitationOutputResponse: Equatable {

    public init() {}
}

struct AcceptInvitationOutputResponseBody: Equatable {
}

extension AcceptInvitationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Account: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case emailAddress = "EmailAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
    }
}

extension Account: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Account(accountId: \(String(describing: accountId)), emailAddress: \(String(describing: emailAddress)))"}
}

/// <p>An AWS account that is the administrator account of or a member of a behavior
///          graph.</p>
public struct Account: Equatable {
    /// <p>The account identifier of the AWS account.</p>
    public let accountId: String?
    /// <p>The AWS account root user email address for the AWS account.</p>
    public let emailAddress: String?

    public init (
        accountId: String? = nil,
        emailAddress: String? = nil
    )
    {
        self.accountId = accountId
        self.emailAddress = emailAddress
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request attempted an invalid action.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateGraphInputBodyMiddleware: Middleware {
    public let id: String = "CreateGraphInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGraphInput>
    public typealias MOutput = OperationOutput<CreateGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGraphOutputError>
}

extension CreateGraphInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGraphInput(tags: \(String(describing: tags)))"}
}

extension CreateGraphInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateGraphInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGraphInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGraphInput>
    public typealias MOutput = OperationOutput<CreateGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGraphOutputError>
}

public struct CreateGraphInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGraphInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGraphInput>
    public typealias MOutput = OperationOutput<CreateGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGraphOutputError>
}

public struct CreateGraphInput: Equatable {
    /// <p>The tags to assign to the new behavior graph. You can add up to 50 tags. For each tag,
    ///          you provide the tag key and the tag value. Each tag key can contain up to 128 characters.
    ///          Each tag value can contain up to 256 characters.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct CreateGraphInputBody: Equatable {
    public let tags: [String:String]?
}

extension CreateGraphInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGraphOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGraphOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGraphOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGraphOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGraphOutputResponse(graphArn: \(String(describing: graphArn)))"}
}

extension CreateGraphOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGraphOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.graphArn = output.graphArn
        } else {
            self.graphArn = nil
        }
    }
}

public struct CreateGraphOutputResponse: Equatable {
    /// <p>The ARN of the new behavior graph.</p>
    public let graphArn: String?

    public init (
        graphArn: String? = nil
    )
    {
        self.graphArn = graphArn
    }
}

struct CreateGraphOutputResponseBody: Equatable {
    public let graphArn: String?
}

extension CreateGraphOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case graphArn = "GraphArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
    }
}

public struct CreateMembersInputBodyMiddleware: Middleware {
    public let id: String = "CreateMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMembersInput>
    public typealias MOutput = OperationOutput<CreateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMembersOutputError>
}

extension CreateMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMembersInput(accounts: \(String(describing: accounts)), disableEmailNotification: \(String(describing: disableEmailNotification)), graphArn: \(String(describing: graphArn)), message: \(String(describing: message)))"}
}

extension CreateMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accounts = "Accounts"
        case disableEmailNotification = "DisableEmailNotification"
        case graphArn = "GraphArn"
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accounts = accounts {
            var accountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accounts)
            for accountlist0 in accounts {
                try accountsContainer.encode(accountlist0)
            }
        }
        if disableEmailNotification != false {
            try encodeContainer.encode(disableEmailNotification, forKey: .disableEmailNotification)
        }
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }
}

public struct CreateMembersInputHeadersMiddleware: Middleware {
    public let id: String = "CreateMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMembersInput>
    public typealias MOutput = OperationOutput<CreateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMembersOutputError>
}

public struct CreateMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMembersInput>
    public typealias MOutput = OperationOutput<CreateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMembersOutputError>
}

public struct CreateMembersInput: Equatable {
    /// <p>The list of AWS accounts to invite to become member accounts in the behavior graph.
    ///          You can invite up to 50 accounts at a time. For each invited account, the account list
    ///          contains the account identifier and the AWS account root user email address.</p>
    public let accounts: [Account]?
    /// <p>if set to <code>true</code>, then the member accounts do not receive email
    ///          notifications. By default, this is set to <code>false</code>, and the member accounts
    ///          receive email notifications.</p>
    public let disableEmailNotification: Bool
    /// <p>The ARN of the behavior graph to invite the member accounts to contribute their data
    ///          to.</p>
    public let graphArn: String?
    /// <p>Customized message text to include in the invitation email message to the invited member
    ///          accounts.</p>
    public let message: String?

    public init (
        accounts: [Account]? = nil,
        disableEmailNotification: Bool = false,
        graphArn: String? = nil,
        message: String? = nil
    )
    {
        self.accounts = accounts
        self.disableEmailNotification = disableEmailNotification
        self.graphArn = graphArn
        self.message = message
    }
}

struct CreateMembersInputBody: Equatable {
    public let graphArn: String?
    public let message: String?
    public let disableEmailNotification: Bool
    public let accounts: [Account]?
}

extension CreateMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accounts = "Accounts"
        case disableEmailNotification = "DisableEmailNotification"
        case graphArn = "GraphArn"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let disableEmailNotificationDecoded = try containerValues.decode(Bool.self, forKey: .disableEmailNotification)
        disableEmailNotification = disableEmailNotificationDecoded
        let accountsContainer = try containerValues.decodeIfPresent([Account?].self, forKey: .accounts)
        var accountsDecoded0:[Account]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Account]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
    }
}

extension CreateMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMembersOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMembersOutputResponse(members: \(String(describing: members)), unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension CreateMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateMembersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.members = output.members
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.members = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct CreateMembersOutputResponse: Equatable {
    /// <p>The set of member account invitation requests that Detective was able to process. This
    ///          includes accounts that are being verified, that failed verification, and that passed
    ///          verification and are being sent an invitation.</p>
    public let members: [MemberDetail]?
    /// <p>The list of accounts for which Detective was unable to process the invitation request. For
    ///          each account, the list provides the reason why the request could not be processed. The list
    ///          includes accounts that are already member accounts in the behavior graph.</p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        members: [MemberDetail]? = nil,
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.members = members
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct CreateMembersOutputResponseBody: Equatable {
    public let members: [MemberDetail]?
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension CreateMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case members = "Members"
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([MemberDetail?].self, forKey: .members)
        var membersDecoded0:[MemberDetail]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [MemberDetail]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

public struct DeleteGraphInputBodyMiddleware: Middleware {
    public let id: String = "DeleteGraphInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGraphInput>
    public typealias MOutput = OperationOutput<DeleteGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGraphOutputError>
}

extension DeleteGraphInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGraphInput(graphArn: \(String(describing: graphArn)))"}
}

extension DeleteGraphInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

public struct DeleteGraphInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGraphInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGraphInput>
    public typealias MOutput = OperationOutput<DeleteGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGraphOutputError>
}

public struct DeleteGraphInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGraphInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGraphInput>
    public typealias MOutput = OperationOutput<DeleteGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGraphOutputError>
}

public struct DeleteGraphInput: Equatable {
    /// <p>The ARN of the behavior graph to disable.</p>
    public let graphArn: String?

    public init (
        graphArn: String? = nil
    )
    {
        self.graphArn = graphArn
    }
}

struct DeleteGraphInputBody: Equatable {
    public let graphArn: String?
}

extension DeleteGraphInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case graphArn = "GraphArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
    }
}

extension DeleteGraphOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGraphOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGraphOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGraphOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGraphOutputResponse()"}
}

extension DeleteGraphOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGraphOutputResponse: Equatable {

    public init() {}
}

struct DeleteGraphOutputResponseBody: Equatable {
}

extension DeleteGraphOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteMembersInputBodyMiddleware: Middleware {
    public let id: String = "DeleteMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMembersInput>
    public typealias MOutput = OperationOutput<DeleteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMembersOutputError>
}

extension DeleteMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMembersInput(accountIds: \(String(describing: accountIds)), graphArn: \(String(describing: graphArn)))"}
}

extension DeleteMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountidlist0 in accountIds {
                try accountIdsContainer.encode(accountidlist0)
            }
        }
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

public struct DeleteMembersInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMembersInput>
    public typealias MOutput = OperationOutput<DeleteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMembersOutputError>
}

public struct DeleteMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMembersInput>
    public typealias MOutput = OperationOutput<DeleteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMembersOutputError>
}

public struct DeleteMembersInput: Equatable {
    /// <p>The list of AWS account identifiers for the member accounts to delete from the
    ///          behavior graph. You can delete up to 50 member accounts at a time.</p>
    public let accountIds: [String]?
    /// <p>The ARN of the behavior graph to delete members from.</p>
    public let graphArn: String?

    public init (
        accountIds: [String]? = nil,
        graphArn: String? = nil
    )
    {
        self.accountIds = accountIds
        self.graphArn = graphArn
    }
}

struct DeleteMembersInputBody: Equatable {
    public let graphArn: String?
    public let accountIds: [String]?
}

extension DeleteMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
        case graphArn = "GraphArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMembersOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMembersOutputResponse(accountIds: \(String(describing: accountIds)), unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension DeleteMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteMembersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountIds = output.accountIds
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.accountIds = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteMembersOutputResponse: Equatable {
    /// <p>The list of AWS account identifiers for the member accounts that Detective successfully
    ///          deleted from the behavior graph.</p>
    public let accountIds: [String]?
    /// <p>The list of member accounts that Detective was not able to delete from the behavior graph.
    ///          For each member account, provides the reason that the deletion could not be
    ///          processed.</p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        accountIds: [String]? = nil,
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.accountIds = accountIds
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteMembersOutputResponseBody: Equatable {
    public let accountIds: [String]?
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension DeleteMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

public struct DisassociateMembershipInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateMembershipInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMembershipInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMembershipInput>
    public typealias MOutput = OperationOutput<DisassociateMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMembershipOutputError>
}

extension DisassociateMembershipInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateMembershipInput(graphArn: \(String(describing: graphArn)))"}
}

extension DisassociateMembershipInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

public struct DisassociateMembershipInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMembershipInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMembershipInput>
    public typealias MOutput = OperationOutput<DisassociateMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMembershipOutputError>
}

public struct DisassociateMembershipInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMembershipInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMembershipInput>
    public typealias MOutput = OperationOutput<DisassociateMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMembershipOutputError>
}

public struct DisassociateMembershipInput: Equatable {
    /// <p>The ARN of the behavior graph to remove the member account from.</p>
    ///          <p>The member account's member status in the behavior graph must be
    ///          <code>ENABLED</code>.</p>
    public let graphArn: String?

    public init (
        graphArn: String? = nil
    )
    {
        self.graphArn = graphArn
    }
}

struct DisassociateMembershipInputBody: Equatable {
    public let graphArn: String?
}

extension DisassociateMembershipInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case graphArn = "GraphArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
    }
}

extension DisassociateMembershipOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMembershipOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateMembershipOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMembershipOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateMembershipOutputResponse()"}
}

extension DisassociateMembershipOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateMembershipOutputResponse: Equatable {

    public init() {}
}

struct DisassociateMembershipOutputResponseBody: Equatable {
}

extension DisassociateMembershipOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct GetMembersInputBodyMiddleware: Middleware {
    public let id: String = "GetMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMembersInput>
    public typealias MOutput = OperationOutput<GetMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMembersOutputError>
}

extension GetMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMembersInput(accountIds: \(String(describing: accountIds)), graphArn: \(String(describing: graphArn)))"}
}

extension GetMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountidlist0 in accountIds {
                try accountIdsContainer.encode(accountidlist0)
            }
        }
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

public struct GetMembersInputHeadersMiddleware: Middleware {
    public let id: String = "GetMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMembersInput>
    public typealias MOutput = OperationOutput<GetMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMembersOutputError>
}

public struct GetMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMembersInput>
    public typealias MOutput = OperationOutput<GetMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMembersOutputError>
}

public struct GetMembersInput: Equatable {
    /// <p>The list of AWS account identifiers for the member account for which to return member
    ///          details. You can request details for up to 50 member accounts at a time.</p>
    ///          <p>You cannot use <code>GetMembers</code> to retrieve information about member accounts
    ///          that were removed from the behavior graph.</p>
    public let accountIds: [String]?
    /// <p>The ARN of the behavior graph for which to request the member details.</p>
    public let graphArn: String?

    public init (
        accountIds: [String]? = nil,
        graphArn: String? = nil
    )
    {
        self.accountIds = accountIds
        self.graphArn = graphArn
    }
}

struct GetMembersInputBody: Equatable {
    public let graphArn: String?
    public let accountIds: [String]?
}

extension GetMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
        case graphArn = "GraphArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMembersOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMembersOutputResponse(memberDetails: \(String(describing: memberDetails)), unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension GetMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMembersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.memberDetails = output.memberDetails
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.memberDetails = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct GetMembersOutputResponse: Equatable {
    /// <p>The member account details that Detective is returning in response to the request.</p>
    public let memberDetails: [MemberDetail]?
    /// <p>The requested member accounts for which Detective was unable to return member
    ///          details.</p>
    ///          <p>For each account, provides the reason why the request could not be processed.</p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        memberDetails: [MemberDetail]? = nil,
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.memberDetails = memberDetails
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct GetMembersOutputResponseBody: Equatable {
    public let memberDetails: [MemberDetail]?
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension GetMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case memberDetails = "MemberDetails"
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDetailsContainer = try containerValues.decodeIfPresent([MemberDetail?].self, forKey: .memberDetails)
        var memberDetailsDecoded0:[MemberDetail]? = nil
        if let memberDetailsContainer = memberDetailsContainer {
            memberDetailsDecoded0 = [MemberDetail]()
            for structure0 in memberDetailsContainer {
                if let structure0 = structure0 {
                    memberDetailsDecoded0?.append(structure0)
                }
            }
        }
        memberDetails = memberDetailsDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension Graph: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension Graph: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Graph(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)))"}
}

/// <p>A behavior graph in Detective.</p>
public struct Graph: Equatable {
    /// <p>The ARN of the behavior graph.</p>
    public let arn: String?
    /// <p>The date and time that the behavior graph was created. The value is in milliseconds
    ///          since the epoch.</p>
    public let createdTime: Date?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was valid but failed because of a problem with the service.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListGraphsInputBodyMiddleware: Middleware {
    public let id: String = "ListGraphsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGraphsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGraphsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGraphsInput>
    public typealias MOutput = OperationOutput<ListGraphsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGraphsOutputError>
}

extension ListGraphsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGraphsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGraphsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListGraphsInputHeadersMiddleware: Middleware {
    public let id: String = "ListGraphsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGraphsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGraphsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGraphsInput>
    public typealias MOutput = OperationOutput<ListGraphsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGraphsOutputError>
}

public struct ListGraphsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGraphsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGraphsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGraphsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGraphsInput>
    public typealias MOutput = OperationOutput<ListGraphsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGraphsOutputError>
}

public struct ListGraphsInput: Equatable {
    /// <p>The maximum number of graphs to return at a time. The total must be less than the
    ///          overall limit on the number of results to return, which is currently 200.</p>
    public let maxResults: Int?
    /// <p>For requests to get the next page of results, the pagination token that was returned
    ///          with the previous set of results. The initial request does not include a pagination
    ///          token.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGraphsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListGraphsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGraphsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGraphsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGraphsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGraphsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGraphsOutputResponse(graphList: \(String(describing: graphList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGraphsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGraphsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.graphList = output.graphList
            self.nextToken = output.nextToken
        } else {
            self.graphList = nil
            self.nextToken = nil
        }
    }
}

public struct ListGraphsOutputResponse: Equatable {
    /// <p>A list of behavior graphs that the account is an administrator account for.</p>
    public let graphList: [Graph]?
    /// <p>If there are more behavior graphs remaining in the results, then this is the pagination
    ///          token to use to request the next page of behavior graphs.</p>
    public let nextToken: String?

    public init (
        graphList: [Graph]? = nil,
        nextToken: String? = nil
    )
    {
        self.graphList = graphList
        self.nextToken = nextToken
    }
}

struct ListGraphsOutputResponseBody: Equatable {
    public let graphList: [Graph]?
    public let nextToken: String?
}

extension ListGraphsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case graphList = "GraphList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphListContainer = try containerValues.decodeIfPresent([Graph?].self, forKey: .graphList)
        var graphListDecoded0:[Graph]? = nil
        if let graphListContainer = graphListContainer {
            graphListDecoded0 = [Graph]()
            for structure0 in graphListContainer {
                if let structure0 = structure0 {
                    graphListDecoded0?.append(structure0)
                }
            }
        }
        graphList = graphListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListInvitationsInputBodyMiddleware: Middleware {
    public let id: String = "ListInvitationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInvitationsInput>
    public typealias MOutput = OperationOutput<ListInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInvitationsOutputError>
}

extension ListInvitationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInvitationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInvitationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListInvitationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInvitationsInput>
    public typealias MOutput = OperationOutput<ListInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInvitationsOutputError>
}

public struct ListInvitationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInvitationsInput>
    public typealias MOutput = OperationOutput<ListInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInvitationsOutputError>
}

public struct ListInvitationsInput: Equatable {
    /// <p>The maximum number of behavior graph invitations to return in the response. The total
    ///          must be less than the overall limit on the number of results to return, which is currently
    ///          200.</p>
    public let maxResults: Int?
    /// <p>For requests to retrieve the next page of results, the pagination token that was
    ///          returned with the previous page of results. The initial request does not include a
    ///          pagination token.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInvitationsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListInvitationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListInvitationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInvitationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInvitationsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInvitationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInvitationsOutputResponse(invitations: \(String(describing: invitations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInvitationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invitations = output.invitations
            self.nextToken = output.nextToken
        } else {
            self.invitations = nil
            self.nextToken = nil
        }
    }
}

public struct ListInvitationsOutputResponse: Equatable {
    /// <p>The list of behavior graphs for which the member account has open or accepted
    ///          invitations.</p>
    public let invitations: [MemberDetail]?
    /// <p>If there are more behavior graphs remaining in the results, then this is the pagination
    ///          token to use to request the next page of behavior graphs.</p>
    public let nextToken: String?

    public init (
        invitations: [MemberDetail]? = nil,
        nextToken: String? = nil
    )
    {
        self.invitations = invitations
        self.nextToken = nextToken
    }
}

struct ListInvitationsOutputResponseBody: Equatable {
    public let invitations: [MemberDetail]?
    public let nextToken: String?
}

extension ListInvitationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invitations = "Invitations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsContainer = try containerValues.decodeIfPresent([MemberDetail?].self, forKey: .invitations)
        var invitationsDecoded0:[MemberDetail]? = nil
        if let invitationsContainer = invitationsContainer {
            invitationsDecoded0 = [MemberDetail]()
            for structure0 in invitationsContainer {
                if let structure0 = structure0 {
                    invitationsDecoded0?.append(structure0)
                }
            }
        }
        invitations = invitationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListMembersInputBodyMiddleware: Middleware {
    public let id: String = "ListMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMembersInput>
    public typealias MOutput = OperationOutput<ListMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMembersOutputError>
}

extension ListMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMembersInput(graphArn: \(String(describing: graphArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case graphArn = "GraphArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListMembersInputHeadersMiddleware: Middleware {
    public let id: String = "ListMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMembersInput>
    public typealias MOutput = OperationOutput<ListMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMembersOutputError>
}

public struct ListMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMembersInput>
    public typealias MOutput = OperationOutput<ListMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMembersOutputError>
}

public struct ListMembersInput: Equatable {
    /// <p>The ARN of the behavior graph for which to retrieve the list of member accounts.</p>
    public let graphArn: String?
    /// <p>The maximum number of member accounts to include in the response. The total must be less
    ///          than the overall limit on the number of results to return, which is currently 200.</p>
    public let maxResults: Int?
    /// <p>For requests to retrieve the next page of member account results, the pagination token
    ///          that was returned with the previous page of results. The initial request does not include a
    ///          pagination token.</p>
    public let nextToken: String?

    public init (
        graphArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.graphArn = graphArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMembersInputBody: Equatable {
    public let graphArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case graphArn = "GraphArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMembersOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMembersOutputResponse(memberDetails: \(String(describing: memberDetails)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMembersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.memberDetails = output.memberDetails
            self.nextToken = output.nextToken
        } else {
            self.memberDetails = nil
            self.nextToken = nil
        }
    }
}

public struct ListMembersOutputResponse: Equatable {
    /// <p>The list of member accounts in the behavior graph.</p>
    ///          <p>The results include member accounts that did not pass verification and member accounts
    ///          that have not yet accepted the invitation to the behavior graph. The results do not include
    ///          member accounts that were removed from the behavior graph.</p>
    public let memberDetails: [MemberDetail]?
    /// <p>If there are more member accounts remaining in the results, then this is the pagination
    ///          token to use to request the next page of member accounts.</p>
    public let nextToken: String?

    public init (
        memberDetails: [MemberDetail]? = nil,
        nextToken: String? = nil
    )
    {
        self.memberDetails = memberDetails
        self.nextToken = nextToken
    }
}

struct ListMembersOutputResponseBody: Equatable {
    public let memberDetails: [MemberDetail]?
    public let nextToken: String?
}

extension ListMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case memberDetails = "MemberDetails"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDetailsContainer = try containerValues.decodeIfPresent([MemberDetail?].self, forKey: .memberDetails)
        var memberDetailsDecoded0:[MemberDetail]? = nil
        if let memberDetailsContainer = memberDetailsContainer {
            memberDetailsDecoded0 = [MemberDetail]()
            for structure0 in memberDetailsContainer {
                if let structure0 = structure0 {
                    memberDetailsDecoded0?.append(structure0)
                }
            }
        }
        memberDetails = memberDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the behavior graph for which to retrieve the tag values.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tag values that are assigned to the behavior graph. The request returns up to 50 tag
    ///          values.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MemberDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case administratorId = "AdministratorId"
        case disabledReason = "DisabledReason"
        case emailAddress = "EmailAddress"
        case graphArn = "GraphArn"
        case invitedTime = "InvitedTime"
        case masterId = "MasterId"
        case percentOfGraphUtilization = "PercentOfGraphUtilization"
        case percentOfGraphUtilizationUpdatedTime = "PercentOfGraphUtilizationUpdatedTime"
        case status = "Status"
        case updatedTime = "UpdatedTime"
        case volumeUsageInBytes = "VolumeUsageInBytes"
        case volumeUsageUpdatedTime = "VolumeUsageUpdatedTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let administratorId = administratorId {
            try encodeContainer.encode(administratorId, forKey: .administratorId)
        }
        if let disabledReason = disabledReason {
            try encodeContainer.encode(disabledReason.rawValue, forKey: .disabledReason)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
        if let invitedTime = invitedTime {
            try encodeContainer.encode(invitedTime.timeIntervalSince1970, forKey: .invitedTime)
        }
        if let masterId = masterId {
            try encodeContainer.encode(masterId, forKey: .masterId)
        }
        if let percentOfGraphUtilization = percentOfGraphUtilization {
            try encodeContainer.encode(percentOfGraphUtilization, forKey: .percentOfGraphUtilization)
        }
        if let percentOfGraphUtilizationUpdatedTime = percentOfGraphUtilizationUpdatedTime {
            try encodeContainer.encode(percentOfGraphUtilizationUpdatedTime.timeIntervalSince1970, forKey: .percentOfGraphUtilizationUpdatedTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTime = updatedTime {
            try encodeContainer.encode(updatedTime.timeIntervalSince1970, forKey: .updatedTime)
        }
        if let volumeUsageInBytes = volumeUsageInBytes {
            try encodeContainer.encode(volumeUsageInBytes, forKey: .volumeUsageInBytes)
        }
        if let volumeUsageUpdatedTime = volumeUsageUpdatedTime {
            try encodeContainer.encode(volumeUsageUpdatedTime.timeIntervalSince1970, forKey: .volumeUsageUpdatedTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let graphArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let masterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterId)
        masterId = masterIdDecoded
        let administratorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .administratorId)
        administratorId = administratorIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MemberStatus.self, forKey: .status)
        status = statusDecoded
        let disabledReasonDecoded = try containerValues.decodeIfPresent(MemberDisabledReason.self, forKey: .disabledReason)
        disabledReason = disabledReasonDecoded
        let invitedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .invitedTime)
        invitedTime = invitedTimeDecoded
        let updatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
        let volumeUsageInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .volumeUsageInBytes)
        volumeUsageInBytes = volumeUsageInBytesDecoded
        let volumeUsageUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .volumeUsageUpdatedTime)
        volumeUsageUpdatedTime = volumeUsageUpdatedTimeDecoded
        let percentOfGraphUtilizationDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .percentOfGraphUtilization)
        percentOfGraphUtilization = percentOfGraphUtilizationDecoded
        let percentOfGraphUtilizationUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .percentOfGraphUtilizationUpdatedTime)
        percentOfGraphUtilizationUpdatedTime = percentOfGraphUtilizationUpdatedTimeDecoded
    }
}

extension MemberDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MemberDetail(accountId: \(String(describing: accountId)), administratorId: \(String(describing: administratorId)), disabledReason: \(String(describing: disabledReason)), emailAddress: \(String(describing: emailAddress)), graphArn: \(String(describing: graphArn)), invitedTime: \(String(describing: invitedTime)), masterId: \(String(describing: masterId)), percentOfGraphUtilization: \(String(describing: percentOfGraphUtilization)), percentOfGraphUtilizationUpdatedTime: \(String(describing: percentOfGraphUtilizationUpdatedTime)), status: \(String(describing: status)), updatedTime: \(String(describing: updatedTime)), volumeUsageInBytes: \(String(describing: volumeUsageInBytes)), volumeUsageUpdatedTime: \(String(describing: volumeUsageUpdatedTime)))"}
}

/// <p>Details about a member account that was invited to contribute to a behavior
///          graph.</p>
public struct MemberDetail: Equatable {
    /// <p>The AWS account identifier for the member account.</p>
    public let accountId: String?
    /// <p>The AWS account identifier of the administrator account for the behavior graph.</p>
    public let administratorId: String?
    /// <p>For member accounts with a status of <code>ACCEPTED_BUT_DISABLED</code>, the reason that
    ///          the member account is not enabled.</p>
    ///          <p>The reason can have one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>VOLUME_TOO_HIGH</code> - Indicates that adding the member account would
    ///                cause the data volume for the behavior graph to be too high.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>VOLUME_UNKNOWN</code> - Indicates that Detective is unable to verify the data
    ///                volume for the member account. This is usually because the member account is not
    ///                enrolled in Amazon GuardDuty. </p>
    ///             </li>
    ///          </ul>
    public let disabledReason: MemberDisabledReason?
    /// <p>The AWS account root user email address for the member account.</p>
    public let emailAddress: String?
    /// <p>The ARN of the behavior graph that the member account was invited to.</p>
    public let graphArn: String?
    /// <p>The date and time that Detective sent the invitation to the member account. The value is in
    ///          milliseconds since the epoch.</p>
    public let invitedTime: Date?
    /// <p>The AWS account identifier of the administrator account for the behavior graph.</p>
    @available(*, deprecated, message: "This property is deprecated. Use AdministratorId instead.")
    public let masterId: String?
    /// <p>The member account data volume as a percentage of the maximum allowed data volume. 0
    ///          indicates 0 percent, and 100 indicates 100 percent.</p>
    ///          <p>Note that this is not the percentage of the behavior graph data volume.</p>
    ///          <p>For example, the data volume for the behavior graph is 80 GB per day. The maximum data
    ///          volume is 160 GB per day. If the data volume for the member account is 40 GB per day, then
    ///             <code>PercentOfGraphUtilization</code> is 25. It represents 25% of the maximum allowed
    ///          data volume. </p>
    @available(*, deprecated, message: "This property is deprecated. Use VolumeUsageInBytes instead.")
    public let percentOfGraphUtilization: Double?
    /// <p>The date and time when the graph utilization percentage was last updated.</p>
    @available(*, deprecated, message: "This property is deprecated. Use VolumeUsageUpdatedTime instead.")
    public let percentOfGraphUtilizationUpdatedTime: Date?
    /// <p>The current membership status of the member account. The status can have one of the
    ///          following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>INVITED</code> - Indicates that the member was sent an invitation but has
    ///                not yet responded.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>VERIFICATION_IN_PROGRESS</code> - Indicates that Detective is verifying that the
    ///                account identifier and email address provided for the member account match. If they
    ///                do match, then Detective sends the invitation. If the email address and account
    ///                identifier don't match, then the member cannot be added to the behavior graph.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>VERIFICATION_FAILED</code> - Indicates that the account and email address
    ///                provided for the member account do not match, and Detective did not send an invitation to
    ///                the account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ENABLED</code> - Indicates that the member account accepted the invitation
    ///                to contribute to the behavior graph.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACCEPTED_BUT_DISABLED</code> - Indicates that the member account accepted
    ///                the invitation but is prevented from contributing data to the behavior graph.
    ///                   <code>DisabledReason</code> provides the reason why the member account is not
    ///                enabled.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Member accounts that declined an invitation or that were removed from the behavior graph
    ///          are not included.</p>
    public let status: MemberStatus?
    /// <p>The date and time that the member account was last updated. The value is in milliseconds
    ///          since the epoch.</p>
    public let updatedTime: Date?
    /// <p>The data volume in bytes per day for the member account.</p>
    public let volumeUsageInBytes: Int?
    /// <p>The data and time when the member account data volume was last updated.</p>
    public let volumeUsageUpdatedTime: Date?

    public init (
        accountId: String? = nil,
        administratorId: String? = nil,
        disabledReason: MemberDisabledReason? = nil,
        emailAddress: String? = nil,
        graphArn: String? = nil,
        invitedTime: Date? = nil,
        masterId: String? = nil,
        percentOfGraphUtilization: Double? = nil,
        percentOfGraphUtilizationUpdatedTime: Date? = nil,
        status: MemberStatus? = nil,
        updatedTime: Date? = nil,
        volumeUsageInBytes: Int? = nil,
        volumeUsageUpdatedTime: Date? = nil
    )
    {
        self.accountId = accountId
        self.administratorId = administratorId
        self.disabledReason = disabledReason
        self.emailAddress = emailAddress
        self.graphArn = graphArn
        self.invitedTime = invitedTime
        self.masterId = masterId
        self.percentOfGraphUtilization = percentOfGraphUtilization
        self.percentOfGraphUtilizationUpdatedTime = percentOfGraphUtilizationUpdatedTime
        self.status = status
        self.updatedTime = updatedTime
        self.volumeUsageInBytes = volumeUsageInBytes
        self.volumeUsageUpdatedTime = volumeUsageUpdatedTime
    }
}

public enum MemberDisabledReason {
    case volumeTooHigh
    case volumeUnknown
    case sdkUnknown(String)
}

extension MemberDisabledReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MemberDisabledReason] {
        return [
            .volumeTooHigh,
            .volumeUnknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .volumeTooHigh: return "VOLUME_TOO_HIGH"
        case .volumeUnknown: return "VOLUME_UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MemberDisabledReason(rawValue: rawValue) ?? MemberDisabledReason.sdkUnknown(rawValue)
    }
}

public enum MemberStatus {
    case acceptedButDisabled
    case enabled
    case invited
    case verificationFailed
    case verificationInProgress
    case sdkUnknown(String)
}

extension MemberStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MemberStatus] {
        return [
            .acceptedButDisabled,
            .enabled,
            .invited,
            .verificationFailed,
            .verificationInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .acceptedButDisabled: return "ACCEPTED_BUT_DISABLED"
        case .enabled: return "ENABLED"
        case .invited: return "INVITED"
        case .verificationFailed: return "VERIFICATION_FAILED"
        case .verificationInProgress: return "VERIFICATION_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MemberStatus(rawValue: rawValue) ?? MemberStatus.sdkUnknown(rawValue)
    }
}

public struct RejectInvitationInputBodyMiddleware: Middleware {
    public let id: String = "RejectInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectInvitationInput>
    public typealias MOutput = OperationOutput<RejectInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectInvitationOutputError>
}

extension RejectInvitationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectInvitationInput(graphArn: \(String(describing: graphArn)))"}
}

extension RejectInvitationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

public struct RejectInvitationInputHeadersMiddleware: Middleware {
    public let id: String = "RejectInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectInvitationInput>
    public typealias MOutput = OperationOutput<RejectInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectInvitationOutputError>
}

public struct RejectInvitationInputQueryItemMiddleware: Middleware {
    public let id: String = "RejectInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectInvitationInput>
    public typealias MOutput = OperationOutput<RejectInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectInvitationOutputError>
}

public struct RejectInvitationInput: Equatable {
    /// <p>The ARN of the behavior graph to reject the invitation to.</p>
    ///          <p>The member account's current member status in the behavior graph must be
    ///             <code>INVITED</code>.</p>
    public let graphArn: String?

    public init (
        graphArn: String? = nil
    )
    {
        self.graphArn = graphArn
    }
}

struct RejectInvitationInputBody: Equatable {
    public let graphArn: String?
}

extension RejectInvitationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case graphArn = "GraphArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
    }
}

extension RejectInvitationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectInvitationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectInvitationOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectInvitationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectInvitationOutputResponse()"}
}

extension RejectInvitationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RejectInvitationOutputResponse: Equatable {

    public init() {}
}

struct RejectInvitationOutputResponseBody: Equatable {
}

extension RejectInvitationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request refers to a nonexistent resource.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This request cannot be completed for one of the following reasons.</p>
///          <ul>
///             <li>
///                <p>The request would cause the number of member accounts in the behavior graph to
///                exceed the maximum allowed. A behavior graph cannot have more than 1000 member
///                accounts.</p>
///             </li>
///             <li>
///                <p>The request would cause the data rate for the behavior graph to exceed the maximum
///                allowed.</p>
///             </li>
///             <li>
///                <p>Detective is unable to verify the data rate for the member account. This is usually
///                because the member account is not enrolled in Amazon GuardDuty. </p>
///             </li>
///          </ul>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartMonitoringMemberInputBodyMiddleware: Middleware {
    public let id: String = "StartMonitoringMemberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMonitoringMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMonitoringMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMonitoringMemberInput>
    public typealias MOutput = OperationOutput<StartMonitoringMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMonitoringMemberOutputError>
}

extension StartMonitoringMemberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartMonitoringMemberInput(accountId: \(String(describing: accountId)), graphArn: \(String(describing: graphArn)))"}
}

extension StartMonitoringMemberInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

public struct StartMonitoringMemberInputHeadersMiddleware: Middleware {
    public let id: String = "StartMonitoringMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMonitoringMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMonitoringMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMonitoringMemberInput>
    public typealias MOutput = OperationOutput<StartMonitoringMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMonitoringMemberOutputError>
}

public struct StartMonitoringMemberInputQueryItemMiddleware: Middleware {
    public let id: String = "StartMonitoringMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMonitoringMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMonitoringMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMonitoringMemberInput>
    public typealias MOutput = OperationOutput<StartMonitoringMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMonitoringMemberOutputError>
}

public struct StartMonitoringMemberInput: Equatable {
    /// <p>The account ID of the member account to try to enable.</p>
    ///          <p>The account must be an invited member account with a status of
    ///             <code>ACCEPTED_BUT_DISABLED</code>. </p>
    public let accountId: String?
    /// <p>The ARN of the behavior graph.</p>
    public let graphArn: String?

    public init (
        accountId: String? = nil,
        graphArn: String? = nil
    )
    {
        self.accountId = accountId
        self.graphArn = graphArn
    }
}

struct StartMonitoringMemberInputBody: Equatable {
    public let graphArn: String?
    public let accountId: String?
}

extension StartMonitoringMemberInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case graphArn = "GraphArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension StartMonitoringMemberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMonitoringMemberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartMonitoringMemberOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMonitoringMemberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartMonitoringMemberOutputResponse()"}
}

extension StartMonitoringMemberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartMonitoringMemberOutputResponse: Equatable {

    public init() {}
}

struct StartMonitoringMemberOutputResponseBody: Equatable {
}

extension StartMonitoringMemberOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the behavior graph to assign the tags to.</p>
    public let resourceArn: String?
    /// <p>The tags to assign to the behavior graph. You can add up to 50 tags. For each tag, you
    ///          provide the tag key and the tag value. Each tag key can contain up to 128 characters. Each
    ///          tag value can contain up to 256 characters.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UnprocessedAccount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case reason = "Reason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension UnprocessedAccount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnprocessedAccount(accountId: \(String(describing: accountId)), reason: \(String(describing: reason)))"}
}

/// <p>A member account that was included in a request but for which the request could not be
///          processed.</p>
public struct UnprocessedAccount: Equatable {
    /// <p>The AWS account identifier of the member account that was not processed.</p>
    public let accountId: String?
    /// <p>The reason that the member account request could not be processed.</p>
    public let reason: String?

    public init (
        accountId: String? = nil,
        reason: String? = nil
    )
    {
        self.accountId = accountId
        self.reason = reason
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the behavior graph to remove the tags from.</p>
    public let resourceArn: String?
    /// <p>The tag keys of the tags to remove from the behavior graph. You can remove up to 50 tags
    ///          at a time.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request parameters are invalid.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
