// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException()"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

public struct CreateEnvironmentInputBodyMiddleware: Middleware {
    public let id: String = "CreateEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentOutputError>
}

extension CreateEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEnvironmentInput(description: \(String(describing: description)), federationMode: \(String(describing: federationMode)), federationParameters: \(String(describing: federationParameters)), kmsKeyId: \(String(describing: kmsKeyId)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateEnvironmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case federationMode
        case federationParameters
        case kmsKeyId
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let federationMode = federationMode {
            try encodeContainer.encode(federationMode.rawValue, forKey: .federationMode)
        }
        if let federationParameters = federationParameters {
            try encodeContainer.encode(federationParameters, forKey: .federationParameters)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInput: Equatable {
    /// <p>The description of the FinSpace environment to be created.</p>
    public let description: String?
    /// <p>Authentication mode for the environment.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>FEDERATED</code> - Users access FinSpace through Single Sign On (SSO) via your Identity provider.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LOCAL</code> - Users access FinSpace via email and password managed within the FinSpace environment.</p>
    ///             </li>
    ///          </ul>
    public let federationMode: FederationMode?
    /// <p>Configuration information when authentication mode is FEDERATED.</p>
    public let federationParameters: FederationParameters?
    /// <p>The KMS key id to encrypt your data in the FinSpace environment.</p>
    public let kmsKeyId: String?
    /// <p>The name of the FinSpace environment to be created.</p>
    public let name: String?
    /// <p>Add tags to your FinSpace environment.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        federationMode: FederationMode? = nil,
        federationParameters: FederationParameters? = nil,
        kmsKeyId: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.federationMode = federationMode
        self.federationParameters = federationParameters
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.tags = tags
    }
}

struct CreateEnvironmentInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let kmsKeyId: String?
    public let tags: [String:String]?
    public let federationMode: FederationMode?
    public let federationParameters: FederationParameters?
}

extension CreateEnvironmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case federationMode
        case federationParameters
        case kmsKeyId
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let federationModeDecoded = try containerValues.decodeIfPresent(FederationMode.self, forKey: .federationMode)
        federationMode = federationModeDecoded
        let federationParametersDecoded = try containerValues.decodeIfPresent(FederationParameters.self, forKey: .federationParameters)
        federationParameters = federationParametersDecoded
    }
}

extension CreateEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEnvironmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEnvironmentOutputResponse(environmentArn: \(String(describing: environmentArn)), environmentId: \(String(describing: environmentId)), environmentUrl: \(String(describing: environmentUrl)))"}
}

extension CreateEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.environmentArn = output.environmentArn
            self.environmentId = output.environmentId
            self.environmentUrl = output.environmentUrl
        } else {
            self.environmentArn = nil
            self.environmentId = nil
            self.environmentUrl = nil
        }
    }
}

public struct CreateEnvironmentOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the FinSpace environment that you created.</p>
    public let environmentArn: String?
    /// <p>The unique identifier for FinSpace environment that you created.</p>
    public let environmentId: String?
    /// <p>The sign-in url for the web application of the FinSpace environment you created.</p>
    public let environmentUrl: String?

    public init (
        environmentArn: String? = nil,
        environmentId: String? = nil,
        environmentUrl: String? = nil
    )
    {
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.environmentUrl = environmentUrl
    }
}

struct CreateEnvironmentOutputResponseBody: Equatable {
    public let environmentId: String?
    public let environmentArn: String?
    public let environmentUrl: String?
}

extension CreateEnvironmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environmentArn
        case environmentId
        case environmentUrl
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let environmentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let environmentUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentUrl)
        environmentUrl = environmentUrlDecoded
    }
}

extension DeleteEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEnvironmentInput(environmentId: \(String(describing: environmentId)))"}
}

extension DeleteEnvironmentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEnvironmentInput>
    public typealias MOutput = OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEnvironmentInput>
    public typealias MOutput = OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInput: Equatable {
    /// <p>The identifier for the FinSpace environment.</p>
    public let environmentId: String?

    public init (
        environmentId: String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct DeleteEnvironmentInputBody: Equatable {
}

extension DeleteEnvironmentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEnvironmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEnvironmentOutputResponse()"}
}

extension DeleteEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEnvironmentOutputResponse: Equatable {

    public init() {}
}

struct DeleteEnvironmentOutputResponseBody: Equatable {
}

extension DeleteEnvironmentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Environment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsAccountId
        case dedicatedServiceAccountId
        case description
        case environmentArn
        case environmentId
        case environmentUrl
        case federationMode
        case federationParameters
        case kmsKeyId
        case name
        case sageMakerStudioDomainUrl
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let dedicatedServiceAccountId = dedicatedServiceAccountId {
            try encodeContainer.encode(dedicatedServiceAccountId, forKey: .dedicatedServiceAccountId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentArn = environmentArn {
            try encodeContainer.encode(environmentArn, forKey: .environmentArn)
        }
        if let environmentId = environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let environmentUrl = environmentUrl {
            try encodeContainer.encode(environmentUrl, forKey: .environmentUrl)
        }
        if let federationMode = federationMode {
            try encodeContainer.encode(federationMode.rawValue, forKey: .federationMode)
        }
        if let federationParameters = federationParameters {
            try encodeContainer.encode(federationParameters, forKey: .federationParameters)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sageMakerStudioDomainUrl = sageMakerStudioDomainUrl {
            try encodeContainer.encode(sageMakerStudioDomainUrl, forKey: .sageMakerStudioDomainUrl)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let environmentUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentUrl)
        environmentUrl = environmentUrlDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let environmentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let sageMakerStudioDomainUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sageMakerStudioDomainUrl)
        sageMakerStudioDomainUrl = sageMakerStudioDomainUrlDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dedicatedServiceAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dedicatedServiceAccountId)
        dedicatedServiceAccountId = dedicatedServiceAccountIdDecoded
        let federationModeDecoded = try containerValues.decodeIfPresent(FederationMode.self, forKey: .federationMode)
        federationMode = federationModeDecoded
        let federationParametersDecoded = try containerValues.decodeIfPresent(FederationParameters.self, forKey: .federationParameters)
        federationParameters = federationParametersDecoded
    }
}

extension Environment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Environment(awsAccountId: \(String(describing: awsAccountId)), dedicatedServiceAccountId: \(String(describing: dedicatedServiceAccountId)), description: \(String(describing: description)), environmentArn: \(String(describing: environmentArn)), environmentId: \(String(describing: environmentId)), environmentUrl: \(String(describing: environmentUrl)), federationMode: \(String(describing: federationMode)), federationParameters: \(String(describing: federationParameters)), kmsKeyId: \(String(describing: kmsKeyId)), name: \(String(describing: name)), sageMakerStudioDomainUrl: \(String(describing: sageMakerStudioDomainUrl)), status: \(String(describing: status)))"}
}

/// <p>Represents an FinSpace environment.</p>
public struct Environment: Equatable {
    /// <p>The ID of the AWS account in which the FinSpace environment is created.</p>
    public let awsAccountId: String?
    /// <p>The AWS account ID of the dedicated service account associated with your FinSpace
    ///          environment.</p>
    public let dedicatedServiceAccountId: String?
    /// <p>The description of the FinSpace environment.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of your FinSpace environment.</p>
    public let environmentArn: String?
    /// <p>The identifier of the FinSpace environment.</p>
    public let environmentId: String?
    /// <p>The sign-in url for the web application of your FinSpace environment.</p>
    public let environmentUrl: String?
    /// <p>The authentication mode for the environment.</p>
    public let federationMode: FederationMode?
    /// <p>Configuration information when authentication mode is FEDERATED.</p>
    public let federationParameters: FederationParameters?
    /// <p>The KMS key id used to encrypt in the FinSpace environment.</p>
    public let kmsKeyId: String?
    /// <p>The name of the FinSpace environment.</p>
    public let name: String?
    /// <p>The url of the integrated FinSpace notebook environment in your web application.</p>
    public let sageMakerStudioDomainUrl: String?
    /// <p>The current status of creation of the FinSpace environment.</p>
    public let status: EnvironmentStatus?

    public init (
        awsAccountId: String? = nil,
        dedicatedServiceAccountId: String? = nil,
        description: String? = nil,
        environmentArn: String? = nil,
        environmentId: String? = nil,
        environmentUrl: String? = nil,
        federationMode: FederationMode? = nil,
        federationParameters: FederationParameters? = nil,
        kmsKeyId: String? = nil,
        name: String? = nil,
        sageMakerStudioDomainUrl: String? = nil,
        status: EnvironmentStatus? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dedicatedServiceAccountId = dedicatedServiceAccountId
        self.description = description
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.environmentUrl = environmentUrl
        self.federationMode = federationMode
        self.federationParameters = federationParameters
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.sageMakerStudioDomainUrl = sageMakerStudioDomainUrl
        self.status = status
    }
}

public enum EnvironmentStatus {
    case created
    case createRequested
    case creating
    case deleted
    case deleteRequested
    case deleting
    case failedCreation
    case failedDeletion
    case retryDeletion
    case suspended
    case sdkUnknown(String)
}

extension EnvironmentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnvironmentStatus] {
        return [
            .created,
            .createRequested,
            .creating,
            .deleted,
            .deleteRequested,
            .deleting,
            .failedCreation,
            .failedDeletion,
            .retryDeletion,
            .suspended,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .created: return "CREATED"
        case .createRequested: return "CREATE_REQUESTED"
        case .creating: return "CREATING"
        case .deleted: return "DELETED"
        case .deleteRequested: return "DELETE_REQUESTED"
        case .deleting: return "DELETING"
        case .failedCreation: return "FAILED_CREATION"
        case .failedDeletion: return "FAILED_DELETION"
        case .retryDeletion: return "RETRY_DELETION"
        case .suspended: return "SUSPENDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnvironmentStatus(rawValue: rawValue) ?? EnvironmentStatus.sdkUnknown(rawValue)
    }
}

public enum FederationMode {
    case federated
    case local
    case sdkUnknown(String)
}

extension FederationMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FederationMode] {
        return [
            .federated,
            .local,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .federated: return "FEDERATED"
        case .local: return "LOCAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FederationMode(rawValue: rawValue) ?? FederationMode.sdkUnknown(rawValue)
    }
}

extension FederationParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationCallBackURL
        case attributeMap
        case federationProviderName
        case federationURN
        case samlMetadataDocument
        case samlMetadataURL
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationCallBackURL = applicationCallBackURL {
            try encodeContainer.encode(applicationCallBackURL, forKey: .applicationCallBackURL)
        }
        if let attributeMap = attributeMap {
            var attributeMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributeMap)
            for (dictKey0, attributemap0) in attributeMap {
                try attributeMapContainer.encode(attributemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let federationProviderName = federationProviderName {
            try encodeContainer.encode(federationProviderName, forKey: .federationProviderName)
        }
        if let federationURN = federationURN {
            try encodeContainer.encode(federationURN, forKey: .federationURN)
        }
        if let samlMetadataDocument = samlMetadataDocument {
            try encodeContainer.encode(samlMetadataDocument, forKey: .samlMetadataDocument)
        }
        if let samlMetadataURL = samlMetadataURL {
            try encodeContainer.encode(samlMetadataURL, forKey: .samlMetadataURL)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlMetadataDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .samlMetadataDocument)
        samlMetadataDocument = samlMetadataDocumentDecoded
        let samlMetadataURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .samlMetadataURL)
        samlMetadataURL = samlMetadataURLDecoded
        let applicationCallBackURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationCallBackURL)
        applicationCallBackURL = applicationCallBackURLDecoded
        let federationURNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .federationURN)
        federationURN = federationURNDecoded
        let federationProviderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .federationProviderName)
        federationProviderName = federationProviderNameDecoded
        let attributeMapContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributeMap)
        var attributeMapDecoded0: [String:String]? = nil
        if let attributeMapContainer = attributeMapContainer {
            attributeMapDecoded0 = [String:String]()
            for (key0, url0) in attributeMapContainer {
                if let url0 = url0 {
                    attributeMapDecoded0?[key0] = url0
                }
            }
        }
        attributeMap = attributeMapDecoded0
    }
}

extension FederationParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FederationParameters(applicationCallBackURL: \(String(describing: applicationCallBackURL)), attributeMap: \(String(describing: attributeMap)), federationProviderName: \(String(describing: federationProviderName)), federationURN: \(String(describing: federationURN)), samlMetadataDocument: \(String(describing: samlMetadataDocument)), samlMetadataURL: \(String(describing: samlMetadataURL)))"}
}

/// <p>Configuration information when authentication mode is FEDERATED.</p>
public struct FederationParameters: Equatable {
    /// <p>The redirect or sign-in URL that should be entered into the SAML 2.0 compliant identity provider configuration
    ///        (IdP).</p>
    public let applicationCallBackURL: String?
    /// <p>SAML attribute name and value. The name must always be <code>Email</code> and the value should be set to
    ///          the attribute definition in which user email is set. For example, name would be <code>Email</code> and
    ///          value <code>http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress</code>.
    ///          Please check your SAML 2.0 compliant identity provider (IdP) documentation for details.</p>
    public let attributeMap: [String:String]?
    /// <p>Name of the identity provider (IdP).</p>
    public let federationProviderName: String?
    /// <p>The Uniform Resource Name (URN). Also referred as Service Provider URN or Audience URI or Service Provider Entity ID.</p>
    public let federationURN: String?
    /// <p>SAML 2.0 Metadata document from identity provider (IdP).</p>
    public let samlMetadataDocument: String?
    /// <p>Provide the metadata URL from your SAML 2.0 compliant identity provider (IdP).</p>
    public let samlMetadataURL: String?

    public init (
        applicationCallBackURL: String? = nil,
        attributeMap: [String:String]? = nil,
        federationProviderName: String? = nil,
        federationURN: String? = nil,
        samlMetadataDocument: String? = nil,
        samlMetadataURL: String? = nil
    )
    {
        self.applicationCallBackURL = applicationCallBackURL
        self.attributeMap = attributeMap
        self.federationProviderName = federationProviderName
        self.federationURN = federationURN
        self.samlMetadataDocument = samlMetadataDocument
        self.samlMetadataURL = samlMetadataURL
    }
}

extension GetEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEnvironmentInput(environmentId: \(String(describing: environmentId)))"}
}

extension GetEnvironmentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "GetEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEnvironmentInput>
    public typealias MOutput = OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEnvironmentInput>
    public typealias MOutput = OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInput: Equatable {
    /// <p>The identifier of the FinSpace environment.</p>
    public let environmentId: String?

    public init (
        environmentId: String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct GetEnvironmentInputBody: Equatable {
}

extension GetEnvironmentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEnvironmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEnvironmentOutputResponse(environment: \(String(describing: environment)))"}
}

extension GetEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct GetEnvironmentOutputResponse: Equatable {
    /// <p>The name of the FinSpace environment.</p>
    public let environment: Environment?

    public init (
        environment: Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct GetEnvironmentOutputResponseBody: Equatable {
    public let environment: Environment?
}

extension GetEnvironmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request processing has failed because of an unknown error, exception or
///          failure.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is invalid. Something is wrong with the input to the request.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A service limit or quota is exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListEnvironmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEnvironmentsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEnvironmentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListEnvironmentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEnvironmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEnvironmentsInput>
    public typealias MOutput = OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEnvironmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEnvironmentsInput>
    public typealias MOutput = OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInput: Equatable {
    /// <p>The maximum number of results to return in this request.</p>
    public let maxResults: Int
    /// <p>A token generated by FinSpace that specifies where to continue pagination if a previous
    ///          request was truncated. To get the next set of pages, pass in the nextToken value from the
    ///          response object of the previous page call.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Equatable {
}

extension ListEnvironmentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListEnvironmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnvironmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEnvironmentsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnvironmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEnvironmentsOutputResponse(environments: \(String(describing: environments)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEnvironmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEnvironmentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.environments = output.environments
            self.nextToken = output.nextToken
        } else {
            self.environments = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutputResponse: Equatable {
    /// <p>A list of all of your FinSpace environments.</p>
    public let environments: [Environment]?
    /// <p>A token that you can use in a subsequent call to retrieve the next set of
    ///          results.</p>
    public let nextToken: String?

    public init (
        environments: [Environment]? = nil,
        nextToken: String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputResponseBody: Equatable {
    public let environments: [Environment]?
    public let nextToken: String?
}

extension ListEnvironmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environments
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentsContainer = try containerValues.decodeIfPresent([Environment?].self, forKey: .environments)
        var environmentsDecoded0:[Environment]? = nil
        if let environmentsContainer = environmentsContainer {
            environmentsDecoded0 = [Environment]()
            for structure0 in environmentsContainer {
                if let structure0 = structure0 {
                    environmentsDecoded0?.append(structure0)
                }
            }
        }
        environments = environmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name of the resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A list of all tags for a resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more resources can't be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> You have exceeded your service quota. To perform the requested action,
///          remove some of the relevant resources, or use Service Quotas to request a service quota increase.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the resource.</p>
    public let resourceArn: String?
    /// <p>One or more tags to be assigned to the resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException()"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>A FinSpace resource from which you want to remove a tag or tags. The value for this
    ///          parameter is an Amazon Resource Name (ARN).</p>
    public let resourceArn: String?
    /// <p>The tag keys (names) of one or more tags to be removed.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateEnvironmentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentOutputError>
}

extension UpdateEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEnvironmentInput(description: \(String(describing: description)), environmentId: \(String(describing: environmentId)), federationMode: \(String(describing: federationMode)), federationParameters: \(String(describing: federationParameters)), name: \(String(describing: name)))"}
}

extension UpdateEnvironmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case federationMode
        case federationParameters
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let federationMode = federationMode {
            try encodeContainer.encode(federationMode.rawValue, forKey: .federationMode)
        }
        if let federationParameters = federationParameters {
            try encodeContainer.encode(federationParameters, forKey: .federationParameters)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInput: Equatable {
    /// <p>The description of the environment.</p>
    public let description: String?
    /// <p>The identifier of the FinSpace environment.</p>
    public let environmentId: String?
    /// <p>Authentication mode for the environment.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>FEDERATED</code> - Users access FinSpace through Single Sign On (SSO) via your Identity provider.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LOCAL</code> - Users access FinSpace via email and password managed within the FinSpace environment.</p>
    ///             </li>
    ///          </ul>
    public let federationMode: FederationMode?
    /// <p>Configuration information when authentication mode is FEDERATED.</p>
    public let federationParameters: FederationParameters?
    /// <p>The name of the environment.</p>
    public let name: String?

    public init (
        description: String? = nil,
        environmentId: String? = nil,
        federationMode: FederationMode? = nil,
        federationParameters: FederationParameters? = nil,
        name: String? = nil
    )
    {
        self.description = description
        self.environmentId = environmentId
        self.federationMode = federationMode
        self.federationParameters = federationParameters
        self.name = name
    }
}

struct UpdateEnvironmentInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let federationMode: FederationMode?
    public let federationParameters: FederationParameters?
}

extension UpdateEnvironmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case federationMode
        case federationParameters
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let federationModeDecoded = try containerValues.decodeIfPresent(FederationMode.self, forKey: .federationMode)
        federationMode = federationModeDecoded
        let federationParametersDecoded = try containerValues.decodeIfPresent(FederationParameters.self, forKey: .federationParameters)
        federationParameters = federationParametersDecoded
    }
}

extension UpdateEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEnvironmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEnvironmentOutputResponse(environment: \(String(describing: environment)))"}
}

extension UpdateEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct UpdateEnvironmentOutputResponse: Equatable {
    /// <p>Returns the FinSpace environment object.</p>
    public let environment: Environment?

    public init (
        environment: Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct UpdateEnvironmentOutputResponseBody: Equatable {
    public let environment: Environment?
}

extension UpdateEnvironmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input fails to satisfy the constraints specified by an AWS service.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
