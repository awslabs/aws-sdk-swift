// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AdvancedBackupSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupOptions = "BackupOptions"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupOptions = backupOptions {
            var backupOptionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .backupOptions)
            for (dictKey0, backupoptions0) in backupOptions {
                try backupOptionsContainer.encode(backupoptions0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let backupOptionsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [String:String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [String:String]()
            for (key0, backupoptionvalue0) in backupOptionsContainer {
                if let backupoptionvalue0 = backupoptionvalue0 {
                    backupOptionsDecoded0?[key0] = backupoptionvalue0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
    }
}

extension AdvancedBackupSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdvancedBackupSetting(backupOptions: \(String(describing: backupOptions)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>A list of backup options for each resource type.</p>
public struct AdvancedBackupSetting: Equatable {
    /// <p>Specifies the backup option for a selected resource. This option is only available for
    ///          Windows VSS backup jobs.</p>
    ///          <p>Valid values: </p>
    ///          <p>Set to <code>"WindowsVSS":"enabled"</code> to enable the WindowsVSS backup option and
    ///          create a VSS Windows backup. </p>
    ///          <p>Set to <code>"WindowsVSS":"disabled"</code> to create a regular backup. The WindowsVSS
    ///          option is not enabled by default.</p>
    ///          <p>If you specify an invalid option, you get an <code>InvalidParameterValueException</code>
    ///          exception.</p>
    ///          <p>For more information about Windows VSS backups, see <a href="https://docs.aws.amazon.com/aws-backup/latest/devguide/windows-backups.html">Creating a VSS-Enabled Windows
    ///             Backup</a>.</p>
    public let backupOptions: [String:String]?
    /// <p>Specifies an object containing resource type and backup options. The only supported
    ///          resource type is Amazon EC2 instances with Windows VSS. For an CloudFormation example, see
    ///          the <a href="https://docs.aws.amazon.com/aws-backup/latest/devguide/integrate-cloudformation-with-aws-backup.html">sample
    ///             CloudFormation template to enable Windows VSS</a> in the <i>AWS Backup User
    ///             Guide</i>.</p>
    ///          <p>Valid values: <code>EC2</code>.</p>
    public let resourceType: String?

    public init (
        backupOptions: [String:String]? = nil,
        resourceType: String? = nil
    )
    {
        self.backupOptions = backupOptions
        self.resourceType = resourceType
    }
}

extension AlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlreadyExistsException(arn: \(String(describing: arn)), code: \(String(describing: code)), context: \(String(describing: context)), creatorRequestId: \(String(describing: creatorRequestId)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension AlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.code = output.code
            self.context = output.context
            self.creatorRequestId = output.creatorRequestId
            self.message = output.message
            self.type = output.type
        } else {
            self.arn = nil
            self.code = nil
            self.context = nil
            self.creatorRequestId = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The required resource already exists.</p>
public struct AlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var arn: String?
    public var code: String?
    /// <p></p>
    public var context: String?
    /// <p></p>
    public var creatorRequestId: String?
    public var message: String?
    /// <p></p>
    public var type: String?

    public init (
        arn: String? = nil,
        code: String? = nil,
        context: String? = nil,
        creatorRequestId: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.arn = arn
        self.code = code
        self.context = context
        self.creatorRequestId = creatorRequestId
        self.message = message
        self.type = type
    }
}

struct AlreadyExistsExceptionBody: Equatable {
    public let code: String?
    public let message: String?
    public let creatorRequestId: String?
    public let arn: String?
    public let type: String?
    public let context: String?
}

extension AlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case code = "Code"
        case context = "Context"
        case creatorRequestId = "CreatorRequestId"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .context)
        context = contextDecoded
    }
}

extension BackupJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case backupJobId = "BackupJobId"
        case backupOptions = "BackupOptions"
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupType = "BackupType"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case bytesTransferred = "BytesTransferred"
        case completionDate = "CompletionDate"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case expectedCompletionDate = "ExpectedCompletionDate"
        case iamRoleArn = "IamRoleArn"
        case percentDone = "PercentDone"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
        case startBy = "StartBy"
        case state = "State"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let backupJobId = backupJobId {
            try encodeContainer.encode(backupJobId, forKey: .backupJobId)
        }
        if let backupOptions = backupOptions {
            var backupOptionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .backupOptions)
            for (dictKey0, backupoptions0) in backupOptions {
                try backupOptionsContainer.encode(backupoptions0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let backupSizeInBytes = backupSizeInBytes {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let backupType = backupType {
            try encodeContainer.encode(backupType, forKey: .backupType)
        }
        if let backupVaultArn = backupVaultArn {
            try encodeContainer.encode(backupVaultArn, forKey: .backupVaultArn)
        }
        if let backupVaultName = backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let bytesTransferred = bytesTransferred {
            try encodeContainer.encode(bytesTransferred, forKey: .bytesTransferred)
        }
        if let completionDate = completionDate {
            try encodeContainer.encode(completionDate.timeIntervalSince1970, forKey: .completionDate)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let expectedCompletionDate = expectedCompletionDate {
            try encodeContainer.encode(expectedCompletionDate.timeIntervalSince1970, forKey: .expectedCompletionDate)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let percentDone = percentDone {
            try encodeContainer.encode(percentDone, forKey: .percentDone)
        }
        if let recoveryPointArn = recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let startBy = startBy {
            try encodeContainer.encode(startBy.timeIntervalSince1970, forKey: .startBy)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let backupJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupJobId)
        backupJobId = backupJobIdDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let stateDecoded = try containerValues.decodeIfPresent(BackupJobState.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let expectedCompletionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expectedCompletionDate)
        expectedCompletionDate = expectedCompletionDateDecoded
        let startByDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startBy)
        startBy = startByDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let bytesTransferredDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .bytesTransferred)
        bytesTransferred = bytesTransferredDecoded
        let backupOptionsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [String:String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [String:String]()
            for (key0, backupoptionvalue0) in backupOptionsContainer {
                if let backupoptionvalue0 = backupoptionvalue0 {
                    backupOptionsDecoded0?[key0] = backupoptionvalue0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
        let backupTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupType)
        backupType = backupTypeDecoded
    }
}

extension BackupJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupJob(accountId: \(String(describing: accountId)), backupJobId: \(String(describing: backupJobId)), backupOptions: \(String(describing: backupOptions)), backupSizeInBytes: \(String(describing: backupSizeInBytes)), backupType: \(String(describing: backupType)), backupVaultArn: \(String(describing: backupVaultArn)), backupVaultName: \(String(describing: backupVaultName)), bytesTransferred: \(String(describing: bytesTransferred)), completionDate: \(String(describing: completionDate)), createdBy: \(String(describing: createdBy)), creationDate: \(String(describing: creationDate)), expectedCompletionDate: \(String(describing: expectedCompletionDate)), iamRoleArn: \(String(describing: iamRoleArn)), percentDone: \(String(describing: percentDone)), recoveryPointArn: \(String(describing: recoveryPointArn)), resourceArn: \(String(describing: resourceArn)), resourceType: \(String(describing: resourceType)), startBy: \(String(describing: startBy)), state: \(String(describing: state)), statusMessage: \(String(describing: statusMessage)))"}
}

/// <p>Contains detailed information about a backup job.</p>
public struct BackupJob: Equatable {
    /// <p>The account ID that owns the backup job.</p>
    public let accountId: String?
    /// <p>Uniquely identifies a request to AWS Backup to back up a resource.</p>
    public let backupJobId: String?
    /// <p>Specifies the backup option for a selected resource. This option is only available for
    ///          Windows VSS backup jobs.</p>
    ///          <p>Valid values: Set to <code>"WindowsVSS”:“enabled"</code> to enable WindowsVSS backup
    ///          option and create a VSS Windows backup. Set to “WindowsVSS”:”disabled” to create a regular
    ///          backup. If you specify an invalid option, you get an
    ///             <code>InvalidParameterValueException</code> exception.</p>
    public let backupOptions: [String:String]?
    /// <p>The size, in bytes, of a backup.</p>
    public let backupSizeInBytes: Int?
    /// <p>Represents the type of backup for a backup job.</p>
    public let backupType: String?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
    public let backupVaultArn: String?
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>The size in bytes transferred to a backup vault at the time that the job status was
    ///          queried.</p>
    public let bytesTransferred: Int?
    /// <p>The date and time a job to create a backup job is completed, in Unix format and
    ///          Coordinated Universal Time (UTC). The value of <code>CompletionDate</code> is accurate to
    ///          milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018
    ///          12:11:30.087 AM.</p>
    public let completionDate: Date?
    /// <p>Contains identifying information about the creation of a backup job, including the
    ///             <code>BackupPlanArn</code>, <code>BackupPlanId</code>, <code>BackupPlanVersion</code>,
    ///          and <code>BackupRuleId</code> of the backup plan used to create it.</p>
    public let createdBy: RecoveryPointCreator?
    /// <p>The date and time a backup job is created, in Unix format and Coordinated Universal Time
    ///          (UTC). The value of <code>CreationDate</code> is accurate to milliseconds. For example, the
    ///          value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.</p>
    public let creationDate: Date?
    /// <p>The date and time a job to back up resources is expected to be completed, in Unix format
    ///          and Coordinated Universal Time (UTC). The value of <code>ExpectedCompletionDate</code> is
    ///          accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January
    ///          26, 2018 12:11:30.087 AM.</p>
    public let expectedCompletionDate: Date?
    /// <p>Specifies the IAM role ARN used to create the target recovery point. IAM roles other
    ///          than the default role must include either <code>AWSBackup</code> or <code>AwsBackup</code>
    ///          in the role name. For example,
    ///             <code>arn:aws:iam::123456789012:role/AWSBackupRDSAccess</code>. Role names without those
    ///          strings lack permissions to perform backup jobs.</p>
    public let iamRoleArn: String?
    /// <p>Contains an estimated percentage complete of a job at the time the job status was
    ///          queried.</p>
    public let percentDone: String?
    /// <p>An ARN that uniquely identifies a recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let recoveryPointArn: String?
    /// <p>An ARN that uniquely identifies a resource. The format of the ARN depends on the
    ///          resource type.</p>
    public let resourceArn: String?
    /// <p>The type of AWS resource to be backed up; for example, an Amazon Elastic Block Store
    ///          (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For VSS
    ///          Windows backups, the only supported resource type is Amazon EC2.</p>
    public let resourceType: String?
    /// <p>Specifies the time in Unix format and Coordinated Universal Time (UTC) when a backup job
    ///          must be started before it is canceled. The value is calculated by adding the start window
    ///          to the scheduled time. So if the scheduled time were 6:00 PM and the start window is 2
    ///          hours, the <code>StartBy</code> time would be 8:00 PM on the date specified. The value of
    ///             <code>StartBy</code> is accurate to milliseconds. For example, the value 1516925490.087
    ///          represents Friday, January 26, 2018 12:11:30.087 AM.</p>
    public let startBy: Date?
    /// <p>The current state of a resource recovery point.</p>
    public let state: BackupJobState?
    /// <p>A detailed message explaining the status of the job to back up a resource.</p>
    public let statusMessage: String?

    public init (
        accountId: String? = nil,
        backupJobId: String? = nil,
        backupOptions: [String:String]? = nil,
        backupSizeInBytes: Int? = nil,
        backupType: String? = nil,
        backupVaultArn: String? = nil,
        backupVaultName: String? = nil,
        bytesTransferred: Int? = nil,
        completionDate: Date? = nil,
        createdBy: RecoveryPointCreator? = nil,
        creationDate: Date? = nil,
        expectedCompletionDate: Date? = nil,
        iamRoleArn: String? = nil,
        percentDone: String? = nil,
        recoveryPointArn: String? = nil,
        resourceArn: String? = nil,
        resourceType: String? = nil,
        startBy: Date? = nil,
        state: BackupJobState? = nil,
        statusMessage: String? = nil
    )
    {
        self.accountId = accountId
        self.backupJobId = backupJobId
        self.backupOptions = backupOptions
        self.backupSizeInBytes = backupSizeInBytes
        self.backupType = backupType
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.bytesTransferred = bytesTransferred
        self.completionDate = completionDate
        self.createdBy = createdBy
        self.creationDate = creationDate
        self.expectedCompletionDate = expectedCompletionDate
        self.iamRoleArn = iamRoleArn
        self.percentDone = percentDone
        self.recoveryPointArn = recoveryPointArn
        self.resourceArn = resourceArn
        self.resourceType = resourceType
        self.startBy = startBy
        self.state = state
        self.statusMessage = statusMessage
    }
}

public enum BackupJobState {
    case aborted
    case aborting
    case completed
    case created
    case expired
    case failed
    case pending
    case running
    case sdkUnknown(String)
}

extension BackupJobState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BackupJobState] {
        return [
            .aborted,
            .aborting,
            .completed,
            .created,
            .expired,
            .failed,
            .pending,
            .running,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aborted: return "ABORTED"
        case .aborting: return "ABORTING"
        case .completed: return "COMPLETED"
        case .created: return "CREATED"
        case .expired: return "EXPIRED"
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case .running: return "RUNNING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BackupJobState(rawValue: rawValue) ?? BackupJobState.sdkUnknown(rawValue)
    }
}

extension BackupPlan: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanName = "BackupPlanName"
        case rules = "Rules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedBackupSettings = advancedBackupSettings {
            var advancedBackupSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedBackupSettings)
            for advancedbackupsettings0 in advancedBackupSettings {
                try advancedBackupSettingsContainer.encode(advancedbackupsettings0)
            }
        }
        if let backupPlanName = backupPlanName {
            try encodeContainer.encode(backupPlanName, forKey: .backupPlanName)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for backuprules0 in rules {
                try rulesContainer.encode(backuprules0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanName)
        backupPlanName = backupPlanNameDecoded
        let rulesContainer = try containerValues.decodeIfPresent([BackupRule?].self, forKey: .rules)
        var rulesDecoded0:[BackupRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [BackupRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension BackupPlan: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupPlan(advancedBackupSettings: \(String(describing: advancedBackupSettings)), backupPlanName: \(String(describing: backupPlanName)), rules: \(String(describing: rules)))"}
}

/// <p>Contains an optional backup plan display name and an array of <code>BackupRule</code>
///          objects, each of which specifies a backup rule. Each rule in a backup plan is a separate
///          scheduled task and can back up a different selection of AWS resources.</p>
public struct BackupPlan: Equatable {
    /// <p>Contains a list of <code>BackupOptions</code> for each resource type.</p>
    public let advancedBackupSettings: [AdvancedBackupSetting]?
    /// <p>The display name of a backup plan.</p>
    public let backupPlanName: String?
    /// <p>An array of <code>BackupRule</code> objects, each of which specifies a scheduled task
    ///          that is used to back up a selection of resources. </p>
    public let rules: [BackupRule]?

    public init (
        advancedBackupSettings: [AdvancedBackupSetting]? = nil,
        backupPlanName: String? = nil,
        rules: [BackupRule]? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlanName = backupPlanName
        self.rules = rules
    }
}

extension BackupPlanInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanName = "BackupPlanName"
        case rules = "Rules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedBackupSettings = advancedBackupSettings {
            var advancedBackupSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedBackupSettings)
            for advancedbackupsettings0 in advancedBackupSettings {
                try advancedBackupSettingsContainer.encode(advancedbackupsettings0)
            }
        }
        if let backupPlanName = backupPlanName {
            try encodeContainer.encode(backupPlanName, forKey: .backupPlanName)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for backuprulesinput0 in rules {
                try rulesContainer.encode(backuprulesinput0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanName)
        backupPlanName = backupPlanNameDecoded
        let rulesContainer = try containerValues.decodeIfPresent([BackupRuleInput?].self, forKey: .rules)
        var rulesDecoded0:[BackupRuleInput]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [BackupRuleInput]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension BackupPlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupPlanInput(advancedBackupSettings: \(String(describing: advancedBackupSettings)), backupPlanName: \(String(describing: backupPlanName)), rules: \(String(describing: rules)))"}
}

/// <p>Contains an optional backup plan display name and an array of <code>BackupRule</code>
///          objects, each of which specifies a backup rule. Each rule in a backup plan is a separate
///          scheduled task and can back up a different selection of AWS resources. </p>
public struct BackupPlanInput: Equatable {
    /// <p>Specifies a list of <code>BackupOptions</code> for each resource type. These settings
    ///          are only available for Windows VSS backup jobs.</p>
    public let advancedBackupSettings: [AdvancedBackupSetting]?
    /// <p>The optional display name of a backup plan.</p>
    public let backupPlanName: String?
    /// <p>An array of <code>BackupRule</code> objects, each of which specifies a scheduled task
    ///          that is used to back up a selection of resources.</p>
    public let rules: [BackupRuleInput]?

    public init (
        advancedBackupSettings: [AdvancedBackupSetting]? = nil,
        backupPlanName: String? = nil,
        rules: [BackupRuleInput]? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlanName = backupPlanName
        self.rules = rules
    }
}

extension BackupPlanTemplatesListMember: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupPlanTemplateId = "BackupPlanTemplateId"
        case backupPlanTemplateName = "BackupPlanTemplateName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanTemplateId = backupPlanTemplateId {
            try encodeContainer.encode(backupPlanTemplateId, forKey: .backupPlanTemplateId)
        }
        if let backupPlanTemplateName = backupPlanTemplateName {
            try encodeContainer.encode(backupPlanTemplateName, forKey: .backupPlanTemplateName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanTemplateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanTemplateId)
        backupPlanTemplateId = backupPlanTemplateIdDecoded
        let backupPlanTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanTemplateName)
        backupPlanTemplateName = backupPlanTemplateNameDecoded
    }
}

extension BackupPlanTemplatesListMember: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupPlanTemplatesListMember(backupPlanTemplateId: \(String(describing: backupPlanTemplateId)), backupPlanTemplateName: \(String(describing: backupPlanTemplateName)))"}
}

/// <p>An object specifying metadata associated with a backup plan template.</p>
public struct BackupPlanTemplatesListMember: Equatable {
    /// <p>Uniquely identifies a stored backup plan template.</p>
    public let backupPlanTemplateId: String?
    /// <p>The optional display name of a backup plan template.</p>
    public let backupPlanTemplateName: String?

    public init (
        backupPlanTemplateId: String? = nil,
        backupPlanTemplateName: String? = nil
    )
    {
        self.backupPlanTemplateId = backupPlanTemplateId
        self.backupPlanTemplateName = backupPlanTemplateName
    }
}

extension BackupPlansListMember: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case backupPlanName = "BackupPlanName"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case deletionDate = "DeletionDate"
        case lastExecutionDate = "LastExecutionDate"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedBackupSettings = advancedBackupSettings {
            var advancedBackupSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedBackupSettings)
            for advancedbackupsettings0 in advancedBackupSettings {
                try advancedBackupSettingsContainer.encode(advancedbackupsettings0)
            }
        }
        if let backupPlanArn = backupPlanArn {
            try encodeContainer.encode(backupPlanArn, forKey: .backupPlanArn)
        }
        if let backupPlanId = backupPlanId {
            try encodeContainer.encode(backupPlanId, forKey: .backupPlanId)
        }
        if let backupPlanName = backupPlanName {
            try encodeContainer.encode(backupPlanName, forKey: .backupPlanName)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let deletionDate = deletionDate {
            try encodeContainer.encode(deletionDate.timeIntervalSince1970, forKey: .deletionDate)
        }
        if let lastExecutionDate = lastExecutionDate {
            try encodeContainer.encode(lastExecutionDate.timeIntervalSince1970, forKey: .lastExecutionDate)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let deletionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let backupPlanNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanName)
        backupPlanName = backupPlanNameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let lastExecutionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension BackupPlansListMember: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupPlansListMember(advancedBackupSettings: \(String(describing: advancedBackupSettings)), backupPlanArn: \(String(describing: backupPlanArn)), backupPlanId: \(String(describing: backupPlanId)), backupPlanName: \(String(describing: backupPlanName)), creationDate: \(String(describing: creationDate)), creatorRequestId: \(String(describing: creatorRequestId)), deletionDate: \(String(describing: deletionDate)), lastExecutionDate: \(String(describing: lastExecutionDate)), versionId: \(String(describing: versionId)))"}
}

/// <p>Contains metadata about a backup plan.</p>
public struct BackupPlansListMember: Equatable {
    /// <p>Contains a list of <code>BackupOptions</code> for a resource type.</p>
    public let advancedBackupSettings: [AdvancedBackupSetting]?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50</code>.</p>
    public let backupPlanArn: String?
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?
    /// <p>The display name of a saved backup plan.</p>
    public let backupPlanName: String?
    /// <p>The date and time a resource backup plan is created, in Unix format and Coordinated
    ///          Universal Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds.
    ///          For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?
    /// <p>A unique string that identifies the request and allows failed requests to be retried
    ///          without the risk of running the operation twice.</p>
    public let creatorRequestId: String?
    /// <p>The date and time a backup plan is deleted, in Unix format and Coordinated Universal
    ///          Time (UTC). The value of <code>DeletionDate</code> is accurate to milliseconds. For
    ///          example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let deletionDate: Date?
    /// <p>The last time a job to back up resources was run with this rule. A date and time, in
    ///          Unix format and Coordinated Universal Time (UTC). The value of
    ///             <code>LastExecutionDate</code> is accurate to milliseconds. For example, the value
    ///          1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.</p>
    public let lastExecutionDate: Date?
    /// <p>Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes
    ///          long. Version IDs cannot be edited.</p>
    public let versionId: String?

    public init (
        advancedBackupSettings: [AdvancedBackupSetting]? = nil,
        backupPlanArn: String? = nil,
        backupPlanId: String? = nil,
        backupPlanName: String? = nil,
        creationDate: Date? = nil,
        creatorRequestId: String? = nil,
        deletionDate: Date? = nil,
        lastExecutionDate: Date? = nil,
        versionId: String? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.backupPlanName = backupPlanName
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.deletionDate = deletionDate
        self.lastExecutionDate = lastExecutionDate
        self.versionId = versionId
    }
}

extension BackupRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case completionWindowMinutes = "CompletionWindowMinutes"
        case copyActions = "CopyActions"
        case enableContinuousBackup = "EnableContinuousBackup"
        case lifecycle = "Lifecycle"
        case recoveryPointTags = "RecoveryPointTags"
        case ruleId = "RuleId"
        case ruleName = "RuleName"
        case scheduleExpression = "ScheduleExpression"
        case startWindowMinutes = "StartWindowMinutes"
        case targetBackupVaultName = "TargetBackupVaultName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionWindowMinutes = completionWindowMinutes {
            try encodeContainer.encode(completionWindowMinutes, forKey: .completionWindowMinutes)
        }
        if let copyActions = copyActions {
            var copyActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .copyActions)
            for copyactions0 in copyActions {
                try copyActionsContainer.encode(copyactions0)
            }
        }
        if let enableContinuousBackup = enableContinuousBackup {
            try encodeContainer.encode(enableContinuousBackup, forKey: .enableContinuousBackup)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointTags = recoveryPointTags {
            var recoveryPointTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .recoveryPointTags)
            for (dictKey0, tags0) in recoveryPointTags {
                try recoveryPointTagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let startWindowMinutes = startWindowMinutes {
            try encodeContainer.encode(startWindowMinutes, forKey: .startWindowMinutes)
        }
        if let targetBackupVaultName = targetBackupVaultName {
            try encodeContainer.encode(targetBackupVaultName, forKey: .targetBackupVaultName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let targetBackupVaultNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetBackupVaultName)
        targetBackupVaultName = targetBackupVaultNameDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let startWindowMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .startWindowMinutes)
        startWindowMinutes = startWindowMinutesDecoded
        let completionWindowMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .completionWindowMinutes)
        completionWindowMinutes = completionWindowMinutesDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let recoveryPointTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .recoveryPointTags)
        var recoveryPointTagsDecoded0: [String:String]? = nil
        if let recoveryPointTagsContainer = recoveryPointTagsContainer {
            recoveryPointTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in recoveryPointTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    recoveryPointTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        recoveryPointTags = recoveryPointTagsDecoded0
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let copyActionsContainer = try containerValues.decodeIfPresent([CopyAction?].self, forKey: .copyActions)
        var copyActionsDecoded0:[CopyAction]? = nil
        if let copyActionsContainer = copyActionsContainer {
            copyActionsDecoded0 = [CopyAction]()
            for structure0 in copyActionsContainer {
                if let structure0 = structure0 {
                    copyActionsDecoded0?.append(structure0)
                }
            }
        }
        copyActions = copyActionsDecoded0
        let enableContinuousBackupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableContinuousBackup)
        enableContinuousBackup = enableContinuousBackupDecoded
    }
}

extension BackupRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupRule(completionWindowMinutes: \(String(describing: completionWindowMinutes)), copyActions: \(String(describing: copyActions)), enableContinuousBackup: \(String(describing: enableContinuousBackup)), lifecycle: \(String(describing: lifecycle)), recoveryPointTags: \(String(describing: recoveryPointTags)), ruleId: \(String(describing: ruleId)), ruleName: \(String(describing: ruleName)), scheduleExpression: \(String(describing: scheduleExpression)), startWindowMinutes: \(String(describing: startWindowMinutes)), targetBackupVaultName: \(String(describing: targetBackupVaultName)))"}
}

/// <p>Specifies a scheduled task used to back up a selection of resources.</p>
public struct BackupRule: Equatable {
    /// <p>A value in minutes after a backup job is successfully started before it must be
    ///          completed or it will be canceled by AWS Backup. This value is optional.</p>
    public let completionWindowMinutes: Int?
    /// <p>An array of <code>CopyAction</code> objects, which contains the details of the copy
    ///          operation.</p>
    public let copyActions: [CopyAction]?
    /// <p>Specifies whether AWS Backup creates continuous backups. True causes AWS Backup to
    ///          create continuous backups capable of point-in-time restore (PITR). False (or not specified)
    ///          causes AWS Backup to create snapshot backups.</p>
    public let enableContinuousBackup: Bool?
    /// <p>The lifecycle defines when a protected resource is transitioned to cold storage and when
    ///          it expires. AWS Backup transitions and expires backups automatically according to the
    ///          lifecycle that you define. </p>
    ///          <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
    ///          days. Therefore, the “expire after days” setting must be 90 days greater than the
    ///          “transition to cold after days” setting. The “transition to cold after days” setting cannot
    ///          be changed after a backup has been transitioned to cold. </p>
    ///          <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
    public let lifecycle: Lifecycle?
    /// <p>An array of key-value pair strings that are assigned to resources that are associated
    ///          with this rule when restored from backup.</p>
    public let recoveryPointTags: [String:String]?
    /// <p>Uniquely identifies a rule that is used to schedule the backup of a selection of
    ///          resources.</p>
    public let ruleId: String?
    /// <p>An optional display name for a backup rule.</p>
    public let ruleName: String?
    /// <p>A CRON expression specifying when AWS Backup initiates a backup job. For more
    ///          information about cron expressions, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html">Schedule Expressions for Rules</a> in the <i>Amazon CloudWatch Events User
    ///             Guide.</i>. Prior to specifying a value for this parameter, we recommend testing
    ///          your cron expression using one of the many available cron generator and testing
    ///          tools.</p>
    public let scheduleExpression: String?
    /// <p>A value in minutes after a backup is scheduled before a job will be canceled if it
    ///          doesn't start successfully. This value is optional.</p>
    public let startWindowMinutes: Int?
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let targetBackupVaultName: String?

    public init (
        completionWindowMinutes: Int? = nil,
        copyActions: [CopyAction]? = nil,
        enableContinuousBackup: Bool? = nil,
        lifecycle: Lifecycle? = nil,
        recoveryPointTags: [String:String]? = nil,
        ruleId: String? = nil,
        ruleName: String? = nil,
        scheduleExpression: String? = nil,
        startWindowMinutes: Int? = nil,
        targetBackupVaultName: String? = nil
    )
    {
        self.completionWindowMinutes = completionWindowMinutes
        self.copyActions = copyActions
        self.enableContinuousBackup = enableContinuousBackup
        self.lifecycle = lifecycle
        self.recoveryPointTags = recoveryPointTags
        self.ruleId = ruleId
        self.ruleName = ruleName
        self.scheduleExpression = scheduleExpression
        self.startWindowMinutes = startWindowMinutes
        self.targetBackupVaultName = targetBackupVaultName
    }
}

extension BackupRuleInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case completionWindowMinutes = "CompletionWindowMinutes"
        case copyActions = "CopyActions"
        case enableContinuousBackup = "EnableContinuousBackup"
        case lifecycle = "Lifecycle"
        case recoveryPointTags = "RecoveryPointTags"
        case ruleName = "RuleName"
        case scheduleExpression = "ScheduleExpression"
        case startWindowMinutes = "StartWindowMinutes"
        case targetBackupVaultName = "TargetBackupVaultName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionWindowMinutes = completionWindowMinutes {
            try encodeContainer.encode(completionWindowMinutes, forKey: .completionWindowMinutes)
        }
        if let copyActions = copyActions {
            var copyActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .copyActions)
            for copyactions0 in copyActions {
                try copyActionsContainer.encode(copyactions0)
            }
        }
        if let enableContinuousBackup = enableContinuousBackup {
            try encodeContainer.encode(enableContinuousBackup, forKey: .enableContinuousBackup)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointTags = recoveryPointTags {
            var recoveryPointTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .recoveryPointTags)
            for (dictKey0, tags0) in recoveryPointTags {
                try recoveryPointTagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let startWindowMinutes = startWindowMinutes {
            try encodeContainer.encode(startWindowMinutes, forKey: .startWindowMinutes)
        }
        if let targetBackupVaultName = targetBackupVaultName {
            try encodeContainer.encode(targetBackupVaultName, forKey: .targetBackupVaultName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let targetBackupVaultNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetBackupVaultName)
        targetBackupVaultName = targetBackupVaultNameDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let startWindowMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .startWindowMinutes)
        startWindowMinutes = startWindowMinutesDecoded
        let completionWindowMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .completionWindowMinutes)
        completionWindowMinutes = completionWindowMinutesDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let recoveryPointTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .recoveryPointTags)
        var recoveryPointTagsDecoded0: [String:String]? = nil
        if let recoveryPointTagsContainer = recoveryPointTagsContainer {
            recoveryPointTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in recoveryPointTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    recoveryPointTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        recoveryPointTags = recoveryPointTagsDecoded0
        let copyActionsContainer = try containerValues.decodeIfPresent([CopyAction?].self, forKey: .copyActions)
        var copyActionsDecoded0:[CopyAction]? = nil
        if let copyActionsContainer = copyActionsContainer {
            copyActionsDecoded0 = [CopyAction]()
            for structure0 in copyActionsContainer {
                if let structure0 = structure0 {
                    copyActionsDecoded0?.append(structure0)
                }
            }
        }
        copyActions = copyActionsDecoded0
        let enableContinuousBackupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableContinuousBackup)
        enableContinuousBackup = enableContinuousBackupDecoded
    }
}

extension BackupRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupRuleInput(completionWindowMinutes: \(String(describing: completionWindowMinutes)), copyActions: \(String(describing: copyActions)), enableContinuousBackup: \(String(describing: enableContinuousBackup)), lifecycle: \(String(describing: lifecycle)), recoveryPointTags: \(String(describing: recoveryPointTags)), ruleName: \(String(describing: ruleName)), scheduleExpression: \(String(describing: scheduleExpression)), startWindowMinutes: \(String(describing: startWindowMinutes)), targetBackupVaultName: \(String(describing: targetBackupVaultName)))"}
}

/// <p>Specifies a scheduled task used to back up a selection of resources.</p>
public struct BackupRuleInput: Equatable {
    /// <p>A value in minutes after a backup job is successfully started before it must be
    ///          completed or it will be canceled by AWS Backup. This value is optional.</p>
    public let completionWindowMinutes: Int?
    /// <p>An array of <code>CopyAction</code> objects, which contains the details of the copy
    ///          operation.</p>
    public let copyActions: [CopyAction]?
    /// <p>Specifies whether AWS Backup creates continuous backups. True causes AWS Backup to
    ///          create continuous backups capable of point-in-time restore (PITR). False (or not specified)
    ///          causes AWS Backup to create snapshot backups.</p>
    public let enableContinuousBackup: Bool?
    /// <p>The lifecycle defines when a protected resource is transitioned to cold storage and when
    ///          it expires. AWS Backup will transition and expire backups automatically according to the
    ///          lifecycle that you define. </p>
    ///          <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
    ///          days. Therefore, the “expire after days” setting must be 90 days greater than the
    ///          “transition to cold after days” setting. The “transition to cold after days” setting cannot
    ///          be changed after a backup has been transitioned to cold. </p>
    ///          <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
    public let lifecycle: Lifecycle?
    /// <p>To help organize your resources, you can assign your own metadata to the resources that
    ///          you create. Each tag is a key-value pair.</p>
    public let recoveryPointTags: [String:String]?
    /// <p>An optional display name for a backup rule.</p>
    public let ruleName: String?
    /// <p>A CRON expression specifying when AWS Backup initiates a backup job.</p>
    public let scheduleExpression: String?
    /// <p>A value in minutes after a backup is scheduled before a job will be canceled if it
    ///          doesn't start successfully. This value is optional.</p>
    public let startWindowMinutes: Int?
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let targetBackupVaultName: String?

    public init (
        completionWindowMinutes: Int? = nil,
        copyActions: [CopyAction]? = nil,
        enableContinuousBackup: Bool? = nil,
        lifecycle: Lifecycle? = nil,
        recoveryPointTags: [String:String]? = nil,
        ruleName: String? = nil,
        scheduleExpression: String? = nil,
        startWindowMinutes: Int? = nil,
        targetBackupVaultName: String? = nil
    )
    {
        self.completionWindowMinutes = completionWindowMinutes
        self.copyActions = copyActions
        self.enableContinuousBackup = enableContinuousBackup
        self.lifecycle = lifecycle
        self.recoveryPointTags = recoveryPointTags
        self.ruleName = ruleName
        self.scheduleExpression = scheduleExpression
        self.startWindowMinutes = startWindowMinutes
        self.targetBackupVaultName = targetBackupVaultName
    }
}

extension BackupSelection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iamRoleArn = "IamRoleArn"
        case listOfTags = "ListOfTags"
        case resources = "Resources"
        case selectionName = "SelectionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let listOfTags = listOfTags {
            var listOfTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listOfTags)
            for listoftags0 in listOfTags {
                try listOfTagsContainer.encode(listoftags0)
            }
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resourcearns0 in resources {
                try resourcesContainer.encode(resourcearns0)
            }
        }
        if let selectionName = selectionName {
            try encodeContainer.encode(selectionName, forKey: .selectionName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selectionName)
        selectionName = selectionNameDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resources)
        var resourcesDecoded0:[String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
        let listOfTagsContainer = try containerValues.decodeIfPresent([Condition?].self, forKey: .listOfTags)
        var listOfTagsDecoded0:[Condition]? = nil
        if let listOfTagsContainer = listOfTagsContainer {
            listOfTagsDecoded0 = [Condition]()
            for structure0 in listOfTagsContainer {
                if let structure0 = structure0 {
                    listOfTagsDecoded0?.append(structure0)
                }
            }
        }
        listOfTags = listOfTagsDecoded0
    }
}

extension BackupSelection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupSelection(iamRoleArn: \(String(describing: iamRoleArn)), listOfTags: \(String(describing: listOfTags)), resources: \(String(describing: resources)), selectionName: \(String(describing: selectionName)))"}
}

/// <p>Used to specify a set of resources to a backup plan.</p>
public struct BackupSelection: Equatable {
    /// <p>The ARN of the IAM role that AWS Backup uses to authenticate when backing up the target
    ///          resource; for example, <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
    public let iamRoleArn: String?
    /// <p>An array of conditions used to specify a set of resources to assign to a backup plan;
    ///          for example, <code>"StringEquals": {"ec2:ResourceTag/Department": "accounting"</code>.
    ///          Assigns the backup plan to every resource with at least one matching tag.</p>
    public let listOfTags: [Condition]?
    /// <p>An array of strings that contain Amazon Resource Names (ARNs)
    ///
    ///          of resources to assign to a backup plan.</p>
    public let resources: [String]?
    /// <p>The display name of a resource selection document.</p>
    public let selectionName: String?

    public init (
        iamRoleArn: String? = nil,
        listOfTags: [Condition]? = nil,
        resources: [String]? = nil,
        selectionName: String? = nil
    )
    {
        self.iamRoleArn = iamRoleArn
        self.listOfTags = listOfTags
        self.resources = resources
        self.selectionName = selectionName
    }
}

extension BackupSelectionsListMember: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case iamRoleArn = "IamRoleArn"
        case selectionId = "SelectionId"
        case selectionName = "SelectionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanId = backupPlanId {
            try encodeContainer.encode(backupPlanId, forKey: .backupPlanId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let selectionId = selectionId {
            try encodeContainer.encode(selectionId, forKey: .selectionId)
        }
        if let selectionName = selectionName {
            try encodeContainer.encode(selectionName, forKey: .selectionName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selectionId)
        selectionId = selectionIdDecoded
        let selectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selectionName)
        selectionName = selectionNameDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

extension BackupSelectionsListMember: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupSelectionsListMember(backupPlanId: \(String(describing: backupPlanId)), creationDate: \(String(describing: creationDate)), creatorRequestId: \(String(describing: creatorRequestId)), iamRoleArn: \(String(describing: iamRoleArn)), selectionId: \(String(describing: selectionId)), selectionName: \(String(describing: selectionName)))"}
}

/// <p>Contains metadata about a <code>BackupSelection</code> object.</p>
public struct BackupSelectionsListMember: Equatable {
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?
    /// <p>The date and time a backup plan is created, in Unix format and Coordinated Universal
    ///          Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds. For
    ///          example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?
    /// <p>A unique string that identifies the request and allows failed requests to be retried
    ///          without the risk of running the operation twice.</p>
    public let creatorRequestId: String?
    /// <p>Specifies the IAM role Amazon Resource Name (ARN) to create the target recovery point;
    ///          for example, <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
    public let iamRoleArn: String?
    /// <p>Uniquely identifies a request to assign a set of resources to a backup plan.</p>
    public let selectionId: String?
    /// <p>The display name of a resource selection document.</p>
    public let selectionName: String?

    public init (
        backupPlanId: String? = nil,
        creationDate: Date? = nil,
        creatorRequestId: String? = nil,
        iamRoleArn: String? = nil,
        selectionId: String? = nil,
        selectionName: String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.iamRoleArn = iamRoleArn
        self.selectionId = selectionId
        self.selectionName = selectionName
    }
}

public enum BackupVaultEvent {
    case backupJobCompleted
    case backupJobExpired
    case backupJobFailed
    case backupJobStarted
    case backupJobSuccessful
    case backupPlanCreated
    case backupPlanModified
    case copyJobFailed
    case copyJobStarted
    case copyJobSuccessful
    case recoveryPointModified
    case restoreJobCompleted
    case restoreJobFailed
    case restoreJobStarted
    case restoreJobSuccessful
    case sdkUnknown(String)
}

extension BackupVaultEvent : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BackupVaultEvent] {
        return [
            .backupJobCompleted,
            .backupJobExpired,
            .backupJobFailed,
            .backupJobStarted,
            .backupJobSuccessful,
            .backupPlanCreated,
            .backupPlanModified,
            .copyJobFailed,
            .copyJobStarted,
            .copyJobSuccessful,
            .recoveryPointModified,
            .restoreJobCompleted,
            .restoreJobFailed,
            .restoreJobStarted,
            .restoreJobSuccessful,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .backupJobCompleted: return "BACKUP_JOB_COMPLETED"
        case .backupJobExpired: return "BACKUP_JOB_EXPIRED"
        case .backupJobFailed: return "BACKUP_JOB_FAILED"
        case .backupJobStarted: return "BACKUP_JOB_STARTED"
        case .backupJobSuccessful: return "BACKUP_JOB_SUCCESSFUL"
        case .backupPlanCreated: return "BACKUP_PLAN_CREATED"
        case .backupPlanModified: return "BACKUP_PLAN_MODIFIED"
        case .copyJobFailed: return "COPY_JOB_FAILED"
        case .copyJobStarted: return "COPY_JOB_STARTED"
        case .copyJobSuccessful: return "COPY_JOB_SUCCESSFUL"
        case .recoveryPointModified: return "RECOVERY_POINT_MODIFIED"
        case .restoreJobCompleted: return "RESTORE_JOB_COMPLETED"
        case .restoreJobFailed: return "RESTORE_JOB_FAILED"
        case .restoreJobStarted: return "RESTORE_JOB_STARTED"
        case .restoreJobSuccessful: return "RESTORE_JOB_SUCCESSFUL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BackupVaultEvent(rawValue: rawValue) ?? BackupVaultEvent.sdkUnknown(rawValue)
    }
}

extension BackupVaultListMember: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case encryptionKeyArn = "EncryptionKeyArn"
        case numberOfRecoveryPoints = "NumberOfRecoveryPoints"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupVaultArn = backupVaultArn {
            try encodeContainer.encode(backupVaultArn, forKey: .backupVaultArn)
        }
        if let backupVaultName = backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let encryptionKeyArn = encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if numberOfRecoveryPoints != 0 {
            try encodeContainer.encode(numberOfRecoveryPoints, forKey: .numberOfRecoveryPoints)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let numberOfRecoveryPointsDecoded = try containerValues.decode(Int.self, forKey: .numberOfRecoveryPoints)
        numberOfRecoveryPoints = numberOfRecoveryPointsDecoded
    }
}

extension BackupVaultListMember: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackupVaultListMember(backupVaultArn: \(String(describing: backupVaultArn)), backupVaultName: \(String(describing: backupVaultName)), creationDate: \(String(describing: creationDate)), creatorRequestId: \(String(describing: creatorRequestId)), encryptionKeyArn: \(String(describing: encryptionKeyArn)), numberOfRecoveryPoints: \(String(describing: numberOfRecoveryPoints)))"}
}

/// <p>Contains metadata about a backup vault.</p>
public struct BackupVaultListMember: Equatable {
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
    public let backupVaultArn: String?
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>The date and time a resource backup is created, in Unix format and Coordinated Universal
    ///          Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds. For
    ///          example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?
    /// <p>A unique string that identifies the request and allows failed requests to be retried
    ///          without the risk of running the operation twice.</p>
    public let creatorRequestId: String?
    /// <p>The server-side encryption key that is used to protect your backups; for example,
    ///             <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
    public let encryptionKeyArn: String?
    /// <p>The number of recovery points that are stored in a backup vault.</p>
    public let numberOfRecoveryPoints: Int

    public init (
        backupVaultArn: String? = nil,
        backupVaultName: String? = nil,
        creationDate: Date? = nil,
        creatorRequestId: String? = nil,
        encryptionKeyArn: String? = nil,
        numberOfRecoveryPoints: Int = 0
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.encryptionKeyArn = encryptionKeyArn
        self.numberOfRecoveryPoints = numberOfRecoveryPoints
    }
}

extension CalculatedLifecycle: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleteAt = "DeleteAt"
        case moveToColdStorageAt = "MoveToColdStorageAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteAt = deleteAt {
            try encodeContainer.encode(deleteAt.timeIntervalSince1970, forKey: .deleteAt)
        }
        if let moveToColdStorageAt = moveToColdStorageAt {
            try encodeContainer.encode(moveToColdStorageAt.timeIntervalSince1970, forKey: .moveToColdStorageAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moveToColdStorageAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .moveToColdStorageAt)
        moveToColdStorageAt = moveToColdStorageAtDecoded
        let deleteAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deleteAt)
        deleteAt = deleteAtDecoded
    }
}

extension CalculatedLifecycle: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CalculatedLifecycle(deleteAt: \(String(describing: deleteAt)), moveToColdStorageAt: \(String(describing: moveToColdStorageAt)))"}
}

/// <p>Contains <code>DeleteAt</code> and <code>MoveToColdStorageAt</code> timestamps, which
///          are used to specify a lifecycle for a recovery point.</p>
///          <p>The lifecycle defines when a protected resource is transitioned to cold storage and when
///          it expires. AWS Backup transitions and expires backups automatically according to the
///          lifecycle that you define.</p>
///          <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
///          days. Therefore, the “expire after days” setting must be 90 days greater than the
///          “transition to cold after days” setting. The “transition to cold after days” setting cannot
///          be changed after a backup has been transitioned to cold.</p>
///          <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
public struct CalculatedLifecycle: Equatable {
    /// <p>A timestamp that specifies when to delete a recovery point.</p>
    public let deleteAt: Date?
    /// <p>A timestamp that specifies when to transition a recovery point to cold storage.</p>
    public let moveToColdStorageAt: Date?

    public init (
        deleteAt: Date? = nil,
        moveToColdStorageAt: Date? = nil
    )
    {
        self.deleteAt = deleteAt
        self.moveToColdStorageAt = moveToColdStorageAt
    }
}

extension Condition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conditionKey = "ConditionKey"
        case conditionType = "ConditionType"
        case conditionValue = "ConditionValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionKey = conditionKey {
            try encodeContainer.encode(conditionKey, forKey: .conditionKey)
        }
        if let conditionType = conditionType {
            try encodeContainer.encode(conditionType.rawValue, forKey: .conditionType)
        }
        if let conditionValue = conditionValue {
            try encodeContainer.encode(conditionValue, forKey: .conditionValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionTypeDecoded = try containerValues.decodeIfPresent(ConditionType.self, forKey: .conditionType)
        conditionType = conditionTypeDecoded
        let conditionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conditionKey)
        conditionKey = conditionKeyDecoded
        let conditionValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conditionValue)
        conditionValue = conditionValueDecoded
    }
}

extension Condition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Condition(conditionKey: \(String(describing: conditionKey)), conditionType: \(String(describing: conditionType)), conditionValue: \(String(describing: conditionValue)))"}
}

/// <p>Contains an array of triplets made up of a condition type (such as
///             <code>StringEquals</code>), a key, and a value. Conditions are used to filter resources
///          in a selection that is assigned to a backup plan.</p>
public struct Condition: Equatable {
    /// <p>The key in a key-value pair. For example, in <code>"ec2:ResourceTag/Department":
    ///             "accounting"</code>, <code>"ec2:ResourceTag/Department"</code> is the key.</p>
    public let conditionKey: String?
    /// <p>An operation, such as <code>StringEquals</code>, that is applied to a key-value pair
    ///          used to filter resources in a selection.</p>
    public let conditionType: ConditionType?
    /// <p>The value in a key-value pair. For example, in <code>"ec2:ResourceTag/Department":
    ///             "accounting"</code>, <code>"accounting"</code> is the value.</p>
    public let conditionValue: String?

    public init (
        conditionKey: String? = nil,
        conditionType: ConditionType? = nil,
        conditionValue: String? = nil
    )
    {
        self.conditionKey = conditionKey
        self.conditionType = conditionType
        self.conditionValue = conditionValue
    }
}

public enum ConditionType {
    case stringequals
    case sdkUnknown(String)
}

extension ConditionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConditionType] {
        return [
            .stringequals,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .stringequals: return "STRINGEQUALS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConditionType(rawValue: rawValue) ?? ConditionType.sdkUnknown(rawValue)
    }
}

extension CopyAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case lifecycle = "Lifecycle"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationBackupVaultArn = destinationBackupVaultArn {
            try encodeContainer.encode(destinationBackupVaultArn, forKey: .destinationBackupVaultArn)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleDecoded = try containerValues.decodeIfPresent(Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let destinationBackupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationBackupVaultArn)
        destinationBackupVaultArn = destinationBackupVaultArnDecoded
    }
}

extension CopyAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyAction(destinationBackupVaultArn: \(String(describing: destinationBackupVaultArn)), lifecycle: \(String(describing: lifecycle)))"}
}

/// <p>The details of the copy operation.</p>
public struct CopyAction: Equatable {
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies the destination backup vault for
    ///          the copied backup. For example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
    public let destinationBackupVaultArn: String?
    /// <p>Contains an array of <code>Transition</code> objects specifying how long in days before
    ///          a recovery point transitions to cold storage or is deleted.</p>
    ///          <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
    ///          days. Therefore, on the console, the “expire after days” setting must be 90 days greater
    ///          than the “transition to cold after days” setting. The “transition to cold after days”
    ///          setting cannot be changed after a backup has been transitioned to cold.</p>
    ///          <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
    public let lifecycle: Lifecycle?

    public init (
        destinationBackupVaultArn: String? = nil,
        lifecycle: Lifecycle? = nil
    )
    {
        self.destinationBackupVaultArn = destinationBackupVaultArn
        self.lifecycle = lifecycle
    }
}

extension CopyJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case backupSizeInBytes = "BackupSizeInBytes"
        case completionDate = "CompletionDate"
        case copyJobId = "CopyJobId"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case destinationRecoveryPointArn = "DestinationRecoveryPointArn"
        case iamRoleArn = "IamRoleArn"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
        case sourceBackupVaultArn = "SourceBackupVaultArn"
        case sourceRecoveryPointArn = "SourceRecoveryPointArn"
        case state = "State"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let backupSizeInBytes = backupSizeInBytes {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let completionDate = completionDate {
            try encodeContainer.encode(completionDate.timeIntervalSince1970, forKey: .completionDate)
        }
        if let copyJobId = copyJobId {
            try encodeContainer.encode(copyJobId, forKey: .copyJobId)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let destinationBackupVaultArn = destinationBackupVaultArn {
            try encodeContainer.encode(destinationBackupVaultArn, forKey: .destinationBackupVaultArn)
        }
        if let destinationRecoveryPointArn = destinationRecoveryPointArn {
            try encodeContainer.encode(destinationRecoveryPointArn, forKey: .destinationRecoveryPointArn)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let sourceBackupVaultArn = sourceBackupVaultArn {
            try encodeContainer.encode(sourceBackupVaultArn, forKey: .sourceBackupVaultArn)
        }
        if let sourceRecoveryPointArn = sourceRecoveryPointArn {
            try encodeContainer.encode(sourceRecoveryPointArn, forKey: .sourceRecoveryPointArn)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let copyJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .copyJobId)
        copyJobId = copyJobIdDecoded
        let sourceBackupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBackupVaultArn)
        sourceBackupVaultArn = sourceBackupVaultArnDecoded
        let sourceRecoveryPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceRecoveryPointArn)
        sourceRecoveryPointArn = sourceRecoveryPointArnDecoded
        let destinationBackupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationBackupVaultArn)
        destinationBackupVaultArn = destinationBackupVaultArnDecoded
        let destinationRecoveryPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationRecoveryPointArn)
        destinationRecoveryPointArn = destinationRecoveryPointArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CopyJobState.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CopyJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyJob(accountId: \(String(describing: accountId)), backupSizeInBytes: \(String(describing: backupSizeInBytes)), completionDate: \(String(describing: completionDate)), copyJobId: \(String(describing: copyJobId)), createdBy: \(String(describing: createdBy)), creationDate: \(String(describing: creationDate)), destinationBackupVaultArn: \(String(describing: destinationBackupVaultArn)), destinationRecoveryPointArn: \(String(describing: destinationRecoveryPointArn)), iamRoleArn: \(String(describing: iamRoleArn)), resourceArn: \(String(describing: resourceArn)), resourceType: \(String(describing: resourceType)), sourceBackupVaultArn: \(String(describing: sourceBackupVaultArn)), sourceRecoveryPointArn: \(String(describing: sourceRecoveryPointArn)), state: \(String(describing: state)), statusMessage: \(String(describing: statusMessage)))"}
}

/// <p>Contains detailed information about a copy job.</p>
public struct CopyJob: Equatable {
    /// <p>The account ID that owns the copy job.</p>
    public let accountId: String?
    /// <p>The size, in bytes, of a copy job.</p>
    public let backupSizeInBytes: Int?
    /// <p>The date and time a copy job is completed, in Unix format and Coordinated Universal Time
    ///          (UTC). The value of <code>CompletionDate</code> is accurate to milliseconds. For example,
    ///          the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.</p>
    public let completionDate: Date?
    /// <p>Uniquely identifies a copy job.</p>
    public let copyJobId: String?
    /// <p>Contains information about the backup plan and rule that AWS Backup used to initiate the
    ///          recovery point backup.</p>
    public let createdBy: RecoveryPointCreator?
    /// <p>The date and time a copy job is created, in Unix format and Coordinated Universal Time
    ///          (UTC). The value of <code>CreationDate</code> is accurate to milliseconds. For example, the
    ///          value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.</p>
    public let creationDate: Date?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a destination copy vault; for
    ///          example, <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
    public let destinationBackupVaultArn: String?
    /// <p>An ARN that uniquely identifies a destination recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let destinationRecoveryPointArn: String?
    /// <p>Specifies the IAM role ARN used to copy the target recovery point; for example,
    ///             <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
    public let iamRoleArn: String?
    /// <p>The AWS resource to be copied; for example, an Amazon Elastic Block Store (Amazon EBS)
    ///          volume or an Amazon Relational Database Service (Amazon RDS) database.</p>
    public let resourceArn: String?
    /// <p>The type of AWS resource to be copied; for example, an Amazon Elastic Block Store
    ///          (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.</p>
    public let resourceType: String?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a source copy vault; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>. </p>
    public let sourceBackupVaultArn: String?
    /// <p>An ARN that uniquely identifies a source recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let sourceRecoveryPointArn: String?
    /// <p>The current state of a copy job.</p>
    public let state: CopyJobState?
    /// <p>A detailed message explaining the status of the job to copy a resource.</p>
    public let statusMessage: String?

    public init (
        accountId: String? = nil,
        backupSizeInBytes: Int? = nil,
        completionDate: Date? = nil,
        copyJobId: String? = nil,
        createdBy: RecoveryPointCreator? = nil,
        creationDate: Date? = nil,
        destinationBackupVaultArn: String? = nil,
        destinationRecoveryPointArn: String? = nil,
        iamRoleArn: String? = nil,
        resourceArn: String? = nil,
        resourceType: String? = nil,
        sourceBackupVaultArn: String? = nil,
        sourceRecoveryPointArn: String? = nil,
        state: CopyJobState? = nil,
        statusMessage: String? = nil
    )
    {
        self.accountId = accountId
        self.backupSizeInBytes = backupSizeInBytes
        self.completionDate = completionDate
        self.copyJobId = copyJobId
        self.createdBy = createdBy
        self.creationDate = creationDate
        self.destinationBackupVaultArn = destinationBackupVaultArn
        self.destinationRecoveryPointArn = destinationRecoveryPointArn
        self.iamRoleArn = iamRoleArn
        self.resourceArn = resourceArn
        self.resourceType = resourceType
        self.sourceBackupVaultArn = sourceBackupVaultArn
        self.sourceRecoveryPointArn = sourceRecoveryPointArn
        self.state = state
        self.statusMessage = statusMessage
    }
}

public enum CopyJobState {
    case completed
    case created
    case failed
    case running
    case sdkUnknown(String)
}

extension CopyJobState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CopyJobState] {
        return [
            .completed,
            .created,
            .failed,
            .running,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .created: return "CREATED"
        case .failed: return "FAILED"
        case .running: return "RUNNING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CopyJobState(rawValue: rawValue) ?? CopyJobState.sdkUnknown(rawValue)
    }
}

public struct CreateBackupPlanInputBodyMiddleware: Middleware {
    public let id: String = "CreateBackupPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackupPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackupPlanInput>
    public typealias MOutput = OperationOutput<CreateBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackupPlanOutputError>
}

extension CreateBackupPlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackupPlanInput(backupPlan: \(String(describing: backupPlan)), backupPlanTags: \(String(describing: backupPlanTags)), creatorRequestId: \(String(describing: creatorRequestId)))"}
}

extension CreateBackupPlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupPlan = "BackupPlan"
        case backupPlanTags = "BackupPlanTags"
        case creatorRequestId = "CreatorRequestId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlan = backupPlan {
            try encodeContainer.encode(backupPlan, forKey: .backupPlan)
        }
        if let backupPlanTags = backupPlanTags {
            var backupPlanTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .backupPlanTags)
            for (dictKey0, tags0) in backupPlanTags {
                try backupPlanTagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
    }
}

public struct CreateBackupPlanInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBackupPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackupPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackupPlanInput>
    public typealias MOutput = OperationOutput<CreateBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackupPlanOutputError>
}

public struct CreateBackupPlanInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBackupPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackupPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackupPlanInput>
    public typealias MOutput = OperationOutput<CreateBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackupPlanOutputError>
}

public struct CreateBackupPlanInput: Equatable {
    /// <p>Specifies the body of a backup plan. Includes a <code>BackupPlanName</code> and one or
    ///          more sets of <code>Rules</code>.</p>
    public let backupPlan: BackupPlanInput?
    /// <p>To help organize your resources, you can assign your own metadata to the resources that
    ///          you create. Each tag is a key-value pair. The specified tags are assigned to all backups
    ///          created with this plan.</p>
    public let backupPlanTags: [String:String]?
    /// <p>Identifies the request and allows failed requests to be retried without the risk of
    ///          running the operation twice. If the request includes a <code>CreatorRequestId</code> that
    ///          matches an existing backup plan, that plan is returned. This parameter is optional.</p>
    public let creatorRequestId: String?

    public init (
        backupPlan: BackupPlanInput? = nil,
        backupPlanTags: [String:String]? = nil,
        creatorRequestId: String? = nil
    )
    {
        self.backupPlan = backupPlan
        self.backupPlanTags = backupPlanTags
        self.creatorRequestId = creatorRequestId
    }
}

struct CreateBackupPlanInputBody: Equatable {
    public let backupPlan: BackupPlanInput?
    public let backupPlanTags: [String:String]?
    public let creatorRequestId: String?
}

extension CreateBackupPlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupPlan = "BackupPlan"
        case backupPlanTags = "BackupPlanTags"
        case creatorRequestId = "CreatorRequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(BackupPlanInput.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
        let backupPlanTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .backupPlanTags)
        var backupPlanTagsDecoded0: [String:String]? = nil
        if let backupPlanTagsContainer = backupPlanTagsContainer {
            backupPlanTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in backupPlanTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    backupPlanTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        backupPlanTags = backupPlanTagsDecoded0
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension CreateBackupPlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackupPlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackupPlanOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackupPlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackupPlanOutputResponse(advancedBackupSettings: \(String(describing: advancedBackupSettings)), backupPlanArn: \(String(describing: backupPlanArn)), backupPlanId: \(String(describing: backupPlanId)), creationDate: \(String(describing: creationDate)), versionId: \(String(describing: versionId)))"}
}

extension CreateBackupPlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBackupPlanOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.advancedBackupSettings = output.advancedBackupSettings
            self.backupPlanArn = output.backupPlanArn
            self.backupPlanId = output.backupPlanId
            self.creationDate = output.creationDate
            self.versionId = output.versionId
        } else {
            self.advancedBackupSettings = nil
            self.backupPlanArn = nil
            self.backupPlanId = nil
            self.creationDate = nil
            self.versionId = nil
        }
    }
}

public struct CreateBackupPlanOutputResponse: Equatable {
    /// <p>A list of <code>BackupOptions</code> settings for a resource type. This option is only
    ///          available for Windows VSS backup jobs.</p>
    public let advancedBackupSettings: [AdvancedBackupSetting]?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50</code>.</p>
    public let backupPlanArn: String?
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?
    /// <p>The date and time that a backup plan is created, in Unix format and Coordinated
    ///          Universal Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds.
    ///          For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?
    /// <p>Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes
    ///          long. They cannot be edited.</p>
    public let versionId: String?

    public init (
        advancedBackupSettings: [AdvancedBackupSetting]? = nil,
        backupPlanArn: String? = nil,
        backupPlanId: String? = nil,
        creationDate: Date? = nil,
        versionId: String? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.versionId = versionId
    }
}

struct CreateBackupPlanOutputResponseBody: Equatable {
    public let backupPlanId: String?
    public let backupPlanArn: String?
    public let creationDate: Date?
    public let versionId: String?
    public let advancedBackupSettings: [AdvancedBackupSetting]?
}

extension CreateBackupPlanOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case versionId = "VersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

public struct CreateBackupSelectionInputBodyMiddleware: Middleware {
    public let id: String = "CreateBackupSelectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackupSelectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackupSelectionInput>
    public typealias MOutput = OperationOutput<CreateBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackupSelectionOutputError>
}

extension CreateBackupSelectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackupSelectionInput(backupPlanId: \(String(describing: backupPlanId)), backupSelection: \(String(describing: backupSelection)), creatorRequestId: \(String(describing: creatorRequestId)))"}
}

extension CreateBackupSelectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupSelection = "BackupSelection"
        case creatorRequestId = "CreatorRequestId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupSelection = backupSelection {
            try encodeContainer.encode(backupSelection, forKey: .backupSelection)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
    }
}

public struct CreateBackupSelectionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBackupSelectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackupSelectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackupSelectionInput>
    public typealias MOutput = OperationOutput<CreateBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackupSelectionOutputError>
}

public struct CreateBackupSelectionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBackupSelectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackupSelectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackupSelectionInput>
    public typealias MOutput = OperationOutput<CreateBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackupSelectionOutputError>
}

public struct CreateBackupSelectionInput: Equatable {
    /// <p>Uniquely identifies the backup plan to be associated with the selection of
    ///          resources.</p>
    public let backupPlanId: String?
    /// <p>Specifies the body of a request to assign a set of resources to a backup plan.</p>
    public let backupSelection: BackupSelection?
    /// <p>A unique string that identifies the request and allows failed requests to be retried
    ///          without the risk of running the operation twice.</p>
    public let creatorRequestId: String?

    public init (
        backupPlanId: String? = nil,
        backupSelection: BackupSelection? = nil,
        creatorRequestId: String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.backupSelection = backupSelection
        self.creatorRequestId = creatorRequestId
    }
}

struct CreateBackupSelectionInputBody: Equatable {
    public let backupSelection: BackupSelection?
    public let creatorRequestId: String?
}

extension CreateBackupSelectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupSelection = "BackupSelection"
        case creatorRequestId = "CreatorRequestId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupSelectionDecoded = try containerValues.decodeIfPresent(BackupSelection.self, forKey: .backupSelection)
        backupSelection = backupSelectionDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension CreateBackupSelectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackupSelectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackupSelectionOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackupSelectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackupSelectionOutputResponse(backupPlanId: \(String(describing: backupPlanId)), creationDate: \(String(describing: creationDate)), selectionId: \(String(describing: selectionId)))"}
}

extension CreateBackupSelectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBackupSelectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupPlanId = output.backupPlanId
            self.creationDate = output.creationDate
            self.selectionId = output.selectionId
        } else {
            self.backupPlanId = nil
            self.creationDate = nil
            self.selectionId = nil
        }
    }
}

public struct CreateBackupSelectionOutputResponse: Equatable {
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?
    /// <p>The date and time a backup selection is created, in Unix format and Coordinated
    ///          Universal Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds.
    ///          For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?
    /// <p>Uniquely identifies the body of a request to assign a set of resources to a backup
    ///          plan.</p>
    public let selectionId: String?

    public init (
        backupPlanId: String? = nil,
        creationDate: Date? = nil,
        selectionId: String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.selectionId = selectionId
    }
}

struct CreateBackupSelectionOutputResponseBody: Equatable {
    public let selectionId: String?
    public let backupPlanId: String?
    public let creationDate: Date?
}

extension CreateBackupSelectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case selectionId = "SelectionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selectionId)
        selectionId = selectionIdDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

public struct CreateBackupVaultInputBodyMiddleware: Middleware {
    public let id: String = "CreateBackupVaultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackupVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackupVaultInput>
    public typealias MOutput = OperationOutput<CreateBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackupVaultOutputError>
}

extension CreateBackupVaultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackupVaultInput(backupVaultName: \(String(describing: backupVaultName)), backupVaultTags: \(String(describing: backupVaultTags)), creatorRequestId: \(String(describing: creatorRequestId)), encryptionKeyArn: \(String(describing: encryptionKeyArn)))"}
}

extension CreateBackupVaultInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupVaultTags = "BackupVaultTags"
        case creatorRequestId = "CreatorRequestId"
        case encryptionKeyArn = "EncryptionKeyArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupVaultTags = backupVaultTags {
            var backupVaultTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .backupVaultTags)
            for (dictKey0, tags0) in backupVaultTags {
                try backupVaultTagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let encryptionKeyArn = encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
    }
}

public struct CreateBackupVaultInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBackupVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackupVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackupVaultInput>
    public typealias MOutput = OperationOutput<CreateBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackupVaultOutputError>
}

public struct CreateBackupVaultInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBackupVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackupVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackupVaultInput>
    public typealias MOutput = OperationOutput<CreateBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackupVaultOutputError>
}

public struct CreateBackupVaultInput: Equatable {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>Metadata that you can assign to help organize the resources that you create. Each tag is
    ///          a key-value pair.</p>
    public let backupVaultTags: [String:String]?
    /// <p>A unique string that identifies the request and allows failed requests to be retried
    ///          without the risk of running the operation twice.</p>
    public let creatorRequestId: String?
    /// <p>The server-side encryption key that is used to protect your backups; for example,
    ///             <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
    public let encryptionKeyArn: String?

    public init (
        backupVaultName: String? = nil,
        backupVaultTags: [String:String]? = nil,
        creatorRequestId: String? = nil,
        encryptionKeyArn: String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.backupVaultTags = backupVaultTags
        self.creatorRequestId = creatorRequestId
        self.encryptionKeyArn = encryptionKeyArn
    }
}

struct CreateBackupVaultInputBody: Equatable {
    public let backupVaultTags: [String:String]?
    public let encryptionKeyArn: String?
    public let creatorRequestId: String?
}

extension CreateBackupVaultInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupVaultTags = "BackupVaultTags"
        case creatorRequestId = "CreatorRequestId"
        case encryptionKeyArn = "EncryptionKeyArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .backupVaultTags)
        var backupVaultTagsDecoded0: [String:String]? = nil
        if let backupVaultTagsContainer = backupVaultTagsContainer {
            backupVaultTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in backupVaultTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    backupVaultTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        backupVaultTags = backupVaultTagsDecoded0
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension CreateBackupVaultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackupVaultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackupVaultOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackupVaultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackupVaultOutputResponse(backupVaultArn: \(String(describing: backupVaultArn)), backupVaultName: \(String(describing: backupVaultName)), creationDate: \(String(describing: creationDate)))"}
}

extension CreateBackupVaultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBackupVaultOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.creationDate = output.creationDate
        } else {
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.creationDate = nil
        }
    }
}

public struct CreateBackupVaultOutputResponse: Equatable {
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
    public let backupVaultArn: String?
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the Region where they are
    ///          created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>The date and time a backup vault is created, in Unix format and Coordinated Universal
    ///          Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds. For
    ///          example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?

    public init (
        backupVaultArn: String? = nil,
        backupVaultName: String? = nil,
        creationDate: Date? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.creationDate = creationDate
    }
}

struct CreateBackupVaultOutputResponseBody: Equatable {
    public let backupVaultName: String?
    public let backupVaultArn: String?
    public let creationDate: Date?
}

extension CreateBackupVaultOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension DeleteBackupPlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackupPlanInput(backupPlanId: \(String(describing: backupPlanId)))"}
}

extension DeleteBackupPlanInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBackupPlanInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBackupPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupPlanInput>
    public typealias MOutput = OperationOutput<DeleteBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupPlanOutputError>
}

public struct DeleteBackupPlanInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBackupPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupPlanInput>
    public typealias MOutput = OperationOutput<DeleteBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupPlanOutputError>
}

public struct DeleteBackupPlanInput: Equatable {
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?

    public init (
        backupPlanId: String? = nil
    )
    {
        self.backupPlanId = backupPlanId
    }
}

struct DeleteBackupPlanInputBody: Equatable {
}

extension DeleteBackupPlanInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBackupPlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupPlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackupPlanOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupPlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackupPlanOutputResponse(backupPlanArn: \(String(describing: backupPlanArn)), backupPlanId: \(String(describing: backupPlanId)), deletionDate: \(String(describing: deletionDate)), versionId: \(String(describing: versionId)))"}
}

extension DeleteBackupPlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteBackupPlanOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupPlanArn = output.backupPlanArn
            self.backupPlanId = output.backupPlanId
            self.deletionDate = output.deletionDate
            self.versionId = output.versionId
        } else {
            self.backupPlanArn = nil
            self.backupPlanId = nil
            self.deletionDate = nil
            self.versionId = nil
        }
    }
}

public struct DeleteBackupPlanOutputResponse: Equatable {
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50</code>.</p>
    public let backupPlanArn: String?
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?
    /// <p>The date and time a backup plan is deleted, in Unix format and Coordinated Universal
    ///          Time (UTC). The value of <code>DeletionDate</code> is accurate to milliseconds. For
    ///          example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let deletionDate: Date?
    /// <p>Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes
    ///          long. Version IDs cannot be edited.</p>
    public let versionId: String?

    public init (
        backupPlanArn: String? = nil,
        backupPlanId: String? = nil,
        deletionDate: Date? = nil,
        versionId: String? = nil
    )
    {
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.deletionDate = deletionDate
        self.versionId = versionId
    }
}

struct DeleteBackupPlanOutputResponseBody: Equatable {
    public let backupPlanId: String?
    public let backupPlanArn: String?
    public let deletionDate: Date?
    public let versionId: String?
}

extension DeleteBackupPlanOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case deletionDate = "DeletionDate"
        case versionId = "VersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let deletionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension DeleteBackupSelectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackupSelectionInput(backupPlanId: \(String(describing: backupPlanId)), selectionId: \(String(describing: selectionId)))"}
}

extension DeleteBackupSelectionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBackupSelectionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBackupSelectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupSelectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupSelectionInput>
    public typealias MOutput = OperationOutput<DeleteBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupSelectionOutputError>
}

public struct DeleteBackupSelectionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBackupSelectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupSelectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupSelectionInput>
    public typealias MOutput = OperationOutput<DeleteBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupSelectionOutputError>
}

public struct DeleteBackupSelectionInput: Equatable {
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?
    /// <p>Uniquely identifies the body of a request to assign a set of resources to a backup
    ///          plan.</p>
    public let selectionId: String?

    public init (
        backupPlanId: String? = nil,
        selectionId: String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.selectionId = selectionId
    }
}

struct DeleteBackupSelectionInputBody: Equatable {
}

extension DeleteBackupSelectionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBackupSelectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupSelectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackupSelectionOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupSelectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackupSelectionOutputResponse()"}
}

extension DeleteBackupSelectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBackupSelectionOutputResponse: Equatable {

    public init() {}
}

struct DeleteBackupSelectionOutputResponseBody: Equatable {
}

extension DeleteBackupSelectionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBackupVaultAccessPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackupVaultAccessPolicyInput(backupVaultName: \(String(describing: backupVaultName)))"}
}

extension DeleteBackupVaultAccessPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBackupVaultAccessPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBackupVaultAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupVaultAccessPolicyInput>
    public typealias MOutput = OperationOutput<DeleteBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupVaultAccessPolicyOutputError>
}

public struct DeleteBackupVaultAccessPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBackupVaultAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupVaultAccessPolicyInput>
    public typealias MOutput = OperationOutput<DeleteBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupVaultAccessPolicyOutputError>
}

public struct DeleteBackupVaultAccessPolicyInput: Equatable {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?

    public init (
        backupVaultName: String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DeleteBackupVaultAccessPolicyInputBody: Equatable {
}

extension DeleteBackupVaultAccessPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBackupVaultAccessPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupVaultAccessPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackupVaultAccessPolicyOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupVaultAccessPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackupVaultAccessPolicyOutputResponse()"}
}

extension DeleteBackupVaultAccessPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBackupVaultAccessPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteBackupVaultAccessPolicyOutputResponseBody: Equatable {
}

extension DeleteBackupVaultAccessPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBackupVaultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackupVaultInput(backupVaultName: \(String(describing: backupVaultName)))"}
}

extension DeleteBackupVaultInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBackupVaultInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBackupVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupVaultInput>
    public typealias MOutput = OperationOutput<DeleteBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupVaultOutputError>
}

public struct DeleteBackupVaultInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBackupVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupVaultInput>
    public typealias MOutput = OperationOutput<DeleteBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupVaultOutputError>
}

public struct DeleteBackupVaultInput: Equatable {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?

    public init (
        backupVaultName: String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DeleteBackupVaultInputBody: Equatable {
}

extension DeleteBackupVaultInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBackupVaultNotificationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackupVaultNotificationsInput(backupVaultName: \(String(describing: backupVaultName)))"}
}

extension DeleteBackupVaultNotificationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBackupVaultNotificationsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBackupVaultNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupVaultNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupVaultNotificationsInput>
    public typealias MOutput = OperationOutput<DeleteBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupVaultNotificationsOutputError>
}

public struct DeleteBackupVaultNotificationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBackupVaultNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupVaultNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupVaultNotificationsInput>
    public typealias MOutput = OperationOutput<DeleteBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupVaultNotificationsOutputError>
}

public struct DeleteBackupVaultNotificationsInput: Equatable {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the Region where they are
    ///          created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?

    public init (
        backupVaultName: String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DeleteBackupVaultNotificationsInputBody: Equatable {
}

extension DeleteBackupVaultNotificationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBackupVaultNotificationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupVaultNotificationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackupVaultNotificationsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupVaultNotificationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackupVaultNotificationsOutputResponse()"}
}

extension DeleteBackupVaultNotificationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBackupVaultNotificationsOutputResponse: Equatable {

    public init() {}
}

struct DeleteBackupVaultNotificationsOutputResponseBody: Equatable {
}

extension DeleteBackupVaultNotificationsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBackupVaultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupVaultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackupVaultOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupVaultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackupVaultOutputResponse()"}
}

extension DeleteBackupVaultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBackupVaultOutputResponse: Equatable {

    public init() {}
}

struct DeleteBackupVaultOutputResponseBody: Equatable {
}

extension DeleteBackupVaultOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRecoveryPointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRecoveryPointInput(backupVaultName: \(String(describing: backupVaultName)), recoveryPointArn: \(String(describing: recoveryPointArn)))"}
}

extension DeleteRecoveryPointInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRecoveryPointInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRecoveryPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRecoveryPointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRecoveryPointInput>
    public typealias MOutput = OperationOutput<DeleteRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRecoveryPointOutputError>
}

public struct DeleteRecoveryPointInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRecoveryPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRecoveryPointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRecoveryPointInput>
    public typealias MOutput = OperationOutput<DeleteRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRecoveryPointOutputError>
}

public struct DeleteRecoveryPointInput: Equatable {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let recoveryPointArn: String?

    public init (
        backupVaultName: String? = nil,
        recoveryPointArn: String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct DeleteRecoveryPointInputBody: Equatable {
}

extension DeleteRecoveryPointInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRecoveryPointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecoveryPointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRecoveryPointOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case invalidResourceStateException(InvalidResourceStateException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecoveryPointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRecoveryPointOutputResponse()"}
}

extension DeleteRecoveryPointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRecoveryPointOutputResponse: Equatable {

    public init() {}
}

struct DeleteRecoveryPointOutputResponseBody: Equatable {
}

extension DeleteRecoveryPointOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DependencyFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DependencyFailureException(code: \(String(describing: code)), context: \(String(describing: context)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension DependencyFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DependencyFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A dependent AWS service or resource returned an error to the AWS Backup service, and the
///          action cannot be completed.</p>
public struct DependencyFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var code: String?
    /// <p></p>
    public var context: String?
    public var message: String?
    /// <p></p>
    public var type: String?

    public init (
        code: String? = nil,
        context: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct DependencyFailureExceptionBody: Equatable {
    public let code: String?
    public let message: String?
    public let type: String?
    public let context: String?
}

extension DependencyFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .context)
        context = contextDecoded
    }
}

extension DescribeBackupJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBackupJobInput(backupJobId: \(String(describing: backupJobId)))"}
}

extension DescribeBackupJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeBackupJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBackupJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBackupJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBackupJobInput>
    public typealias MOutput = OperationOutput<DescribeBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBackupJobOutputError>
}

public struct DescribeBackupJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBackupJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBackupJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBackupJobInput>
    public typealias MOutput = OperationOutput<DescribeBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBackupJobOutputError>
}

public struct DescribeBackupJobInput: Equatable {
    /// <p>Uniquely identifies a request to AWS Backup to back up a resource.</p>
    public let backupJobId: String?

    public init (
        backupJobId: String? = nil
    )
    {
        self.backupJobId = backupJobId
    }
}

struct DescribeBackupJobInputBody: Equatable {
}

extension DescribeBackupJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeBackupJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBackupJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyFailureException" : self = .dependencyFailureException(try DependencyFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBackupJobOutputError: Equatable {
    case dependencyFailureException(DependencyFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBackupJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBackupJobOutputResponse(accountId: \(String(describing: accountId)), backupJobId: \(String(describing: backupJobId)), backupOptions: \(String(describing: backupOptions)), backupSizeInBytes: \(String(describing: backupSizeInBytes)), backupType: \(String(describing: backupType)), backupVaultArn: \(String(describing: backupVaultArn)), backupVaultName: \(String(describing: backupVaultName)), bytesTransferred: \(String(describing: bytesTransferred)), completionDate: \(String(describing: completionDate)), createdBy: \(String(describing: createdBy)), creationDate: \(String(describing: creationDate)), expectedCompletionDate: \(String(describing: expectedCompletionDate)), iamRoleArn: \(String(describing: iamRoleArn)), percentDone: \(String(describing: percentDone)), recoveryPointArn: \(String(describing: recoveryPointArn)), resourceArn: \(String(describing: resourceArn)), resourceType: \(String(describing: resourceType)), startBy: \(String(describing: startBy)), state: \(String(describing: state)), statusMessage: \(String(describing: statusMessage)))"}
}

extension DescribeBackupJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBackupJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountId = output.accountId
            self.backupJobId = output.backupJobId
            self.backupOptions = output.backupOptions
            self.backupSizeInBytes = output.backupSizeInBytes
            self.backupType = output.backupType
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.bytesTransferred = output.bytesTransferred
            self.completionDate = output.completionDate
            self.createdBy = output.createdBy
            self.creationDate = output.creationDate
            self.expectedCompletionDate = output.expectedCompletionDate
            self.iamRoleArn = output.iamRoleArn
            self.percentDone = output.percentDone
            self.recoveryPointArn = output.recoveryPointArn
            self.resourceArn = output.resourceArn
            self.resourceType = output.resourceType
            self.startBy = output.startBy
            self.state = output.state
            self.statusMessage = output.statusMessage
        } else {
            self.accountId = nil
            self.backupJobId = nil
            self.backupOptions = nil
            self.backupSizeInBytes = nil
            self.backupType = nil
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.bytesTransferred = nil
            self.completionDate = nil
            self.createdBy = nil
            self.creationDate = nil
            self.expectedCompletionDate = nil
            self.iamRoleArn = nil
            self.percentDone = nil
            self.recoveryPointArn = nil
            self.resourceArn = nil
            self.resourceType = nil
            self.startBy = nil
            self.state = nil
            self.statusMessage = nil
        }
    }
}

public struct DescribeBackupJobOutputResponse: Equatable {
    /// <p>Returns the account ID that owns the backup job.</p>
    public let accountId: String?
    /// <p>Uniquely identifies a request to AWS Backup to back up a resource.</p>
    public let backupJobId: String?
    /// <p>Represents the options specified as part of backup plan or on-demand backup job.</p>
    public let backupOptions: [String:String]?
    /// <p>The size, in bytes, of a backup.</p>
    public let backupSizeInBytes: Int?
    /// <p>Represents the actual backup type selected for a backup job. For example, if a
    ///          successful WindowsVSS backup was taken, <code>BackupType</code> returns "WindowsVSS". If
    ///             <code>BackupType</code> is empty, then the backup type that was is a regular
    ///          backup.</p>
    public let backupType: String?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
    public let backupVaultArn: String?
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>The size in bytes transferred to a backup vault at the time that the job status was
    ///          queried.</p>
    public let bytesTransferred: Int?
    /// <p>The date and time that a job to create a backup job is completed, in Unix format and
    ///          Coordinated Universal Time (UTC). The value of <code>CompletionDate</code> is accurate to
    ///          milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018
    ///          12:11:30.087 AM.</p>
    public let completionDate: Date?
    /// <p>Contains identifying information about the creation of a backup job, including the
    ///             <code>BackupPlanArn</code>, <code>BackupPlanId</code>, <code>BackupPlanVersion</code>,
    ///          and <code>BackupRuleId</code> of the backup plan that is used to create it.</p>
    public let createdBy: RecoveryPointCreator?
    /// <p>The date and time that a backup job is created, in Unix format and Coordinated Universal
    ///          Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds. For
    ///          example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?
    /// <p>The date and time that a job to back up resources is expected to be completed, in Unix
    ///          format and Coordinated Universal Time (UTC). The value of
    ///             <code>ExpectedCompletionDate</code> is accurate to milliseconds. For example, the value
    ///          1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.</p>
    public let expectedCompletionDate: Date?
    /// <p>Specifies the IAM role ARN used to create the target recovery point; for example,
    ///             <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
    public let iamRoleArn: String?
    /// <p>Contains an estimated percentage that is complete of a job at the time the job status
    ///          was queried.</p>
    public let percentDone: String?
    /// <p>An ARN that uniquely identifies a recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let recoveryPointArn: String?
    /// <p>An ARN that uniquely identifies a saved resource. The format of the ARN depends on the
    ///          resource type.</p>
    public let resourceArn: String?
    /// <p>The type of AWS resource to be backed up; for example, an Amazon Elastic Block Store
    ///          (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.</p>
    public let resourceType: String?
    /// <p>Specifies the time in Unix format and Coordinated Universal Time (UTC) when a backup job
    ///          must be started before it is canceled. The value is calculated by adding the start window
    ///          to the scheduled time. So if the scheduled time were 6:00 PM and the start window is 2
    ///          hours, the <code>StartBy</code> time would be 8:00 PM on the date specified. The value of
    ///             <code>StartBy</code> is accurate to milliseconds. For example, the value 1516925490.087
    ///          represents Friday, January 26, 2018 12:11:30.087 AM.</p>
    public let startBy: Date?
    /// <p>The current state of a resource recovery point.</p>
    public let state: BackupJobState?
    /// <p>A detailed message explaining the status of the job to back up a resource.</p>
    public let statusMessage: String?

    public init (
        accountId: String? = nil,
        backupJobId: String? = nil,
        backupOptions: [String:String]? = nil,
        backupSizeInBytes: Int? = nil,
        backupType: String? = nil,
        backupVaultArn: String? = nil,
        backupVaultName: String? = nil,
        bytesTransferred: Int? = nil,
        completionDate: Date? = nil,
        createdBy: RecoveryPointCreator? = nil,
        creationDate: Date? = nil,
        expectedCompletionDate: Date? = nil,
        iamRoleArn: String? = nil,
        percentDone: String? = nil,
        recoveryPointArn: String? = nil,
        resourceArn: String? = nil,
        resourceType: String? = nil,
        startBy: Date? = nil,
        state: BackupJobState? = nil,
        statusMessage: String? = nil
    )
    {
        self.accountId = accountId
        self.backupJobId = backupJobId
        self.backupOptions = backupOptions
        self.backupSizeInBytes = backupSizeInBytes
        self.backupType = backupType
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.bytesTransferred = bytesTransferred
        self.completionDate = completionDate
        self.createdBy = createdBy
        self.creationDate = creationDate
        self.expectedCompletionDate = expectedCompletionDate
        self.iamRoleArn = iamRoleArn
        self.percentDone = percentDone
        self.recoveryPointArn = recoveryPointArn
        self.resourceArn = resourceArn
        self.resourceType = resourceType
        self.startBy = startBy
        self.state = state
        self.statusMessage = statusMessage
    }
}

struct DescribeBackupJobOutputResponseBody: Equatable {
    public let accountId: String?
    public let backupJobId: String?
    public let backupVaultName: String?
    public let backupVaultArn: String?
    public let recoveryPointArn: String?
    public let resourceArn: String?
    public let creationDate: Date?
    public let completionDate: Date?
    public let state: BackupJobState?
    public let statusMessage: String?
    public let percentDone: String?
    public let backupSizeInBytes: Int?
    public let iamRoleArn: String?
    public let createdBy: RecoveryPointCreator?
    public let resourceType: String?
    public let bytesTransferred: Int?
    public let expectedCompletionDate: Date?
    public let startBy: Date?
    public let backupOptions: [String:String]?
    public let backupType: String?
}

extension DescribeBackupJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case backupJobId = "BackupJobId"
        case backupOptions = "BackupOptions"
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupType = "BackupType"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case bytesTransferred = "BytesTransferred"
        case completionDate = "CompletionDate"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case expectedCompletionDate = "ExpectedCompletionDate"
        case iamRoleArn = "IamRoleArn"
        case percentDone = "PercentDone"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
        case startBy = "StartBy"
        case state = "State"
        case statusMessage = "StatusMessage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let backupJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupJobId)
        backupJobId = backupJobIdDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let stateDecoded = try containerValues.decodeIfPresent(BackupJobState.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let bytesTransferredDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .bytesTransferred)
        bytesTransferred = bytesTransferredDecoded
        let expectedCompletionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expectedCompletionDate)
        expectedCompletionDate = expectedCompletionDateDecoded
        let startByDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startBy)
        startBy = startByDecoded
        let backupOptionsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [String:String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [String:String]()
            for (key0, backupoptionvalue0) in backupOptionsContainer {
                if let backupoptionvalue0 = backupoptionvalue0 {
                    backupOptionsDecoded0?[key0] = backupoptionvalue0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
        let backupTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupType)
        backupType = backupTypeDecoded
    }
}

extension DescribeBackupVaultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBackupVaultInput(backupVaultName: \(String(describing: backupVaultName)))"}
}

extension DescribeBackupVaultInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeBackupVaultInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBackupVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBackupVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBackupVaultInput>
    public typealias MOutput = OperationOutput<DescribeBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBackupVaultOutputError>
}

public struct DescribeBackupVaultInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBackupVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBackupVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBackupVaultInput>
    public typealias MOutput = OperationOutput<DescribeBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBackupVaultOutputError>
}

public struct DescribeBackupVaultInput: Equatable {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?

    public init (
        backupVaultName: String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DescribeBackupVaultInputBody: Equatable {
}

extension DescribeBackupVaultInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeBackupVaultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBackupVaultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBackupVaultOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBackupVaultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBackupVaultOutputResponse(backupVaultArn: \(String(describing: backupVaultArn)), backupVaultName: \(String(describing: backupVaultName)), creationDate: \(String(describing: creationDate)), creatorRequestId: \(String(describing: creatorRequestId)), encryptionKeyArn: \(String(describing: encryptionKeyArn)), numberOfRecoveryPoints: \(String(describing: numberOfRecoveryPoints)))"}
}

extension DescribeBackupVaultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBackupVaultOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.creationDate = output.creationDate
            self.creatorRequestId = output.creatorRequestId
            self.encryptionKeyArn = output.encryptionKeyArn
            self.numberOfRecoveryPoints = output.numberOfRecoveryPoints
        } else {
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.creationDate = nil
            self.creatorRequestId = nil
            self.encryptionKeyArn = nil
            self.numberOfRecoveryPoints = 0
        }
    }
}

public struct DescribeBackupVaultOutputResponse: Equatable {
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
    public let backupVaultArn: String?
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the Region where they are
    ///          created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>The date and time that a backup vault is created, in Unix format and Coordinated
    ///          Universal Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds.
    ///          For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?
    /// <p>A unique string that identifies the request and allows failed requests to be retried
    ///          without the risk of running the operation twice.</p>
    public let creatorRequestId: String?
    /// <p>The server-side encryption key that is used to protect your backups; for example,
    ///             <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
    public let encryptionKeyArn: String?
    /// <p>The number of recovery points that are stored in a backup vault.</p>
    public let numberOfRecoveryPoints: Int

    public init (
        backupVaultArn: String? = nil,
        backupVaultName: String? = nil,
        creationDate: Date? = nil,
        creatorRequestId: String? = nil,
        encryptionKeyArn: String? = nil,
        numberOfRecoveryPoints: Int = 0
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.encryptionKeyArn = encryptionKeyArn
        self.numberOfRecoveryPoints = numberOfRecoveryPoints
    }
}

struct DescribeBackupVaultOutputResponseBody: Equatable {
    public let backupVaultName: String?
    public let backupVaultArn: String?
    public let encryptionKeyArn: String?
    public let creationDate: Date?
    public let creatorRequestId: String?
    public let numberOfRecoveryPoints: Int
}

extension DescribeBackupVaultOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case encryptionKeyArn = "EncryptionKeyArn"
        case numberOfRecoveryPoints = "NumberOfRecoveryPoints"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let numberOfRecoveryPointsDecoded = try containerValues.decode(Int.self, forKey: .numberOfRecoveryPoints)
        numberOfRecoveryPoints = numberOfRecoveryPointsDecoded
    }
}

extension DescribeCopyJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCopyJobInput(copyJobId: \(String(describing: copyJobId)))"}
}

extension DescribeCopyJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeCopyJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCopyJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCopyJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCopyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCopyJobInput>
    public typealias MOutput = OperationOutput<DescribeCopyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCopyJobOutputError>
}

public struct DescribeCopyJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCopyJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCopyJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCopyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCopyJobInput>
    public typealias MOutput = OperationOutput<DescribeCopyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCopyJobOutputError>
}

public struct DescribeCopyJobInput: Equatable {
    /// <p>Uniquely identifies a copy job.</p>
    public let copyJobId: String?

    public init (
        copyJobId: String? = nil
    )
    {
        self.copyJobId = copyJobId
    }
}

struct DescribeCopyJobInputBody: Equatable {
}

extension DescribeCopyJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeCopyJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCopyJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCopyJobOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCopyJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCopyJobOutputResponse(copyJob: \(String(describing: copyJob)))"}
}

extension DescribeCopyJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCopyJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.copyJob = output.copyJob
        } else {
            self.copyJob = nil
        }
    }
}

public struct DescribeCopyJobOutputResponse: Equatable {
    /// <p>Contains detailed information about a copy job.</p>
    public let copyJob: CopyJob?

    public init (
        copyJob: CopyJob? = nil
    )
    {
        self.copyJob = copyJob
    }
}

struct DescribeCopyJobOutputResponseBody: Equatable {
    public let copyJob: CopyJob?
}

extension DescribeCopyJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case copyJob = "CopyJob"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyJobDecoded = try containerValues.decodeIfPresent(CopyJob.self, forKey: .copyJob)
        copyJob = copyJobDecoded
    }
}

extension DescribeGlobalSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGlobalSettingsInput()"}
}

extension DescribeGlobalSettingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeGlobalSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeGlobalSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGlobalSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGlobalSettingsInput>
    public typealias MOutput = OperationOutput<DescribeGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGlobalSettingsOutputError>
}

public struct DescribeGlobalSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeGlobalSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGlobalSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGlobalSettingsInput>
    public typealias MOutput = OperationOutput<DescribeGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGlobalSettingsOutputError>
}

public struct DescribeGlobalSettingsInput: Equatable {

    public init() {}
}

struct DescribeGlobalSettingsInputBody: Equatable {
}

extension DescribeGlobalSettingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeGlobalSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGlobalSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGlobalSettingsOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGlobalSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGlobalSettingsOutputResponse(globalSettings: \(String(describing: globalSettings)), lastUpdateTime: \(String(describing: lastUpdateTime)))"}
}

extension DescribeGlobalSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeGlobalSettingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.globalSettings = output.globalSettings
            self.lastUpdateTime = output.lastUpdateTime
        } else {
            self.globalSettings = nil
            self.lastUpdateTime = nil
        }
    }
}

public struct DescribeGlobalSettingsOutputResponse: Equatable {
    /// <p>A list of resources along with the opt-in preferences for the account.</p>
    public let globalSettings: [String:String]?
    /// <p>The date and time that the global settings were last updated. This update is in Unix
    ///          format and Coordinated Universal Time (UTC). The value of <code>LastUpdateTime</code> is
    ///          accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January
    ///          26, 2018 12:11:30.087 AM.</p>
    public let lastUpdateTime: Date?

    public init (
        globalSettings: [String:String]? = nil,
        lastUpdateTime: Date? = nil
    )
    {
        self.globalSettings = globalSettings
        self.lastUpdateTime = lastUpdateTime
    }
}

struct DescribeGlobalSettingsOutputResponseBody: Equatable {
    public let globalSettings: [String:String]?
    public let lastUpdateTime: Date?
}

extension DescribeGlobalSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case globalSettings = "GlobalSettings"
        case lastUpdateTime = "LastUpdateTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalSettingsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .globalSettings)
        var globalSettingsDecoded0: [String:String]? = nil
        if let globalSettingsContainer = globalSettingsContainer {
            globalSettingsDecoded0 = [String:String]()
            for (key0, globalsettingsvalue0) in globalSettingsContainer {
                if let globalsettingsvalue0 = globalsettingsvalue0 {
                    globalSettingsDecoded0?[key0] = globalsettingsvalue0
                }
            }
        }
        globalSettings = globalSettingsDecoded0
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension DescribeProtectedResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProtectedResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension DescribeProtectedResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeProtectedResourceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProtectedResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProtectedResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProtectedResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProtectedResourceInput>
    public typealias MOutput = OperationOutput<DescribeProtectedResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProtectedResourceOutputError>
}

public struct DescribeProtectedResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProtectedResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProtectedResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProtectedResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProtectedResourceInput>
    public typealias MOutput = OperationOutput<DescribeProtectedResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProtectedResourceOutputError>
}

public struct DescribeProtectedResourceInput: Equatable {
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN
    ///          depends on the resource type.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DescribeProtectedResourceInputBody: Equatable {
}

extension DescribeProtectedResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeProtectedResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProtectedResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProtectedResourceOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProtectedResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProtectedResourceOutputResponse(lastBackupTime: \(String(describing: lastBackupTime)), resourceArn: \(String(describing: resourceArn)), resourceType: \(String(describing: resourceType)))"}
}

extension DescribeProtectedResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProtectedResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lastBackupTime = output.lastBackupTime
            self.resourceArn = output.resourceArn
            self.resourceType = output.resourceType
        } else {
            self.lastBackupTime = nil
            self.resourceArn = nil
            self.resourceType = nil
        }
    }
}

public struct DescribeProtectedResourceOutputResponse: Equatable {
    /// <p>The date and time that a resource was last backed up, in Unix format and Coordinated
    ///          Universal Time (UTC). The value of <code>LastBackupTime</code> is accurate to milliseconds.
    ///          For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let lastBackupTime: Date?
    /// <p>An ARN that uniquely identifies a resource. The format of the ARN depends on the
    ///          resource type.</p>
    public let resourceArn: String?
    /// <p>The type of AWS resource saved as a recovery point; for example, an EBS volume or an
    ///          Amazon RDS database.</p>
    public let resourceType: String?

    public init (
        lastBackupTime: Date? = nil,
        resourceArn: String? = nil,
        resourceType: String? = nil
    )
    {
        self.lastBackupTime = lastBackupTime
        self.resourceArn = resourceArn
        self.resourceType = resourceType
    }
}

struct DescribeProtectedResourceOutputResponseBody: Equatable {
    public let resourceArn: String?
    public let resourceType: String?
    public let lastBackupTime: Date?
}

extension DescribeProtectedResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lastBackupTime = "LastBackupTime"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let lastBackupTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastBackupTime)
        lastBackupTime = lastBackupTimeDecoded
    }
}

extension DescribeRecoveryPointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRecoveryPointInput(backupVaultName: \(String(describing: backupVaultName)), recoveryPointArn: \(String(describing: recoveryPointArn)))"}
}

extension DescribeRecoveryPointInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeRecoveryPointInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRecoveryPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRecoveryPointInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRecoveryPointInput>
    public typealias MOutput = OperationOutput<DescribeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRecoveryPointOutputError>
}

public struct DescribeRecoveryPointInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRecoveryPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRecoveryPointInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRecoveryPointInput>
    public typealias MOutput = OperationOutput<DescribeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRecoveryPointOutputError>
}

public struct DescribeRecoveryPointInput: Equatable {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let recoveryPointArn: String?

    public init (
        backupVaultName: String? = nil,
        recoveryPointArn: String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct DescribeRecoveryPointInputBody: Equatable {
}

extension DescribeRecoveryPointInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeRecoveryPointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRecoveryPointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRecoveryPointOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRecoveryPointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRecoveryPointOutputResponse(backupSizeInBytes: \(String(describing: backupSizeInBytes)), backupVaultArn: \(String(describing: backupVaultArn)), backupVaultName: \(String(describing: backupVaultName)), calculatedLifecycle: \(String(describing: calculatedLifecycle)), completionDate: \(String(describing: completionDate)), createdBy: \(String(describing: createdBy)), creationDate: \(String(describing: creationDate)), encryptionKeyArn: \(String(describing: encryptionKeyArn)), iamRoleArn: \(String(describing: iamRoleArn)), isEncrypted: \(String(describing: isEncrypted)), lastRestoreTime: \(String(describing: lastRestoreTime)), lifecycle: \(String(describing: lifecycle)), recoveryPointArn: \(String(describing: recoveryPointArn)), resourceArn: \(String(describing: resourceArn)), resourceType: \(String(describing: resourceType)), sourceBackupVaultArn: \(String(describing: sourceBackupVaultArn)), status: \(String(describing: status)), storageClass: \(String(describing: storageClass)))"}
}

extension DescribeRecoveryPointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRecoveryPointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupSizeInBytes = output.backupSizeInBytes
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.calculatedLifecycle = output.calculatedLifecycle
            self.completionDate = output.completionDate
            self.createdBy = output.createdBy
            self.creationDate = output.creationDate
            self.encryptionKeyArn = output.encryptionKeyArn
            self.iamRoleArn = output.iamRoleArn
            self.isEncrypted = output.isEncrypted
            self.lastRestoreTime = output.lastRestoreTime
            self.lifecycle = output.lifecycle
            self.recoveryPointArn = output.recoveryPointArn
            self.resourceArn = output.resourceArn
            self.resourceType = output.resourceType
            self.sourceBackupVaultArn = output.sourceBackupVaultArn
            self.status = output.status
            self.storageClass = output.storageClass
        } else {
            self.backupSizeInBytes = nil
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.calculatedLifecycle = nil
            self.completionDate = nil
            self.createdBy = nil
            self.creationDate = nil
            self.encryptionKeyArn = nil
            self.iamRoleArn = nil
            self.isEncrypted = false
            self.lastRestoreTime = nil
            self.lifecycle = nil
            self.recoveryPointArn = nil
            self.resourceArn = nil
            self.resourceType = nil
            self.sourceBackupVaultArn = nil
            self.status = nil
            self.storageClass = nil
        }
    }
}

public struct DescribeRecoveryPointOutputResponse: Equatable {
    /// <p>The size, in bytes, of a backup.</p>
    public let backupSizeInBytes: Int?
    /// <p>An ARN that uniquely identifies a backup vault; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
    public let backupVaultArn: String?
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the Region where they are
    ///          created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>A <code>CalculatedLifecycle</code> object containing <code>DeleteAt</code> and
    ///             <code>MoveToColdStorageAt</code> timestamps.</p>
    public let calculatedLifecycle: CalculatedLifecycle?
    /// <p>The date and time that a job to create a recovery point is completed, in Unix format and
    ///          Coordinated Universal Time (UTC). The value of <code>CompletionDate</code> is accurate to
    ///          milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018
    ///          12:11:30.087 AM.</p>
    public let completionDate: Date?
    /// <p>Contains identifying information about the creation of a recovery point, including the
    ///             <code>BackupPlanArn</code>, <code>BackupPlanId</code>, <code>BackupPlanVersion</code>,
    ///          and <code>BackupRuleId</code> of the backup plan used to create it.</p>
    public let createdBy: RecoveryPointCreator?
    /// <p>The date and time that a recovery point is created, in Unix format and Coordinated
    ///          Universal Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds.
    ///          For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?
    /// <p>The server-side encryption key used to protect your backups; for example,
    ///             <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
    public let encryptionKeyArn: String?
    /// <p>Specifies the IAM role ARN used to create the target recovery point; for example,
    ///             <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
    public let iamRoleArn: String?
    /// <p>A Boolean value that is returned as <code>TRUE</code> if the specified recovery point is
    ///          encrypted, or <code>FALSE</code> if the recovery point is not encrypted.</p>
    public let isEncrypted: Bool
    /// <p>The date and time that a recovery point was last restored, in Unix format and
    ///          Coordinated Universal Time (UTC). The value of <code>LastRestoreTime</code> is accurate to
    ///          milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018
    ///          12:11:30.087 AM.</p>
    public let lastRestoreTime: Date?
    /// <p>The lifecycle defines when a protected resource is transitioned to cold storage and when
    ///          it expires. AWS Backup transitions and expires backups automatically according to the
    ///          lifecycle that you define. </p>
    ///          <p>Backups that are transitioned to cold storage must be stored in cold storage for a
    ///          minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than
    ///          the “transition to cold after days” setting. The “transition to cold after days” setting
    ///          cannot be changed after a backup has been transitioned to cold. </p>
    ///          <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
    public let lifecycle: Lifecycle?
    /// <p>An ARN that uniquely identifies a recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let recoveryPointArn: String?
    /// <p>An ARN that uniquely identifies a saved resource. The format of the ARN depends on the
    ///          resource type.</p>
    public let resourceArn: String?
    /// <p>The type of AWS resource to save as a recovery point; for example, an Amazon Elastic
    ///          Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS)
    ///          database.</p>
    public let resourceType: String?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies the source vault where the
    ///          resource was originally backed up in; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:vault:BackupVault</code>. If the recovery is
    ///          restored to the same AWS account or Region, this value will be <code>null</code>.</p>
    public let sourceBackupVaultArn: String?
    /// <p>A status code specifying the state of the recovery point.</p>
    ///          <note>
    ///             <p>A partial status indicates that the recovery point was not successfully re-created
    ///             and must be retried.</p>
    ///          </note>
    public let status: RecoveryPointStatus?
    /// <p>Specifies the storage class of the recovery point. Valid values are <code>WARM</code> or
    ///             <code>COLD</code>.</p>
    public let storageClass: StorageClass?

    public init (
        backupSizeInBytes: Int? = nil,
        backupVaultArn: String? = nil,
        backupVaultName: String? = nil,
        calculatedLifecycle: CalculatedLifecycle? = nil,
        completionDate: Date? = nil,
        createdBy: RecoveryPointCreator? = nil,
        creationDate: Date? = nil,
        encryptionKeyArn: String? = nil,
        iamRoleArn: String? = nil,
        isEncrypted: Bool = false,
        lastRestoreTime: Date? = nil,
        lifecycle: Lifecycle? = nil,
        recoveryPointArn: String? = nil,
        resourceArn: String? = nil,
        resourceType: String? = nil,
        sourceBackupVaultArn: String? = nil,
        status: RecoveryPointStatus? = nil,
        storageClass: StorageClass? = nil
    )
    {
        self.backupSizeInBytes = backupSizeInBytes
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.calculatedLifecycle = calculatedLifecycle
        self.completionDate = completionDate
        self.createdBy = createdBy
        self.creationDate = creationDate
        self.encryptionKeyArn = encryptionKeyArn
        self.iamRoleArn = iamRoleArn
        self.isEncrypted = isEncrypted
        self.lastRestoreTime = lastRestoreTime
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
        self.resourceArn = resourceArn
        self.resourceType = resourceType
        self.sourceBackupVaultArn = sourceBackupVaultArn
        self.status = status
        self.storageClass = storageClass
    }
}

struct DescribeRecoveryPointOutputResponseBody: Equatable {
    public let recoveryPointArn: String?
    public let backupVaultName: String?
    public let backupVaultArn: String?
    public let sourceBackupVaultArn: String?
    public let resourceArn: String?
    public let resourceType: String?
    public let createdBy: RecoveryPointCreator?
    public let iamRoleArn: String?
    public let status: RecoveryPointStatus?
    public let creationDate: Date?
    public let completionDate: Date?
    public let backupSizeInBytes: Int?
    public let calculatedLifecycle: CalculatedLifecycle?
    public let lifecycle: Lifecycle?
    public let encryptionKeyArn: String?
    public let isEncrypted: Bool
    public let storageClass: StorageClass?
    public let lastRestoreTime: Date?
}

extension DescribeRecoveryPointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case calculatedLifecycle = "CalculatedLifecycle"
        case completionDate = "CompletionDate"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case encryptionKeyArn = "EncryptionKeyArn"
        case iamRoleArn = "IamRoleArn"
        case isEncrypted = "IsEncrypted"
        case lastRestoreTime = "LastRestoreTime"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
        case sourceBackupVaultArn = "SourceBackupVaultArn"
        case status = "Status"
        case storageClass = "StorageClass"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let sourceBackupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBackupVaultArn)
        sourceBackupVaultArn = sourceBackupVaultArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RecoveryPointStatus.self, forKey: .status)
        status = statusDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let calculatedLifecycleDecoded = try containerValues.decodeIfPresent(CalculatedLifecycle.self, forKey: .calculatedLifecycle)
        calculatedLifecycle = calculatedLifecycleDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let isEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .isEncrypted)
        isEncrypted = isEncryptedDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let lastRestoreTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastRestoreTime)
        lastRestoreTime = lastRestoreTimeDecoded
    }
}

extension DescribeRegionSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRegionSettingsInput()"}
}

extension DescribeRegionSettingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeRegionSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRegionSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRegionSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRegionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRegionSettingsInput>
    public typealias MOutput = OperationOutput<DescribeRegionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRegionSettingsOutputError>
}

public struct DescribeRegionSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRegionSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRegionSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRegionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRegionSettingsInput>
    public typealias MOutput = OperationOutput<DescribeRegionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRegionSettingsOutputError>
}

public struct DescribeRegionSettingsInput: Equatable {

    public init() {}
}

struct DescribeRegionSettingsInputBody: Equatable {
}

extension DescribeRegionSettingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeRegionSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRegionSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRegionSettingsOutputError: Equatable {
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRegionSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRegionSettingsOutputResponse(resourceTypeOptInPreference: \(String(describing: resourceTypeOptInPreference)))"}
}

extension DescribeRegionSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRegionSettingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceTypeOptInPreference = output.resourceTypeOptInPreference
        } else {
            self.resourceTypeOptInPreference = nil
        }
    }
}

public struct DescribeRegionSettingsOutputResponse: Equatable {
    /// <p>Returns a list of all services along with the opt-in preferences in the Region.</p>
    public let resourceTypeOptInPreference: [String:Bool]?

    public init (
        resourceTypeOptInPreference: [String:Bool]? = nil
    )
    {
        self.resourceTypeOptInPreference = resourceTypeOptInPreference
    }
}

struct DescribeRegionSettingsOutputResponseBody: Equatable {
    public let resourceTypeOptInPreference: [String:Bool]?
}

extension DescribeRegionSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceTypeOptInPreference = "ResourceTypeOptInPreference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeOptInPreferenceContainer = try containerValues.decodeIfPresent([String: Bool?].self, forKey: .resourceTypeOptInPreference)
        var resourceTypeOptInPreferenceDecoded0: [String:Bool]? = nil
        if let resourceTypeOptInPreferenceContainer = resourceTypeOptInPreferenceContainer {
            resourceTypeOptInPreferenceDecoded0 = [String:Bool]()
            for (key0, isenabled0) in resourceTypeOptInPreferenceContainer {
                if let isenabled0 = isenabled0 {
                    resourceTypeOptInPreferenceDecoded0?[key0] = isenabled0
                }
            }
        }
        resourceTypeOptInPreference = resourceTypeOptInPreferenceDecoded0
    }
}

extension DescribeRestoreJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRestoreJobInput(restoreJobId: \(String(describing: restoreJobId)))"}
}

extension DescribeRestoreJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeRestoreJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRestoreJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRestoreJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRestoreJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRestoreJobInput>
    public typealias MOutput = OperationOutput<DescribeRestoreJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRestoreJobOutputError>
}

public struct DescribeRestoreJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRestoreJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRestoreJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRestoreJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRestoreJobInput>
    public typealias MOutput = OperationOutput<DescribeRestoreJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRestoreJobOutputError>
}

public struct DescribeRestoreJobInput: Equatable {
    /// <p>Uniquely identifies the job that restores a recovery point.</p>
    public let restoreJobId: String?

    public init (
        restoreJobId: String? = nil
    )
    {
        self.restoreJobId = restoreJobId
    }
}

struct DescribeRestoreJobInputBody: Equatable {
}

extension DescribeRestoreJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeRestoreJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRestoreJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyFailureException" : self = .dependencyFailureException(try DependencyFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRestoreJobOutputError: Equatable {
    case dependencyFailureException(DependencyFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRestoreJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRestoreJobOutputResponse(accountId: \(String(describing: accountId)), backupSizeInBytes: \(String(describing: backupSizeInBytes)), completionDate: \(String(describing: completionDate)), createdResourceArn: \(String(describing: createdResourceArn)), creationDate: \(String(describing: creationDate)), expectedCompletionTimeMinutes: \(String(describing: expectedCompletionTimeMinutes)), iamRoleArn: \(String(describing: iamRoleArn)), percentDone: \(String(describing: percentDone)), recoveryPointArn: \(String(describing: recoveryPointArn)), resourceType: \(String(describing: resourceType)), restoreJobId: \(String(describing: restoreJobId)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

extension DescribeRestoreJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRestoreJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountId = output.accountId
            self.backupSizeInBytes = output.backupSizeInBytes
            self.completionDate = output.completionDate
            self.createdResourceArn = output.createdResourceArn
            self.creationDate = output.creationDate
            self.expectedCompletionTimeMinutes = output.expectedCompletionTimeMinutes
            self.iamRoleArn = output.iamRoleArn
            self.percentDone = output.percentDone
            self.recoveryPointArn = output.recoveryPointArn
            self.resourceType = output.resourceType
            self.restoreJobId = output.restoreJobId
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.accountId = nil
            self.backupSizeInBytes = nil
            self.completionDate = nil
            self.createdResourceArn = nil
            self.creationDate = nil
            self.expectedCompletionTimeMinutes = nil
            self.iamRoleArn = nil
            self.percentDone = nil
            self.recoveryPointArn = nil
            self.resourceType = nil
            self.restoreJobId = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct DescribeRestoreJobOutputResponse: Equatable {
    /// <p>Returns the account ID that owns the restore job.</p>
    public let accountId: String?
    /// <p>The size, in bytes, of the restored resource.</p>
    public let backupSizeInBytes: Int?
    /// <p>The date and time that a job to restore a recovery point is completed, in Unix format
    ///          and Coordinated Universal Time (UTC). The value of <code>CompletionDate</code> is accurate
    ///          to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018
    ///          12:11:30.087 AM.</p>
    public let completionDate: Date?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a resource whose recovery point
    ///          is being restored. The format of the ARN depends on the resource type of the backed-up
    ///          resource.</p>
    public let createdResourceArn: String?
    /// <p>The date and time that a restore job is created, in Unix format and Coordinated
    ///          Universal Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds.
    ///          For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?
    /// <p>The amount of time in minutes that a job restoring a recovery point is expected to
    ///          take.</p>
    public let expectedCompletionTimeMinutes: Int?
    /// <p>Specifies the IAM role ARN used to create the target recovery point; for example,
    ///             <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
    public let iamRoleArn: String?
    /// <p>Contains an estimated percentage that is complete of a job at the time the job status
    ///          was queried.</p>
    public let percentDone: String?
    /// <p>An ARN that uniquely identifies a recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let recoveryPointArn: String?
    /// <p>Returns metadata associated with a restore job listed by resource type.</p>
    public let resourceType: String?
    /// <p>Uniquely identifies the job that restores a recovery point.</p>
    public let restoreJobId: String?
    /// <p>Status code specifying the state of the job that is initiated by AWS Backup to restore a
    ///          recovery point.</p>
    public let status: RestoreJobStatus?
    /// <p>A message showing the status of a job to restore a recovery point.</p>
    public let statusMessage: String?

    public init (
        accountId: String? = nil,
        backupSizeInBytes: Int? = nil,
        completionDate: Date? = nil,
        createdResourceArn: String? = nil,
        creationDate: Date? = nil,
        expectedCompletionTimeMinutes: Int? = nil,
        iamRoleArn: String? = nil,
        percentDone: String? = nil,
        recoveryPointArn: String? = nil,
        resourceType: String? = nil,
        restoreJobId: String? = nil,
        status: RestoreJobStatus? = nil,
        statusMessage: String? = nil
    )
    {
        self.accountId = accountId
        self.backupSizeInBytes = backupSizeInBytes
        self.completionDate = completionDate
        self.createdResourceArn = createdResourceArn
        self.creationDate = creationDate
        self.expectedCompletionTimeMinutes = expectedCompletionTimeMinutes
        self.iamRoleArn = iamRoleArn
        self.percentDone = percentDone
        self.recoveryPointArn = recoveryPointArn
        self.resourceType = resourceType
        self.restoreJobId = restoreJobId
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct DescribeRestoreJobOutputResponseBody: Equatable {
    public let accountId: String?
    public let restoreJobId: String?
    public let recoveryPointArn: String?
    public let creationDate: Date?
    public let completionDate: Date?
    public let status: RestoreJobStatus?
    public let statusMessage: String?
    public let percentDone: String?
    public let backupSizeInBytes: Int?
    public let iamRoleArn: String?
    public let expectedCompletionTimeMinutes: Int?
    public let createdResourceArn: String?
    public let resourceType: String?
}

extension DescribeRestoreJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case backupSizeInBytes = "BackupSizeInBytes"
        case completionDate = "CompletionDate"
        case createdResourceArn = "CreatedResourceArn"
        case creationDate = "CreationDate"
        case expectedCompletionTimeMinutes = "ExpectedCompletionTimeMinutes"
        case iamRoleArn = "IamRoleArn"
        case percentDone = "PercentDone"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceType = "ResourceType"
        case restoreJobId = "RestoreJobId"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let restoreJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .restoreJobId)
        restoreJobId = restoreJobIdDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RestoreJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let expectedCompletionTimeMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expectedCompletionTimeMinutes)
        expectedCompletionTimeMinutes = expectedCompletionTimeMinutesDecoded
        let createdResourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdResourceArn)
        createdResourceArn = createdResourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension DisassociateRecoveryPointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateRecoveryPointInput(backupVaultName: \(String(describing: backupVaultName)), recoveryPointArn: \(String(describing: recoveryPointArn)))"}
}

extension DisassociateRecoveryPointInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateRecoveryPointInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateRecoveryPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateRecoveryPointInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateRecoveryPointInput>
    public typealias MOutput = OperationOutput<DisassociateRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateRecoveryPointOutputError>
}

public struct DisassociateRecoveryPointInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateRecoveryPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateRecoveryPointInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateRecoveryPointInput>
    public typealias MOutput = OperationOutput<DisassociateRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateRecoveryPointOutputError>
}

public struct DisassociateRecoveryPointInput: Equatable {
    /// <p>The unique name of an AWS Backup vault. Required.</p>
    public let backupVaultName: String?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies an AWS Backup recovery point.
    ///          Required.</p>
    public let recoveryPointArn: String?

    public init (
        backupVaultName: String? = nil,
        recoveryPointArn: String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct DisassociateRecoveryPointInputBody: Equatable {
}

extension DisassociateRecoveryPointInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateRecoveryPointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateRecoveryPointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateRecoveryPointOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case invalidResourceStateException(InvalidResourceStateException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateRecoveryPointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateRecoveryPointOutputResponse()"}
}

extension DisassociateRecoveryPointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateRecoveryPointOutputResponse: Equatable {

    public init() {}
}

struct DisassociateRecoveryPointOutputResponseBody: Equatable {
}

extension DisassociateRecoveryPointOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ExportBackupPlanTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportBackupPlanTemplateInput(backupPlanId: \(String(describing: backupPlanId)))"}
}

extension ExportBackupPlanTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ExportBackupPlanTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "ExportBackupPlanTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportBackupPlanTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportBackupPlanTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportBackupPlanTemplateInput>
    public typealias MOutput = OperationOutput<ExportBackupPlanTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportBackupPlanTemplateOutputError>
}

public struct ExportBackupPlanTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "ExportBackupPlanTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportBackupPlanTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportBackupPlanTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportBackupPlanTemplateInput>
    public typealias MOutput = OperationOutput<ExportBackupPlanTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportBackupPlanTemplateOutputError>
}

public struct ExportBackupPlanTemplateInput: Equatable {
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?

    public init (
        backupPlanId: String? = nil
    )
    {
        self.backupPlanId = backupPlanId
    }
}

struct ExportBackupPlanTemplateInputBody: Equatable {
}

extension ExportBackupPlanTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ExportBackupPlanTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportBackupPlanTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportBackupPlanTemplateOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportBackupPlanTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportBackupPlanTemplateOutputResponse(backupPlanTemplateJson: \(String(describing: backupPlanTemplateJson)))"}
}

extension ExportBackupPlanTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExportBackupPlanTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupPlanTemplateJson = output.backupPlanTemplateJson
        } else {
            self.backupPlanTemplateJson = nil
        }
    }
}

public struct ExportBackupPlanTemplateOutputResponse: Equatable {
    /// <p>The body of a backup plan template in JSON format.</p>
    ///          <note>
    ///             <p>This is a signed JSON document that cannot be modified before being passed to
    ///                <code>GetBackupPlanFromJSON.</code>
    ///             </p>
    ///          </note>
    public let backupPlanTemplateJson: String?

    public init (
        backupPlanTemplateJson: String? = nil
    )
    {
        self.backupPlanTemplateJson = backupPlanTemplateJson
    }
}

struct ExportBackupPlanTemplateOutputResponseBody: Equatable {
    public let backupPlanTemplateJson: String?
}

extension ExportBackupPlanTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupPlanTemplateJson = "BackupPlanTemplateJson"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanTemplateJsonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanTemplateJson)
        backupPlanTemplateJson = backupPlanTemplateJsonDecoded
    }
}

public struct GetBackupPlanFromJSONInputBodyMiddleware: Middleware {
    public let id: String = "GetBackupPlanFromJSONInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackupPlanFromJSONInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackupPlanFromJSONOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackupPlanFromJSONInput>
    public typealias MOutput = OperationOutput<GetBackupPlanFromJSONOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackupPlanFromJSONOutputError>
}

extension GetBackupPlanFromJSONInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackupPlanFromJSONInput(backupPlanTemplateJson: \(String(describing: backupPlanTemplateJson)))"}
}

extension GetBackupPlanFromJSONInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupPlanTemplateJson = "BackupPlanTemplateJson"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanTemplateJson = backupPlanTemplateJson {
            try encodeContainer.encode(backupPlanTemplateJson, forKey: .backupPlanTemplateJson)
        }
    }
}

public struct GetBackupPlanFromJSONInputHeadersMiddleware: Middleware {
    public let id: String = "GetBackupPlanFromJSONInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackupPlanFromJSONInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackupPlanFromJSONOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackupPlanFromJSONInput>
    public typealias MOutput = OperationOutput<GetBackupPlanFromJSONOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackupPlanFromJSONOutputError>
}

public struct GetBackupPlanFromJSONInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBackupPlanFromJSONInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackupPlanFromJSONInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackupPlanFromJSONOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackupPlanFromJSONInput>
    public typealias MOutput = OperationOutput<GetBackupPlanFromJSONOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackupPlanFromJSONOutputError>
}

public struct GetBackupPlanFromJSONInput: Equatable {
    /// <p>A customer-supplied backup plan document in JSON format.</p>
    public let backupPlanTemplateJson: String?

    public init (
        backupPlanTemplateJson: String? = nil
    )
    {
        self.backupPlanTemplateJson = backupPlanTemplateJson
    }
}

struct GetBackupPlanFromJSONInputBody: Equatable {
    public let backupPlanTemplateJson: String?
}

extension GetBackupPlanFromJSONInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupPlanTemplateJson = "BackupPlanTemplateJson"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanTemplateJsonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanTemplateJson)
        backupPlanTemplateJson = backupPlanTemplateJsonDecoded
    }
}

extension GetBackupPlanFromJSONOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupPlanFromJSONOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackupPlanFromJSONOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupPlanFromJSONOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackupPlanFromJSONOutputResponse(backupPlan: \(String(describing: backupPlan)))"}
}

extension GetBackupPlanFromJSONOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBackupPlanFromJSONOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupPlan = output.backupPlan
        } else {
            self.backupPlan = nil
        }
    }
}

public struct GetBackupPlanFromJSONOutputResponse: Equatable {
    /// <p>Specifies the body of a backup plan. Includes a <code>BackupPlanName</code> and one or
    ///          more sets of <code>Rules</code>.</p>
    public let backupPlan: BackupPlan?

    public init (
        backupPlan: BackupPlan? = nil
    )
    {
        self.backupPlan = backupPlan
    }
}

struct GetBackupPlanFromJSONOutputResponseBody: Equatable {
    public let backupPlan: BackupPlan?
}

extension GetBackupPlanFromJSONOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupPlan = "BackupPlan"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(BackupPlan.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
    }
}

extension GetBackupPlanFromTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackupPlanFromTemplateInput(backupPlanTemplateId: \(String(describing: backupPlanTemplateId)))"}
}

extension GetBackupPlanFromTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBackupPlanFromTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetBackupPlanFromTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackupPlanFromTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackupPlanFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackupPlanFromTemplateInput>
    public typealias MOutput = OperationOutput<GetBackupPlanFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackupPlanFromTemplateOutputError>
}

public struct GetBackupPlanFromTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBackupPlanFromTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackupPlanFromTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackupPlanFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackupPlanFromTemplateInput>
    public typealias MOutput = OperationOutput<GetBackupPlanFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackupPlanFromTemplateOutputError>
}

public struct GetBackupPlanFromTemplateInput: Equatable {
    /// <p>Uniquely identifies a stored backup plan template.</p>
    public let backupPlanTemplateId: String?

    public init (
        backupPlanTemplateId: String? = nil
    )
    {
        self.backupPlanTemplateId = backupPlanTemplateId
    }
}

struct GetBackupPlanFromTemplateInputBody: Equatable {
}

extension GetBackupPlanFromTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBackupPlanFromTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupPlanFromTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackupPlanFromTemplateOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupPlanFromTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackupPlanFromTemplateOutputResponse(backupPlanDocument: \(String(describing: backupPlanDocument)))"}
}

extension GetBackupPlanFromTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBackupPlanFromTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupPlanDocument = output.backupPlanDocument
        } else {
            self.backupPlanDocument = nil
        }
    }
}

public struct GetBackupPlanFromTemplateOutputResponse: Equatable {
    /// <p>Returns the body of a backup plan based on the target template, including the name,
    ///          rules, and backup vault of the plan.</p>
    public let backupPlanDocument: BackupPlan?

    public init (
        backupPlanDocument: BackupPlan? = nil
    )
    {
        self.backupPlanDocument = backupPlanDocument
    }
}

struct GetBackupPlanFromTemplateOutputResponseBody: Equatable {
    public let backupPlanDocument: BackupPlan?
}

extension GetBackupPlanFromTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupPlanDocument = "BackupPlanDocument"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDocumentDecoded = try containerValues.decodeIfPresent(BackupPlan.self, forKey: .backupPlanDocument)
        backupPlanDocument = backupPlanDocumentDecoded
    }
}

extension GetBackupPlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackupPlanInput(backupPlanId: \(String(describing: backupPlanId)), versionId: \(String(describing: versionId)))"}
}

extension GetBackupPlanInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBackupPlanInputHeadersMiddleware: Middleware {
    public let id: String = "GetBackupPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackupPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackupPlanInput>
    public typealias MOutput = OperationOutput<GetBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackupPlanOutputError>
}

public struct GetBackupPlanInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBackupPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackupPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackupPlanInput>
    public typealias MOutput = OperationOutput<GetBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackupPlanOutputError>
}

public struct GetBackupPlanInput: Equatable {
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?
    /// <p>Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes
    ///          long. Version IDs cannot be edited.</p>
    public let versionId: String?

    public init (
        backupPlanId: String? = nil,
        versionId: String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.versionId = versionId
    }
}

struct GetBackupPlanInputBody: Equatable {
}

extension GetBackupPlanInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBackupPlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupPlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackupPlanOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupPlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackupPlanOutputResponse(advancedBackupSettings: \(String(describing: advancedBackupSettings)), backupPlan: \(String(describing: backupPlan)), backupPlanArn: \(String(describing: backupPlanArn)), backupPlanId: \(String(describing: backupPlanId)), creationDate: \(String(describing: creationDate)), creatorRequestId: \(String(describing: creatorRequestId)), deletionDate: \(String(describing: deletionDate)), lastExecutionDate: \(String(describing: lastExecutionDate)), versionId: \(String(describing: versionId)))"}
}

extension GetBackupPlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBackupPlanOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.advancedBackupSettings = output.advancedBackupSettings
            self.backupPlan = output.backupPlan
            self.backupPlanArn = output.backupPlanArn
            self.backupPlanId = output.backupPlanId
            self.creationDate = output.creationDate
            self.creatorRequestId = output.creatorRequestId
            self.deletionDate = output.deletionDate
            self.lastExecutionDate = output.lastExecutionDate
            self.versionId = output.versionId
        } else {
            self.advancedBackupSettings = nil
            self.backupPlan = nil
            self.backupPlanArn = nil
            self.backupPlanId = nil
            self.creationDate = nil
            self.creatorRequestId = nil
            self.deletionDate = nil
            self.lastExecutionDate = nil
            self.versionId = nil
        }
    }
}

public struct GetBackupPlanOutputResponse: Equatable {
    /// <p>Contains a list of <code>BackupOptions</code> for each resource type. The list is
    ///          populated only if the advanced option is set for the backup plan.</p>
    public let advancedBackupSettings: [AdvancedBackupSetting]?
    /// <p>Specifies the body of a backup plan. Includes a <code>BackupPlanName</code> and one or
    ///          more sets of <code>Rules</code>.</p>
    public let backupPlan: BackupPlan?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50</code>.</p>
    public let backupPlanArn: String?
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?
    /// <p>The date and time that a backup plan is created, in Unix format and Coordinated
    ///          Universal Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds.
    ///          For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?
    /// <p>A unique string that identifies the request and allows failed requests to be retried
    ///          without the risk of running the operation twice.</p>
    public let creatorRequestId: String?
    /// <p>The date and time that a backup plan is deleted, in Unix format and Coordinated
    ///          Universal Time (UTC). The value of <code>DeletionDate</code> is accurate to milliseconds.
    ///          For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let deletionDate: Date?
    /// <p>The last time a job to back up resources was run with this backup plan. A date and time,
    ///          in Unix format and Coordinated Universal Time (UTC). The value of
    ///             <code>LastExecutionDate</code> is accurate to milliseconds. For example, the value
    ///          1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.</p>
    public let lastExecutionDate: Date?
    /// <p>Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes
    ///          long. Version IDs cannot be edited.</p>
    public let versionId: String?

    public init (
        advancedBackupSettings: [AdvancedBackupSetting]? = nil,
        backupPlan: BackupPlan? = nil,
        backupPlanArn: String? = nil,
        backupPlanId: String? = nil,
        creationDate: Date? = nil,
        creatorRequestId: String? = nil,
        deletionDate: Date? = nil,
        lastExecutionDate: Date? = nil,
        versionId: String? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlan = backupPlan
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.deletionDate = deletionDate
        self.lastExecutionDate = lastExecutionDate
        self.versionId = versionId
    }
}

struct GetBackupPlanOutputResponseBody: Equatable {
    public let backupPlan: BackupPlan?
    public let backupPlanId: String?
    public let backupPlanArn: String?
    public let versionId: String?
    public let creatorRequestId: String?
    public let creationDate: Date?
    public let deletionDate: Date?
    public let lastExecutionDate: Date?
    public let advancedBackupSettings: [AdvancedBackupSetting]?
}

extension GetBackupPlanOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlan = "BackupPlan"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case deletionDate = "DeletionDate"
        case lastExecutionDate = "LastExecutionDate"
        case versionId = "VersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(BackupPlan.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let deletionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
        let lastExecutionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension GetBackupSelectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackupSelectionInput(backupPlanId: \(String(describing: backupPlanId)), selectionId: \(String(describing: selectionId)))"}
}

extension GetBackupSelectionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBackupSelectionInputHeadersMiddleware: Middleware {
    public let id: String = "GetBackupSelectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackupSelectionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackupSelectionInput>
    public typealias MOutput = OperationOutput<GetBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackupSelectionOutputError>
}

public struct GetBackupSelectionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBackupSelectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackupSelectionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackupSelectionInput>
    public typealias MOutput = OperationOutput<GetBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackupSelectionOutputError>
}

public struct GetBackupSelectionInput: Equatable {
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?
    /// <p>Uniquely identifies the body of a request to assign a set of resources to a backup
    ///          plan.</p>
    public let selectionId: String?

    public init (
        backupPlanId: String? = nil,
        selectionId: String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.selectionId = selectionId
    }
}

struct GetBackupSelectionInputBody: Equatable {
}

extension GetBackupSelectionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBackupSelectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupSelectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackupSelectionOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupSelectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackupSelectionOutputResponse(backupPlanId: \(String(describing: backupPlanId)), backupSelection: \(String(describing: backupSelection)), creationDate: \(String(describing: creationDate)), creatorRequestId: \(String(describing: creatorRequestId)), selectionId: \(String(describing: selectionId)))"}
}

extension GetBackupSelectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBackupSelectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupPlanId = output.backupPlanId
            self.backupSelection = output.backupSelection
            self.creationDate = output.creationDate
            self.creatorRequestId = output.creatorRequestId
            self.selectionId = output.selectionId
        } else {
            self.backupPlanId = nil
            self.backupSelection = nil
            self.creationDate = nil
            self.creatorRequestId = nil
            self.selectionId = nil
        }
    }
}

public struct GetBackupSelectionOutputResponse: Equatable {
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?
    /// <p>Specifies the body of a request to assign a set of resources to a backup plan.</p>
    public let backupSelection: BackupSelection?
    /// <p>The date and time a backup selection is created, in Unix format and Coordinated
    ///          Universal Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds.
    ///          For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?
    /// <p>A unique string that identifies the request and allows failed requests to be retried
    ///          without the risk of running the operation twice.</p>
    public let creatorRequestId: String?
    /// <p>Uniquely identifies the body of a request to assign a set of resources to a backup
    ///          plan.</p>
    public let selectionId: String?

    public init (
        backupPlanId: String? = nil,
        backupSelection: BackupSelection? = nil,
        creationDate: Date? = nil,
        creatorRequestId: String? = nil,
        selectionId: String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.backupSelection = backupSelection
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.selectionId = selectionId
    }
}

struct GetBackupSelectionOutputResponseBody: Equatable {
    public let backupSelection: BackupSelection?
    public let selectionId: String?
    public let backupPlanId: String?
    public let creationDate: Date?
    public let creatorRequestId: String?
}

extension GetBackupSelectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupPlanId = "BackupPlanId"
        case backupSelection = "BackupSelection"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case selectionId = "SelectionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupSelectionDecoded = try containerValues.decodeIfPresent(BackupSelection.self, forKey: .backupSelection)
        backupSelection = backupSelectionDecoded
        let selectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selectionId)
        selectionId = selectionIdDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension GetBackupVaultAccessPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackupVaultAccessPolicyInput(backupVaultName: \(String(describing: backupVaultName)))"}
}

extension GetBackupVaultAccessPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBackupVaultAccessPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetBackupVaultAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackupVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackupVaultAccessPolicyInput>
    public typealias MOutput = OperationOutput<GetBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackupVaultAccessPolicyOutputError>
}

public struct GetBackupVaultAccessPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBackupVaultAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackupVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackupVaultAccessPolicyInput>
    public typealias MOutput = OperationOutput<GetBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackupVaultAccessPolicyOutputError>
}

public struct GetBackupVaultAccessPolicyInput: Equatable {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?

    public init (
        backupVaultName: String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct GetBackupVaultAccessPolicyInputBody: Equatable {
}

extension GetBackupVaultAccessPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBackupVaultAccessPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupVaultAccessPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackupVaultAccessPolicyOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupVaultAccessPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackupVaultAccessPolicyOutputResponse(backupVaultArn: \(String(describing: backupVaultArn)), backupVaultName: \(String(describing: backupVaultName)), policy: \(String(describing: policy)))"}
}

extension GetBackupVaultAccessPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBackupVaultAccessPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.policy = output.policy
        } else {
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.policy = nil
        }
    }
}

public struct GetBackupVaultAccessPolicyOutputResponse: Equatable {
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
    public let backupVaultArn: String?
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the Region where they are
    ///          created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>The backup vault access policy document in JSON format.</p>
    public let policy: String?

    public init (
        backupVaultArn: String? = nil,
        backupVaultName: String? = nil,
        policy: String? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.policy = policy
    }
}

struct GetBackupVaultAccessPolicyOutputResponseBody: Equatable {
    public let backupVaultName: String?
    public let backupVaultArn: String?
    public let policy: String?
}

extension GetBackupVaultAccessPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetBackupVaultNotificationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackupVaultNotificationsInput(backupVaultName: \(String(describing: backupVaultName)))"}
}

extension GetBackupVaultNotificationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBackupVaultNotificationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetBackupVaultNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackupVaultNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackupVaultNotificationsInput>
    public typealias MOutput = OperationOutput<GetBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackupVaultNotificationsOutputError>
}

public struct GetBackupVaultNotificationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBackupVaultNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackupVaultNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackupVaultNotificationsInput>
    public typealias MOutput = OperationOutput<GetBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackupVaultNotificationsOutputError>
}

public struct GetBackupVaultNotificationsInput: Equatable {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?

    public init (
        backupVaultName: String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct GetBackupVaultNotificationsInputBody: Equatable {
}

extension GetBackupVaultNotificationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBackupVaultNotificationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupVaultNotificationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackupVaultNotificationsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupVaultNotificationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackupVaultNotificationsOutputResponse(backupVaultArn: \(String(describing: backupVaultArn)), backupVaultEvents: \(String(describing: backupVaultEvents)), backupVaultName: \(String(describing: backupVaultName)), sNSTopicArn: \(String(describing: sNSTopicArn)))"}
}

extension GetBackupVaultNotificationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBackupVaultNotificationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultEvents = output.backupVaultEvents
            self.backupVaultName = output.backupVaultName
            self.sNSTopicArn = output.sNSTopicArn
        } else {
            self.backupVaultArn = nil
            self.backupVaultEvents = nil
            self.backupVaultName = nil
            self.sNSTopicArn = nil
        }
    }
}

public struct GetBackupVaultNotificationsOutputResponse: Equatable {
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
    public let backupVaultArn: String?
    /// <p>An array of events that indicate the status of jobs to back up resources to the backup
    ///          vault.</p>
    public let backupVaultEvents: [BackupVaultEvent]?
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the Region where they are
    ///          created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>An ARN that uniquely identifies an Amazon Simple Notification Service (Amazon SNS)
    ///          topic; for example, <code>arn:aws:sns:us-west-2:111122223333:MyTopic</code>.</p>
    public let sNSTopicArn: String?

    public init (
        backupVaultArn: String? = nil,
        backupVaultEvents: [BackupVaultEvent]? = nil,
        backupVaultName: String? = nil,
        sNSTopicArn: String? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultEvents = backupVaultEvents
        self.backupVaultName = backupVaultName
        self.sNSTopicArn = sNSTopicArn
    }
}

struct GetBackupVaultNotificationsOutputResponseBody: Equatable {
    public let backupVaultName: String?
    public let backupVaultArn: String?
    public let sNSTopicArn: String?
    public let backupVaultEvents: [BackupVaultEvent]?
}

extension GetBackupVaultNotificationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultEvents = "BackupVaultEvents"
        case backupVaultName = "BackupVaultName"
        case sNSTopicArn = "SNSTopicArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let sNSTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sNSTopicArn)
        sNSTopicArn = sNSTopicArnDecoded
        let backupVaultEventsContainer = try containerValues.decodeIfPresent([BackupVaultEvent?].self, forKey: .backupVaultEvents)
        var backupVaultEventsDecoded0:[BackupVaultEvent]? = nil
        if let backupVaultEventsContainer = backupVaultEventsContainer {
            backupVaultEventsDecoded0 = [BackupVaultEvent]()
            for string0 in backupVaultEventsContainer {
                if let string0 = string0 {
                    backupVaultEventsDecoded0?.append(string0)
                }
            }
        }
        backupVaultEvents = backupVaultEventsDecoded0
    }
}

extension GetRecoveryPointRestoreMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecoveryPointRestoreMetadataInput(backupVaultName: \(String(describing: backupVaultName)), recoveryPointArn: \(String(describing: recoveryPointArn)))"}
}

extension GetRecoveryPointRestoreMetadataInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRecoveryPointRestoreMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "GetRecoveryPointRestoreMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecoveryPointRestoreMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecoveryPointRestoreMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecoveryPointRestoreMetadataInput>
    public typealias MOutput = OperationOutput<GetRecoveryPointRestoreMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecoveryPointRestoreMetadataOutputError>
}

public struct GetRecoveryPointRestoreMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRecoveryPointRestoreMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecoveryPointRestoreMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecoveryPointRestoreMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecoveryPointRestoreMetadataInput>
    public typealias MOutput = OperationOutput<GetRecoveryPointRestoreMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecoveryPointRestoreMetadataOutputError>
}

public struct GetRecoveryPointRestoreMetadataInput: Equatable {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let recoveryPointArn: String?

    public init (
        backupVaultName: String? = nil,
        recoveryPointArn: String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct GetRecoveryPointRestoreMetadataInputBody: Equatable {
}

extension GetRecoveryPointRestoreMetadataInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRecoveryPointRestoreMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecoveryPointRestoreMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecoveryPointRestoreMetadataOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecoveryPointRestoreMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecoveryPointRestoreMetadataOutputResponse(backupVaultArn: \(String(describing: backupVaultArn)), recoveryPointArn: \(String(describing: recoveryPointArn)), restoreMetadata: \(String(describing: restoreMetadata)))"}
}

extension GetRecoveryPointRestoreMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRecoveryPointRestoreMetadataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupVaultArn = output.backupVaultArn
            self.recoveryPointArn = output.recoveryPointArn
            self.restoreMetadata = output.restoreMetadata
        } else {
            self.backupVaultArn = nil
            self.recoveryPointArn = nil
            self.restoreMetadata = nil
        }
    }
}

public struct GetRecoveryPointRestoreMetadataOutputResponse: Equatable {
    /// <p>An ARN that uniquely identifies a backup vault; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
    public let backupVaultArn: String?
    /// <p>An ARN that uniquely identifies a recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let recoveryPointArn: String?
    /// <p>The set of metadata key-value pairs that describe the original configuration of the
    ///          backed-up resource. These values vary depending on the service that is being
    ///          restored.</p>
    public let restoreMetadata: [String:String]?

    public init (
        backupVaultArn: String? = nil,
        recoveryPointArn: String? = nil,
        restoreMetadata: [String:String]? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.recoveryPointArn = recoveryPointArn
        self.restoreMetadata = restoreMetadata
    }
}

struct GetRecoveryPointRestoreMetadataOutputResponseBody: Equatable {
    public let backupVaultArn: String?
    public let recoveryPointArn: String?
    public let restoreMetadata: [String:String]?
}

extension GetRecoveryPointRestoreMetadataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case recoveryPointArn = "RecoveryPointArn"
        case restoreMetadata = "RestoreMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let restoreMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .restoreMetadata)
        var restoreMetadataDecoded0: [String:String]? = nil
        if let restoreMetadataContainer = restoreMetadataContainer {
            restoreMetadataDecoded0 = [String:String]()
            for (key0, metadatavalue0) in restoreMetadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    restoreMetadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        restoreMetadata = restoreMetadataDecoded0
    }
}

extension GetSupportedResourceTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSupportedResourceTypesInput()"}
}

extension GetSupportedResourceTypesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSupportedResourceTypesInputHeadersMiddleware: Middleware {
    public let id: String = "GetSupportedResourceTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSupportedResourceTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSupportedResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSupportedResourceTypesInput>
    public typealias MOutput = OperationOutput<GetSupportedResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSupportedResourceTypesOutputError>
}

public struct GetSupportedResourceTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSupportedResourceTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSupportedResourceTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSupportedResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSupportedResourceTypesInput>
    public typealias MOutput = OperationOutput<GetSupportedResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSupportedResourceTypesOutputError>
}

public struct GetSupportedResourceTypesInput: Equatable {

    public init() {}
}

struct GetSupportedResourceTypesInputBody: Equatable {
}

extension GetSupportedResourceTypesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSupportedResourceTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSupportedResourceTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSupportedResourceTypesOutputError: Equatable {
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSupportedResourceTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSupportedResourceTypesOutputResponse(resourceTypes: \(String(describing: resourceTypes)))"}
}

extension GetSupportedResourceTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSupportedResourceTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceTypes = output.resourceTypes
        } else {
            self.resourceTypes = nil
        }
    }
}

public struct GetSupportedResourceTypesOutputResponse: Equatable {
    /// <p>Contains a string with the supported AWS resource types:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DynamoDB</code> for Amazon DynamoDB</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EBS</code> for Amazon Elastic Block Store</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EC2</code> for Amazon Elastic Compute Cloud</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EFS</code> for Amazon Elastic File System</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RDS</code> for Amazon Relational Database Service</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Aurora</code> for Amazon Aurora</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Storage Gateway</code> for AWS Storage Gateway</p>
    ///             </li>
    ///          </ul>
    public let resourceTypes: [String]?

    public init (
        resourceTypes: [String]? = nil
    )
    {
        self.resourceTypes = resourceTypes
    }
}

struct GetSupportedResourceTypesOutputResponseBody: Equatable {
    public let resourceTypes: [String]?
}

extension GetSupportedResourceTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceTypes = "ResourceTypes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
    }
}

extension InvalidParameterValueException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterValueException(code: \(String(describing: code)), context: \(String(describing: context)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension InvalidParameterValueException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that something is wrong with a parameter's value. For example, the value is
///          out of range.</p>
public struct InvalidParameterValueException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    /// <p></p>
    public var context: String?
    public var message: String?
    /// <p></p>
    public var type: String?

    public init (
        code: String? = nil,
        context: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct InvalidParameterValueExceptionBody: Equatable {
    public let code: String?
    public let message: String?
    public let type: String?
    public let context: String?
}

extension InvalidParameterValueExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .context)
        context = contextDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(code: \(String(describing: code)), context: \(String(describing: context)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that something is wrong with the input to the request. For example, a
///          parameter is of the wrong type.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    /// <p></p>
    public var context: String?
    public var message: String?
    /// <p></p>
    public var type: String?

    public init (
        code: String? = nil,
        context: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let code: String?
    public let message: String?
    public let type: String?
    public let context: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .context)
        context = contextDecoded
    }
}

extension InvalidResourceStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResourceStateException(code: \(String(describing: code)), context: \(String(describing: context)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension InvalidResourceStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidResourceStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS Backup is already performing an action on this recovery point. It can't perform the
///          action you requested until the first action finishes. Try again later.</p>
public struct InvalidResourceStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    /// <p></p>
    public var context: String?
    public var message: String?
    /// <p></p>
    public var type: String?

    public init (
        code: String? = nil,
        context: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct InvalidResourceStateExceptionBody: Equatable {
    public let code: String?
    public let message: String?
    public let type: String?
    public let context: String?
}

extension InvalidResourceStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .context)
        context = contextDecoded
    }
}

extension Lifecycle: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleteAfterDays = "DeleteAfterDays"
        case moveToColdStorageAfterDays = "MoveToColdStorageAfterDays"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteAfterDays = deleteAfterDays {
            try encodeContainer.encode(deleteAfterDays, forKey: .deleteAfterDays)
        }
        if let moveToColdStorageAfterDays = moveToColdStorageAfterDays {
            try encodeContainer.encode(moveToColdStorageAfterDays, forKey: .moveToColdStorageAfterDays)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moveToColdStorageAfterDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .moveToColdStorageAfterDays)
        moveToColdStorageAfterDays = moveToColdStorageAfterDaysDecoded
        let deleteAfterDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .deleteAfterDays)
        deleteAfterDays = deleteAfterDaysDecoded
    }
}

extension Lifecycle: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Lifecycle(deleteAfterDays: \(String(describing: deleteAfterDays)), moveToColdStorageAfterDays: \(String(describing: moveToColdStorageAfterDays)))"}
}

/// <p>Contains an array of <code>Transition</code> objects specifying how long in days before
///          a recovery point transitions to cold storage or is deleted.</p>
///          <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
///          days. Therefore, on the console, the “expire after days” setting must be 90 days greater
///          than the “transition to cold after days” setting. The “transition to cold after days”
///          setting cannot be changed after a backup has been transitioned to cold.</p>
///          <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
public struct Lifecycle: Equatable {
    /// <p>Specifies the number of days after creation that a recovery point is deleted. Must be
    ///          greater than 90 days plus <code>MoveToColdStorageAfterDays</code>.</p>
    public let deleteAfterDays: Int?
    /// <p>Specifies the number of days after creation that a recovery point is moved to cold
    ///          storage.</p>
    public let moveToColdStorageAfterDays: Int?

    public init (
        deleteAfterDays: Int? = nil,
        moveToColdStorageAfterDays: Int? = nil
    )
    {
        self.deleteAfterDays = deleteAfterDays
        self.moveToColdStorageAfterDays = moveToColdStorageAfterDays
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(code: \(String(describing: code)), context: \(String(describing: context)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A limit in the request has been exceeded; for example, a maximum number of items allowed
///          in a request.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    /// <p></p>
    public var context: String?
    public var message: String?
    /// <p></p>
    public var type: String?

    public init (
        code: String? = nil,
        context: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let code: String?
    public let message: String?
    public let type: String?
    public let context: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .context)
        context = contextDecoded
    }
}

extension ListBackupJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBackupJobsInput(byAccountId: \(String(describing: byAccountId)), byBackupVaultName: \(String(describing: byBackupVaultName)), byCreatedAfter: \(String(describing: byCreatedAfter)), byCreatedBefore: \(String(describing: byCreatedBefore)), byResourceArn: \(String(describing: byResourceArn)), byResourceType: \(String(describing: byResourceType)), byState: \(String(describing: byState)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBackupJobsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBackupJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBackupJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackupJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackupJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackupJobsInput>
    public typealias MOutput = OperationOutput<ListBackupJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackupJobsOutputError>
}

public struct ListBackupJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBackupJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackupJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackupJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let byCreatedBefore = input.operationInput.byCreatedBefore {
            let byCreatedBeforeQueryItem = URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: String(byCreatedBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreatedBeforeQueryItem)
        }
        if let byResourceType = input.operationInput.byResourceType {
            let byResourceTypeQueryItem = URLQueryItem(name: "resourceType".urlPercentEncoding(), value: String(byResourceType).urlPercentEncoding())
            input.builder.withQueryItem(byResourceTypeQueryItem)
        }
        if let byBackupVaultName = input.operationInput.byBackupVaultName {
            let byBackupVaultNameQueryItem = URLQueryItem(name: "backupVaultName".urlPercentEncoding(), value: String(byBackupVaultName).urlPercentEncoding())
            input.builder.withQueryItem(byBackupVaultNameQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let byResourceArn = input.operationInput.byResourceArn {
            let byResourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(byResourceArn).urlPercentEncoding())
            input.builder.withQueryItem(byResourceArnQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let byState = input.operationInput.byState {
            let byStateQueryItem = URLQueryItem(name: "state".urlPercentEncoding(), value: String(byState.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(byStateQueryItem)
        }
        if let byAccountId = input.operationInput.byAccountId {
            let byAccountIdQueryItem = URLQueryItem(name: "accountId".urlPercentEncoding(), value: String(byAccountId).urlPercentEncoding())
            input.builder.withQueryItem(byAccountIdQueryItem)
        }
        if let byCreatedAfter = input.operationInput.byCreatedAfter {
            let byCreatedAfterQueryItem = URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: String(byCreatedAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreatedAfterQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackupJobsInput>
    public typealias MOutput = OperationOutput<ListBackupJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackupJobsOutputError>
}

public struct ListBackupJobsInput: Equatable {
    /// <p>The account ID to list the jobs from. Returns only backup jobs associated with the
    ///          specified account ID.</p>
    ///          <p>If used from an AWS Organizations management account, passing <code>*</code> returns all
    ///          jobs across the organization.</p>
    public let byAccountId: String?
    /// <p>Returns only backup jobs that will be stored in the specified backup vault. Backup
    ///          vaults are identified by names that are unique to the account used to create them and the
    ///          AWS Region where they are created. They consist of lowercase letters, numbers, and
    ///          hyphens.</p>
    public let byBackupVaultName: String?
    /// <p>Returns only backup jobs that were created after the specified date.</p>
    public let byCreatedAfter: Date?
    /// <p>Returns only backup jobs that were created before the specified date.</p>
    public let byCreatedBefore: Date?
    /// <p>Returns only backup jobs that match the specified resource Amazon Resource Name
    ///          (ARN).</p>
    public let byResourceArn: String?
    /// <p>Returns only backup jobs for the specified resources:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DynamoDB</code> for Amazon DynamoDB</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EBS</code> for Amazon Elastic Block Store</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EC2</code> for Amazon Elastic Compute Cloud</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EFS</code> for Amazon Elastic File System</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RDS</code> for Amazon Relational Database Service</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Aurora</code> for Amazon Aurora</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Storage Gateway</code> for AWS Storage Gateway</p>
    ///             </li>
    ///          </ul>
    public let byResourceType: String?
    /// <p>Returns only backup jobs that are in the specified state.</p>
    public let byState: BackupJobState?
    /// <p>The maximum number of items to be returned.</p>
    public let maxResults: Int?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?

    public init (
        byAccountId: String? = nil,
        byBackupVaultName: String? = nil,
        byCreatedAfter: Date? = nil,
        byCreatedBefore: Date? = nil,
        byResourceArn: String? = nil,
        byResourceType: String? = nil,
        byState: BackupJobState? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.byAccountId = byAccountId
        self.byBackupVaultName = byBackupVaultName
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byResourceArn = byResourceArn
        self.byResourceType = byResourceType
        self.byState = byState
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupJobsInputBody: Equatable {
}

extension ListBackupJobsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBackupJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBackupJobsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBackupJobsOutputResponse(backupJobs: \(String(describing: backupJobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBackupJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBackupJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupJobs = output.backupJobs
            self.nextToken = output.nextToken
        } else {
            self.backupJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupJobsOutputResponse: Equatable {
    /// <p>An array of structures containing metadata about your backup jobs returned in JSON
    ///          format.</p>
    public let backupJobs: [BackupJob]?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?

    public init (
        backupJobs: [BackupJob]? = nil,
        nextToken: String? = nil
    )
    {
        self.backupJobs = backupJobs
        self.nextToken = nextToken
    }
}

struct ListBackupJobsOutputResponseBody: Equatable {
    public let backupJobs: [BackupJob]?
    public let nextToken: String?
}

extension ListBackupJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupJobs = "BackupJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupJobsContainer = try containerValues.decodeIfPresent([BackupJob?].self, forKey: .backupJobs)
        var backupJobsDecoded0:[BackupJob]? = nil
        if let backupJobsContainer = backupJobsContainer {
            backupJobsDecoded0 = [BackupJob]()
            for structure0 in backupJobsContainer {
                if let structure0 = structure0 {
                    backupJobsDecoded0?.append(structure0)
                }
            }
        }
        backupJobs = backupJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBackupPlanTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBackupPlanTemplatesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBackupPlanTemplatesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBackupPlanTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListBackupPlanTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackupPlanTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackupPlanTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackupPlanTemplatesInput>
    public typealias MOutput = OperationOutput<ListBackupPlanTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackupPlanTemplatesOutputError>
}

public struct ListBackupPlanTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBackupPlanTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackupPlanTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackupPlanTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackupPlanTemplatesInput>
    public typealias MOutput = OperationOutput<ListBackupPlanTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackupPlanTemplatesOutputError>
}

public struct ListBackupPlanTemplatesInput: Equatable {
    /// <p>The maximum number of items to be returned.</p>
    public let maxResults: Int?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupPlanTemplatesInputBody: Equatable {
}

extension ListBackupPlanTemplatesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBackupPlanTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupPlanTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBackupPlanTemplatesOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupPlanTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBackupPlanTemplatesOutputResponse(backupPlanTemplatesList: \(String(describing: backupPlanTemplatesList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBackupPlanTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBackupPlanTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupPlanTemplatesList = output.backupPlanTemplatesList
            self.nextToken = output.nextToken
        } else {
            self.backupPlanTemplatesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupPlanTemplatesOutputResponse: Equatable {
    /// <p>An array of template list items containing metadata about your saved templates.</p>
    public let backupPlanTemplatesList: [BackupPlanTemplatesListMember]?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?

    public init (
        backupPlanTemplatesList: [BackupPlanTemplatesListMember]? = nil,
        nextToken: String? = nil
    )
    {
        self.backupPlanTemplatesList = backupPlanTemplatesList
        self.nextToken = nextToken
    }
}

struct ListBackupPlanTemplatesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let backupPlanTemplatesList: [BackupPlanTemplatesListMember]?
}

extension ListBackupPlanTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupPlanTemplatesList = "BackupPlanTemplatesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let backupPlanTemplatesListContainer = try containerValues.decodeIfPresent([BackupPlanTemplatesListMember?].self, forKey: .backupPlanTemplatesList)
        var backupPlanTemplatesListDecoded0:[BackupPlanTemplatesListMember]? = nil
        if let backupPlanTemplatesListContainer = backupPlanTemplatesListContainer {
            backupPlanTemplatesListDecoded0 = [BackupPlanTemplatesListMember]()
            for structure0 in backupPlanTemplatesListContainer {
                if let structure0 = structure0 {
                    backupPlanTemplatesListDecoded0?.append(structure0)
                }
            }
        }
        backupPlanTemplatesList = backupPlanTemplatesListDecoded0
    }
}

extension ListBackupPlanVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBackupPlanVersionsInput(backupPlanId: \(String(describing: backupPlanId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBackupPlanVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBackupPlanVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBackupPlanVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackupPlanVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackupPlanVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackupPlanVersionsInput>
    public typealias MOutput = OperationOutput<ListBackupPlanVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackupPlanVersionsOutputError>
}

public struct ListBackupPlanVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBackupPlanVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackupPlanVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackupPlanVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackupPlanVersionsInput>
    public typealias MOutput = OperationOutput<ListBackupPlanVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackupPlanVersionsOutputError>
}

public struct ListBackupPlanVersionsInput: Equatable {
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?
    /// <p>The maximum number of items to be returned.</p>
    public let maxResults: Int?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?

    public init (
        backupPlanId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupPlanVersionsInputBody: Equatable {
}

extension ListBackupPlanVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBackupPlanVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupPlanVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBackupPlanVersionsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupPlanVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBackupPlanVersionsOutputResponse(backupPlanVersionsList: \(String(describing: backupPlanVersionsList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBackupPlanVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBackupPlanVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupPlanVersionsList = output.backupPlanVersionsList
            self.nextToken = output.nextToken
        } else {
            self.backupPlanVersionsList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupPlanVersionsOutputResponse: Equatable {
    /// <p>An array of version list items containing metadata about your backup plans.</p>
    public let backupPlanVersionsList: [BackupPlansListMember]?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?

    public init (
        backupPlanVersionsList: [BackupPlansListMember]? = nil,
        nextToken: String? = nil
    )
    {
        self.backupPlanVersionsList = backupPlanVersionsList
        self.nextToken = nextToken
    }
}

struct ListBackupPlanVersionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let backupPlanVersionsList: [BackupPlansListMember]?
}

extension ListBackupPlanVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupPlanVersionsList = "BackupPlanVersionsList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let backupPlanVersionsListContainer = try containerValues.decodeIfPresent([BackupPlansListMember?].self, forKey: .backupPlanVersionsList)
        var backupPlanVersionsListDecoded0:[BackupPlansListMember]? = nil
        if let backupPlanVersionsListContainer = backupPlanVersionsListContainer {
            backupPlanVersionsListDecoded0 = [BackupPlansListMember]()
            for structure0 in backupPlanVersionsListContainer {
                if let structure0 = structure0 {
                    backupPlanVersionsListDecoded0?.append(structure0)
                }
            }
        }
        backupPlanVersionsList = backupPlanVersionsListDecoded0
    }
}

extension ListBackupPlansInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBackupPlansInput(includeDeleted: \(String(describing: includeDeleted)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBackupPlansInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBackupPlansInputHeadersMiddleware: Middleware {
    public let id: String = "ListBackupPlansInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackupPlansInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackupPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackupPlansInput>
    public typealias MOutput = OperationOutput<ListBackupPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackupPlansOutputError>
}

public struct ListBackupPlansInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBackupPlansInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackupPlansInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackupPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let includeDeleted = input.operationInput.includeDeleted {
            let includeDeletedQueryItem = URLQueryItem(name: "includeDeleted".urlPercentEncoding(), value: String(includeDeleted).urlPercentEncoding())
            input.builder.withQueryItem(includeDeletedQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackupPlansInput>
    public typealias MOutput = OperationOutput<ListBackupPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackupPlansOutputError>
}

public struct ListBackupPlansInput: Equatable {
    /// <p>A Boolean value with a default value of <code>FALSE</code> that returns deleted backup
    ///          plans when set to <code>TRUE</code>.</p>
    public let includeDeleted: Bool?
    /// <p>The maximum number of items to be returned.</p>
    public let maxResults: Int?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?

    public init (
        includeDeleted: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.includeDeleted = includeDeleted
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupPlansInputBody: Equatable {
}

extension ListBackupPlansInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBackupPlansOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupPlansOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBackupPlansOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupPlansOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBackupPlansOutputResponse(backupPlansList: \(String(describing: backupPlansList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBackupPlansOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBackupPlansOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupPlansList = output.backupPlansList
            self.nextToken = output.nextToken
        } else {
            self.backupPlansList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupPlansOutputResponse: Equatable {
    /// <p>An array of backup plan list items containing metadata about your saved backup
    ///          plans.</p>
    public let backupPlansList: [BackupPlansListMember]?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?

    public init (
        backupPlansList: [BackupPlansListMember]? = nil,
        nextToken: String? = nil
    )
    {
        self.backupPlansList = backupPlansList
        self.nextToken = nextToken
    }
}

struct ListBackupPlansOutputResponseBody: Equatable {
    public let nextToken: String?
    public let backupPlansList: [BackupPlansListMember]?
}

extension ListBackupPlansOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupPlansList = "BackupPlansList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let backupPlansListContainer = try containerValues.decodeIfPresent([BackupPlansListMember?].self, forKey: .backupPlansList)
        var backupPlansListDecoded0:[BackupPlansListMember]? = nil
        if let backupPlansListContainer = backupPlansListContainer {
            backupPlansListDecoded0 = [BackupPlansListMember]()
            for structure0 in backupPlansListContainer {
                if let structure0 = structure0 {
                    backupPlansListDecoded0?.append(structure0)
                }
            }
        }
        backupPlansList = backupPlansListDecoded0
    }
}

extension ListBackupSelectionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBackupSelectionsInput(backupPlanId: \(String(describing: backupPlanId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBackupSelectionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBackupSelectionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBackupSelectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackupSelectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackupSelectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackupSelectionsInput>
    public typealias MOutput = OperationOutput<ListBackupSelectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackupSelectionsOutputError>
}

public struct ListBackupSelectionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBackupSelectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackupSelectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackupSelectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackupSelectionsInput>
    public typealias MOutput = OperationOutput<ListBackupSelectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackupSelectionsOutputError>
}

public struct ListBackupSelectionsInput: Equatable {
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?
    /// <p>The maximum number of items to be returned.</p>
    public let maxResults: Int?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?

    public init (
        backupPlanId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupSelectionsInputBody: Equatable {
}

extension ListBackupSelectionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBackupSelectionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupSelectionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBackupSelectionsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupSelectionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBackupSelectionsOutputResponse(backupSelectionsList: \(String(describing: backupSelectionsList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBackupSelectionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBackupSelectionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupSelectionsList = output.backupSelectionsList
            self.nextToken = output.nextToken
        } else {
            self.backupSelectionsList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupSelectionsOutputResponse: Equatable {
    /// <p>An array of backup selection list items containing metadata about each resource in the
    ///          list.</p>
    public let backupSelectionsList: [BackupSelectionsListMember]?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?

    public init (
        backupSelectionsList: [BackupSelectionsListMember]? = nil,
        nextToken: String? = nil
    )
    {
        self.backupSelectionsList = backupSelectionsList
        self.nextToken = nextToken
    }
}

struct ListBackupSelectionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let backupSelectionsList: [BackupSelectionsListMember]?
}

extension ListBackupSelectionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupSelectionsList = "BackupSelectionsList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let backupSelectionsListContainer = try containerValues.decodeIfPresent([BackupSelectionsListMember?].self, forKey: .backupSelectionsList)
        var backupSelectionsListDecoded0:[BackupSelectionsListMember]? = nil
        if let backupSelectionsListContainer = backupSelectionsListContainer {
            backupSelectionsListDecoded0 = [BackupSelectionsListMember]()
            for structure0 in backupSelectionsListContainer {
                if let structure0 = structure0 {
                    backupSelectionsListDecoded0?.append(structure0)
                }
            }
        }
        backupSelectionsList = backupSelectionsListDecoded0
    }
}

extension ListBackupVaultsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBackupVaultsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBackupVaultsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBackupVaultsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBackupVaultsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackupVaultsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackupVaultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackupVaultsInput>
    public typealias MOutput = OperationOutput<ListBackupVaultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackupVaultsOutputError>
}

public struct ListBackupVaultsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBackupVaultsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackupVaultsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackupVaultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackupVaultsInput>
    public typealias MOutput = OperationOutput<ListBackupVaultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackupVaultsOutputError>
}

public struct ListBackupVaultsInput: Equatable {
    /// <p>The maximum number of items to be returned.</p>
    public let maxResults: Int?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupVaultsInputBody: Equatable {
}

extension ListBackupVaultsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBackupVaultsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupVaultsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBackupVaultsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupVaultsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBackupVaultsOutputResponse(backupVaultList: \(String(describing: backupVaultList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBackupVaultsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBackupVaultsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupVaultList = output.backupVaultList
            self.nextToken = output.nextToken
        } else {
            self.backupVaultList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupVaultsOutputResponse: Equatable {
    /// <p>An array of backup vault list members containing vault metadata, including Amazon
    ///          Resource Name (ARN), display name, creation date, number of saved recovery points, and
    ///          encryption information if the resources saved in the backup vault are encrypted.</p>
    public let backupVaultList: [BackupVaultListMember]?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?

    public init (
        backupVaultList: [BackupVaultListMember]? = nil,
        nextToken: String? = nil
    )
    {
        self.backupVaultList = backupVaultList
        self.nextToken = nextToken
    }
}

struct ListBackupVaultsOutputResponseBody: Equatable {
    public let backupVaultList: [BackupVaultListMember]?
    public let nextToken: String?
}

extension ListBackupVaultsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupVaultList = "BackupVaultList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultListContainer = try containerValues.decodeIfPresent([BackupVaultListMember?].self, forKey: .backupVaultList)
        var backupVaultListDecoded0:[BackupVaultListMember]? = nil
        if let backupVaultListContainer = backupVaultListContainer {
            backupVaultListDecoded0 = [BackupVaultListMember]()
            for structure0 in backupVaultListContainer {
                if let structure0 = structure0 {
                    backupVaultListDecoded0?.append(structure0)
                }
            }
        }
        backupVaultList = backupVaultListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCopyJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCopyJobsInput(byAccountId: \(String(describing: byAccountId)), byCreatedAfter: \(String(describing: byCreatedAfter)), byCreatedBefore: \(String(describing: byCreatedBefore)), byDestinationVaultArn: \(String(describing: byDestinationVaultArn)), byResourceArn: \(String(describing: byResourceArn)), byResourceType: \(String(describing: byResourceType)), byState: \(String(describing: byState)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCopyJobsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListCopyJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListCopyJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCopyJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCopyJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCopyJobsInput>
    public typealias MOutput = OperationOutput<ListCopyJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCopyJobsOutputError>
}

public struct ListCopyJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCopyJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCopyJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCopyJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let byCreatedBefore = input.operationInput.byCreatedBefore {
            let byCreatedBeforeQueryItem = URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: String(byCreatedBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreatedBeforeQueryItem)
        }
        if let byResourceType = input.operationInput.byResourceType {
            let byResourceTypeQueryItem = URLQueryItem(name: "resourceType".urlPercentEncoding(), value: String(byResourceType).urlPercentEncoding())
            input.builder.withQueryItem(byResourceTypeQueryItem)
        }
        if let byDestinationVaultArn = input.operationInput.byDestinationVaultArn {
            let byDestinationVaultArnQueryItem = URLQueryItem(name: "destinationVaultArn".urlPercentEncoding(), value: String(byDestinationVaultArn).urlPercentEncoding())
            input.builder.withQueryItem(byDestinationVaultArnQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let byResourceArn = input.operationInput.byResourceArn {
            let byResourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(byResourceArn).urlPercentEncoding())
            input.builder.withQueryItem(byResourceArnQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let byState = input.operationInput.byState {
            let byStateQueryItem = URLQueryItem(name: "state".urlPercentEncoding(), value: String(byState.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(byStateQueryItem)
        }
        if let byAccountId = input.operationInput.byAccountId {
            let byAccountIdQueryItem = URLQueryItem(name: "accountId".urlPercentEncoding(), value: String(byAccountId).urlPercentEncoding())
            input.builder.withQueryItem(byAccountIdQueryItem)
        }
        if let byCreatedAfter = input.operationInput.byCreatedAfter {
            let byCreatedAfterQueryItem = URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: String(byCreatedAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreatedAfterQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCopyJobsInput>
    public typealias MOutput = OperationOutput<ListCopyJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCopyJobsOutputError>
}

public struct ListCopyJobsInput: Equatable {
    /// <p>The account ID to list the jobs from. Returns only copy jobs associated with the
    ///          specified account ID.</p>
    public let byAccountId: String?
    /// <p>Returns only copy jobs that were created after the specified date.</p>
    public let byCreatedAfter: Date?
    /// <p>Returns only copy jobs that were created before the specified date.</p>
    public let byCreatedBefore: Date?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a source backup vault to copy
    ///          from; for example, <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.
    ///       </p>
    public let byDestinationVaultArn: String?
    /// <p>Returns only copy jobs that match the specified resource Amazon Resource Name (ARN).
    ///       </p>
    public let byResourceArn: String?
    /// <p>Returns only backup jobs for the specified resources:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DynamoDB</code> for Amazon DynamoDB</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EBS</code> for Amazon Elastic Block Store</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EC2</code> for Amazon Elastic Compute Cloud</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EFS</code> for Amazon Elastic File System</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RDS</code> for Amazon Relational Database Service</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Aurora</code> for Amazon Aurora</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Storage Gateway</code> for AWS Storage Gateway</p>
    ///             </li>
    ///          </ul>
    public let byResourceType: String?
    /// <p>Returns only copy jobs that are in the specified state.</p>
    public let byState: CopyJobState?
    /// <p>The maximum number of items to be returned.</p>
    public let maxResults: Int?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return maxResults number of items, NextToken allows you to return more items in
    ///          your list starting at the location pointed to by the next token. </p>
    public let nextToken: String?

    public init (
        byAccountId: String? = nil,
        byCreatedAfter: Date? = nil,
        byCreatedBefore: Date? = nil,
        byDestinationVaultArn: String? = nil,
        byResourceArn: String? = nil,
        byResourceType: String? = nil,
        byState: CopyJobState? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.byAccountId = byAccountId
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byDestinationVaultArn = byDestinationVaultArn
        self.byResourceArn = byResourceArn
        self.byResourceType = byResourceType
        self.byState = byState
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCopyJobsInputBody: Equatable {
}

extension ListCopyJobsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListCopyJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCopyJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCopyJobsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCopyJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCopyJobsOutputResponse(copyJobs: \(String(describing: copyJobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCopyJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCopyJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.copyJobs = output.copyJobs
            self.nextToken = output.nextToken
        } else {
            self.copyJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListCopyJobsOutputResponse: Equatable {
    /// <p>An array of structures containing metadata about your copy jobs returned in JSON format.
    ///       </p>
    public let copyJobs: [CopyJob]?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return maxResults number of items, NextToken allows you to return more items in
    ///          your list starting at the location pointed to by the next token. </p>
    public let nextToken: String?

    public init (
        copyJobs: [CopyJob]? = nil,
        nextToken: String? = nil
    )
    {
        self.copyJobs = copyJobs
        self.nextToken = nextToken
    }
}

struct ListCopyJobsOutputResponseBody: Equatable {
    public let copyJobs: [CopyJob]?
    public let nextToken: String?
}

extension ListCopyJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case copyJobs = "CopyJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyJobsContainer = try containerValues.decodeIfPresent([CopyJob?].self, forKey: .copyJobs)
        var copyJobsDecoded0:[CopyJob]? = nil
        if let copyJobsContainer = copyJobsContainer {
            copyJobsDecoded0 = [CopyJob]()
            for structure0 in copyJobsContainer {
                if let structure0 = structure0 {
                    copyJobsDecoded0?.append(structure0)
                }
            }
        }
        copyJobs = copyJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProtectedResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProtectedResourcesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProtectedResourcesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListProtectedResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListProtectedResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProtectedResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProtectedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProtectedResourcesInput>
    public typealias MOutput = OperationOutput<ListProtectedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProtectedResourcesOutputError>
}

public struct ListProtectedResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProtectedResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProtectedResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProtectedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProtectedResourcesInput>
    public typealias MOutput = OperationOutput<ListProtectedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProtectedResourcesOutputError>
}

public struct ListProtectedResourcesInput: Equatable {
    /// <p>The maximum number of items to be returned.</p>
    public let maxResults: Int?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProtectedResourcesInputBody: Equatable {
}

extension ListProtectedResourcesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListProtectedResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProtectedResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProtectedResourcesOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProtectedResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProtectedResourcesOutputResponse(nextToken: \(String(describing: nextToken)), results: \(String(describing: results)))"}
}

extension ListProtectedResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProtectedResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.results = output.results
        } else {
            self.nextToken = nil
            self.results = nil
        }
    }
}

public struct ListProtectedResourcesOutputResponse: Equatable {
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?
    /// <p>An array of resources successfully backed up by AWS Backup including the time the
    ///          resource was saved, an Amazon Resource Name (ARN) of the resource, and a resource
    ///          type.</p>
    public let results: [ProtectedResource]?

    public init (
        nextToken: String? = nil,
        results: [ProtectedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

struct ListProtectedResourcesOutputResponseBody: Equatable {
    public let results: [ProtectedResource]?
    public let nextToken: String?
}

extension ListProtectedResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case results = "Results"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([ProtectedResource?].self, forKey: .results)
        var resultsDecoded0:[ProtectedResource]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [ProtectedResource]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecoveryPointsByBackupVaultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecoveryPointsByBackupVaultInput(backupVaultName: \(String(describing: backupVaultName)), byBackupPlanId: \(String(describing: byBackupPlanId)), byCreatedAfter: \(String(describing: byCreatedAfter)), byCreatedBefore: \(String(describing: byCreatedBefore)), byResourceArn: \(String(describing: byResourceArn)), byResourceType: \(String(describing: byResourceType)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRecoveryPointsByBackupVaultInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRecoveryPointsByBackupVaultInputHeadersMiddleware: Middleware {
    public let id: String = "ListRecoveryPointsByBackupVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecoveryPointsByBackupVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecoveryPointsByBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecoveryPointsByBackupVaultInput>
    public typealias MOutput = OperationOutput<ListRecoveryPointsByBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecoveryPointsByBackupVaultOutputError>
}

public struct ListRecoveryPointsByBackupVaultInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRecoveryPointsByBackupVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecoveryPointsByBackupVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecoveryPointsByBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let byResourceType = input.operationInput.byResourceType {
            let byResourceTypeQueryItem = URLQueryItem(name: "resourceType".urlPercentEncoding(), value: String(byResourceType).urlPercentEncoding())
            input.builder.withQueryItem(byResourceTypeQueryItem)
        }
        if let byCreatedBefore = input.operationInput.byCreatedBefore {
            let byCreatedBeforeQueryItem = URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: String(byCreatedBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreatedBeforeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let byResourceArn = input.operationInput.byResourceArn {
            let byResourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(byResourceArn).urlPercentEncoding())
            input.builder.withQueryItem(byResourceArnQueryItem)
        }
        if let byBackupPlanId = input.operationInput.byBackupPlanId {
            let byBackupPlanIdQueryItem = URLQueryItem(name: "backupPlanId".urlPercentEncoding(), value: String(byBackupPlanId).urlPercentEncoding())
            input.builder.withQueryItem(byBackupPlanIdQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let byCreatedAfter = input.operationInput.byCreatedAfter {
            let byCreatedAfterQueryItem = URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: String(byCreatedAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreatedAfterQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecoveryPointsByBackupVaultInput>
    public typealias MOutput = OperationOutput<ListRecoveryPointsByBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecoveryPointsByBackupVaultOutputError>
}

public struct ListRecoveryPointsByBackupVaultInput: Equatable {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>Returns only recovery points that match the specified backup plan ID.</p>
    public let byBackupPlanId: String?
    /// <p>Returns only recovery points that were created after the specified timestamp.</p>
    public let byCreatedAfter: Date?
    /// <p>Returns only recovery points that were created before the specified timestamp.</p>
    public let byCreatedBefore: Date?
    /// <p>Returns only recovery points that match the specified resource Amazon Resource Name
    ///          (ARN).</p>
    public let byResourceArn: String?
    /// <p>Returns only recovery points that match the specified resource type.</p>
    public let byResourceType: String?
    /// <p>The maximum number of items to be returned.</p>
    public let maxResults: Int?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?

    public init (
        backupVaultName: String? = nil,
        byBackupPlanId: String? = nil,
        byCreatedAfter: Date? = nil,
        byCreatedBefore: Date? = nil,
        byResourceArn: String? = nil,
        byResourceType: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.byBackupPlanId = byBackupPlanId
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byResourceArn = byResourceArn
        self.byResourceType = byResourceType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecoveryPointsByBackupVaultInputBody: Equatable {
}

extension ListRecoveryPointsByBackupVaultInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRecoveryPointsByBackupVaultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecoveryPointsByBackupVaultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecoveryPointsByBackupVaultOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecoveryPointsByBackupVaultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecoveryPointsByBackupVaultOutputResponse(nextToken: \(String(describing: nextToken)), recoveryPoints: \(String(describing: recoveryPoints)))"}
}

extension ListRecoveryPointsByBackupVaultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRecoveryPointsByBackupVaultOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.recoveryPoints = output.recoveryPoints
        } else {
            self.nextToken = nil
            self.recoveryPoints = nil
        }
    }
}

public struct ListRecoveryPointsByBackupVaultOutputResponse: Equatable {
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?
    /// <p>An array of objects that contain detailed information about recovery points saved in a
    ///          backup vault.</p>
    public let recoveryPoints: [RecoveryPointByBackupVault]?

    public init (
        nextToken: String? = nil,
        recoveryPoints: [RecoveryPointByBackupVault]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryPoints = recoveryPoints
    }
}

struct ListRecoveryPointsByBackupVaultOutputResponseBody: Equatable {
    public let nextToken: String?
    public let recoveryPoints: [RecoveryPointByBackupVault]?
}

extension ListRecoveryPointsByBackupVaultOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case recoveryPoints = "RecoveryPoints"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recoveryPointsContainer = try containerValues.decodeIfPresent([RecoveryPointByBackupVault?].self, forKey: .recoveryPoints)
        var recoveryPointsDecoded0:[RecoveryPointByBackupVault]? = nil
        if let recoveryPointsContainer = recoveryPointsContainer {
            recoveryPointsDecoded0 = [RecoveryPointByBackupVault]()
            for structure0 in recoveryPointsContainer {
                if let structure0 = structure0 {
                    recoveryPointsDecoded0?.append(structure0)
                }
            }
        }
        recoveryPoints = recoveryPointsDecoded0
    }
}

extension ListRecoveryPointsByResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecoveryPointsByResourceInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListRecoveryPointsByResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRecoveryPointsByResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListRecoveryPointsByResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecoveryPointsByResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecoveryPointsByResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecoveryPointsByResourceInput>
    public typealias MOutput = OperationOutput<ListRecoveryPointsByResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecoveryPointsByResourceOutputError>
}

public struct ListRecoveryPointsByResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRecoveryPointsByResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecoveryPointsByResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecoveryPointsByResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecoveryPointsByResourceInput>
    public typealias MOutput = OperationOutput<ListRecoveryPointsByResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecoveryPointsByResourceOutputError>
}

public struct ListRecoveryPointsByResourceInput: Equatable {
    /// <p>The maximum number of items to be returned.</p>
    public let maxResults: Int?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?
    /// <p>An ARN that uniquely identifies a resource. The format of the ARN depends on the
    ///          resource type.</p>
    public let resourceArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListRecoveryPointsByResourceInputBody: Equatable {
}

extension ListRecoveryPointsByResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRecoveryPointsByResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecoveryPointsByResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecoveryPointsByResourceOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecoveryPointsByResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecoveryPointsByResourceOutputResponse(nextToken: \(String(describing: nextToken)), recoveryPoints: \(String(describing: recoveryPoints)))"}
}

extension ListRecoveryPointsByResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRecoveryPointsByResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.recoveryPoints = output.recoveryPoints
        } else {
            self.nextToken = nil
            self.recoveryPoints = nil
        }
    }
}

public struct ListRecoveryPointsByResourceOutputResponse: Equatable {
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?
    /// <p>An array of objects that contain detailed information about recovery points of the
    ///          specified resource type.</p>
    public let recoveryPoints: [RecoveryPointByResource]?

    public init (
        nextToken: String? = nil,
        recoveryPoints: [RecoveryPointByResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryPoints = recoveryPoints
    }
}

struct ListRecoveryPointsByResourceOutputResponseBody: Equatable {
    public let nextToken: String?
    public let recoveryPoints: [RecoveryPointByResource]?
}

extension ListRecoveryPointsByResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case recoveryPoints = "RecoveryPoints"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recoveryPointsContainer = try containerValues.decodeIfPresent([RecoveryPointByResource?].self, forKey: .recoveryPoints)
        var recoveryPointsDecoded0:[RecoveryPointByResource]? = nil
        if let recoveryPointsContainer = recoveryPointsContainer {
            recoveryPointsDecoded0 = [RecoveryPointByResource]()
            for structure0 in recoveryPointsContainer {
                if let structure0 = structure0 {
                    recoveryPointsDecoded0?.append(structure0)
                }
            }
        }
        recoveryPoints = recoveryPointsDecoded0
    }
}

extension ListRestoreJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRestoreJobsInput(byAccountId: \(String(describing: byAccountId)), byCreatedAfter: \(String(describing: byCreatedAfter)), byCreatedBefore: \(String(describing: byCreatedBefore)), byStatus: \(String(describing: byStatus)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRestoreJobsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRestoreJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRestoreJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRestoreJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRestoreJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRestoreJobsInput>
    public typealias MOutput = OperationOutput<ListRestoreJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRestoreJobsOutputError>
}

public struct ListRestoreJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRestoreJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRestoreJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRestoreJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let byCreatedBefore = input.operationInput.byCreatedBefore {
            let byCreatedBeforeQueryItem = URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: String(byCreatedBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreatedBeforeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let byAccountId = input.operationInput.byAccountId {
            let byAccountIdQueryItem = URLQueryItem(name: "accountId".urlPercentEncoding(), value: String(byAccountId).urlPercentEncoding())
            input.builder.withQueryItem(byAccountIdQueryItem)
        }
        if let byCreatedAfter = input.operationInput.byCreatedAfter {
            let byCreatedAfterQueryItem = URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: String(byCreatedAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreatedAfterQueryItem)
        }
        if let byStatus = input.operationInput.byStatus {
            let byStatusQueryItem = URLQueryItem(name: "status".urlPercentEncoding(), value: String(byStatus.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(byStatusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRestoreJobsInput>
    public typealias MOutput = OperationOutput<ListRestoreJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRestoreJobsOutputError>
}

public struct ListRestoreJobsInput: Equatable {
    /// <p>The account ID to list the jobs from. Returns only restore jobs associated with the
    ///          specified account ID.</p>
    public let byAccountId: String?
    /// <p>Returns only restore jobs that were created after the specified date.</p>
    public let byCreatedAfter: Date?
    /// <p>Returns only restore jobs that were created before the specified date.</p>
    public let byCreatedBefore: Date?
    /// <p>Returns only restore jobs associated with the specified job status.</p>
    public let byStatus: RestoreJobStatus?
    /// <p>The maximum number of items to be returned.</p>
    public let maxResults: Int?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?

    public init (
        byAccountId: String? = nil,
        byCreatedAfter: Date? = nil,
        byCreatedBefore: Date? = nil,
        byStatus: RestoreJobStatus? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.byAccountId = byAccountId
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byStatus = byStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRestoreJobsInputBody: Equatable {
}

extension ListRestoreJobsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRestoreJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRestoreJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRestoreJobsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRestoreJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRestoreJobsOutputResponse(nextToken: \(String(describing: nextToken)), restoreJobs: \(String(describing: restoreJobs)))"}
}

extension ListRestoreJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRestoreJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.restoreJobs = output.restoreJobs
        } else {
            self.nextToken = nil
            self.restoreJobs = nil
        }
    }
}

public struct ListRestoreJobsOutputResponse: Equatable {
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?
    /// <p>An array of objects that contain detailed information about jobs to restore saved
    ///          resources.</p>
    public let restoreJobs: [RestoreJobsListMember]?

    public init (
        nextToken: String? = nil,
        restoreJobs: [RestoreJobsListMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.restoreJobs = restoreJobs
    }
}

struct ListRestoreJobsOutputResponseBody: Equatable {
    public let restoreJobs: [RestoreJobsListMember]?
    public let nextToken: String?
}

extension ListRestoreJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case restoreJobs = "RestoreJobs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restoreJobsContainer = try containerValues.decodeIfPresent([RestoreJobsListMember?].self, forKey: .restoreJobs)
        var restoreJobsDecoded0:[RestoreJobsListMember]? = nil
        if let restoreJobsContainer = restoreJobsContainer {
            restoreJobsDecoded0 = [RestoreJobsListMember]()
            for structure0 in restoreJobsContainer {
                if let structure0 = structure0 {
                    restoreJobsDecoded0?.append(structure0)
                }
            }
        }
        restoreJobs = restoreJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInput: Equatable {
    /// <p>The maximum number of items to be returned.</p>
    public let maxResults: Int?
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN
    ///          depends on the type of resource. Valid targets for <code>ListTags</code> are recovery
    ///          points, backup plans, and backup vaults.</p>
    public let resourceArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsInputBody: Equatable {
}

extension ListTagsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Equatable {
    /// <p>The next item following a partial list of returned items. For example, if a request is
    ///          made to return <code>maxResults</code> number of items, <code>NextToken</code> allows you
    ///          to return more items in your list starting at the location pointed to by the next
    ///          token.</p>
    public let nextToken: String?
    /// <p>To help organize your resources, you can assign your own metadata to the resources you
    ///          create. Each tag is a key-value pair.</p>
    public let tags: [String:String]?

    public init (
        nextToken: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let tags: [String:String]?
}

extension ListTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MissingParameterValueException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MissingParameterValueException(code: \(String(describing: code)), context: \(String(describing: context)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension MissingParameterValueException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MissingParameterValueExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a required parameter is missing.</p>
public struct MissingParameterValueException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    /// <p></p>
    public var context: String?
    public var message: String?
    /// <p></p>
    public var type: String?

    public init (
        code: String? = nil,
        context: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct MissingParameterValueExceptionBody: Equatable {
    public let code: String?
    public let message: String?
    public let type: String?
    public let context: String?
}

extension MissingParameterValueExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .context)
        context = contextDecoded
    }
}

extension ProtectedResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastBackupTime = "LastBackupTime"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastBackupTime = lastBackupTime {
            try encodeContainer.encode(lastBackupTime.timeIntervalSince1970, forKey: .lastBackupTime)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let lastBackupTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastBackupTime)
        lastBackupTime = lastBackupTimeDecoded
    }
}

extension ProtectedResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProtectedResource(lastBackupTime: \(String(describing: lastBackupTime)), resourceArn: \(String(describing: resourceArn)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>A structure that contains information about a backed-up resource.</p>
public struct ProtectedResource: Equatable {
    /// <p>The date and time a resource was last backed up, in Unix format and Coordinated
    ///          Universal Time (UTC). The value of <code>LastBackupTime</code> is accurate to milliseconds.
    ///          For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let lastBackupTime: Date?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN
    ///          depends on the resource type.</p>
    public let resourceArn: String?
    /// <p>The type of AWS resource; for example, an Amazon Elastic Block Store (Amazon EBS) volume
    ///          or an Amazon Relational Database Service (Amazon RDS) database. For VSS Windows backups,
    ///          the only supported resource type is Amazon EC2.</p>
    public let resourceType: String?

    public init (
        lastBackupTime: Date? = nil,
        resourceArn: String? = nil,
        resourceType: String? = nil
    )
    {
        self.lastBackupTime = lastBackupTime
        self.resourceArn = resourceArn
        self.resourceType = resourceType
    }
}

public struct PutBackupVaultAccessPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutBackupVaultAccessPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBackupVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBackupVaultAccessPolicyInput>
    public typealias MOutput = OperationOutput<PutBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBackupVaultAccessPolicyOutputError>
}

extension PutBackupVaultAccessPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBackupVaultAccessPolicyInput(backupVaultName: \(String(describing: backupVaultName)), policy: \(String(describing: policy)))"}
}

extension PutBackupVaultAccessPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutBackupVaultAccessPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutBackupVaultAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBackupVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBackupVaultAccessPolicyInput>
    public typealias MOutput = OperationOutput<PutBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBackupVaultAccessPolicyOutputError>
}

public struct PutBackupVaultAccessPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBackupVaultAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBackupVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBackupVaultAccessPolicyInput>
    public typealias MOutput = OperationOutput<PutBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBackupVaultAccessPolicyOutputError>
}

public struct PutBackupVaultAccessPolicyInput: Equatable {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>The backup vault access policy document in JSON format.</p>
    public let policy: String?

    public init (
        backupVaultName: String? = nil,
        policy: String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.policy = policy
    }
}

struct PutBackupVaultAccessPolicyInputBody: Equatable {
    public let policy: String?
}

extension PutBackupVaultAccessPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutBackupVaultAccessPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutBackupVaultAccessPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBackupVaultAccessPolicyOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBackupVaultAccessPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBackupVaultAccessPolicyOutputResponse()"}
}

extension PutBackupVaultAccessPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBackupVaultAccessPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutBackupVaultAccessPolicyOutputResponseBody: Equatable {
}

extension PutBackupVaultAccessPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBackupVaultNotificationsInputBodyMiddleware: Middleware {
    public let id: String = "PutBackupVaultNotificationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBackupVaultNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBackupVaultNotificationsInput>
    public typealias MOutput = OperationOutput<PutBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBackupVaultNotificationsOutputError>
}

extension PutBackupVaultNotificationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBackupVaultNotificationsInput(backupVaultEvents: \(String(describing: backupVaultEvents)), backupVaultName: \(String(describing: backupVaultName)), sNSTopicArn: \(String(describing: sNSTopicArn)))"}
}

extension PutBackupVaultNotificationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupVaultEvents = "BackupVaultEvents"
        case sNSTopicArn = "SNSTopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupVaultEvents = backupVaultEvents {
            var backupVaultEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .backupVaultEvents)
            for backupvaultevents0 in backupVaultEvents {
                try backupVaultEventsContainer.encode(backupvaultevents0.rawValue)
            }
        }
        if let sNSTopicArn = sNSTopicArn {
            try encodeContainer.encode(sNSTopicArn, forKey: .sNSTopicArn)
        }
    }
}

public struct PutBackupVaultNotificationsInputHeadersMiddleware: Middleware {
    public let id: String = "PutBackupVaultNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBackupVaultNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBackupVaultNotificationsInput>
    public typealias MOutput = OperationOutput<PutBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBackupVaultNotificationsOutputError>
}

public struct PutBackupVaultNotificationsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBackupVaultNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBackupVaultNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBackupVaultNotificationsInput>
    public typealias MOutput = OperationOutput<PutBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBackupVaultNotificationsOutputError>
}

public struct PutBackupVaultNotificationsInput: Equatable {
    /// <p>An array of events that indicate the status of jobs to back up resources to the backup
    ///          vault.</p>
    public let backupVaultEvents: [BackupVaultEvent]?
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>The Amazon Resource Name (ARN) that specifies the topic for a backup vault’s events; for
    ///          example, <code>arn:aws:sns:us-west-2:111122223333:MyVaultTopic</code>.</p>
    public let sNSTopicArn: String?

    public init (
        backupVaultEvents: [BackupVaultEvent]? = nil,
        backupVaultName: String? = nil,
        sNSTopicArn: String? = nil
    )
    {
        self.backupVaultEvents = backupVaultEvents
        self.backupVaultName = backupVaultName
        self.sNSTopicArn = sNSTopicArn
    }
}

struct PutBackupVaultNotificationsInputBody: Equatable {
    public let sNSTopicArn: String?
    public let backupVaultEvents: [BackupVaultEvent]?
}

extension PutBackupVaultNotificationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupVaultEvents = "BackupVaultEvents"
        case sNSTopicArn = "SNSTopicArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sNSTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sNSTopicArn)
        sNSTopicArn = sNSTopicArnDecoded
        let backupVaultEventsContainer = try containerValues.decodeIfPresent([BackupVaultEvent?].self, forKey: .backupVaultEvents)
        var backupVaultEventsDecoded0:[BackupVaultEvent]? = nil
        if let backupVaultEventsContainer = backupVaultEventsContainer {
            backupVaultEventsDecoded0 = [BackupVaultEvent]()
            for string0 in backupVaultEventsContainer {
                if let string0 = string0 {
                    backupVaultEventsDecoded0?.append(string0)
                }
            }
        }
        backupVaultEvents = backupVaultEventsDecoded0
    }
}

extension PutBackupVaultNotificationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutBackupVaultNotificationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBackupVaultNotificationsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBackupVaultNotificationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBackupVaultNotificationsOutputResponse()"}
}

extension PutBackupVaultNotificationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBackupVaultNotificationsOutputResponse: Equatable {

    public init() {}
}

struct PutBackupVaultNotificationsOutputResponseBody: Equatable {
}

extension PutBackupVaultNotificationsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RecoveryPointByBackupVault: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case calculatedLifecycle = "CalculatedLifecycle"
        case completionDate = "CompletionDate"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case encryptionKeyArn = "EncryptionKeyArn"
        case iamRoleArn = "IamRoleArn"
        case isEncrypted = "IsEncrypted"
        case lastRestoreTime = "LastRestoreTime"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
        case sourceBackupVaultArn = "SourceBackupVaultArn"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupSizeInBytes = backupSizeInBytes {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let backupVaultArn = backupVaultArn {
            try encodeContainer.encode(backupVaultArn, forKey: .backupVaultArn)
        }
        if let backupVaultName = backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let calculatedLifecycle = calculatedLifecycle {
            try encodeContainer.encode(calculatedLifecycle, forKey: .calculatedLifecycle)
        }
        if let completionDate = completionDate {
            try encodeContainer.encode(completionDate.timeIntervalSince1970, forKey: .completionDate)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let encryptionKeyArn = encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if isEncrypted != false {
            try encodeContainer.encode(isEncrypted, forKey: .isEncrypted)
        }
        if let lastRestoreTime = lastRestoreTime {
            try encodeContainer.encode(lastRestoreTime.timeIntervalSince1970, forKey: .lastRestoreTime)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointArn = recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let sourceBackupVaultArn = sourceBackupVaultArn {
            try encodeContainer.encode(sourceBackupVaultArn, forKey: .sourceBackupVaultArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let sourceBackupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBackupVaultArn)
        sourceBackupVaultArn = sourceBackupVaultArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RecoveryPointStatus.self, forKey: .status)
        status = statusDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let calculatedLifecycleDecoded = try containerValues.decodeIfPresent(CalculatedLifecycle.self, forKey: .calculatedLifecycle)
        calculatedLifecycle = calculatedLifecycleDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let isEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .isEncrypted)
        isEncrypted = isEncryptedDecoded
        let lastRestoreTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastRestoreTime)
        lastRestoreTime = lastRestoreTimeDecoded
    }
}

extension RecoveryPointByBackupVault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecoveryPointByBackupVault(backupSizeInBytes: \(String(describing: backupSizeInBytes)), backupVaultArn: \(String(describing: backupVaultArn)), backupVaultName: \(String(describing: backupVaultName)), calculatedLifecycle: \(String(describing: calculatedLifecycle)), completionDate: \(String(describing: completionDate)), createdBy: \(String(describing: createdBy)), creationDate: \(String(describing: creationDate)), encryptionKeyArn: \(String(describing: encryptionKeyArn)), iamRoleArn: \(String(describing: iamRoleArn)), isEncrypted: \(String(describing: isEncrypted)), lastRestoreTime: \(String(describing: lastRestoreTime)), lifecycle: \(String(describing: lifecycle)), recoveryPointArn: \(String(describing: recoveryPointArn)), resourceArn: \(String(describing: resourceArn)), resourceType: \(String(describing: resourceType)), sourceBackupVaultArn: \(String(describing: sourceBackupVaultArn)), status: \(String(describing: status)))"}
}

/// <p>Contains detailed information about the recovery points stored in a backup vault.</p>
public struct RecoveryPointByBackupVault: Equatable {
    /// <p>The size, in bytes, of a backup.</p>
    public let backupSizeInBytes: Int?
    /// <p>An ARN that uniquely identifies a backup vault; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
    public let backupVaultArn: String?
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>A <code>CalculatedLifecycle</code> object containing <code>DeleteAt</code> and
    ///             <code>MoveToColdStorageAt</code> timestamps.</p>
    public let calculatedLifecycle: CalculatedLifecycle?
    /// <p>The date and time a job to restore a recovery point is completed, in Unix format and
    ///          Coordinated Universal Time (UTC). The value of <code>CompletionDate</code> is accurate to
    ///          milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018
    ///          12:11:30.087 AM.</p>
    public let completionDate: Date?
    /// <p>Contains identifying information about the creation of a recovery point, including the
    ///             <code>BackupPlanArn</code>, <code>BackupPlanId</code>, <code>BackupPlanVersion</code>,
    ///          and <code>BackupRuleId</code> of the backup plan that is used to create it.</p>
    public let createdBy: RecoveryPointCreator?
    /// <p>The date and time a recovery point is created, in Unix format and Coordinated Universal
    ///          Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds. For
    ///          example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?
    /// <p>The server-side encryption key that is used to protect your backups; for example,
    ///             <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
    public let encryptionKeyArn: String?
    /// <p>Specifies the IAM role ARN used to create the target recovery point; for example,
    ///             <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
    public let iamRoleArn: String?
    /// <p>A Boolean value that is returned as <code>TRUE</code> if the specified recovery point is
    ///          encrypted, or <code>FALSE</code> if the recovery point is not encrypted.</p>
    public let isEncrypted: Bool
    /// <p>The date and time a recovery point was last restored, in Unix format and Coordinated
    ///          Universal Time (UTC). The value of <code>LastRestoreTime</code> is accurate to
    ///          milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018
    ///          12:11:30.087 AM.</p>
    public let lastRestoreTime: Date?
    /// <p>The lifecycle defines when a protected resource is transitioned to cold storage and when
    ///          it expires. AWS Backup transitions and expires backups automatically according to the
    ///          lifecycle that you define. </p>
    ///          <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
    ///          days. Therefore, the “expire after days” setting must be 90 days greater than the
    ///          “transition to cold after days” setting. The “transition to cold after days” setting cannot
    ///          be changed after a backup has been transitioned to cold. </p>
    ///          <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
    public let lifecycle: Lifecycle?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let recoveryPointArn: String?
    /// <p>An ARN that uniquely identifies a resource. The format of the ARN depends on the
    ///          resource type.</p>
    public let resourceArn: String?
    /// <p>The type of AWS resource saved as a recovery point; for example, an Amazon Elastic Block
    ///          Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
    ///          For VSS Windows backups, the only supported resource type is Amazon EC2.</p>
    public let resourceType: String?
    /// <p>The backup vault where the recovery point was originally copied from. If the recovery
    ///          point is restored to the same account this value will be <code>null</code>.</p>
    public let sourceBackupVaultArn: String?
    /// <p>A status code specifying the state of the recovery point.</p>
    public let status: RecoveryPointStatus?

    public init (
        backupSizeInBytes: Int? = nil,
        backupVaultArn: String? = nil,
        backupVaultName: String? = nil,
        calculatedLifecycle: CalculatedLifecycle? = nil,
        completionDate: Date? = nil,
        createdBy: RecoveryPointCreator? = nil,
        creationDate: Date? = nil,
        encryptionKeyArn: String? = nil,
        iamRoleArn: String? = nil,
        isEncrypted: Bool = false,
        lastRestoreTime: Date? = nil,
        lifecycle: Lifecycle? = nil,
        recoveryPointArn: String? = nil,
        resourceArn: String? = nil,
        resourceType: String? = nil,
        sourceBackupVaultArn: String? = nil,
        status: RecoveryPointStatus? = nil
    )
    {
        self.backupSizeInBytes = backupSizeInBytes
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.calculatedLifecycle = calculatedLifecycle
        self.completionDate = completionDate
        self.createdBy = createdBy
        self.creationDate = creationDate
        self.encryptionKeyArn = encryptionKeyArn
        self.iamRoleArn = iamRoleArn
        self.isEncrypted = isEncrypted
        self.lastRestoreTime = lastRestoreTime
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
        self.resourceArn = resourceArn
        self.resourceType = resourceType
        self.sourceBackupVaultArn = sourceBackupVaultArn
        self.status = status
    }
}

extension RecoveryPointByResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupSizeBytes = "BackupSizeBytes"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
        case encryptionKeyArn = "EncryptionKeyArn"
        case recoveryPointArn = "RecoveryPointArn"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupSizeBytes = backupSizeBytes {
            try encodeContainer.encode(backupSizeBytes, forKey: .backupSizeBytes)
        }
        if let backupVaultName = backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let encryptionKeyArn = encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let recoveryPointArn = recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RecoveryPointStatus.self, forKey: .status)
        status = statusDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let backupSizeBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupSizeBytes)
        backupSizeBytes = backupSizeBytesDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
    }
}

extension RecoveryPointByResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecoveryPointByResource(backupSizeBytes: \(String(describing: backupSizeBytes)), backupVaultName: \(String(describing: backupVaultName)), creationDate: \(String(describing: creationDate)), encryptionKeyArn: \(String(describing: encryptionKeyArn)), recoveryPointArn: \(String(describing: recoveryPointArn)), status: \(String(describing: status)))"}
}

/// <p>Contains detailed information about a saved recovery point.</p>
public struct RecoveryPointByResource: Equatable {
    /// <p>The size, in bytes, of a backup.</p>
    public let backupSizeBytes: Int?
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>The date and time a recovery point is created, in Unix format and Coordinated Universal
    ///          Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds. For
    ///          example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?
    /// <p>The server-side encryption key that is used to protect your backups; for example,
    ///             <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
    public let encryptionKeyArn: String?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let recoveryPointArn: String?
    /// <p>A status code specifying the state of the recovery point.</p>
    public let status: RecoveryPointStatus?

    public init (
        backupSizeBytes: Int? = nil,
        backupVaultName: String? = nil,
        creationDate: Date? = nil,
        encryptionKeyArn: String? = nil,
        recoveryPointArn: String? = nil,
        status: RecoveryPointStatus? = nil
    )
    {
        self.backupSizeBytes = backupSizeBytes
        self.backupVaultName = backupVaultName
        self.creationDate = creationDate
        self.encryptionKeyArn = encryptionKeyArn
        self.recoveryPointArn = recoveryPointArn
        self.status = status
    }
}

extension RecoveryPointCreator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case backupPlanVersion = "BackupPlanVersion"
        case backupRuleId = "BackupRuleId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanArn = backupPlanArn {
            try encodeContainer.encode(backupPlanArn, forKey: .backupPlanArn)
        }
        if let backupPlanId = backupPlanId {
            try encodeContainer.encode(backupPlanId, forKey: .backupPlanId)
        }
        if let backupPlanVersion = backupPlanVersion {
            try encodeContainer.encode(backupPlanVersion, forKey: .backupPlanVersion)
        }
        if let backupRuleId = backupRuleId {
            try encodeContainer.encode(backupRuleId, forKey: .backupRuleId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let backupPlanVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanVersion)
        backupPlanVersion = backupPlanVersionDecoded
        let backupRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupRuleId)
        backupRuleId = backupRuleIdDecoded
    }
}

extension RecoveryPointCreator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecoveryPointCreator(backupPlanArn: \(String(describing: backupPlanArn)), backupPlanId: \(String(describing: backupPlanId)), backupPlanVersion: \(String(describing: backupPlanVersion)), backupRuleId: \(String(describing: backupRuleId)))"}
}

/// <p>Contains information about the backup plan and rule that AWS Backup used to initiate the
///          recovery point backup.</p>
public struct RecoveryPointCreator: Equatable {
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50</code>.</p>
    public let backupPlanArn: String?
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?
    /// <p>Version IDs are unique, randomly generated, Unicode, UTF-8 encoded strings that are at
    ///          most 1,024 bytes long. They cannot be edited.</p>
    public let backupPlanVersion: String?
    /// <p>Uniquely identifies a rule used to schedule the backup of a selection of
    ///          resources.</p>
    public let backupRuleId: String?

    public init (
        backupPlanArn: String? = nil,
        backupPlanId: String? = nil,
        backupPlanVersion: String? = nil,
        backupRuleId: String? = nil
    )
    {
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.backupPlanVersion = backupPlanVersion
        self.backupRuleId = backupRuleId
    }
}

public enum RecoveryPointStatus {
    case completed
    case deleting
    case expired
    case partial
    case sdkUnknown(String)
}

extension RecoveryPointStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RecoveryPointStatus] {
        return [
            .completed,
            .deleting,
            .expired,
            .partial,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .deleting: return "DELETING"
        case .expired: return "EXPIRED"
        case .partial: return "PARTIAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RecoveryPointStatus(rawValue: rawValue) ?? RecoveryPointStatus.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(code: \(String(describing: code)), context: \(String(describing: context)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource that is required for the action doesn't exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    /// <p></p>
    public var context: String?
    public var message: String?
    /// <p></p>
    public var type: String?

    public init (
        code: String? = nil,
        context: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let code: String?
    public let message: String?
    public let type: String?
    public let context: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .context)
        context = contextDecoded
    }
}

public enum RestoreJobStatus {
    case aborted
    case completed
    case failed
    case pending
    case running
    case sdkUnknown(String)
}

extension RestoreJobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RestoreJobStatus] {
        return [
            .aborted,
            .completed,
            .failed,
            .pending,
            .running,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aborted: return "ABORTED"
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case .running: return "RUNNING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RestoreJobStatus(rawValue: rawValue) ?? RestoreJobStatus.sdkUnknown(rawValue)
    }
}

extension RestoreJobsListMember: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case backupSizeInBytes = "BackupSizeInBytes"
        case completionDate = "CompletionDate"
        case createdResourceArn = "CreatedResourceArn"
        case creationDate = "CreationDate"
        case expectedCompletionTimeMinutes = "ExpectedCompletionTimeMinutes"
        case iamRoleArn = "IamRoleArn"
        case percentDone = "PercentDone"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceType = "ResourceType"
        case restoreJobId = "RestoreJobId"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let backupSizeInBytes = backupSizeInBytes {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let completionDate = completionDate {
            try encodeContainer.encode(completionDate.timeIntervalSince1970, forKey: .completionDate)
        }
        if let createdResourceArn = createdResourceArn {
            try encodeContainer.encode(createdResourceArn, forKey: .createdResourceArn)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let expectedCompletionTimeMinutes = expectedCompletionTimeMinutes {
            try encodeContainer.encode(expectedCompletionTimeMinutes, forKey: .expectedCompletionTimeMinutes)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let percentDone = percentDone {
            try encodeContainer.encode(percentDone, forKey: .percentDone)
        }
        if let recoveryPointArn = recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let restoreJobId = restoreJobId {
            try encodeContainer.encode(restoreJobId, forKey: .restoreJobId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let restoreJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .restoreJobId)
        restoreJobId = restoreJobIdDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RestoreJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let expectedCompletionTimeMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expectedCompletionTimeMinutes)
        expectedCompletionTimeMinutes = expectedCompletionTimeMinutesDecoded
        let createdResourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdResourceArn)
        createdResourceArn = createdResourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension RestoreJobsListMember: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreJobsListMember(accountId: \(String(describing: accountId)), backupSizeInBytes: \(String(describing: backupSizeInBytes)), completionDate: \(String(describing: completionDate)), createdResourceArn: \(String(describing: createdResourceArn)), creationDate: \(String(describing: creationDate)), expectedCompletionTimeMinutes: \(String(describing: expectedCompletionTimeMinutes)), iamRoleArn: \(String(describing: iamRoleArn)), percentDone: \(String(describing: percentDone)), recoveryPointArn: \(String(describing: recoveryPointArn)), resourceType: \(String(describing: resourceType)), restoreJobId: \(String(describing: restoreJobId)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

/// <p>Contains metadata about a restore job.</p>
public struct RestoreJobsListMember: Equatable {
    /// <p>The account ID that owns the restore job.</p>
    public let accountId: String?
    /// <p>The size, in bytes, of the restored resource.</p>
    public let backupSizeInBytes: Int?
    /// <p>The date and time a job to restore a recovery point is completed, in Unix format and
    ///          Coordinated Universal Time (UTC). The value of <code>CompletionDate</code> is accurate to
    ///          milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018
    ///          12:11:30.087 AM.</p>
    public let completionDate: Date?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN
    ///          depends on the resource type.</p>
    public let createdResourceArn: String?
    /// <p>The date and time a restore job is created, in Unix format and Coordinated Universal
    ///          Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds. For
    ///          example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?
    /// <p>The amount of time in minutes that a job restoring a recovery point is expected to
    ///          take.</p>
    public let expectedCompletionTimeMinutes: Int?
    /// <p>Specifies the IAM role ARN used to create the target recovery point; for example,
    ///             <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
    public let iamRoleArn: String?
    /// <p>Contains an estimated percentage complete of a job at the time the job status was
    ///          queried.</p>
    public let percentDone: String?
    /// <p>An ARN that uniquely identifies a recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let recoveryPointArn: String?
    /// <p>The resource type of the listed restore jobs; for example, an Amazon Elastic Block Store
    ///          (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For VSS
    ///          Windows backups, the only supported resource type is Amazon EC2.</p>
    public let resourceType: String?
    /// <p>Uniquely identifies the job that restores a recovery point.</p>
    public let restoreJobId: String?
    /// <p>A status code specifying the state of the job initiated by AWS Backup to restore a
    ///          recovery point.</p>
    public let status: RestoreJobStatus?
    /// <p>A detailed message explaining the status of the job to restore a recovery point.</p>
    public let statusMessage: String?

    public init (
        accountId: String? = nil,
        backupSizeInBytes: Int? = nil,
        completionDate: Date? = nil,
        createdResourceArn: String? = nil,
        creationDate: Date? = nil,
        expectedCompletionTimeMinutes: Int? = nil,
        iamRoleArn: String? = nil,
        percentDone: String? = nil,
        recoveryPointArn: String? = nil,
        resourceType: String? = nil,
        restoreJobId: String? = nil,
        status: RestoreJobStatus? = nil,
        statusMessage: String? = nil
    )
    {
        self.accountId = accountId
        self.backupSizeInBytes = backupSizeInBytes
        self.completionDate = completionDate
        self.createdResourceArn = createdResourceArn
        self.creationDate = creationDate
        self.expectedCompletionTimeMinutes = expectedCompletionTimeMinutes
        self.iamRoleArn = iamRoleArn
        self.percentDone = percentDone
        self.recoveryPointArn = recoveryPointArn
        self.resourceType = resourceType
        self.restoreJobId = restoreJobId
        self.status = status
        self.statusMessage = statusMessage
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(code: \(String(describing: code)), context: \(String(describing: context)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed due to a temporary failure of the server.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var code: String?
    /// <p></p>
    public var context: String?
    public var message: String?
    /// <p></p>
    public var type: String?

    public init (
        code: String? = nil,
        context: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let code: String?
    public let message: String?
    public let type: String?
    public let context: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .context)
        context = contextDecoded
    }
}

public struct StartBackupJobInputBodyMiddleware: Middleware {
    public let id: String = "StartBackupJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBackupJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBackupJobInput>
    public typealias MOutput = OperationOutput<StartBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBackupJobOutputError>
}

extension StartBackupJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartBackupJobInput(backupOptions: \(String(describing: backupOptions)), backupVaultName: \(String(describing: backupVaultName)), completeWindowMinutes: \(String(describing: completeWindowMinutes)), iamRoleArn: \(String(describing: iamRoleArn)), idempotencyToken: \(String(describing: idempotencyToken)), lifecycle: \(String(describing: lifecycle)), recoveryPointTags: \(String(describing: recoveryPointTags)), resourceArn: \(String(describing: resourceArn)), startWindowMinutes: \(String(describing: startWindowMinutes)))"}
}

extension StartBackupJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupOptions = "BackupOptions"
        case backupVaultName = "BackupVaultName"
        case completeWindowMinutes = "CompleteWindowMinutes"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case lifecycle = "Lifecycle"
        case recoveryPointTags = "RecoveryPointTags"
        case resourceArn = "ResourceArn"
        case startWindowMinutes = "StartWindowMinutes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupOptions = backupOptions {
            var backupOptionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .backupOptions)
            for (dictKey0, backupoptions0) in backupOptions {
                try backupOptionsContainer.encode(backupoptions0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let backupVaultName = backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let completeWindowMinutes = completeWindowMinutes {
            try encodeContainer.encode(completeWindowMinutes, forKey: .completeWindowMinutes)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointTags = recoveryPointTags {
            var recoveryPointTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .recoveryPointTags)
            for (dictKey0, tags0) in recoveryPointTags {
                try recoveryPointTagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let startWindowMinutes = startWindowMinutes {
            try encodeContainer.encode(startWindowMinutes, forKey: .startWindowMinutes)
        }
    }
}

public struct StartBackupJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartBackupJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBackupJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBackupJobInput>
    public typealias MOutput = OperationOutput<StartBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBackupJobOutputError>
}

public struct StartBackupJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartBackupJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartBackupJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartBackupJobInput>
    public typealias MOutput = OperationOutput<StartBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartBackupJobOutputError>
}

public struct StartBackupJobInput: Equatable {
    /// <p>Specifies the backup option for a selected resource. This option is only available for
    ///          Windows VSS backup jobs.</p>
    ///          <p>Valid values: Set to <code>"WindowsVSS”:“enabled"</code> to enable WindowsVSS backup
    ///          option and create a VSS Windows backup. Set to “WindowsVSS”:”disabled” to create a regular
    ///          backup. The WindowsVSS option is not enabled by default.</p>
    public let backupOptions: [String:String]?
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>A value in minutes during which a successfully started backup must complete, or else AWS
    ///          Backup will cancel the job. This value is optional. This value begins counting down from
    ///          when the backup was scheduled. It does not add additional time for
    ///             <code>StartWindowMinutes</code>, or if the backup started later than scheduled.</p>
    public let completeWindowMinutes: Int?
    /// <p>Specifies the IAM role ARN used to create the target recovery point; for example,
    ///             <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
    public let iamRoleArn: String?
    /// <p>A customer chosen string that can be used to distinguish between calls to
    ///             <code>StartBackupJob</code>.</p>
    public let idempotencyToken: String?
    /// <p>The lifecycle defines when a protected resource is transitioned to cold storage and when
    ///          it expires. AWS Backup will transition and expire backups automatically according to the
    ///          lifecycle that you define. </p>
    ///          <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
    ///          days. Therefore, the “expire after days” setting must be 90 days greater than the
    ///          “transition to cold after days” setting. The “transition to cold after days” setting cannot
    ///          be changed after a backup has been transitioned to cold. </p>
    ///          <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
    public let lifecycle: Lifecycle?
    /// <p>To help organize your resources, you can assign your own metadata to the resources that
    ///          you create. Each tag is a key-value pair.</p>
    public let recoveryPointTags: [String:String]?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN
    ///          depends on the resource type.</p>
    public let resourceArn: String?
    /// <p>A value in minutes after a backup is scheduled before a job will be canceled if it
    ///          doesn't start successfully. This value is optional, and the default is 8 hours.</p>
    public let startWindowMinutes: Int?

    public init (
        backupOptions: [String:String]? = nil,
        backupVaultName: String? = nil,
        completeWindowMinutes: Int? = nil,
        iamRoleArn: String? = nil,
        idempotencyToken: String? = nil,
        lifecycle: Lifecycle? = nil,
        recoveryPointTags: [String:String]? = nil,
        resourceArn: String? = nil,
        startWindowMinutes: Int? = nil
    )
    {
        self.backupOptions = backupOptions
        self.backupVaultName = backupVaultName
        self.completeWindowMinutes = completeWindowMinutes
        self.iamRoleArn = iamRoleArn
        self.idempotencyToken = idempotencyToken
        self.lifecycle = lifecycle
        self.recoveryPointTags = recoveryPointTags
        self.resourceArn = resourceArn
        self.startWindowMinutes = startWindowMinutes
    }
}

struct StartBackupJobInputBody: Equatable {
    public let backupVaultName: String?
    public let resourceArn: String?
    public let iamRoleArn: String?
    public let idempotencyToken: String?
    public let startWindowMinutes: Int?
    public let completeWindowMinutes: Int?
    public let lifecycle: Lifecycle?
    public let recoveryPointTags: [String:String]?
    public let backupOptions: [String:String]?
}

extension StartBackupJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupOptions = "BackupOptions"
        case backupVaultName = "BackupVaultName"
        case completeWindowMinutes = "CompleteWindowMinutes"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case lifecycle = "Lifecycle"
        case recoveryPointTags = "RecoveryPointTags"
        case resourceArn = "ResourceArn"
        case startWindowMinutes = "StartWindowMinutes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let startWindowMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .startWindowMinutes)
        startWindowMinutes = startWindowMinutesDecoded
        let completeWindowMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .completeWindowMinutes)
        completeWindowMinutes = completeWindowMinutesDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let recoveryPointTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .recoveryPointTags)
        var recoveryPointTagsDecoded0: [String:String]? = nil
        if let recoveryPointTagsContainer = recoveryPointTagsContainer {
            recoveryPointTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in recoveryPointTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    recoveryPointTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        recoveryPointTags = recoveryPointTagsDecoded0
        let backupOptionsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [String:String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [String:String]()
            for (key0, backupoptionvalue0) in backupOptionsContainer {
                if let backupoptionvalue0 = backupoptionvalue0 {
                    backupOptionsDecoded0?[key0] = backupoptionvalue0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
    }
}

extension StartBackupJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartBackupJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartBackupJobOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartBackupJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartBackupJobOutputResponse(backupJobId: \(String(describing: backupJobId)), creationDate: \(String(describing: creationDate)), recoveryPointArn: \(String(describing: recoveryPointArn)))"}
}

extension StartBackupJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartBackupJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupJobId = output.backupJobId
            self.creationDate = output.creationDate
            self.recoveryPointArn = output.recoveryPointArn
        } else {
            self.backupJobId = nil
            self.creationDate = nil
            self.recoveryPointArn = nil
        }
    }
}

public struct StartBackupJobOutputResponse: Equatable {
    /// <p>Uniquely identifies a request to AWS Backup to back up a resource.</p>
    public let backupJobId: String?
    /// <p>The date and time that a backup job is created, in Unix format and Coordinated Universal
    ///          Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds. For
    ///          example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?
    /// <p>An ARN that uniquely identifies a recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let recoveryPointArn: String?

    public init (
        backupJobId: String? = nil,
        creationDate: Date? = nil,
        recoveryPointArn: String? = nil
    )
    {
        self.backupJobId = backupJobId
        self.creationDate = creationDate
        self.recoveryPointArn = recoveryPointArn
    }
}

struct StartBackupJobOutputResponseBody: Equatable {
    public let backupJobId: String?
    public let recoveryPointArn: String?
    public let creationDate: Date?
}

extension StartBackupJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupJobId = "BackupJobId"
        case creationDate = "CreationDate"
        case recoveryPointArn = "RecoveryPointArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupJobId)
        backupJobId = backupJobIdDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

public struct StartCopyJobInputBodyMiddleware: Middleware {
    public let id: String = "StartCopyJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCopyJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCopyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCopyJobInput>
    public typealias MOutput = OperationOutput<StartCopyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCopyJobOutputError>
}

extension StartCopyJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartCopyJobInput(destinationBackupVaultArn: \(String(describing: destinationBackupVaultArn)), iamRoleArn: \(String(describing: iamRoleArn)), idempotencyToken: \(String(describing: idempotencyToken)), lifecycle: \(String(describing: lifecycle)), recoveryPointArn: \(String(describing: recoveryPointArn)), sourceBackupVaultName: \(String(describing: sourceBackupVaultName)))"}
}

extension StartCopyJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
        case sourceBackupVaultName = "SourceBackupVaultName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationBackupVaultArn = destinationBackupVaultArn {
            try encodeContainer.encode(destinationBackupVaultArn, forKey: .destinationBackupVaultArn)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointArn = recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let sourceBackupVaultName = sourceBackupVaultName {
            try encodeContainer.encode(sourceBackupVaultName, forKey: .sourceBackupVaultName)
        }
    }
}

public struct StartCopyJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartCopyJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCopyJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCopyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCopyJobInput>
    public typealias MOutput = OperationOutput<StartCopyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCopyJobOutputError>
}

public struct StartCopyJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartCopyJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCopyJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCopyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCopyJobInput>
    public typealias MOutput = OperationOutput<StartCopyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCopyJobOutputError>
}

public struct StartCopyJobInput: Equatable {
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a destination backup vault to
    ///          copy to; for example,
    ///          <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
    public let destinationBackupVaultArn: String?
    /// <p>Specifies the IAM role ARN used to copy the target recovery point; for example,
    ///             <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
    public let iamRoleArn: String?
    /// <p>A customer chosen string that can be used to distinguish between calls to
    ///             <code>StartCopyJob</code>.</p>
    public let idempotencyToken: String?
    /// <p>Contains an array of <code>Transition</code> objects specifying how long in days before
    ///          a recovery point transitions to cold storage or is deleted.</p>
    ///          <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
    ///          days. Therefore, on the console, the “expire after days” setting must be 90 days greater
    ///          than the “transition to cold after days” setting. The “transition to cold after days”
    ///          setting cannot be changed after a backup has been transitioned to cold.</p>
    ///          <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
    public let lifecycle: Lifecycle?
    /// <p>An ARN that uniquely identifies a recovery point to use for the copy job; for example,
    ///          arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    ///       </p>
    public let recoveryPointArn: String?
    /// <p>The name of a logical source container where backups are stored. Backup vaults are
    ///          identified by names that are unique to the account used to create them and the AWS Region
    ///          where they are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let sourceBackupVaultName: String?

    public init (
        destinationBackupVaultArn: String? = nil,
        iamRoleArn: String? = nil,
        idempotencyToken: String? = nil,
        lifecycle: Lifecycle? = nil,
        recoveryPointArn: String? = nil,
        sourceBackupVaultName: String? = nil
    )
    {
        self.destinationBackupVaultArn = destinationBackupVaultArn
        self.iamRoleArn = iamRoleArn
        self.idempotencyToken = idempotencyToken
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
        self.sourceBackupVaultName = sourceBackupVaultName
    }
}

struct StartCopyJobInputBody: Equatable {
    public let recoveryPointArn: String?
    public let sourceBackupVaultName: String?
    public let destinationBackupVaultArn: String?
    public let iamRoleArn: String?
    public let idempotencyToken: String?
    public let lifecycle: Lifecycle?
}

extension StartCopyJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
        case sourceBackupVaultName = "SourceBackupVaultName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let sourceBackupVaultNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBackupVaultName)
        sourceBackupVaultName = sourceBackupVaultNameDecoded
        let destinationBackupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationBackupVaultArn)
        destinationBackupVaultArn = destinationBackupVaultArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
    }
}

extension StartCopyJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartCopyJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartCopyJobOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartCopyJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartCopyJobOutputResponse(copyJobId: \(String(describing: copyJobId)), creationDate: \(String(describing: creationDate)))"}
}

extension StartCopyJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartCopyJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.copyJobId = output.copyJobId
            self.creationDate = output.creationDate
        } else {
            self.copyJobId = nil
            self.creationDate = nil
        }
    }
}

public struct StartCopyJobOutputResponse: Equatable {
    /// <p>Uniquely identifies a copy job.</p>
    public let copyJobId: String?
    /// <p>The date and time that a copy job is created, in Unix format and Coordinated Universal
    ///          Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds. For
    ///          example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?

    public init (
        copyJobId: String? = nil,
        creationDate: Date? = nil
    )
    {
        self.copyJobId = copyJobId
        self.creationDate = creationDate
    }
}

struct StartCopyJobOutputResponseBody: Equatable {
    public let copyJobId: String?
    public let creationDate: Date?
}

extension StartCopyJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case copyJobId = "CopyJobId"
        case creationDate = "CreationDate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .copyJobId)
        copyJobId = copyJobIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

public struct StartRestoreJobInputBodyMiddleware: Middleware {
    public let id: String = "StartRestoreJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartRestoreJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartRestoreJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartRestoreJobInput>
    public typealias MOutput = OperationOutput<StartRestoreJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartRestoreJobOutputError>
}

extension StartRestoreJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartRestoreJobInput(iamRoleArn: \(String(describing: iamRoleArn)), idempotencyToken: \(String(describing: idempotencyToken)), metadata: \(String(describing: metadata)), recoveryPointArn: \(String(describing: recoveryPointArn)), resourceType: \(String(describing: resourceType)))"}
}

extension StartRestoreJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case metadata = "Metadata"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metadata)
            for (dictKey0, metadata0) in metadata {
                try metadataContainer.encode(metadata0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let recoveryPointArn = recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

public struct StartRestoreJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartRestoreJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartRestoreJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartRestoreJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartRestoreJobInput>
    public typealias MOutput = OperationOutput<StartRestoreJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartRestoreJobOutputError>
}

public struct StartRestoreJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartRestoreJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartRestoreJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartRestoreJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartRestoreJobInput>
    public typealias MOutput = OperationOutput<StartRestoreJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartRestoreJobOutputError>
}

public struct StartRestoreJobInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the IAM role that AWS Backup uses to create the target
    ///          recovery point; for example, <code>arn:aws:iam::123456789012:role/S3Access</code>.</p>
    public let iamRoleArn: String?
    /// <p>A customer chosen string that can be used to distinguish between calls to
    ///             <code>StartRestoreJob</code>.</p>
    public let idempotencyToken: String?
    /// <p>A set of metadata key-value pairs. Contains information, such as a resource name,
    ///          required to restore a recovery point.</p>
    ///          <p> You can get configuration metadata about a resource at the time it was backed up by
    ///          calling <code>GetRecoveryPointRestoreMetadata</code>. However, values in addition to those
    ///          provided by <code>GetRecoveryPointRestoreMetadata</code> might be required to restore a
    ///          resource. For example, you might need to provide a new resource name if the original
    ///          already exists.</p>
    ///          <p>You need to specify specific metadata to restore an Amazon Elastic File System (Amazon
    ///          EFS) instance:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>file-system-id</code>: The ID of the Amazon EFS file system that is backed
    ///                up by AWS Backup. Returned in <code>GetRecoveryPointRestoreMetadata</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Encrypted</code>: A Boolean value that, if true, specifies that the file
    ///                system is encrypted. If <code>KmsKeyId</code> is specified, <code>Encrypted</code>
    ///                must be set to <code>true</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>KmsKeyId</code>: Specifies the AWS KMS key that is used to encrypt the
    ///                restored file system. You can specify a key from another AWS account provided that
    ///                key it is properly shared with your account via AWS KMS.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PerformanceMode</code>: Specifies the throughput mode of the file
    ///                system.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CreationToken</code>: A user-supplied value that ensures the uniqueness
    ///                (idempotency) of the request.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>newFileSystem</code>: A Boolean value that, if true, specifies that the
    ///                recovery point is restored to a new Amazon EFS file system.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ItemsToRestore </code>: An array of one to five strings where each string is
    ///                a file path. Use <code>ItemsToRestore</code> to restore specific files or directories
    ///                rather than the entire file system. This parameter is optional. For example,
    ///                   <code>"itemsToRestore":"[\"/my.test\"]"</code>.</p>
    ///             </li>
    ///          </ul>
    public let metadata: [String:String]?
    /// <p>An ARN that uniquely identifies a recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let recoveryPointArn: String?
    /// <p>Starts a job to restore a recovery point for one of the following resources:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DynamoDB</code> for Amazon DynamoDB</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EBS</code> for Amazon Elastic Block Store</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EC2</code> for Amazon Elastic Compute Cloud</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EFS</code> for Amazon Elastic File System</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RDS</code> for Amazon Relational Database Service</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Aurora</code> for Amazon Aurora</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Storage Gateway</code> for AWS Storage Gateway</p>
    ///             </li>
    ///          </ul>
    public let resourceType: String?

    public init (
        iamRoleArn: String? = nil,
        idempotencyToken: String? = nil,
        metadata: [String:String]? = nil,
        recoveryPointArn: String? = nil,
        resourceType: String? = nil
    )
    {
        self.iamRoleArn = iamRoleArn
        self.idempotencyToken = idempotencyToken
        self.metadata = metadata
        self.recoveryPointArn = recoveryPointArn
        self.resourceType = resourceType
    }
}

struct StartRestoreJobInputBody: Equatable {
    public let recoveryPointArn: String?
    public let metadata: [String:String]?
    public let iamRoleArn: String?
    public let idempotencyToken: String?
    public let resourceType: String?
}

extension StartRestoreJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case metadata = "Metadata"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let metadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .metadata)
        var metadataDecoded0: [String:String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [String:String]()
            for (key0, metadatavalue0) in metadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    metadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        metadata = metadataDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension StartRestoreJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartRestoreJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartRestoreJobOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartRestoreJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartRestoreJobOutputResponse(restoreJobId: \(String(describing: restoreJobId)))"}
}

extension StartRestoreJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartRestoreJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.restoreJobId = output.restoreJobId
        } else {
            self.restoreJobId = nil
        }
    }
}

public struct StartRestoreJobOutputResponse: Equatable {
    /// <p>Uniquely identifies the job that restores a recovery point.</p>
    public let restoreJobId: String?

    public init (
        restoreJobId: String? = nil
    )
    {
        self.restoreJobId = restoreJobId
    }
}

struct StartRestoreJobOutputResponseBody: Equatable {
    public let restoreJobId: String?
}

extension StartRestoreJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case restoreJobId = "RestoreJobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restoreJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .restoreJobId)
        restoreJobId = restoreJobIdDecoded
    }
}

extension StopBackupJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopBackupJobInput(backupJobId: \(String(describing: backupJobId)))"}
}

extension StopBackupJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StopBackupJobInputHeadersMiddleware: Middleware {
    public let id: String = "StopBackupJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopBackupJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopBackupJobInput>
    public typealias MOutput = OperationOutput<StopBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopBackupJobOutputError>
}

public struct StopBackupJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StopBackupJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopBackupJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopBackupJobInput>
    public typealias MOutput = OperationOutput<StopBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopBackupJobOutputError>
}

public struct StopBackupJobInput: Equatable {
    /// <p>Uniquely identifies a request to AWS Backup to back up a resource.</p>
    public let backupJobId: String?

    public init (
        backupJobId: String? = nil
    )
    {
        self.backupJobId = backupJobId
    }
}

struct StopBackupJobInputBody: Equatable {
}

extension StopBackupJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StopBackupJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopBackupJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopBackupJobOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopBackupJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopBackupJobOutputResponse()"}
}

extension StopBackupJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopBackupJobOutputResponse: Equatable {

    public init() {}
}

struct StopBackupJobOutputResponseBody: Equatable {
}

extension StopBackupJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum StorageClass {
    case cold
    case deleted
    case warm
    case sdkUnknown(String)
}

extension StorageClass : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StorageClass] {
        return [
            .cold,
            .deleted,
            .warm,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cold: return "COLD"
        case .deleted: return "DELETED"
        case .warm: return "WARM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StorageClass(rawValue: rawValue) ?? StorageClass.sdkUnknown(rawValue)
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>An ARN that uniquely identifies a resource. The format of the ARN depends on the type of
    ///          the tagged resource.</p>
    public let resourceArn: String?
    /// <p>Key-value pairs that are used to help organize your resources. You can assign your own
    ///          metadata to the resources you create.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeyList: \(String(describing: tagKeyList)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for tagkeylist0 in tagKeyList {
                try tagKeyListContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>An ARN that uniquely identifies a resource. The format of the ARN depends on the type of
    ///          the tagged resource.</p>
    public let resourceArn: String?
    /// <p>A list of keys to identify which key-value tags to remove from a resource.</p>
    public let tagKeyList: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeyList: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeyList = tagKeyList
    }
}

struct UntagResourceInputBody: Equatable {
    public let tagKeyList: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagKeyList = "TagKeyList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateBackupPlanInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBackupPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBackupPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBackupPlanInput>
    public typealias MOutput = OperationOutput<UpdateBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBackupPlanOutputError>
}

extension UpdateBackupPlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackupPlanInput(backupPlan: \(String(describing: backupPlan)), backupPlanId: \(String(describing: backupPlanId)))"}
}

extension UpdateBackupPlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupPlan = "BackupPlan"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlan = backupPlan {
            try encodeContainer.encode(backupPlan, forKey: .backupPlan)
        }
    }
}

public struct UpdateBackupPlanInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBackupPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBackupPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBackupPlanInput>
    public typealias MOutput = OperationOutput<UpdateBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBackupPlanOutputError>
}

public struct UpdateBackupPlanInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBackupPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBackupPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBackupPlanInput>
    public typealias MOutput = OperationOutput<UpdateBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBackupPlanOutputError>
}

public struct UpdateBackupPlanInput: Equatable {
    /// <p>Specifies the body of a backup plan. Includes a <code>BackupPlanName</code> and one or
    ///          more sets of <code>Rules</code>.</p>
    public let backupPlan: BackupPlanInput?
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?

    public init (
        backupPlan: BackupPlanInput? = nil,
        backupPlanId: String? = nil
    )
    {
        self.backupPlan = backupPlan
        self.backupPlanId = backupPlanId
    }
}

struct UpdateBackupPlanInputBody: Equatable {
    public let backupPlan: BackupPlanInput?
}

extension UpdateBackupPlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupPlan = "BackupPlan"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(BackupPlanInput.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
    }
}

extension UpdateBackupPlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBackupPlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBackupPlanOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBackupPlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackupPlanOutputResponse(advancedBackupSettings: \(String(describing: advancedBackupSettings)), backupPlanArn: \(String(describing: backupPlanArn)), backupPlanId: \(String(describing: backupPlanId)), creationDate: \(String(describing: creationDate)), versionId: \(String(describing: versionId)))"}
}

extension UpdateBackupPlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBackupPlanOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.advancedBackupSettings = output.advancedBackupSettings
            self.backupPlanArn = output.backupPlanArn
            self.backupPlanId = output.backupPlanId
            self.creationDate = output.creationDate
            self.versionId = output.versionId
        } else {
            self.advancedBackupSettings = nil
            self.backupPlanArn = nil
            self.backupPlanId = nil
            self.creationDate = nil
            self.versionId = nil
        }
    }
}

public struct UpdateBackupPlanOutputResponse: Equatable {
    /// <p>Contains a list of <code>BackupOptions</code> for each resource type.</p>
    public let advancedBackupSettings: [AdvancedBackupSetting]?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50</code>.</p>
    public let backupPlanArn: String?
    /// <p>Uniquely identifies a backup plan.</p>
    public let backupPlanId: String?
    /// <p>The date and time a backup plan is updated, in Unix format and Coordinated Universal
    ///          Time (UTC). The value of <code>CreationDate</code> is accurate to milliseconds. For
    ///          example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
    ///          AM.</p>
    public let creationDate: Date?
    /// <p>Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes
    ///          long. Version Ids cannot be edited.</p>
    public let versionId: String?

    public init (
        advancedBackupSettings: [AdvancedBackupSetting]? = nil,
        backupPlanArn: String? = nil,
        backupPlanId: String? = nil,
        creationDate: Date? = nil,
        versionId: String? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.versionId = versionId
    }
}

struct UpdateBackupPlanOutputResponseBody: Equatable {
    public let backupPlanId: String?
    public let backupPlanArn: String?
    public let creationDate: Date?
    public let versionId: String?
    public let advancedBackupSettings: [AdvancedBackupSetting]?
}

extension UpdateBackupPlanOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case versionId = "VersionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

public struct UpdateGlobalSettingsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGlobalSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGlobalSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGlobalSettingsInput>
    public typealias MOutput = OperationOutput<UpdateGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGlobalSettingsOutputError>
}

extension UpdateGlobalSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGlobalSettingsInput(globalSettings: \(String(describing: globalSettings)))"}
}

extension UpdateGlobalSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case globalSettings = "GlobalSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let globalSettings = globalSettings {
            var globalSettingsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .globalSettings)
            for (dictKey0, globalsettings0) in globalSettings {
                try globalSettingsContainer.encode(globalsettings0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateGlobalSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGlobalSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGlobalSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGlobalSettingsInput>
    public typealias MOutput = OperationOutput<UpdateGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGlobalSettingsOutputError>
}

public struct UpdateGlobalSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGlobalSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGlobalSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGlobalSettingsInput>
    public typealias MOutput = OperationOutput<UpdateGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGlobalSettingsOutputError>
}

public struct UpdateGlobalSettingsInput: Equatable {
    /// <p>A list of resources along with the opt-in preferences for the account.</p>
    public let globalSettings: [String:String]?

    public init (
        globalSettings: [String:String]? = nil
    )
    {
        self.globalSettings = globalSettings
    }
}

struct UpdateGlobalSettingsInputBody: Equatable {
    public let globalSettings: [String:String]?
}

extension UpdateGlobalSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case globalSettings = "GlobalSettings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalSettingsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .globalSettings)
        var globalSettingsDecoded0: [String:String]? = nil
        if let globalSettingsContainer = globalSettingsContainer {
            globalSettingsDecoded0 = [String:String]()
            for (key0, globalsettingsvalue0) in globalSettingsContainer {
                if let globalsettingsvalue0 = globalsettingsvalue0 {
                    globalSettingsDecoded0?[key0] = globalsettingsvalue0
                }
            }
        }
        globalSettings = globalSettingsDecoded0
    }
}

extension UpdateGlobalSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGlobalSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGlobalSettingsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGlobalSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGlobalSettingsOutputResponse()"}
}

extension UpdateGlobalSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGlobalSettingsOutputResponse: Equatable {

    public init() {}
}

struct UpdateGlobalSettingsOutputResponseBody: Equatable {
}

extension UpdateGlobalSettingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRecoveryPointLifecycleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRecoveryPointLifecycleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRecoveryPointLifecycleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRecoveryPointLifecycleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRecoveryPointLifecycleInput>
    public typealias MOutput = OperationOutput<UpdateRecoveryPointLifecycleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRecoveryPointLifecycleOutputError>
}

extension UpdateRecoveryPointLifecycleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRecoveryPointLifecycleInput(backupVaultName: \(String(describing: backupVaultName)), lifecycle: \(String(describing: lifecycle)), recoveryPointArn: \(String(describing: recoveryPointArn)))"}
}

extension UpdateRecoveryPointLifecycleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lifecycle = "Lifecycle"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
    }
}

public struct UpdateRecoveryPointLifecycleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRecoveryPointLifecycleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRecoveryPointLifecycleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRecoveryPointLifecycleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRecoveryPointLifecycleInput>
    public typealias MOutput = OperationOutput<UpdateRecoveryPointLifecycleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRecoveryPointLifecycleOutputError>
}

public struct UpdateRecoveryPointLifecycleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRecoveryPointLifecycleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRecoveryPointLifecycleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRecoveryPointLifecycleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRecoveryPointLifecycleInput>
    public typealias MOutput = OperationOutput<UpdateRecoveryPointLifecycleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRecoveryPointLifecycleOutputError>
}

public struct UpdateRecoveryPointLifecycleInput: Equatable {
    /// <p>The name of a logical container where backups are stored. Backup vaults are identified
    ///          by names that are unique to the account used to create them and the AWS Region where they
    ///          are created. They consist of lowercase letters, numbers, and hyphens.</p>
    public let backupVaultName: String?
    /// <p>The lifecycle defines when a protected resource is transitioned to cold storage and when
    ///          it expires. AWS Backup transitions and expires backups automatically according to the
    ///          lifecycle that you define. </p>
    ///          <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
    ///          days. Therefore, the “expire after days” setting must be 90 days greater than the
    ///          “transition to cold after days” setting. The “transition to cold after days” setting cannot
    ///          be changed after a backup has been transitioned to cold. </p>
    public let lifecycle: Lifecycle?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let recoveryPointArn: String?

    public init (
        backupVaultName: String? = nil,
        lifecycle: Lifecycle? = nil,
        recoveryPointArn: String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
    }
}

struct UpdateRecoveryPointLifecycleInputBody: Equatable {
    public let lifecycle: Lifecycle?
}

extension UpdateRecoveryPointLifecycleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lifecycle = "Lifecycle"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleDecoded = try containerValues.decodeIfPresent(Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
    }
}

extension UpdateRecoveryPointLifecycleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRecoveryPointLifecycleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRecoveryPointLifecycleOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRecoveryPointLifecycleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRecoveryPointLifecycleOutputResponse(backupVaultArn: \(String(describing: backupVaultArn)), calculatedLifecycle: \(String(describing: calculatedLifecycle)), lifecycle: \(String(describing: lifecycle)), recoveryPointArn: \(String(describing: recoveryPointArn)))"}
}

extension UpdateRecoveryPointLifecycleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRecoveryPointLifecycleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backupVaultArn = output.backupVaultArn
            self.calculatedLifecycle = output.calculatedLifecycle
            self.lifecycle = output.lifecycle
            self.recoveryPointArn = output.recoveryPointArn
        } else {
            self.backupVaultArn = nil
            self.calculatedLifecycle = nil
            self.lifecycle = nil
            self.recoveryPointArn = nil
        }
    }
}

public struct UpdateRecoveryPointLifecycleOutputResponse: Equatable {
    /// <p>An ARN that uniquely identifies a backup vault; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:vault:aBackupVault</code>.</p>
    public let backupVaultArn: String?
    /// <p>A <code>CalculatedLifecycle</code> object containing <code>DeleteAt</code> and
    ///             <code>MoveToColdStorageAt</code> timestamps.</p>
    public let calculatedLifecycle: CalculatedLifecycle?
    /// <p>The lifecycle defines when a protected resource is transitioned to cold storage and when
    ///          it expires. AWS Backup transitions and expires backups automatically according to the
    ///          lifecycle that you define. </p>
    ///          <p>Backups transitioned to cold storage must be stored in cold storage for a minimum of 90
    ///          days. Therefore, the “expire after days” setting must be 90 days greater than the
    ///          “transition to cold after days” setting. The “transition to cold after days” setting cannot
    ///          be changed after a backup has been transitioned to cold. </p>
    ///          <p>Only Amazon EFS file system backups can be transitioned to cold storage.</p>
    public let lifecycle: Lifecycle?
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example,
    ///             <code>arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45</code>.</p>
    public let recoveryPointArn: String?

    public init (
        backupVaultArn: String? = nil,
        calculatedLifecycle: CalculatedLifecycle? = nil,
        lifecycle: Lifecycle? = nil,
        recoveryPointArn: String? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.calculatedLifecycle = calculatedLifecycle
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
    }
}

struct UpdateRecoveryPointLifecycleOutputResponseBody: Equatable {
    public let backupVaultArn: String?
    public let recoveryPointArn: String?
    public let lifecycle: Lifecycle?
    public let calculatedLifecycle: CalculatedLifecycle?
}

extension UpdateRecoveryPointLifecycleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case calculatedLifecycle = "CalculatedLifecycle"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let calculatedLifecycleDecoded = try containerValues.decodeIfPresent(CalculatedLifecycle.self, forKey: .calculatedLifecycle)
        calculatedLifecycle = calculatedLifecycleDecoded
    }
}

public struct UpdateRegionSettingsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRegionSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegionSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegionSettingsInput>
    public typealias MOutput = OperationOutput<UpdateRegionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegionSettingsOutputError>
}

extension UpdateRegionSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRegionSettingsInput(resourceTypeOptInPreference: \(String(describing: resourceTypeOptInPreference)))"}
}

extension UpdateRegionSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceTypeOptInPreference = "ResourceTypeOptInPreference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceTypeOptInPreference = resourceTypeOptInPreference {
            var resourceTypeOptInPreferenceContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .resourceTypeOptInPreference)
            for (dictKey0, resourcetypeoptinpreference0) in resourceTypeOptInPreference {
                try resourceTypeOptInPreferenceContainer.encode(resourcetypeoptinpreference0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateRegionSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRegionSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegionSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegionSettingsInput>
    public typealias MOutput = OperationOutput<UpdateRegionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegionSettingsOutputError>
}

public struct UpdateRegionSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRegionSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegionSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegionSettingsInput>
    public typealias MOutput = OperationOutput<UpdateRegionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegionSettingsOutputError>
}

public struct UpdateRegionSettingsInput: Equatable {
    /// <p>Updates the list of services along with the opt-in preferences for the Region.</p>
    public let resourceTypeOptInPreference: [String:Bool]?

    public init (
        resourceTypeOptInPreference: [String:Bool]? = nil
    )
    {
        self.resourceTypeOptInPreference = resourceTypeOptInPreference
    }
}

struct UpdateRegionSettingsInputBody: Equatable {
    public let resourceTypeOptInPreference: [String:Bool]?
}

extension UpdateRegionSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceTypeOptInPreference = "ResourceTypeOptInPreference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeOptInPreferenceContainer = try containerValues.decodeIfPresent([String: Bool?].self, forKey: .resourceTypeOptInPreference)
        var resourceTypeOptInPreferenceDecoded0: [String:Bool]? = nil
        if let resourceTypeOptInPreferenceContainer = resourceTypeOptInPreferenceContainer {
            resourceTypeOptInPreferenceDecoded0 = [String:Bool]()
            for (key0, isenabled0) in resourceTypeOptInPreferenceContainer {
                if let isenabled0 = isenabled0 {
                    resourceTypeOptInPreferenceDecoded0?[key0] = isenabled0
                }
            }
        }
        resourceTypeOptInPreference = resourceTypeOptInPreferenceDecoded0
    }
}

extension UpdateRegionSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRegionSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRegionSettingsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRegionSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRegionSettingsOutputResponse()"}
}

extension UpdateRegionSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRegionSettingsOutputResponse: Equatable {

    public init() {}
}

struct UpdateRegionSettingsOutputResponseBody: Equatable {
}

extension UpdateRegionSettingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
