// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The current account doesn't have the IAM permissions required to perform the specified Resolver operation.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Action {
    case alert
    case allow
    case block
    case sdkUnknown(String)
}

extension Action : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Action] {
        return [
            .alert,
            .allow,
            .block,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .alert: return "ALERT"
        case .allow: return "ALLOW"
        case .block: return "BLOCK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Action(rawValue: rawValue) ?? Action.sdkUnknown(rawValue)
    }
}

public struct AssociateFirewallRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "AssociateFirewallRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateFirewallRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateFirewallRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateFirewallRuleGroupInput>
    public typealias MOutput = OperationOutput<AssociateFirewallRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateFirewallRuleGroupOutputError>
}

extension AssociateFirewallRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateFirewallRuleGroupInput(creatorRequestId: \(String(describing: creatorRequestId)), firewallRuleGroupId: \(String(describing: firewallRuleGroupId)), mutationProtection: \(String(describing: mutationProtection)), name: \(String(describing: name)), priority: \(String(describing: priority)), tags: \(String(describing: tags)), vpcId: \(String(describing: vpcId)))"}
}

extension AssociateFirewallRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case mutationProtection = "MutationProtection"
        case name = "Name"
        case priority = "Priority"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let mutationProtection = mutationProtection {
            try encodeContainer.encode(mutationProtection.rawValue, forKey: .mutationProtection)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

public struct AssociateFirewallRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateFirewallRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateFirewallRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateFirewallRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateFirewallRuleGroupInput>
    public typealias MOutput = OperationOutput<AssociateFirewallRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateFirewallRuleGroupOutputError>
}

public struct AssociateFirewallRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateFirewallRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateFirewallRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateFirewallRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateFirewallRuleGroupInput>
    public typealias MOutput = OperationOutput<AssociateFirewallRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateFirewallRuleGroupOutputError>
}

public struct AssociateFirewallRuleGroupInput: Equatable {
    /// <p>A unique string that identifies the request and that allows failed requests to be
    /// 			retried without the risk of running the operation twice. <code>CreatorRequestId</code>
    /// 			can be any unique string, for example, a date/time stamp. </p>
    public var creatorRequestId: String?
    /// <p>The unique identifier of the firewall rule group. </p>
    public let firewallRuleGroupId: String?
    /// <p>If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections.
    ///        When you create the association, the default setting is <code>DISABLED</code>. </p>
    public let mutationProtection: MutationProtectionStatus?
    /// <p>A name that lets you identify the association, to manage and use it.</p>
    public let name: String?
    /// <p>The setting that determines the processing order of the rule group among the rule
    /// 			groups that you associate with the specified VPC. DNS Firewall filters VPC traffic
    /// 			starting from the rule group with the lowest numeric priority setting. </p>
    ///          <p>You must specify a unique priority for each rule group that you associate with a single VPC.
    ///            To make it easier to insert rule groups later, leave space between the numbers, for example, use 101, 200, and so on. You
    ///    can change the priority setting for a rule group association after you create it.</p>
    ///    	     <p>The allowed values for <code>Priority</code> are between 100 and 9900.</p>
    public let priority: Int?
    /// <p>A list of the tag keys and values that you want to associate with the rule group association. </p>
    public let tags: [Tag]?
    /// <p>The unique identifier of the VPC that you want to associate with the rule group. </p>
    public let vpcId: String?

    public init (
        creatorRequestId: String? = nil,
        firewallRuleGroupId: String? = nil,
        mutationProtection: MutationProtectionStatus? = nil,
        name: String? = nil,
        priority: Int? = nil,
        tags: [Tag]? = nil,
        vpcId: String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.firewallRuleGroupId = firewallRuleGroupId
        self.mutationProtection = mutationProtection
        self.name = name
        self.priority = priority
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct AssociateFirewallRuleGroupInputBody: Equatable {
    public let creatorRequestId: String?
    public let firewallRuleGroupId: String?
    public let vpcId: String?
    public let priority: Int?
    public let name: String?
    public let mutationProtection: MutationProtectionStatus?
    public let tags: [Tag]?
}

extension AssociateFirewallRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case mutationProtection = "MutationProtection"
        case name = "Name"
        case priority = "Priority"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let mutationProtectionDecoded = try containerValues.decodeIfPresent(MutationProtectionStatus.self, forKey: .mutationProtection)
        mutationProtection = mutationProtectionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AssociateFirewallRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateFirewallRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateFirewallRuleGroupOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateFirewallRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateFirewallRuleGroupOutputResponse(firewallRuleGroupAssociation: \(String(describing: firewallRuleGroupAssociation)))"}
}

extension AssociateFirewallRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateFirewallRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallRuleGroupAssociation = output.firewallRuleGroupAssociation
        } else {
            self.firewallRuleGroupAssociation = nil
        }
    }
}

public struct AssociateFirewallRuleGroupOutputResponse: Equatable {
    /// <p>The association that you just created. The association has an ID that you can use to
    /// 			identify it in other requests, like update and delete.</p>
    public let firewallRuleGroupAssociation: FirewallRuleGroupAssociation?

    public init (
        firewallRuleGroupAssociation: FirewallRuleGroupAssociation? = nil
    )
    {
        self.firewallRuleGroupAssociation = firewallRuleGroupAssociation
    }
}

struct AssociateFirewallRuleGroupOutputResponseBody: Equatable {
    public let firewallRuleGroupAssociation: FirewallRuleGroupAssociation?
}

extension AssociateFirewallRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupAssociation = "FirewallRuleGroupAssociation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationDecoded = try containerValues.decodeIfPresent(FirewallRuleGroupAssociation.self, forKey: .firewallRuleGroupAssociation)
        firewallRuleGroupAssociation = firewallRuleGroupAssociationDecoded
    }
}

public struct AssociateResolverEndpointIpAddressInputBodyMiddleware: Middleware {
    public let id: String = "AssociateResolverEndpointIpAddressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResolverEndpointIpAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResolverEndpointIpAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResolverEndpointIpAddressInput>
    public typealias MOutput = OperationOutput<AssociateResolverEndpointIpAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResolverEndpointIpAddressOutputError>
}

extension AssociateResolverEndpointIpAddressInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateResolverEndpointIpAddressInput(ipAddress: \(String(describing: ipAddress)), resolverEndpointId: \(String(describing: resolverEndpointId)))"}
}

extension AssociateResolverEndpointIpAddressInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ipAddress = "IpAddress"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

public struct AssociateResolverEndpointIpAddressInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateResolverEndpointIpAddressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResolverEndpointIpAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResolverEndpointIpAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResolverEndpointIpAddressInput>
    public typealias MOutput = OperationOutput<AssociateResolverEndpointIpAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResolverEndpointIpAddressOutputError>
}

public struct AssociateResolverEndpointIpAddressInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateResolverEndpointIpAddressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResolverEndpointIpAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResolverEndpointIpAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResolverEndpointIpAddressInput>
    public typealias MOutput = OperationOutput<AssociateResolverEndpointIpAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResolverEndpointIpAddressOutputError>
}

public struct AssociateResolverEndpointIpAddressInput: Equatable {
    /// <p>Either the IPv4 address that you want to add to a Resolver endpoint or a subnet ID. If you specify a subnet ID,
    /// 			Resolver chooses an IP address for you from the available IPs in the specified subnet.</p>
    public let ipAddress: IpAddressUpdate?
    /// <p>The ID of the Resolver endpoint that you want to associate IP addresses with.</p>
    public let resolverEndpointId: String?

    public init (
        ipAddress: IpAddressUpdate? = nil,
        resolverEndpointId: String? = nil
    )
    {
        self.ipAddress = ipAddress
        self.resolverEndpointId = resolverEndpointId
    }
}

struct AssociateResolverEndpointIpAddressInputBody: Equatable {
    public let resolverEndpointId: String?
    public let ipAddress: IpAddressUpdate?
}

extension AssociateResolverEndpointIpAddressInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ipAddress = "IpAddress"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(IpAddressUpdate.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension AssociateResolverEndpointIpAddressOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateResolverEndpointIpAddressOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateResolverEndpointIpAddressOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateResolverEndpointIpAddressOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateResolverEndpointIpAddressOutputResponse(resolverEndpoint: \(String(describing: resolverEndpoint)))"}
}

extension AssociateResolverEndpointIpAddressOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateResolverEndpointIpAddressOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct AssociateResolverEndpointIpAddressOutputResponse: Equatable {
    /// <p>The response to an <code>AssociateResolverEndpointIpAddress</code> request.</p>
    public let resolverEndpoint: ResolverEndpoint?

    public init (
        resolverEndpoint: ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct AssociateResolverEndpointIpAddressOutputResponseBody: Equatable {
    public let resolverEndpoint: ResolverEndpoint?
}

extension AssociateResolverEndpointIpAddressOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

public struct AssociateResolverQueryLogConfigInputBodyMiddleware: Middleware {
    public let id: String = "AssociateResolverQueryLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResolverQueryLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResolverQueryLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResolverQueryLogConfigInput>
    public typealias MOutput = OperationOutput<AssociateResolverQueryLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResolverQueryLogConfigOutputError>
}

extension AssociateResolverQueryLogConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateResolverQueryLogConfigInput(resolverQueryLogConfigId: \(String(describing: resolverQueryLogConfigId)), resourceId: \(String(describing: resourceId)))"}
}

extension AssociateResolverQueryLogConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverQueryLogConfigId = resolverQueryLogConfigId {
            try encodeContainer.encode(resolverQueryLogConfigId, forKey: .resolverQueryLogConfigId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct AssociateResolverQueryLogConfigInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateResolverQueryLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResolverQueryLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResolverQueryLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResolverQueryLogConfigInput>
    public typealias MOutput = OperationOutput<AssociateResolverQueryLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResolverQueryLogConfigOutputError>
}

public struct AssociateResolverQueryLogConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateResolverQueryLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResolverQueryLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResolverQueryLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResolverQueryLogConfigInput>
    public typealias MOutput = OperationOutput<AssociateResolverQueryLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResolverQueryLogConfigOutputError>
}

public struct AssociateResolverQueryLogConfigInput: Equatable {
    /// <p>The ID of the query logging configuration that you want to associate a VPC with.</p>
    public let resolverQueryLogConfigId: String?
    /// <p>The ID of an Amazon VPC that you want this query logging configuration to log queries for.</p>
    /// 		
    /// 		       <note>
    /// 			         <p>The VPCs and the query logging configuration must be in the same Region.</p>
    /// 		       </note>
    public let resourceId: String?

    public init (
        resolverQueryLogConfigId: String? = nil,
        resourceId: String? = nil
    )
    {
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
        self.resourceId = resourceId
    }
}

struct AssociateResolverQueryLogConfigInputBody: Equatable {
    public let resolverQueryLogConfigId: String?
    public let resourceId: String?
}

extension AssociateResolverQueryLogConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverQueryLogConfigId)
        resolverQueryLogConfigId = resolverQueryLogConfigIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension AssociateResolverQueryLogConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateResolverQueryLogConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateResolverQueryLogConfigOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateResolverQueryLogConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateResolverQueryLogConfigOutputResponse(resolverQueryLogConfigAssociation: \(String(describing: resolverQueryLogConfigAssociation)))"}
}

extension AssociateResolverQueryLogConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateResolverQueryLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverQueryLogConfigAssociation = output.resolverQueryLogConfigAssociation
        } else {
            self.resolverQueryLogConfigAssociation = nil
        }
    }
}

public struct AssociateResolverQueryLogConfigOutputResponse: Equatable {
    /// <p>A complex type that contains settings for a specified association between an Amazon VPC and a query logging configuration.</p>
    public let resolverQueryLogConfigAssociation: ResolverQueryLogConfigAssociation?

    public init (
        resolverQueryLogConfigAssociation: ResolverQueryLogConfigAssociation? = nil
    )
    {
        self.resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociation
    }
}

struct AssociateResolverQueryLogConfigOutputResponseBody: Equatable {
    public let resolverQueryLogConfigAssociation: ResolverQueryLogConfigAssociation?
}

extension AssociateResolverQueryLogConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfigAssociation = "ResolverQueryLogConfigAssociation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigAssociationDecoded = try containerValues.decodeIfPresent(ResolverQueryLogConfigAssociation.self, forKey: .resolverQueryLogConfigAssociation)
        resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociationDecoded
    }
}

public struct AssociateResolverRuleInputBodyMiddleware: Middleware {
    public let id: String = "AssociateResolverRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResolverRuleInput>
    public typealias MOutput = OperationOutput<AssociateResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResolverRuleOutputError>
}

extension AssociateResolverRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateResolverRuleInput(name: \(String(describing: name)), resolverRuleId: \(String(describing: resolverRuleId)), vPCId: \(String(describing: vPCId)))"}
}

extension AssociateResolverRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case resolverRuleId = "ResolverRuleId"
        case vPCId = "VPCId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolverRuleId = resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
        if let vPCId = vPCId {
            try encodeContainer.encode(vPCId, forKey: .vPCId)
        }
    }
}

public struct AssociateResolverRuleInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateResolverRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResolverRuleInput>
    public typealias MOutput = OperationOutput<AssociateResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResolverRuleOutputError>
}

public struct AssociateResolverRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateResolverRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateResolverRuleInput>
    public typealias MOutput = OperationOutput<AssociateResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateResolverRuleOutputError>
}

public struct AssociateResolverRuleInput: Equatable {
    /// <p>A name for the association that you're creating between a Resolver rule and a VPC.</p>
    public let name: String?
    /// <p>The ID of the Resolver rule that you want to associate with the VPC. To list the existing Resolver rules, use
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html">ListResolverRules</a>.</p>
    public let resolverRuleId: String?
    /// <p>The ID of the VPC that you want to associate the Resolver rule with.</p>
    public let vPCId: String?

    public init (
        name: String? = nil,
        resolverRuleId: String? = nil,
        vPCId: String? = nil
    )
    {
        self.name = name
        self.resolverRuleId = resolverRuleId
        self.vPCId = vPCId
    }
}

struct AssociateResolverRuleInputBody: Equatable {
    public let resolverRuleId: String?
    public let name: String?
    public let vPCId: String?
}

extension AssociateResolverRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case resolverRuleId = "ResolverRuleId"
        case vPCId = "VPCId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let vPCIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vPCId)
        vPCId = vPCIdDecoded
    }
}

extension AssociateResolverRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateResolverRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateResolverRuleOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateResolverRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateResolverRuleOutputResponse(resolverRuleAssociation: \(String(describing: resolverRuleAssociation)))"}
}

extension AssociateResolverRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateResolverRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverRuleAssociation = output.resolverRuleAssociation
        } else {
            self.resolverRuleAssociation = nil
        }
    }
}

public struct AssociateResolverRuleOutputResponse: Equatable {
    /// <p>Information about the <code>AssociateResolverRule</code> request, including the status of the request.</p>
    public let resolverRuleAssociation: ResolverRuleAssociation?

    public init (
        resolverRuleAssociation: ResolverRuleAssociation? = nil
    )
    {
        self.resolverRuleAssociation = resolverRuleAssociation
    }
}

struct AssociateResolverRuleOutputResponseBody: Equatable {
    public let resolverRuleAssociation: ResolverRuleAssociation?
}

extension AssociateResolverRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverRuleAssociation = "ResolverRuleAssociation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleAssociationDecoded = try containerValues.decodeIfPresent(ResolverRuleAssociation.self, forKey: .resolverRuleAssociation)
        resolverRuleAssociation = resolverRuleAssociationDecoded
    }
}

public enum BlockOverrideDnsType {
    case cname
    case sdkUnknown(String)
}

extension BlockOverrideDnsType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BlockOverrideDnsType] {
        return [
            .cname,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cname: return "CNAME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BlockOverrideDnsType(rawValue: rawValue) ?? BlockOverrideDnsType.sdkUnknown(rawValue)
    }
}

public enum BlockResponse {
    case nodata
    case nxdomain
    case `override`
    case sdkUnknown(String)
}

extension BlockResponse : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BlockResponse] {
        return [
            .nodata,
            .nxdomain,
            .override,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .nodata: return "NODATA"
        case .nxdomain: return "NXDOMAIN"
        case .override: return "OVERRIDE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BlockResponse(rawValue: rawValue) ?? BlockResponse.sdkUnknown(rawValue)
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateFirewallDomainListInputBodyMiddleware: Middleware {
    public let id: String = "CreateFirewallDomainListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFirewallDomainListInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFirewallDomainListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFirewallDomainListInput>
    public typealias MOutput = OperationOutput<CreateFirewallDomainListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFirewallDomainListOutputError>
}

extension CreateFirewallDomainListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFirewallDomainListInput(creatorRequestId: \(String(describing: creatorRequestId)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateFirewallDomainListInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateFirewallDomainListInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFirewallDomainListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFirewallDomainListInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFirewallDomainListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFirewallDomainListInput>
    public typealias MOutput = OperationOutput<CreateFirewallDomainListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFirewallDomainListOutputError>
}

public struct CreateFirewallDomainListInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFirewallDomainListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFirewallDomainListInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFirewallDomainListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFirewallDomainListInput>
    public typealias MOutput = OperationOutput<CreateFirewallDomainListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFirewallDomainListOutputError>
}

public struct CreateFirewallDomainListInput: Equatable {
    /// <p>A unique string that identifies the request and that allows you to retry failed requests
    /// 			without the risk of running the operation twice. <code>CreatorRequestId</code> can be
    /// 			any unique string, for example, a date/time stamp. </p>
    public var creatorRequestId: String?
    /// <p>A name that lets you identify the domain list to manage and use it.</p>
    public let name: String?
    /// <p>A list of the tag keys and values that you want to associate with the domain list. </p>
    public let tags: [Tag]?

    public init (
        creatorRequestId: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.name = name
        self.tags = tags
    }
}

struct CreateFirewallDomainListInputBody: Equatable {
    public let creatorRequestId: String?
    public let name: String?
    public let tags: [Tag]?
}

extension CreateFirewallDomainListInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFirewallDomainListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFirewallDomainListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFirewallDomainListOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFirewallDomainListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFirewallDomainListOutputResponse(firewallDomainList: \(String(describing: firewallDomainList)))"}
}

extension CreateFirewallDomainListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFirewallDomainListOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallDomainList = output.firewallDomainList
        } else {
            self.firewallDomainList = nil
        }
    }
}

public struct CreateFirewallDomainListOutputResponse: Equatable {
    /// <p>The
    /// 			domain list that you just created.</p>
    public let firewallDomainList: FirewallDomainList?

    public init (
        firewallDomainList: FirewallDomainList? = nil
    )
    {
        self.firewallDomainList = firewallDomainList
    }
}

struct CreateFirewallDomainListOutputResponseBody: Equatable {
    public let firewallDomainList: FirewallDomainList?
}

extension CreateFirewallDomainListOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallDomainList = "FirewallDomainList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListDecoded = try containerValues.decodeIfPresent(FirewallDomainList.self, forKey: .firewallDomainList)
        firewallDomainList = firewallDomainListDecoded
    }
}

public struct CreateFirewallRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateFirewallRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFirewallRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFirewallRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFirewallRuleGroupInput>
    public typealias MOutput = OperationOutput<CreateFirewallRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFirewallRuleGroupOutputError>
}

extension CreateFirewallRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFirewallRuleGroupInput(creatorRequestId: \(String(describing: creatorRequestId)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateFirewallRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateFirewallRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFirewallRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFirewallRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFirewallRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFirewallRuleGroupInput>
    public typealias MOutput = OperationOutput<CreateFirewallRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFirewallRuleGroupOutputError>
}

public struct CreateFirewallRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFirewallRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFirewallRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFirewallRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFirewallRuleGroupInput>
    public typealias MOutput = OperationOutput<CreateFirewallRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFirewallRuleGroupOutputError>
}

public struct CreateFirewallRuleGroupInput: Equatable {
    /// <p>A unique string defined by you to identify the request. This allows you to retry failed
    /// 			requests without the risk of running the operation twice. This can be any unique string,
    /// 			for example, a timestamp. </p>
    public var creatorRequestId: String?
    /// <p>A name that lets you identify the rule group, to manage and use it.</p>
    public let name: String?
    /// <p>A list of the tag keys and values that you want to associate with the rule group. </p>
    public let tags: [Tag]?

    public init (
        creatorRequestId: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.name = name
        self.tags = tags
    }
}

struct CreateFirewallRuleGroupInputBody: Equatable {
    public let creatorRequestId: String?
    public let name: String?
    public let tags: [Tag]?
}

extension CreateFirewallRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFirewallRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFirewallRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFirewallRuleGroupOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFirewallRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFirewallRuleGroupOutputResponse(firewallRuleGroup: \(String(describing: firewallRuleGroup)))"}
}

extension CreateFirewallRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFirewallRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallRuleGroup = output.firewallRuleGroup
        } else {
            self.firewallRuleGroup = nil
        }
    }
}

public struct CreateFirewallRuleGroupOutputResponse: Equatable {
    /// <p>A collection of rules used to filter DNS network traffic. </p>
    public let firewallRuleGroup: FirewallRuleGroup?

    public init (
        firewallRuleGroup: FirewallRuleGroup? = nil
    )
    {
        self.firewallRuleGroup = firewallRuleGroup
    }
}

struct CreateFirewallRuleGroupOutputResponseBody: Equatable {
    public let firewallRuleGroup: FirewallRuleGroup?
}

extension CreateFirewallRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroup = "FirewallRuleGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupDecoded = try containerValues.decodeIfPresent(FirewallRuleGroup.self, forKey: .firewallRuleGroup)
        firewallRuleGroup = firewallRuleGroupDecoded
    }
}

public struct CreateFirewallRuleInputBodyMiddleware: Middleware {
    public let id: String = "CreateFirewallRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFirewallRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFirewallRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFirewallRuleInput>
    public typealias MOutput = OperationOutput<CreateFirewallRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFirewallRuleOutputError>
}

extension CreateFirewallRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFirewallRuleInput(action: \(String(describing: action)), blockOverrideDnsType: \(String(describing: blockOverrideDnsType)), blockOverrideDomain: \(String(describing: blockOverrideDomain)), blockOverrideTtl: \(String(describing: blockOverrideTtl)), blockResponse: \(String(describing: blockResponse)), creatorRequestId: \(String(describing: creatorRequestId)), firewallDomainListId: \(String(describing: firewallDomainListId)), firewallRuleGroupId: \(String(describing: firewallRuleGroupId)), name: \(String(describing: name)), priority: \(String(describing: priority)))"}
}

extension CreateFirewallRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case blockOverrideDnsType = "BlockOverrideDnsType"
        case blockOverrideDomain = "BlockOverrideDomain"
        case blockOverrideTtl = "BlockOverrideTtl"
        case blockResponse = "BlockResponse"
        case creatorRequestId = "CreatorRequestId"
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case name = "Name"
        case priority = "Priority"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let blockOverrideDnsType = blockOverrideDnsType {
            try encodeContainer.encode(blockOverrideDnsType.rawValue, forKey: .blockOverrideDnsType)
        }
        if let blockOverrideDomain = blockOverrideDomain {
            try encodeContainer.encode(blockOverrideDomain, forKey: .blockOverrideDomain)
        }
        if let blockOverrideTtl = blockOverrideTtl {
            try encodeContainer.encode(blockOverrideTtl, forKey: .blockOverrideTtl)
        }
        if let blockResponse = blockResponse {
            try encodeContainer.encode(blockResponse.rawValue, forKey: .blockResponse)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }
}

public struct CreateFirewallRuleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFirewallRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFirewallRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFirewallRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFirewallRuleInput>
    public typealias MOutput = OperationOutput<CreateFirewallRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFirewallRuleOutputError>
}

public struct CreateFirewallRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFirewallRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFirewallRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFirewallRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFirewallRuleInput>
    public typealias MOutput = OperationOutput<CreateFirewallRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFirewallRuleOutputError>
}

public struct CreateFirewallRuleInput: Equatable {
    /// <p>The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALLOW</code> - Permit the request to go through.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ALERT</code> - Permit the request and send metrics and logs to Cloud Watch.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BLOCK</code> - Disallow the request. This option requires additional details in the rule's <code>BlockResponse</code>. </p>
    ///             </li>
    ///          </ul>
    public let action: Action?
    /// <p>The DNS record's type. This determines the format of the record value that you provided in <code>BlockOverrideDomain</code>. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
    ///          <p>This setting is required if the <code>BlockResponse</code> setting is <code>OVERRIDE</code>.</p>
    public let blockOverrideDnsType: BlockOverrideDnsType?
    /// <p>The custom DNS record to send back in response to the query. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
    ///          <p>This setting is required if the <code>BlockResponse</code> setting is <code>OVERRIDE</code>.</p>
    public let blockOverrideDomain: String?
    /// <p>The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
    ///          <p>This setting is required if the <code>BlockResponse</code> setting is <code>OVERRIDE</code>.</p>
    public let blockOverrideTtl: Int?
    /// <p>The way that you want DNS Firewall to block the request, used with the rule action
    /// 			setting <code>BLOCK</code>. </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NODATA</code> - Respond indicating that the query was successful, but no response is available for it.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NXDOMAIN</code> - Respond indicating that the domain name that's in the query doesn't exist.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OVERRIDE</code> - Provide a custom override in the response. This option requires custom handling details in the rule's <code>BlockOverride*</code> settings. </p>
    ///             </li>
    ///          </ul>
    ///          <p>This setting is required if the rule action setting is <code>BLOCK</code>.</p>
    public let blockResponse: BlockResponse?
    /// <p>A unique string that identifies the request and that allows you to retry failed requests
    /// 			without the risk of running the operation twice. <code>CreatorRequestId</code> can be
    /// 			any unique string, for example, a date/time stamp. </p>
    public var creatorRequestId: String?
    /// <p>The ID of the domain list that you want to use in the rule. </p>
    public let firewallDomainListId: String?
    /// <p>The unique identifier of the firewall rule group where you want to create the rule. </p>
    public let firewallRuleGroupId: String?
    /// <p>A name that lets you identify the rule in the rule group.</p>
    public let name: String?
    /// <p>The setting that determines the processing order of the rule in the rule group. DNS Firewall
    ///            processes the rules in a rule group by order of priority, starting from the lowest setting.</p>
    ///          <p>You must specify a unique priority for each rule in a rule group.
    ///            To make it easier to insert rules later, leave space between the numbers, for example, use 100, 200, and so on. You
    ///    can change the priority setting for the rules in a rule group at any time.</p>
    public let priority: Int?

    public init (
        action: Action? = nil,
        blockOverrideDnsType: BlockOverrideDnsType? = nil,
        blockOverrideDomain: String? = nil,
        blockOverrideTtl: Int? = nil,
        blockResponse: BlockResponse? = nil,
        creatorRequestId: String? = nil,
        firewallDomainListId: String? = nil,
        firewallRuleGroupId: String? = nil,
        name: String? = nil,
        priority: Int? = nil
    )
    {
        self.action = action
        self.blockOverrideDnsType = blockOverrideDnsType
        self.blockOverrideDomain = blockOverrideDomain
        self.blockOverrideTtl = blockOverrideTtl
        self.blockResponse = blockResponse
        self.creatorRequestId = creatorRequestId
        self.firewallDomainListId = firewallDomainListId
        self.firewallRuleGroupId = firewallRuleGroupId
        self.name = name
        self.priority = priority
    }
}

struct CreateFirewallRuleInputBody: Equatable {
    public let creatorRequestId: String?
    public let firewallRuleGroupId: String?
    public let firewallDomainListId: String?
    public let priority: Int?
    public let action: Action?
    public let blockResponse: BlockResponse?
    public let blockOverrideDomain: String?
    public let blockOverrideDnsType: BlockOverrideDnsType?
    public let blockOverrideTtl: Int?
    public let name: String?
}

extension CreateFirewallRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case blockOverrideDnsType = "BlockOverrideDnsType"
        case blockOverrideDomain = "BlockOverrideDomain"
        case blockOverrideTtl = "BlockOverrideTtl"
        case blockResponse = "BlockResponse"
        case creatorRequestId = "CreatorRequestId"
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case name = "Name"
        case priority = "Priority"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let blockResponseDecoded = try containerValues.decodeIfPresent(BlockResponse.self, forKey: .blockResponse)
        blockResponse = blockResponseDecoded
        let blockOverrideDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .blockOverrideDomain)
        blockOverrideDomain = blockOverrideDomainDecoded
        let blockOverrideDnsTypeDecoded = try containerValues.decodeIfPresent(BlockOverrideDnsType.self, forKey: .blockOverrideDnsType)
        blockOverrideDnsType = blockOverrideDnsTypeDecoded
        let blockOverrideTtlDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .blockOverrideTtl)
        blockOverrideTtl = blockOverrideTtlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateFirewallRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFirewallRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFirewallRuleOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFirewallRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFirewallRuleOutputResponse(firewallRule: \(String(describing: firewallRule)))"}
}

extension CreateFirewallRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFirewallRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallRule = output.firewallRule
        } else {
            self.firewallRule = nil
        }
    }
}

public struct CreateFirewallRuleOutputResponse: Equatable {
    /// <p>The
    /// 			firewall rule that you just created. </p>
    public let firewallRule: FirewallRule?

    public init (
        firewallRule: FirewallRule? = nil
    )
    {
        self.firewallRule = firewallRule
    }
}

struct CreateFirewallRuleOutputResponseBody: Equatable {
    public let firewallRule: FirewallRule?
}

extension CreateFirewallRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRule = "FirewallRule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleDecoded = try containerValues.decodeIfPresent(FirewallRule.self, forKey: .firewallRule)
        firewallRule = firewallRuleDecoded
    }
}

public struct CreateResolverEndpointInputBodyMiddleware: Middleware {
    public let id: String = "CreateResolverEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResolverEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResolverEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResolverEndpointInput>
    public typealias MOutput = OperationOutput<CreateResolverEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResolverEndpointOutputError>
}

extension CreateResolverEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResolverEndpointInput(creatorRequestId: \(String(describing: creatorRequestId)), direction: \(String(describing: direction)), ipAddresses: \(String(describing: ipAddresses)), name: \(String(describing: name)), securityGroupIds: \(String(describing: securityGroupIds)), tags: \(String(describing: tags)))"}
}

extension CreateResolverEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case direction = "Direction"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case securityGroupIds = "SecurityGroupIds"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let direction = direction {
            try encodeContainer.encode(direction.rawValue, forKey: .direction)
        }
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipaddressesrequest0 in ipAddresses {
                try ipAddressesContainer.encode(ipaddressesrequest0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateResolverEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "CreateResolverEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResolverEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResolverEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResolverEndpointInput>
    public typealias MOutput = OperationOutput<CreateResolverEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResolverEndpointOutputError>
}

public struct CreateResolverEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateResolverEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResolverEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResolverEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResolverEndpointInput>
    public typealias MOutput = OperationOutput<CreateResolverEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResolverEndpointOutputError>
}

public struct CreateResolverEndpointInput: Equatable {
    /// <p>A unique string that identifies the request and that allows failed requests to be retried
    /// 			without the risk of running the operation twice. <code>CreatorRequestId</code> can be
    /// 			any unique string, for example, a date/time stamp. </p>
    public let creatorRequestId: String?
    /// <p>Specify the applicable value:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>INBOUND</code>: Resolver forwards DNS queries to the DNS service for a VPC from your network</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OUTBOUND</code>: Resolver forwards DNS queries from the DNS service for a VPC to your network</p>
    ///             </li>
    ///          </ul>
    public let direction: ResolverEndpointDirection?
    /// <p>The subnets and IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward
    /// 			DNS queries to (for inbound endpoints). The subnet ID uniquely identifies a VPC. </p>
    public let ipAddresses: [IpAddressRequest]?
    /// <p>A friendly name that lets you easily find a configuration in the Resolver dashboard in the Route 53 console.</p>
    public let name: String?
    /// <p>The ID of one or more security groups that you want to use to control access to this VPC. The security group that you specify
    /// 			must include one or more inbound rules (for inbound Resolver endpoints) or outbound rules (for outbound Resolver endpoints).
    /// 			Inbound and outbound rules must allow TCP and UDP access. For inbound access, open port 53. For outbound access, open the port
    /// 			that you're using for DNS queries on your network.</p>
    public let securityGroupIds: [String]?
    /// <p>A list of the tag keys and values that you want to associate with the endpoint.</p>
    public let tags: [Tag]?

    public init (
        creatorRequestId: String? = nil,
        direction: ResolverEndpointDirection? = nil,
        ipAddresses: [IpAddressRequest]? = nil,
        name: String? = nil,
        securityGroupIds: [String]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.direction = direction
        self.ipAddresses = ipAddresses
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.tags = tags
    }
}

struct CreateResolverEndpointInputBody: Equatable {
    public let creatorRequestId: String?
    public let name: String?
    public let securityGroupIds: [String]?
    public let direction: ResolverEndpointDirection?
    public let ipAddresses: [IpAddressRequest]?
    public let tags: [Tag]?
}

extension CreateResolverEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case direction = "Direction"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case securityGroupIds = "SecurityGroupIds"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let directionDecoded = try containerValues.decodeIfPresent(ResolverEndpointDirection.self, forKey: .direction)
        direction = directionDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([IpAddressRequest?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[IpAddressRequest]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [IpAddressRequest]()
            for structure0 in ipAddressesContainer {
                if let structure0 = structure0 {
                    ipAddressesDecoded0?.append(structure0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResolverEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResolverEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResolverEndpointOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResolverEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResolverEndpointOutputResponse(resolverEndpoint: \(String(describing: resolverEndpoint)))"}
}

extension CreateResolverEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateResolverEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct CreateResolverEndpointOutputResponse: Equatable {
    /// <p>Information about the <code>CreateResolverEndpoint</code> request, including the status of the request.</p>
    public let resolverEndpoint: ResolverEndpoint?

    public init (
        resolverEndpoint: ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct CreateResolverEndpointOutputResponseBody: Equatable {
    public let resolverEndpoint: ResolverEndpoint?
}

extension CreateResolverEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

public struct CreateResolverQueryLogConfigInputBodyMiddleware: Middleware {
    public let id: String = "CreateResolverQueryLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResolverQueryLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResolverQueryLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResolverQueryLogConfigInput>
    public typealias MOutput = OperationOutput<CreateResolverQueryLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResolverQueryLogConfigOutputError>
}

extension CreateResolverQueryLogConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResolverQueryLogConfigInput(creatorRequestId: \(String(describing: creatorRequestId)), destinationArn: \(String(describing: destinationArn)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateResolverQueryLogConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case destinationArn = "DestinationArn"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let destinationArn = destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateResolverQueryLogConfigInputHeadersMiddleware: Middleware {
    public let id: String = "CreateResolverQueryLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResolverQueryLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResolverQueryLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResolverQueryLogConfigInput>
    public typealias MOutput = OperationOutput<CreateResolverQueryLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResolverQueryLogConfigOutputError>
}

public struct CreateResolverQueryLogConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateResolverQueryLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResolverQueryLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResolverQueryLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResolverQueryLogConfigInput>
    public typealias MOutput = OperationOutput<CreateResolverQueryLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResolverQueryLogConfigOutputError>
}

public struct CreateResolverQueryLogConfigInput: Equatable {
    /// <p>A unique string that identifies the request and that allows failed requests to be retried
    /// 			without the risk of running the operation twice. <code>CreatorRequestId</code> can be
    /// 			any unique string, for example, a date/time stamp. </p>
    public var creatorRequestId: String?
    /// <p>The ARN of the resource that you want Resolver to send query logs. You can send query logs to an S3 bucket, a CloudWatch Logs log group,
    /// 			or a Kinesis Data Firehose delivery stream. Examples of valid values include the following:</p>
    /// 		
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <b>S3 bucket</b>: </p>
    /// 				           <p>
    ///                   <code>arn:aws:s3:::examplebucket</code>
    ///                </p>
    /// 				           <p>You can optionally append a file prefix to the end of the ARN.</p>
    /// 				           <p>
    ///                   <code>arn:aws:s3:::examplebucket/development/</code>
    ///                </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <b>CloudWatch Logs log group</b>: </p>
    /// 				           <p>
    ///                   <code>arn:aws:logs:us-west-1:123456789012:log-group:/mystack-testgroup-12ABC1AB12A1:*</code>
    ///                </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <b>Kinesis Data Firehose delivery stream</b>:</p>
    /// 				           <p>
    ///                   <code>arn:aws:kinesis:us-east-2:0123456789:stream/my_stream_name</code>
    ///                </p>
    /// 			         </li>
    ///          </ul>
    public let destinationArn: String?
    /// <p>The name that you want to give the query logging configuration.</p>
    public let name: String?
    /// <p>A list of the tag keys and values that you want to associate with the query logging configuration.</p>
    public let tags: [Tag]?

    public init (
        creatorRequestId: String? = nil,
        destinationArn: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.destinationArn = destinationArn
        self.name = name
        self.tags = tags
    }
}

struct CreateResolverQueryLogConfigInputBody: Equatable {
    public let name: String?
    public let destinationArn: String?
    public let creatorRequestId: String?
    public let tags: [Tag]?
}

extension CreateResolverQueryLogConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case destinationArn = "DestinationArn"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResolverQueryLogConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResolverQueryLogConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResolverQueryLogConfigOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResolverQueryLogConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResolverQueryLogConfigOutputResponse(resolverQueryLogConfig: \(String(describing: resolverQueryLogConfig)))"}
}

extension CreateResolverQueryLogConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateResolverQueryLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverQueryLogConfig = output.resolverQueryLogConfig
        } else {
            self.resolverQueryLogConfig = nil
        }
    }
}

public struct CreateResolverQueryLogConfigOutputResponse: Equatable {
    /// <p>Information about the <code>CreateResolverQueryLogConfig</code> request, including the status of the request.</p>
    public let resolverQueryLogConfig: ResolverQueryLogConfig?

    public init (
        resolverQueryLogConfig: ResolverQueryLogConfig? = nil
    )
    {
        self.resolverQueryLogConfig = resolverQueryLogConfig
    }
}

struct CreateResolverQueryLogConfigOutputResponseBody: Equatable {
    public let resolverQueryLogConfig: ResolverQueryLogConfig?
}

extension CreateResolverQueryLogConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfig = "ResolverQueryLogConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigDecoded = try containerValues.decodeIfPresent(ResolverQueryLogConfig.self, forKey: .resolverQueryLogConfig)
        resolverQueryLogConfig = resolverQueryLogConfigDecoded
    }
}

public struct CreateResolverRuleInputBodyMiddleware: Middleware {
    public let id: String = "CreateResolverRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResolverRuleInput>
    public typealias MOutput = OperationOutput<CreateResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResolverRuleOutputError>
}

extension CreateResolverRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResolverRuleInput(creatorRequestId: \(String(describing: creatorRequestId)), domainName: \(String(describing: domainName)), name: \(String(describing: name)), resolverEndpointId: \(String(describing: resolverEndpointId)), ruleType: \(String(describing: ruleType)), tags: \(String(describing: tags)), targetIps: \(String(describing: targetIps)))"}
}

extension CreateResolverRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case domainName = "DomainName"
        case name = "Name"
        case resolverEndpointId = "ResolverEndpointId"
        case ruleType = "RuleType"
        case tags = "Tags"
        case targetIps = "TargetIps"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
        if let ruleType = ruleType {
            try encodeContainer.encode(ruleType.rawValue, forKey: .ruleType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetIps = targetIps {
            var targetIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetIps)
            for targetlist0 in targetIps {
                try targetIpsContainer.encode(targetlist0)
            }
        }
    }
}

public struct CreateResolverRuleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateResolverRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResolverRuleInput>
    public typealias MOutput = OperationOutput<CreateResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResolverRuleOutputError>
}

public struct CreateResolverRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateResolverRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResolverRuleInput>
    public typealias MOutput = OperationOutput<CreateResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResolverRuleOutputError>
}

public struct CreateResolverRuleInput: Equatable {
    /// <p>A unique string that identifies the request and that allows failed requests to be retried
    /// 			without the risk of running the operation twice. <code>CreatorRequestId</code> can be
    /// 			any unique string, for example, a date/time stamp. </p>
    public let creatorRequestId: String?
    /// <p>DNS queries for this domain name are forwarded to the IP addresses that you specify in <code>TargetIps</code>. If a query matches
    /// 			multiple Resolver rules (example.com and www.example.com), outbound DNS queries are routed using the Resolver rule that contains
    /// 			the most specific domain name (www.example.com).</p>
    public let domainName: String?
    /// <p>A friendly name that lets you easily find a rule in the Resolver dashboard in the Route 53 console.</p>
    public let name: String?
    /// <p>The ID of the outbound Resolver endpoint that you want to use to route DNS queries to the IP addresses that you specify
    /// 			in <code>TargetIps</code>.</p>
    public let resolverEndpointId: String?
    /// <p>When you want to forward DNS queries for specified domain name to resolvers on your network, specify <code>FORWARD</code>.</p>
    /// 		       <p>When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for
    /// 			a subdomain of that domain, specify <code>SYSTEM</code>.</p>
    /// 		       <p>For example, to forward DNS queries for example.com to resolvers on your network, you create a rule and specify <code>FORWARD</code>
    /// 			for <code>RuleType</code>. To then have Resolver process queries for apex.example.com, you create a rule and specify
    /// 			<code>SYSTEM</code> for <code>RuleType</code>.</p>
    /// 		       <p>Currently, only Resolver can create rules that have a value of <code>RECURSIVE</code> for <code>RuleType</code>.</p>
    public let ruleType: RuleTypeOption?
    /// <p>A list of the tag keys and values that you want to associate with the endpoint.</p>
    public let tags: [Tag]?
    /// <p>The IPs that you want Resolver to forward DNS queries to. You can specify only IPv4 addresses. Separate IP addresses with a space.</p>
    /// 		       <p>
    ///             <code>TargetIps</code> is available only when the value of <code>Rule type</code> is <code>FORWARD</code>.</p>
    public let targetIps: [TargetAddress]?

    public init (
        creatorRequestId: String? = nil,
        domainName: String? = nil,
        name: String? = nil,
        resolverEndpointId: String? = nil,
        ruleType: RuleTypeOption? = nil,
        tags: [Tag]? = nil,
        targetIps: [TargetAddress]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.domainName = domainName
        self.name = name
        self.resolverEndpointId = resolverEndpointId
        self.ruleType = ruleType
        self.tags = tags
        self.targetIps = targetIps
    }
}

struct CreateResolverRuleInputBody: Equatable {
    public let creatorRequestId: String?
    public let name: String?
    public let ruleType: RuleTypeOption?
    public let domainName: String?
    public let targetIps: [TargetAddress]?
    public let resolverEndpointId: String?
    public let tags: [Tag]?
}

extension CreateResolverRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case domainName = "DomainName"
        case name = "Name"
        case resolverEndpointId = "ResolverEndpointId"
        case ruleType = "RuleType"
        case tags = "Tags"
        case targetIps = "TargetIps"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ruleTypeDecoded = try containerValues.decodeIfPresent(RuleTypeOption.self, forKey: .ruleType)
        ruleType = ruleTypeDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let targetIpsContainer = try containerValues.decodeIfPresent([TargetAddress?].self, forKey: .targetIps)
        var targetIpsDecoded0:[TargetAddress]? = nil
        if let targetIpsContainer = targetIpsContainer {
            targetIpsDecoded0 = [TargetAddress]()
            for structure0 in targetIpsContainer {
                if let structure0 = structure0 {
                    targetIpsDecoded0?.append(structure0)
                }
            }
        }
        targetIps = targetIpsDecoded0
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResolverRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResolverRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResolverRuleOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResolverRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResolverRuleOutputResponse(resolverRule: \(String(describing: resolverRule)))"}
}

extension CreateResolverRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateResolverRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverRule = output.resolverRule
        } else {
            self.resolverRule = nil
        }
    }
}

public struct CreateResolverRuleOutputResponse: Equatable {
    /// <p>Information about the <code>CreateResolverRule</code> request, including the status of the request.</p>
    public let resolverRule: ResolverRule?

    public init (
        resolverRule: ResolverRule? = nil
    )
    {
        self.resolverRule = resolverRule
    }
}

struct CreateResolverRuleOutputResponseBody: Equatable {
    public let resolverRule: ResolverRule?
}

extension CreateResolverRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverRule = "ResolverRule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleDecoded = try containerValues.decodeIfPresent(ResolverRule.self, forKey: .resolverRule)
        resolverRule = resolverRuleDecoded
    }
}

public struct DeleteFirewallDomainListInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFirewallDomainListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallDomainListInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallDomainListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallDomainListInput>
    public typealias MOutput = OperationOutput<DeleteFirewallDomainListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallDomainListOutputError>
}

extension DeleteFirewallDomainListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFirewallDomainListInput(firewallDomainListId: \(String(describing: firewallDomainListId)))"}
}

extension DeleteFirewallDomainListInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
    }
}

public struct DeleteFirewallDomainListInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFirewallDomainListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallDomainListInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallDomainListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallDomainListInput>
    public typealias MOutput = OperationOutput<DeleteFirewallDomainListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallDomainListOutputError>
}

public struct DeleteFirewallDomainListInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFirewallDomainListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallDomainListInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallDomainListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallDomainListInput>
    public typealias MOutput = OperationOutput<DeleteFirewallDomainListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallDomainListOutputError>
}

public struct DeleteFirewallDomainListInput: Equatable {
    /// <p>The ID of the domain list that you want to delete. </p>
    public let firewallDomainListId: String?

    public init (
        firewallDomainListId: String? = nil
    )
    {
        self.firewallDomainListId = firewallDomainListId
    }
}

struct DeleteFirewallDomainListInputBody: Equatable {
    public let firewallDomainListId: String?
}

extension DeleteFirewallDomainListInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
    }
}

extension DeleteFirewallDomainListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFirewallDomainListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFirewallDomainListOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFirewallDomainListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFirewallDomainListOutputResponse(firewallDomainList: \(String(describing: firewallDomainList)))"}
}

extension DeleteFirewallDomainListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteFirewallDomainListOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallDomainList = output.firewallDomainList
        } else {
            self.firewallDomainList = nil
        }
    }
}

public struct DeleteFirewallDomainListOutputResponse: Equatable {
    /// <p>The domain list that you just deleted. </p>
    public let firewallDomainList: FirewallDomainList?

    public init (
        firewallDomainList: FirewallDomainList? = nil
    )
    {
        self.firewallDomainList = firewallDomainList
    }
}

struct DeleteFirewallDomainListOutputResponseBody: Equatable {
    public let firewallDomainList: FirewallDomainList?
}

extension DeleteFirewallDomainListOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallDomainList = "FirewallDomainList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListDecoded = try containerValues.decodeIfPresent(FirewallDomainList.self, forKey: .firewallDomainList)
        firewallDomainList = firewallDomainListDecoded
    }
}

public struct DeleteFirewallRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFirewallRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallRuleGroupInput>
    public typealias MOutput = OperationOutput<DeleteFirewallRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallRuleGroupOutputError>
}

extension DeleteFirewallRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFirewallRuleGroupInput(firewallRuleGroupId: \(String(describing: firewallRuleGroupId)))"}
}

extension DeleteFirewallRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
    }
}

public struct DeleteFirewallRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFirewallRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallRuleGroupInput>
    public typealias MOutput = OperationOutput<DeleteFirewallRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallRuleGroupOutputError>
}

public struct DeleteFirewallRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFirewallRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallRuleGroupInput>
    public typealias MOutput = OperationOutput<DeleteFirewallRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallRuleGroupOutputError>
}

public struct DeleteFirewallRuleGroupInput: Equatable {
    /// <p>The unique identifier of the firewall rule group that you want to delete. </p>
    public let firewallRuleGroupId: String?

    public init (
        firewallRuleGroupId: String? = nil
    )
    {
        self.firewallRuleGroupId = firewallRuleGroupId
    }
}

struct DeleteFirewallRuleGroupInputBody: Equatable {
    public let firewallRuleGroupId: String?
}

extension DeleteFirewallRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
    }
}

extension DeleteFirewallRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFirewallRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFirewallRuleGroupOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFirewallRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFirewallRuleGroupOutputResponse(firewallRuleGroup: \(String(describing: firewallRuleGroup)))"}
}

extension DeleteFirewallRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteFirewallRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallRuleGroup = output.firewallRuleGroup
        } else {
            self.firewallRuleGroup = nil
        }
    }
}

public struct DeleteFirewallRuleGroupOutputResponse: Equatable {
    /// <p>A collection of rules used to filter DNS network traffic. </p>
    public let firewallRuleGroup: FirewallRuleGroup?

    public init (
        firewallRuleGroup: FirewallRuleGroup? = nil
    )
    {
        self.firewallRuleGroup = firewallRuleGroup
    }
}

struct DeleteFirewallRuleGroupOutputResponseBody: Equatable {
    public let firewallRuleGroup: FirewallRuleGroup?
}

extension DeleteFirewallRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroup = "FirewallRuleGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupDecoded = try containerValues.decodeIfPresent(FirewallRuleGroup.self, forKey: .firewallRuleGroup)
        firewallRuleGroup = firewallRuleGroupDecoded
    }
}

public struct DeleteFirewallRuleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFirewallRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallRuleInput>
    public typealias MOutput = OperationOutput<DeleteFirewallRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallRuleOutputError>
}

extension DeleteFirewallRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFirewallRuleInput(firewallDomainListId: \(String(describing: firewallDomainListId)), firewallRuleGroupId: \(String(describing: firewallRuleGroupId)))"}
}

extension DeleteFirewallRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
    }
}

public struct DeleteFirewallRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFirewallRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallRuleInput>
    public typealias MOutput = OperationOutput<DeleteFirewallRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallRuleOutputError>
}

public struct DeleteFirewallRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFirewallRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallRuleInput>
    public typealias MOutput = OperationOutput<DeleteFirewallRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallRuleOutputError>
}

public struct DeleteFirewallRuleInput: Equatable {
    /// <p>The ID of the domain list that's used in the rule.  </p>
    public let firewallDomainListId: String?
    /// <p>The unique identifier of the firewall rule group that you want to delete the rule from. </p>
    public let firewallRuleGroupId: String?

    public init (
        firewallDomainListId: String? = nil,
        firewallRuleGroupId: String? = nil
    )
    {
        self.firewallDomainListId = firewallDomainListId
        self.firewallRuleGroupId = firewallRuleGroupId
    }
}

struct DeleteFirewallRuleInputBody: Equatable {
    public let firewallRuleGroupId: String?
    public let firewallDomainListId: String?
}

extension DeleteFirewallRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
    }
}

extension DeleteFirewallRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFirewallRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFirewallRuleOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFirewallRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFirewallRuleOutputResponse(firewallRule: \(String(describing: firewallRule)))"}
}

extension DeleteFirewallRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteFirewallRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallRule = output.firewallRule
        } else {
            self.firewallRule = nil
        }
    }
}

public struct DeleteFirewallRuleOutputResponse: Equatable {
    /// <p>The specification for the firewall rule that you just deleted.</p>
    public let firewallRule: FirewallRule?

    public init (
        firewallRule: FirewallRule? = nil
    )
    {
        self.firewallRule = firewallRule
    }
}

struct DeleteFirewallRuleOutputResponseBody: Equatable {
    public let firewallRule: FirewallRule?
}

extension DeleteFirewallRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRule = "FirewallRule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleDecoded = try containerValues.decodeIfPresent(FirewallRule.self, forKey: .firewallRule)
        firewallRule = firewallRuleDecoded
    }
}

public struct DeleteResolverEndpointInputBodyMiddleware: Middleware {
    public let id: String = "DeleteResolverEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResolverEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResolverEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResolverEndpointInput>
    public typealias MOutput = OperationOutput<DeleteResolverEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResolverEndpointOutputError>
}

extension DeleteResolverEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResolverEndpointInput(resolverEndpointId: \(String(describing: resolverEndpointId)))"}
}

extension DeleteResolverEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

public struct DeleteResolverEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResolverEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResolverEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResolverEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResolverEndpointInput>
    public typealias MOutput = OperationOutput<DeleteResolverEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResolverEndpointOutputError>
}

public struct DeleteResolverEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResolverEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResolverEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResolverEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResolverEndpointInput>
    public typealias MOutput = OperationOutput<DeleteResolverEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResolverEndpointOutputError>
}

public struct DeleteResolverEndpointInput: Equatable {
    /// <p>The ID of the Resolver endpoint that you want to delete.</p>
    public let resolverEndpointId: String?

    public init (
        resolverEndpointId: String? = nil
    )
    {
        self.resolverEndpointId = resolverEndpointId
    }
}

struct DeleteResolverEndpointInputBody: Equatable {
    public let resolverEndpointId: String?
}

extension DeleteResolverEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
    }
}

extension DeleteResolverEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResolverEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResolverEndpointOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResolverEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResolverEndpointOutputResponse(resolverEndpoint: \(String(describing: resolverEndpoint)))"}
}

extension DeleteResolverEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteResolverEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct DeleteResolverEndpointOutputResponse: Equatable {
    /// <p>Information about the <code>DeleteResolverEndpoint</code> request, including the status of the request.</p>
    public let resolverEndpoint: ResolverEndpoint?

    public init (
        resolverEndpoint: ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct DeleteResolverEndpointOutputResponseBody: Equatable {
    public let resolverEndpoint: ResolverEndpoint?
}

extension DeleteResolverEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

public struct DeleteResolverQueryLogConfigInputBodyMiddleware: Middleware {
    public let id: String = "DeleteResolverQueryLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResolverQueryLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResolverQueryLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResolverQueryLogConfigInput>
    public typealias MOutput = OperationOutput<DeleteResolverQueryLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResolverQueryLogConfigOutputError>
}

extension DeleteResolverQueryLogConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResolverQueryLogConfigInput(resolverQueryLogConfigId: \(String(describing: resolverQueryLogConfigId)))"}
}

extension DeleteResolverQueryLogConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverQueryLogConfigId = resolverQueryLogConfigId {
            try encodeContainer.encode(resolverQueryLogConfigId, forKey: .resolverQueryLogConfigId)
        }
    }
}

public struct DeleteResolverQueryLogConfigInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResolverQueryLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResolverQueryLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResolverQueryLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResolverQueryLogConfigInput>
    public typealias MOutput = OperationOutput<DeleteResolverQueryLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResolverQueryLogConfigOutputError>
}

public struct DeleteResolverQueryLogConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResolverQueryLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResolverQueryLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResolverQueryLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResolverQueryLogConfigInput>
    public typealias MOutput = OperationOutput<DeleteResolverQueryLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResolverQueryLogConfigOutputError>
}

public struct DeleteResolverQueryLogConfigInput: Equatable {
    /// <p>The ID of the query logging configuration that you want to delete.</p>
    public let resolverQueryLogConfigId: String?

    public init (
        resolverQueryLogConfigId: String? = nil
    )
    {
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
    }
}

struct DeleteResolverQueryLogConfigInputBody: Equatable {
    public let resolverQueryLogConfigId: String?
}

extension DeleteResolverQueryLogConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverQueryLogConfigId)
        resolverQueryLogConfigId = resolverQueryLogConfigIdDecoded
    }
}

extension DeleteResolverQueryLogConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResolverQueryLogConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResolverQueryLogConfigOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResolverQueryLogConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResolverQueryLogConfigOutputResponse(resolverQueryLogConfig: \(String(describing: resolverQueryLogConfig)))"}
}

extension DeleteResolverQueryLogConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteResolverQueryLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverQueryLogConfig = output.resolverQueryLogConfig
        } else {
            self.resolverQueryLogConfig = nil
        }
    }
}

public struct DeleteResolverQueryLogConfigOutputResponse: Equatable {
    /// <p>Information about the query logging configuration that you deleted, including the status of the request.</p>
    public let resolverQueryLogConfig: ResolverQueryLogConfig?

    public init (
        resolverQueryLogConfig: ResolverQueryLogConfig? = nil
    )
    {
        self.resolverQueryLogConfig = resolverQueryLogConfig
    }
}

struct DeleteResolverQueryLogConfigOutputResponseBody: Equatable {
    public let resolverQueryLogConfig: ResolverQueryLogConfig?
}

extension DeleteResolverQueryLogConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfig = "ResolverQueryLogConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigDecoded = try containerValues.decodeIfPresent(ResolverQueryLogConfig.self, forKey: .resolverQueryLogConfig)
        resolverQueryLogConfig = resolverQueryLogConfigDecoded
    }
}

public struct DeleteResolverRuleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteResolverRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResolverRuleInput>
    public typealias MOutput = OperationOutput<DeleteResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResolverRuleOutputError>
}

extension DeleteResolverRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResolverRuleInput(resolverRuleId: \(String(describing: resolverRuleId)))"}
}

extension DeleteResolverRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resolverRuleId = "ResolverRuleId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverRuleId = resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
    }
}

public struct DeleteResolverRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResolverRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResolverRuleInput>
    public typealias MOutput = OperationOutput<DeleteResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResolverRuleOutputError>
}

public struct DeleteResolverRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResolverRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResolverRuleInput>
    public typealias MOutput = OperationOutput<DeleteResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResolverRuleOutputError>
}

public struct DeleteResolverRuleInput: Equatable {
    /// <p>The ID of the Resolver rule that you want to delete.</p>
    public let resolverRuleId: String?

    public init (
        resolverRuleId: String? = nil
    )
    {
        self.resolverRuleId = resolverRuleId
    }
}

struct DeleteResolverRuleInputBody: Equatable {
    public let resolverRuleId: String?
}

extension DeleteResolverRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverRuleId = "ResolverRuleId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
    }
}

extension DeleteResolverRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResolverRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResolverRuleOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResolverRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResolverRuleOutputResponse(resolverRule: \(String(describing: resolverRule)))"}
}

extension DeleteResolverRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteResolverRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverRule = output.resolverRule
        } else {
            self.resolverRule = nil
        }
    }
}

public struct DeleteResolverRuleOutputResponse: Equatable {
    /// <p>Information about the <code>DeleteResolverRule</code> request, including the status of the request.</p>
    public let resolverRule: ResolverRule?

    public init (
        resolverRule: ResolverRule? = nil
    )
    {
        self.resolverRule = resolverRule
    }
}

struct DeleteResolverRuleOutputResponseBody: Equatable {
    public let resolverRule: ResolverRule?
}

extension DeleteResolverRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverRule = "ResolverRule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleDecoded = try containerValues.decodeIfPresent(ResolverRule.self, forKey: .resolverRule)
        resolverRule = resolverRuleDecoded
    }
}

public struct DisassociateFirewallRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateFirewallRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFirewallRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFirewallRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFirewallRuleGroupInput>
    public typealias MOutput = OperationOutput<DisassociateFirewallRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFirewallRuleGroupOutputError>
}

extension DisassociateFirewallRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFirewallRuleGroupInput(firewallRuleGroupAssociationId: \(String(describing: firewallRuleGroupAssociationId)))"}
}

extension DisassociateFirewallRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupAssociationId = firewallRuleGroupAssociationId {
            try encodeContainer.encode(firewallRuleGroupAssociationId, forKey: .firewallRuleGroupAssociationId)
        }
    }
}

public struct DisassociateFirewallRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateFirewallRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFirewallRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFirewallRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFirewallRuleGroupInput>
    public typealias MOutput = OperationOutput<DisassociateFirewallRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFirewallRuleGroupOutputError>
}

public struct DisassociateFirewallRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateFirewallRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFirewallRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFirewallRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFirewallRuleGroupInput>
    public typealias MOutput = OperationOutput<DisassociateFirewallRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFirewallRuleGroupOutputError>
}

public struct DisassociateFirewallRuleGroupInput: Equatable {
    /// <p>The identifier of the <a>FirewallRuleGroupAssociation</a>. </p>
    public let firewallRuleGroupAssociationId: String?

    public init (
        firewallRuleGroupAssociationId: String? = nil
    )
    {
        self.firewallRuleGroupAssociationId = firewallRuleGroupAssociationId
    }
}

struct DisassociateFirewallRuleGroupInputBody: Equatable {
    public let firewallRuleGroupAssociationId: String?
}

extension DisassociateFirewallRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallRuleGroupAssociationId)
        firewallRuleGroupAssociationId = firewallRuleGroupAssociationIdDecoded
    }
}

extension DisassociateFirewallRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFirewallRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateFirewallRuleGroupOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFirewallRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFirewallRuleGroupOutputResponse(firewallRuleGroupAssociation: \(String(describing: firewallRuleGroupAssociation)))"}
}

extension DisassociateFirewallRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateFirewallRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallRuleGroupAssociation = output.firewallRuleGroupAssociation
        } else {
            self.firewallRuleGroupAssociation = nil
        }
    }
}

public struct DisassociateFirewallRuleGroupOutputResponse: Equatable {
    /// <p>The firewall rule group association that you just removed. </p>
    public let firewallRuleGroupAssociation: FirewallRuleGroupAssociation?

    public init (
        firewallRuleGroupAssociation: FirewallRuleGroupAssociation? = nil
    )
    {
        self.firewallRuleGroupAssociation = firewallRuleGroupAssociation
    }
}

struct DisassociateFirewallRuleGroupOutputResponseBody: Equatable {
    public let firewallRuleGroupAssociation: FirewallRuleGroupAssociation?
}

extension DisassociateFirewallRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupAssociation = "FirewallRuleGroupAssociation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationDecoded = try containerValues.decodeIfPresent(FirewallRuleGroupAssociation.self, forKey: .firewallRuleGroupAssociation)
        firewallRuleGroupAssociation = firewallRuleGroupAssociationDecoded
    }
}

public struct DisassociateResolverEndpointIpAddressInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateResolverEndpointIpAddressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResolverEndpointIpAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResolverEndpointIpAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResolverEndpointIpAddressInput>
    public typealias MOutput = OperationOutput<DisassociateResolverEndpointIpAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResolverEndpointIpAddressOutputError>
}

extension DisassociateResolverEndpointIpAddressInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateResolverEndpointIpAddressInput(ipAddress: \(String(describing: ipAddress)), resolverEndpointId: \(String(describing: resolverEndpointId)))"}
}

extension DisassociateResolverEndpointIpAddressInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ipAddress = "IpAddress"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

public struct DisassociateResolverEndpointIpAddressInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateResolverEndpointIpAddressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResolverEndpointIpAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResolverEndpointIpAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResolverEndpointIpAddressInput>
    public typealias MOutput = OperationOutput<DisassociateResolverEndpointIpAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResolverEndpointIpAddressOutputError>
}

public struct DisassociateResolverEndpointIpAddressInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateResolverEndpointIpAddressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResolverEndpointIpAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResolverEndpointIpAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResolverEndpointIpAddressInput>
    public typealias MOutput = OperationOutput<DisassociateResolverEndpointIpAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResolverEndpointIpAddressOutputError>
}

public struct DisassociateResolverEndpointIpAddressInput: Equatable {
    /// <p>The IPv4 address that you want to remove from a Resolver endpoint.</p>
    public let ipAddress: IpAddressUpdate?
    /// <p>The ID of the Resolver endpoint that you want to disassociate an IP address from.</p>
    public let resolverEndpointId: String?

    public init (
        ipAddress: IpAddressUpdate? = nil,
        resolverEndpointId: String? = nil
    )
    {
        self.ipAddress = ipAddress
        self.resolverEndpointId = resolverEndpointId
    }
}

struct DisassociateResolverEndpointIpAddressInputBody: Equatable {
    public let resolverEndpointId: String?
    public let ipAddress: IpAddressUpdate?
}

extension DisassociateResolverEndpointIpAddressInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ipAddress = "IpAddress"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(IpAddressUpdate.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension DisassociateResolverEndpointIpAddressOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateResolverEndpointIpAddressOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateResolverEndpointIpAddressOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateResolverEndpointIpAddressOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateResolverEndpointIpAddressOutputResponse(resolverEndpoint: \(String(describing: resolverEndpoint)))"}
}

extension DisassociateResolverEndpointIpAddressOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateResolverEndpointIpAddressOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct DisassociateResolverEndpointIpAddressOutputResponse: Equatable {
    /// <p>The response to an <code>DisassociateResolverEndpointIpAddress</code> request.</p>
    public let resolverEndpoint: ResolverEndpoint?

    public init (
        resolverEndpoint: ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct DisassociateResolverEndpointIpAddressOutputResponseBody: Equatable {
    public let resolverEndpoint: ResolverEndpoint?
}

extension DisassociateResolverEndpointIpAddressOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

public struct DisassociateResolverQueryLogConfigInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateResolverQueryLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResolverQueryLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResolverQueryLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResolverQueryLogConfigInput>
    public typealias MOutput = OperationOutput<DisassociateResolverQueryLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResolverQueryLogConfigOutputError>
}

extension DisassociateResolverQueryLogConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateResolverQueryLogConfigInput(resolverQueryLogConfigId: \(String(describing: resolverQueryLogConfigId)), resourceId: \(String(describing: resourceId)))"}
}

extension DisassociateResolverQueryLogConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverQueryLogConfigId = resolverQueryLogConfigId {
            try encodeContainer.encode(resolverQueryLogConfigId, forKey: .resolverQueryLogConfigId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct DisassociateResolverQueryLogConfigInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateResolverQueryLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResolverQueryLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResolverQueryLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResolverQueryLogConfigInput>
    public typealias MOutput = OperationOutput<DisassociateResolverQueryLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResolverQueryLogConfigOutputError>
}

public struct DisassociateResolverQueryLogConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateResolverQueryLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResolverQueryLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResolverQueryLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResolverQueryLogConfigInput>
    public typealias MOutput = OperationOutput<DisassociateResolverQueryLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResolverQueryLogConfigOutputError>
}

public struct DisassociateResolverQueryLogConfigInput: Equatable {
    /// <p>The ID of the query logging configuration that you want to disassociate a specified VPC from.</p>
    public let resolverQueryLogConfigId: String?
    /// <p>The ID of the Amazon VPC that you want to disassociate from a specified query logging configuration.</p>
    public let resourceId: String?

    public init (
        resolverQueryLogConfigId: String? = nil,
        resourceId: String? = nil
    )
    {
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
        self.resourceId = resourceId
    }
}

struct DisassociateResolverQueryLogConfigInputBody: Equatable {
    public let resolverQueryLogConfigId: String?
    public let resourceId: String?
}

extension DisassociateResolverQueryLogConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverQueryLogConfigId)
        resolverQueryLogConfigId = resolverQueryLogConfigIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DisassociateResolverQueryLogConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateResolverQueryLogConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateResolverQueryLogConfigOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateResolverQueryLogConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateResolverQueryLogConfigOutputResponse(resolverQueryLogConfigAssociation: \(String(describing: resolverQueryLogConfigAssociation)))"}
}

extension DisassociateResolverQueryLogConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateResolverQueryLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverQueryLogConfigAssociation = output.resolverQueryLogConfigAssociation
        } else {
            self.resolverQueryLogConfigAssociation = nil
        }
    }
}

public struct DisassociateResolverQueryLogConfigOutputResponse: Equatable {
    /// <p>A complex type that contains settings for the association that you deleted between an Amazon VPC and a query logging configuration.</p>
    public let resolverQueryLogConfigAssociation: ResolverQueryLogConfigAssociation?

    public init (
        resolverQueryLogConfigAssociation: ResolverQueryLogConfigAssociation? = nil
    )
    {
        self.resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociation
    }
}

struct DisassociateResolverQueryLogConfigOutputResponseBody: Equatable {
    public let resolverQueryLogConfigAssociation: ResolverQueryLogConfigAssociation?
}

extension DisassociateResolverQueryLogConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfigAssociation = "ResolverQueryLogConfigAssociation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigAssociationDecoded = try containerValues.decodeIfPresent(ResolverQueryLogConfigAssociation.self, forKey: .resolverQueryLogConfigAssociation)
        resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociationDecoded
    }
}

public struct DisassociateResolverRuleInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateResolverRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResolverRuleInput>
    public typealias MOutput = OperationOutput<DisassociateResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResolverRuleOutputError>
}

extension DisassociateResolverRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateResolverRuleInput(resolverRuleId: \(String(describing: resolverRuleId)), vPCId: \(String(describing: vPCId)))"}
}

extension DisassociateResolverRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resolverRuleId = "ResolverRuleId"
        case vPCId = "VPCId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverRuleId = resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
        if let vPCId = vPCId {
            try encodeContainer.encode(vPCId, forKey: .vPCId)
        }
    }
}

public struct DisassociateResolverRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateResolverRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResolverRuleInput>
    public typealias MOutput = OperationOutput<DisassociateResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResolverRuleOutputError>
}

public struct DisassociateResolverRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateResolverRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateResolverRuleInput>
    public typealias MOutput = OperationOutput<DisassociateResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateResolverRuleOutputError>
}

public struct DisassociateResolverRuleInput: Equatable {
    /// <p>The ID of the Resolver rule that you want to disassociate from the specified VPC.</p>
    public let resolverRuleId: String?
    /// <p>The ID of the VPC that you want to disassociate the Resolver rule from.</p>
    public let vPCId: String?

    public init (
        resolverRuleId: String? = nil,
        vPCId: String? = nil
    )
    {
        self.resolverRuleId = resolverRuleId
        self.vPCId = vPCId
    }
}

struct DisassociateResolverRuleInputBody: Equatable {
    public let vPCId: String?
    public let resolverRuleId: String?
}

extension DisassociateResolverRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverRuleId = "ResolverRuleId"
        case vPCId = "VPCId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vPCIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vPCId)
        vPCId = vPCIdDecoded
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
    }
}

extension DisassociateResolverRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateResolverRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateResolverRuleOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateResolverRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateResolverRuleOutputResponse(resolverRuleAssociation: \(String(describing: resolverRuleAssociation)))"}
}

extension DisassociateResolverRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateResolverRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverRuleAssociation = output.resolverRuleAssociation
        } else {
            self.resolverRuleAssociation = nil
        }
    }
}

public struct DisassociateResolverRuleOutputResponse: Equatable {
    /// <p>Information about the <code>DisassociateResolverRule</code> request, including the status of the request.</p>
    public let resolverRuleAssociation: ResolverRuleAssociation?

    public init (
        resolverRuleAssociation: ResolverRuleAssociation? = nil
    )
    {
        self.resolverRuleAssociation = resolverRuleAssociation
    }
}

struct DisassociateResolverRuleOutputResponseBody: Equatable {
    public let resolverRuleAssociation: ResolverRuleAssociation?
}

extension DisassociateResolverRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverRuleAssociation = "ResolverRuleAssociation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleAssociationDecoded = try containerValues.decodeIfPresent(ResolverRuleAssociation.self, forKey: .resolverRuleAssociation)
        resolverRuleAssociation = resolverRuleAssociationDecoded
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>For Resolver list operations
/// 			(<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html">ListResolverEndpoints</a>,
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html">ListResolverRules</a>,
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html">ListResolverRuleAssociations</a>,
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigs.html">ListResolverQueryLogConfigs</a>,
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigAssociations.html">ListResolverQueryLogConfigAssociations</a>),
/// 			and
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverDnssecConfigs.html">ListResolverDnssecConfigs</a>),
/// 			an optional specification to return a subset of objects.</p>
/// 		       <p>To filter objects, such as Resolver endpoints or Resolver rules, you specify <code>Name</code> and <code>Values</code>. For example,
/// 			to list only inbound Resolver endpoints, specify <code>Direction</code> for <code>Name</code> and specify <code>INBOUND</code> for <code>Values</code>. </p>
public struct Filter: Equatable {
    /// <p>The name of the parameter that you want to use to filter objects.</p>
    /// 		       <p>The valid values for <code>Name</code> depend on the action that you're including the filter in,
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html">ListResolverEndpoints</a>,
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html">ListResolverRules</a>,
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html">ListResolverRuleAssociations</a>,
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigs.html">ListResolverQueryLogConfigs</a>,
    /// 			or
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigAssociations.html">ListResolverQueryLogConfigAssociations</a>.</p>
    /// 		
    /// 		       <note>
    /// 			         <p>In early versions of Resolver, values for <code>Name</code> were listed as uppercase, with underscore (_) delimiters. For example,
    /// 				<code>CreatorRequestId</code> was originally listed as <code>CREATOR_REQUEST_ID</code>. Uppercase values for <code>Name</code> are still supported.</p>
    /// 		       </note>
    /// 		
    /// 		       <p>
    ///             <b>ListResolverEndpoints</b>
    ///          </p>
    /// 		       <p>Valid values for <code>Name</code> include the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CreatorRequestId</code>: The value that you specified when you created the Resolver endpoint.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Direction</code>: Whether you want to return inbound or outbound Resolver endpoints. If you specify <code>DIRECTION</code>
    /// 				for <code>Name</code>, specify <code>INBOUND</code> or <code>OUTBOUND</code> for <code>Values</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HostVpcId</code>: The ID of the VPC that inbound DNS queries pass through on the way from your network to your VPCs in a region, or
    /// 				the VPC that outbound queries pass through on the way from your VPCs to your network. In a
    /// 				<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html">CreateResolverEndpoint</a>
    /// 				request, <code>SubnetId</code> indirectly identifies the VPC. In a
    /// 				<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html">GetResolverEndpoint</a>
    /// 				request, the VPC ID for a Resolver endpoint
    /// 				is returned in the <code>HostVPCId</code> element. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IpAddressCount</code>: The number of IP addresses that you have associated with the Resolver endpoint.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Name</code>: The name of the Resolver endpoint.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SecurityGroupIds</code>: The IDs of the VPC security groups that you specified when you created the
    /// 				Resolver endpoint.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Status</code>: The status of the Resolver endpoint. If you specify <code>Status</code> for <code>Name</code>,
    /// 				specify one of the following status codes for <code>Values</code>: <code>CREATING</code>, <code>OPERATIONAL</code>, <code>UPDATING</code>,
    /// 				<code>AUTO_RECOVERING</code>, <code>ACTION_NEEDED</code>, or <code>DELETING</code>. For more information, see <code>Status</code> in
    /// 				<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ResolverEndpoint.html">ResolverEndpoint</a>.</p>
    ///             </li>
    ///          </ul>
    /// 		
    /// 		       <p>
    ///             <b>ListResolverRules</b>
    ///          </p>
    /// 		       <p>Valid values for <code>Name</code> include the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CreatorRequestId</code>: The value that you specified when you created the Resolver rule.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DomainName</code>: The domain name for which Resolver is forwarding DNS queries to your network. In the value that
    /// 				you specify for <code>Values</code>, include a trailing dot (.) after the domain name. For example, if the domain name is example.com,
    /// 				specify the following value. Note the "." after <code>com</code>:</p>
    /// 				           <p>
    ///                   <code>example.com.</code>
    ///                </p>
    /// 			         </li>
    ///             <li>
    ///                <p>
    ///                   <code>Name</code>: The name of the Resolver rule.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ResolverEndpointId</code>: The ID of the Resolver endpoint that the Resolver rule is associated with.</p>
    /// 				           <note>
    ///                   <p>You can filter on the Resolver endpoint only for rules that have a value of <code>FORWARD</code> for
    /// 					<code>RuleType</code>.</p>
    ///                </note>
    /// 			         </li>
    ///             <li>
    ///                <p>
    ///                   <code>Status</code>: The status of the Resolver rule. If you specify <code>Status</code> for <code>Name</code>,
    /// 				specify one of the following status codes for <code>Values</code>: <code>COMPLETE</code>, <code>DELETING</code>, <code>UPDATING</code>,
    /// 				or <code>FAILED</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Type</code>: The type of the Resolver rule. If you specify <code>TYPE</code>
    /// 				for <code>Name</code>, specify <code>FORWARD</code> or <code>SYSTEM</code> for <code>Values</code>.</p>
    ///             </li>
    ///          </ul>
    /// 		
    /// 		       <p>
    ///             <b>ListResolverRuleAssociations</b>
    ///          </p>
    /// 		       <p>Valid values for <code>Name</code> include the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Name</code>: The name of the Resolver rule association.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ResolverRuleId</code>: The ID of the Resolver rule that is associated with one or more VPCs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Status</code>: The status of the Resolver rule association. If you specify <code>Status</code> for <code>Name</code>,
    /// 				specify one of the following status codes for <code>Values</code>: <code>CREATING</code>, <code>COMPLETE</code>, <code>DELETING</code>, or
    /// 				<code>FAILED</code>.</p>
    /// 			         </li>
    ///             <li>
    ///                <p>
    ///                   <code>VPCId</code>: The ID of the VPC that the Resolver rule is associated with.</p>
    ///             </li>
    ///          </ul>
    ///
    /// 		       <p>
    ///             <b>ListResolverQueryLogConfigs</b>
    ///          </p>
    /// 		       <p>Valid values for <code>Name</code> include the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Arn</code>: The ARN for the query logging configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AssociationCount</code>: The number of VPCs that are associated with the query logging configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CreationTime</code>: The date and time that the query logging configuration was created, in Unix time format and
    /// 				Coordinated Universal Time (UTC). </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CreatorRequestId</code>: A unique string that identifies the request that created the query logging configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Destination</code>: The AWS service that you want to forward query logs to. Valid values include the following:</p>
    /// 				           <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>S3</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>CloudWatchLogs</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>KinesisFirehose</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    /// 			         </li>
    ///             <li>
    ///                <p>
    ///                   <code>DestinationArn</code>: The ARN of the location that Resolver is sending query logs to. This value can be the ARN for an
    /// 				S3 bucket, a CloudWatch Logs log group, or a Kinesis Data Firehose delivery stream.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Id</code>: The ID of the query logging configuration</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Name</code>: The name of the query logging configuration</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OwnerId</code>: The AWS account ID for the account that created the query logging configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ShareStatus</code>: An indication of whether the query logging configuration is shared with other AWS accounts,
    /// 				or was shared with the current account by another AWS account. Valid values include: <code>NOT_SHARED</code>, <code>SHARED_WITH_ME</code>,
    /// 				or <code>SHARED_BY_ME</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Status</code>: The status of the query logging configuration. If you specify <code>Status</code> for <code>Name</code>,
    /// 				specify the applicable status code for <code>Values</code>: <code>CREATING</code>, <code>CREATED</code>,
    /// 				<code>DELETING</code>, or <code>FAILED</code>. For more information, see
    /// 				<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ResolverQueryLogConfig.html#Route53Resolver-Type-route53resolver_ResolverQueryLogConfig-Status">Status</a>.
    /// 				</p>
    /// 			         </li>
    ///          </ul>
    /// 		
    /// 		       <p>
    ///             <b>ListResolverQueryLogConfigAssociations</b>
    ///          </p>
    /// 		       <p>Valid values for <code>Name</code> include the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CreationTime</code>: The date and time that the VPC was associated with the query logging configuration, in Unix time format and
    /// 				Coordinated Universal Time (UTC).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Error</code>: If the value of <code>Status</code> is <code>FAILED</code>, specify the cause:
    /// 				<code>DESTINATION_NOT_FOUND</code> or <code>ACCESS_DENIED</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Id</code>: The ID of the query logging association.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ResolverQueryLogConfigId</code>: The ID of the query logging configuration that a VPC is associated with.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ResourceId</code>: The ID of the Amazon VPC that is associated with the query logging configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Status</code>: The status of the query logging association. If you specify <code>Status</code> for <code>Name</code>,
    /// 				specify the applicable status code for <code>Values</code>: <code>CREATING</code>, <code>CREATED</code>,
    /// 				<code>DELETING</code>, or <code>FAILED</code>. For more information, see
    /// 			    <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ResolverQueryLogConfigAssociation.html#Route53Resolver-Type-route53resolver_ResolverQueryLogConfigAssociation-Status">Status</a>.
    /// 				</p>
    /// 			         </li>
    ///          </ul>
    public let name: String?
    /// <p>When you're using a <code>List</code> operation and you want the operation to return a subset of objects, such as Resolver endpoints or Resolver rules,
    /// 			the value of the parameter that you want to use to filter objects. For example, to list only inbound Resolver endpoints, specify <code>Direction</code> for
    /// 			<code>Name</code> and specify <code>INBOUND</code> for <code>Values</code>.</p>
    public let values: [String]?

    public init (
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension FirewallConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallFailOpen = "FirewallFailOpen"
        case id = "Id"
        case ownerId = "OwnerId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallFailOpen = firewallFailOpen {
            try encodeContainer.encode(firewallFailOpen.rawValue, forKey: .firewallFailOpen)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let firewallFailOpenDecoded = try containerValues.decodeIfPresent(FirewallFailOpenStatus.self, forKey: .firewallFailOpen)
        firewallFailOpen = firewallFailOpenDecoded
    }
}

extension FirewallConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FirewallConfig(firewallFailOpen: \(String(describing: firewallFailOpen)), id: \(String(describing: id)), ownerId: \(String(describing: ownerId)), resourceId: \(String(describing: resourceId)))"}
}

/// <p>Configuration of the firewall behavior provided by DNS Firewall for a single VPC from
/// 			Amazon Virtual Private Cloud (Amazon VPC). </p>
public struct FirewallConfig: Equatable {
    /// <p>Determines how DNS Firewall operates during failures, for example when all traffic that is sent to DNS Firewall fails to receive a reply. </p>
    ///          <ul>
    ///             <li>
    ///                <p>By default, fail open is disabled, which means the failure mode is closed. This approach favors security over availability. DNS Firewall returns
    ///            a failure error when it is unable to properly evaluate a query. </p>
    ///             </li>
    ///             <li>
    ///                <p>If you enable this option, the failure mode is open. This approach favors availability over security. DNS Firewall allows queries to proceed if it
    ///        is unable to properly evaluate them. </p>
    ///             </li>
    ///          </ul>
    ///          <p>This behavior is only enforced for VPCs that have at least one DNS Firewall rule group association. </p>
    public let firewallFailOpen: FirewallFailOpenStatus?
    /// <p>The ID of the firewall configuration.</p>
    public let id: String?
    /// <p>The AWS account ID of the owner of the VPC that this firewall configuration applies to.</p>
    public let ownerId: String?
    /// <p>The ID of the VPC that this firewall configuration applies to.</p>
    public let resourceId: String?

    public init (
        firewallFailOpen: FirewallFailOpenStatus? = nil,
        id: String? = nil,
        ownerId: String? = nil,
        resourceId: String? = nil
    )
    {
        self.firewallFailOpen = firewallFailOpen
        self.id = id
        self.ownerId = ownerId
        self.resourceId = resourceId
    }
}

public enum FirewallDomainImportOperation {
    case replace
    case sdkUnknown(String)
}

extension FirewallDomainImportOperation : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FirewallDomainImportOperation] {
        return [
            .replace,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .replace: return "REPLACE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FirewallDomainImportOperation(rawValue: rawValue) ?? FirewallDomainImportOperation.sdkUnknown(rawValue)
    }
}

extension FirewallDomainList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case domainCount = "DomainCount"
        case id = "Id"
        case managedOwnerName = "ManagedOwnerName"
        case modificationTime = "ModificationTime"
        case name = "Name"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let domainCount = domainCount {
            try encodeContainer.encode(domainCount, forKey: .domainCount)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let managedOwnerName = managedOwnerName {
            try encodeContainer.encode(managedOwnerName, forKey: .managedOwnerName)
        }
        if let modificationTime = modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let domainCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .domainCount)
        domainCount = domainCountDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FirewallDomainListStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let managedOwnerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .managedOwnerName)
        managedOwnerName = managedOwnerNameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension FirewallDomainList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FirewallDomainList(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), creatorRequestId: \(String(describing: creatorRequestId)), domainCount: \(String(describing: domainCount)), id: \(String(describing: id)), managedOwnerName: \(String(describing: managedOwnerName)), modificationTime: \(String(describing: modificationTime)), name: \(String(describing: name)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

/// <p>High-level information about a list of firewall domains for use in a <a>FirewallRule</a>. This is returned by <a>GetFirewallDomainList</a>.</p>
///          <p>To retrieve the domains that are defined for this domain list, call <a>ListFirewallDomains</a>.</p>
public struct FirewallDomainList: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall domain list.</p>
    public let arn: String?
    /// <p>The date and time that the domain list was created, in Unix time format and Coordinated Universal Time (UTC). </p>
    public let creationTime: String?
    /// <p>A unique string defined by you to identify the request. This allows you to retry failed
    /// 			requests without the risk of running the operation twice. This can be any unique string,
    /// 			for example, a timestamp. </p>
    public let creatorRequestId: String?
    /// <p>The number of domain names that are specified in the domain list.</p>
    public let domainCount: Int?
    /// <p>The ID of the domain list. </p>
    public let id: String?
    /// <p>The owner of the list, used only for lists that are not managed by you. For example, the managed domain list <code>AWSManagedDomainsMalwareDomainList</code> has the managed owner name <code>Route 53 Resolver DNS Firewall</code>.</p>
    public let managedOwnerName: String?
    /// <p>The date and time that the domain list was last modified, in Unix time format and Coordinated Universal Time (UTC). </p>
    public let modificationTime: String?
    /// <p>The name of the domain list. </p>
    public let name: String?
    /// <p>The status of the domain list.  </p>
    public let status: FirewallDomainListStatus?
    /// <p>Additional information about the status of the list, if available.</p>
    public let statusMessage: String?

    public init (
        arn: String? = nil,
        creationTime: String? = nil,
        creatorRequestId: String? = nil,
        domainCount: Int? = nil,
        id: String? = nil,
        managedOwnerName: String? = nil,
        modificationTime: String? = nil,
        name: String? = nil,
        status: FirewallDomainListStatus? = nil,
        statusMessage: String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.creatorRequestId = creatorRequestId
        self.domainCount = domainCount
        self.id = id
        self.managedOwnerName = managedOwnerName
        self.modificationTime = modificationTime
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
    }
}

extension FirewallDomainListMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creatorRequestId = "CreatorRequestId"
        case id = "Id"
        case managedOwnerName = "ManagedOwnerName"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let managedOwnerName = managedOwnerName {
            try encodeContainer.encode(managedOwnerName, forKey: .managedOwnerName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let managedOwnerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .managedOwnerName)
        managedOwnerName = managedOwnerNameDecoded
    }
}

extension FirewallDomainListMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FirewallDomainListMetadata(arn: \(String(describing: arn)), creatorRequestId: \(String(describing: creatorRequestId)), id: \(String(describing: id)), managedOwnerName: \(String(describing: managedOwnerName)), name: \(String(describing: name)))"}
}

/// <p>Minimal high-level information for a firewall domain list. The action <a>ListFirewallDomainLists</a> returns an array of these objects. </p>
///          <p>To retrieve full information for a firewall domain list, call  <a>GetFirewallDomainList</a> and <a>ListFirewallDomains</a>.</p>
public struct FirewallDomainListMetadata: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall domain list metadata.</p>
    public let arn: String?
    /// <p>A unique string defined by you to identify the request. This allows you to retry failed
    /// 			requests without the risk of running the operation twice. This can be any unique string,
    /// 			for example, a timestamp. </p>
    public let creatorRequestId: String?
    /// <p>The ID of the domain list. </p>
    public let id: String?
    /// <p>The owner of the list, used only for lists that are not managed by you. For example, the managed domain list <code>AWSManagedDomainsMalwareDomainList</code> has the managed owner name <code>Route 53 Resolver DNS Firewall</code>.</p>
    public let managedOwnerName: String?
    /// <p>The name of the domain list. </p>
    public let name: String?

    public init (
        arn: String? = nil,
        creatorRequestId: String? = nil,
        id: String? = nil,
        managedOwnerName: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.creatorRequestId = creatorRequestId
        self.id = id
        self.managedOwnerName = managedOwnerName
        self.name = name
    }
}

public enum FirewallDomainListStatus {
    case complete
    case completeImportFailed
    case deleting
    case importing
    case updating
    case sdkUnknown(String)
}

extension FirewallDomainListStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FirewallDomainListStatus] {
        return [
            .complete,
            .completeImportFailed,
            .deleting,
            .importing,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "COMPLETE"
        case .completeImportFailed: return "COMPLETE_IMPORT_FAILED"
        case .deleting: return "DELETING"
        case .importing: return "IMPORTING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FirewallDomainListStatus(rawValue: rawValue) ?? FirewallDomainListStatus.sdkUnknown(rawValue)
    }
}

public enum FirewallDomainUpdateOperation {
    case add
    case remove
    case replace
    case sdkUnknown(String)
}

extension FirewallDomainUpdateOperation : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FirewallDomainUpdateOperation] {
        return [
            .add,
            .remove,
            .replace,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .add: return "ADD"
        case .remove: return "REMOVE"
        case .replace: return "REPLACE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FirewallDomainUpdateOperation(rawValue: rawValue) ?? FirewallDomainUpdateOperation.sdkUnknown(rawValue)
    }
}

public enum FirewallFailOpenStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension FirewallFailOpenStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FirewallFailOpenStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FirewallFailOpenStatus(rawValue: rawValue) ?? FirewallFailOpenStatus.sdkUnknown(rawValue)
    }
}

extension FirewallRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case blockOverrideDnsType = "BlockOverrideDnsType"
        case blockOverrideDomain = "BlockOverrideDomain"
        case blockOverrideTtl = "BlockOverrideTtl"
        case blockResponse = "BlockResponse"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case modificationTime = "ModificationTime"
        case name = "Name"
        case priority = "Priority"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let blockOverrideDnsType = blockOverrideDnsType {
            try encodeContainer.encode(blockOverrideDnsType.rawValue, forKey: .blockOverrideDnsType)
        }
        if let blockOverrideDomain = blockOverrideDomain {
            try encodeContainer.encode(blockOverrideDomain, forKey: .blockOverrideDomain)
        }
        if let blockOverrideTtl = blockOverrideTtl {
            try encodeContainer.encode(blockOverrideTtl, forKey: .blockOverrideTtl)
        }
        if let blockResponse = blockResponse {
            try encodeContainer.encode(blockResponse.rawValue, forKey: .blockResponse)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let modificationTime = modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let blockResponseDecoded = try containerValues.decodeIfPresent(BlockResponse.self, forKey: .blockResponse)
        blockResponse = blockResponseDecoded
        let blockOverrideDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .blockOverrideDomain)
        blockOverrideDomain = blockOverrideDomainDecoded
        let blockOverrideDnsTypeDecoded = try containerValues.decodeIfPresent(BlockOverrideDnsType.self, forKey: .blockOverrideDnsType)
        blockOverrideDnsType = blockOverrideDnsTypeDecoded
        let blockOverrideTtlDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .blockOverrideTtl)
        blockOverrideTtl = blockOverrideTtlDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension FirewallRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FirewallRule(action: \(String(describing: action)), blockOverrideDnsType: \(String(describing: blockOverrideDnsType)), blockOverrideDomain: \(String(describing: blockOverrideDomain)), blockOverrideTtl: \(String(describing: blockOverrideTtl)), blockResponse: \(String(describing: blockResponse)), creationTime: \(String(describing: creationTime)), creatorRequestId: \(String(describing: creatorRequestId)), firewallDomainListId: \(String(describing: firewallDomainListId)), firewallRuleGroupId: \(String(describing: firewallRuleGroupId)), modificationTime: \(String(describing: modificationTime)), name: \(String(describing: name)), priority: \(String(describing: priority)))"}
}

/// <p>A single firewall rule in a rule group.</p>
public struct FirewallRule: Equatable {
    /// <p>The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALLOW</code> - Permit the request to go through.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ALERT</code> - Permit the request to go through but send an alert to the logs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BLOCK</code> - Disallow the request. If this is specified, additional handling details are provided in the rule's <code>BlockResponse</code> setting. </p>
    ///             </li>
    ///          </ul>
    public let action: Action?
    /// <p>The DNS record's type. This determines the format of the record value that you provided in <code>BlockOverrideDomain</code>. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
    public let blockOverrideDnsType: BlockOverrideDnsType?
    /// <p>The custom DNS record to send back in response to the query. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
    public let blockOverrideDomain: String?
    /// <p>The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
    public let blockOverrideTtl: Int?
    /// <p>The way that you want DNS Firewall to block the request. Used for the rule action setting <code>BLOCK</code>.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NODATA</code> - Respond indicating that the query was successful, but no response is available for it.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NXDOMAIN</code> - Respond indicating that the domain name that's in the query doesn't exist.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OVERRIDE</code> - Provide a custom override in the response. This option requires custom handling details in the rule's <code>BlockOverride*</code> settings. </p>
    ///             </li>
    ///          </ul>
    public let blockResponse: BlockResponse?
    /// <p>The date and time that the rule was created, in Unix time format and Coordinated Universal Time (UTC). </p>
    public let creationTime: String?
    /// <p>A unique string defined by you to identify the request. This allows you to retry failed requests
    ///            without the risk of executing the operation twice. This can be any unique string, for example, a timestamp. </p>
    public let creatorRequestId: String?
    /// <p>The ID of the domain list that's used in the rule. </p>
    public let firewallDomainListId: String?
    /// <p>The unique identifier of the firewall rule group of the rule. </p>
    public let firewallRuleGroupId: String?
    /// <p>The date and time that the rule was last modified, in Unix time format and Coordinated Universal Time (UTC).</p>
    public let modificationTime: String?
    /// <p>The name of the rule. </p>
    public let name: String?
    /// <p>The priority of the rule in the rule group. This value must be unique within the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting.</p>
    public let priority: Int?

    public init (
        action: Action? = nil,
        blockOverrideDnsType: BlockOverrideDnsType? = nil,
        blockOverrideDomain: String? = nil,
        blockOverrideTtl: Int? = nil,
        blockResponse: BlockResponse? = nil,
        creationTime: String? = nil,
        creatorRequestId: String? = nil,
        firewallDomainListId: String? = nil,
        firewallRuleGroupId: String? = nil,
        modificationTime: String? = nil,
        name: String? = nil,
        priority: Int? = nil
    )
    {
        self.action = action
        self.blockOverrideDnsType = blockOverrideDnsType
        self.blockOverrideDomain = blockOverrideDomain
        self.blockOverrideTtl = blockOverrideTtl
        self.blockResponse = blockResponse
        self.creationTime = creationTime
        self.creatorRequestId = creatorRequestId
        self.firewallDomainListId = firewallDomainListId
        self.firewallRuleGroupId = firewallRuleGroupId
        self.modificationTime = modificationTime
        self.name = name
        self.priority = priority
    }
}

extension FirewallRuleGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case id = "Id"
        case modificationTime = "ModificationTime"
        case name = "Name"
        case ownerId = "OwnerId"
        case ruleCount = "RuleCount"
        case shareStatus = "ShareStatus"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modificationTime = modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let ruleCount = ruleCount {
            try encodeContainer.encode(ruleCount, forKey: .ruleCount)
        }
        if let shareStatus = shareStatus {
            try encodeContainer.encode(shareStatus.rawValue, forKey: .shareStatus)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ruleCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .ruleCount)
        ruleCount = ruleCountDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FirewallRuleGroupStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let shareStatusDecoded = try containerValues.decodeIfPresent(ShareStatus.self, forKey: .shareStatus)
        shareStatus = shareStatusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension FirewallRuleGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FirewallRuleGroup(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), creatorRequestId: \(String(describing: creatorRequestId)), id: \(String(describing: id)), modificationTime: \(String(describing: modificationTime)), name: \(String(describing: name)), ownerId: \(String(describing: ownerId)), ruleCount: \(String(describing: ruleCount)), shareStatus: \(String(describing: shareStatus)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

/// <p>High-level information for a firewall rule group. A firewall rule group is a collection of rules that DNS Firewall uses to filter DNS network traffic for a VPC. To retrieve the rules for the rule group, call <a>ListFirewallRules</a>.</p>
public struct FirewallRuleGroup: Equatable {
    /// <p>The ARN (Amazon Resource Name) of the rule group.</p>
    public let arn: String?
    /// <p>The date and time that the rule group was created, in Unix time format and Coordinated Universal Time (UTC). </p>
    public let creationTime: String?
    /// <p>A unique string defined by you to identify the request. This allows you to retry failed
    /// 			requests without the risk of running the operation twice. This can be any unique string,
    /// 			for example, a timestamp. </p>
    public let creatorRequestId: String?
    /// <p>The ID of the rule group. </p>
    public let id: String?
    /// <p>The date and time that the rule group was last modified, in Unix time format and Coordinated Universal Time (UTC).</p>
    public let modificationTime: String?
    /// <p>The name of the rule group.</p>
    public let name: String?
    /// <p>The AWS account ID for the account that created the rule group. When a rule group is shared with your account,
    ///        this is the account that has shared the rule group with you.  </p>
    public let ownerId: String?
    /// <p>The number of rules in the rule group.</p>
    public let ruleCount: Int?
    /// <p>Whether the rule group is shared with other AWS accounts, or was shared with the current account by another
    ///               AWS account. Sharing is configured through AWS Resource Access Manager (AWS RAM).</p>
    public let shareStatus: ShareStatus?
    /// <p>The status of the domain list.  </p>
    public let status: FirewallRuleGroupStatus?
    /// <p>Additional information about the status of the rule group, if available.</p>
    public let statusMessage: String?

    public init (
        arn: String? = nil,
        creationTime: String? = nil,
        creatorRequestId: String? = nil,
        id: String? = nil,
        modificationTime: String? = nil,
        name: String? = nil,
        ownerId: String? = nil,
        ruleCount: Int? = nil,
        shareStatus: ShareStatus? = nil,
        status: FirewallRuleGroupStatus? = nil,
        statusMessage: String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.creatorRequestId = creatorRequestId
        self.id = id
        self.modificationTime = modificationTime
        self.name = name
        self.ownerId = ownerId
        self.ruleCount = ruleCount
        self.shareStatus = shareStatus
        self.status = status
        self.statusMessage = statusMessage
    }
}

extension FirewallRuleGroupAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case id = "Id"
        case managedOwnerName = "ManagedOwnerName"
        case modificationTime = "ModificationTime"
        case mutationProtection = "MutationProtection"
        case name = "Name"
        case priority = "Priority"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let managedOwnerName = managedOwnerName {
            try encodeContainer.encode(managedOwnerName, forKey: .managedOwnerName)
        }
        if let modificationTime = modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let mutationProtection = mutationProtection {
            try encodeContainer.encode(mutationProtection.rawValue, forKey: .mutationProtection)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
        let mutationProtectionDecoded = try containerValues.decodeIfPresent(MutationProtectionStatus.self, forKey: .mutationProtection)
        mutationProtection = mutationProtectionDecoded
        let managedOwnerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .managedOwnerName)
        managedOwnerName = managedOwnerNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FirewallRuleGroupAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension FirewallRuleGroupAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FirewallRuleGroupAssociation(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), creatorRequestId: \(String(describing: creatorRequestId)), firewallRuleGroupId: \(String(describing: firewallRuleGroupId)), id: \(String(describing: id)), managedOwnerName: \(String(describing: managedOwnerName)), modificationTime: \(String(describing: modificationTime)), mutationProtection: \(String(describing: mutationProtection)), name: \(String(describing: name)), priority: \(String(describing: priority)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>An association between a firewall rule group and a VPC, which enables DNS filtering for
/// 			the VPC. </p>
public struct FirewallRuleGroupAssociation: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall rule group association.</p>
    public let arn: String?
    /// <p>The date and time that the association was created, in Unix time format and Coordinated Universal Time (UTC). </p>
    public let creationTime: String?
    /// <p>A unique string defined by you to identify the request. This allows you to retry failed
    /// 			requests without the risk of running the operation twice. This can be any unique string,
    /// 			for example, a timestamp. </p>
    public let creatorRequestId: String?
    /// <p>The unique identifier of the firewall rule group. </p>
    public let firewallRuleGroupId: String?
    /// <p>The identifier for the association.</p>
    public let id: String?
    /// <p>The owner of the association, used only for associations that are not managed by you. If you use AWS Firewall Manager to
    ///    manage your DNS Firewalls, then this reports Firewall Manager as the managed owner.</p>
    public let managedOwnerName: String?
    /// <p>The date and time that the association was last modified, in Unix time format and Coordinated Universal Time (UTC).</p>
    public let modificationTime: String?
    /// <p>If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections. </p>
    public let mutationProtection: MutationProtectionStatus?
    /// <p>The name of the association.</p>
    public let name: String?
    /// <p>The setting that determines the processing order of the rule group among the rule groups that are associated with a single VPC. DNS Firewall
    ///            filters VPC traffic starting from rule group with the lowest numeric priority setting. </p>
    public let priority: Int?
    /// <p>The current status of the association.</p>
    public let status: FirewallRuleGroupAssociationStatus?
    /// <p>Additional information about the status of the response, if available.</p>
    public let statusMessage: String?
    /// <p>The unique identifier of the VPC that is associated with the rule group. </p>
    public let vpcId: String?

    public init (
        arn: String? = nil,
        creationTime: String? = nil,
        creatorRequestId: String? = nil,
        firewallRuleGroupId: String? = nil,
        id: String? = nil,
        managedOwnerName: String? = nil,
        modificationTime: String? = nil,
        mutationProtection: MutationProtectionStatus? = nil,
        name: String? = nil,
        priority: Int? = nil,
        status: FirewallRuleGroupAssociationStatus? = nil,
        statusMessage: String? = nil,
        vpcId: String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.creatorRequestId = creatorRequestId
        self.firewallRuleGroupId = firewallRuleGroupId
        self.id = id
        self.managedOwnerName = managedOwnerName
        self.modificationTime = modificationTime
        self.mutationProtection = mutationProtection
        self.name = name
        self.priority = priority
        self.status = status
        self.statusMessage = statusMessage
        self.vpcId = vpcId
    }
}

public enum FirewallRuleGroupAssociationStatus {
    case complete
    case deleting
    case updating
    case sdkUnknown(String)
}

extension FirewallRuleGroupAssociationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FirewallRuleGroupAssociationStatus] {
        return [
            .complete,
            .deleting,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "COMPLETE"
        case .deleting: return "DELETING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FirewallRuleGroupAssociationStatus(rawValue: rawValue) ?? FirewallRuleGroupAssociationStatus.sdkUnknown(rawValue)
    }
}

extension FirewallRuleGroupMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creatorRequestId = "CreatorRequestId"
        case id = "Id"
        case name = "Name"
        case ownerId = "OwnerId"
        case shareStatus = "ShareStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let shareStatus = shareStatus {
            try encodeContainer.encode(shareStatus.rawValue, forKey: .shareStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let shareStatusDecoded = try containerValues.decodeIfPresent(ShareStatus.self, forKey: .shareStatus)
        shareStatus = shareStatusDecoded
    }
}

extension FirewallRuleGroupMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FirewallRuleGroupMetadata(arn: \(String(describing: arn)), creatorRequestId: \(String(describing: creatorRequestId)), id: \(String(describing: id)), name: \(String(describing: name)), ownerId: \(String(describing: ownerId)), shareStatus: \(String(describing: shareStatus)))"}
}

/// <p>Minimal high-level information for a firewall rule group. The action <a>ListFirewallRuleGroups</a> returns an array of these objects. </p>
///          <p>To retrieve full information for a firewall rule group, call <a>GetFirewallRuleGroup</a> and <a>ListFirewallRules</a>.</p>
public struct FirewallRuleGroupMetadata: Equatable {
    /// <p>The ARN (Amazon Resource Name) of the rule group.</p>
    public let arn: String?
    /// <p>A unique string defined by you to identify the request. This allows you to retry failed
    /// 			requests without the risk of running the operation twice. This can be any unique string,
    /// 			for example, a timestamp. </p>
    public let creatorRequestId: String?
    /// <p>The ID of the rule group. </p>
    public let id: String?
    /// <p>The name of the rule group.</p>
    public let name: String?
    /// <p>The AWS account ID for the account that created the rule group. When a rule group is shared with your account,
    ///        this is the account that has shared the rule group with you.  </p>
    public let ownerId: String?
    /// <p>Whether the rule group is shared with other AWS accounts, or was shared with the current account by another
    ///               AWS account. Sharing is configured through AWS Resource Access Manager (AWS RAM).</p>
    public let shareStatus: ShareStatus?

    public init (
        arn: String? = nil,
        creatorRequestId: String? = nil,
        id: String? = nil,
        name: String? = nil,
        ownerId: String? = nil,
        shareStatus: ShareStatus? = nil
    )
    {
        self.arn = arn
        self.creatorRequestId = creatorRequestId
        self.id = id
        self.name = name
        self.ownerId = ownerId
        self.shareStatus = shareStatus
    }
}

public enum FirewallRuleGroupStatus {
    case complete
    case deleting
    case updating
    case sdkUnknown(String)
}

extension FirewallRuleGroupStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FirewallRuleGroupStatus] {
        return [
            .complete,
            .deleting,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "COMPLETE"
        case .deleting: return "DELETING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FirewallRuleGroupStatus(rawValue: rawValue) ?? FirewallRuleGroupStatus.sdkUnknown(rawValue)
    }
}

public struct GetFirewallConfigInputBodyMiddleware: Middleware {
    public let id: String = "GetFirewallConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFirewallConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFirewallConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFirewallConfigInput>
    public typealias MOutput = OperationOutput<GetFirewallConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFirewallConfigOutputError>
}

extension GetFirewallConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFirewallConfigInput(resourceId: \(String(describing: resourceId)))"}
}

extension GetFirewallConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct GetFirewallConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetFirewallConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFirewallConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFirewallConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFirewallConfigInput>
    public typealias MOutput = OperationOutput<GetFirewallConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFirewallConfigOutputError>
}

public struct GetFirewallConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFirewallConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFirewallConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFirewallConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFirewallConfigInput>
    public typealias MOutput = OperationOutput<GetFirewallConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFirewallConfigOutputError>
}

public struct GetFirewallConfigInput: Equatable {
    /// <p>The ID of the VPC from Amazon VPC that the configuration is for.</p>
    public let resourceId: String?

    public init (
        resourceId: String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct GetFirewallConfigInputBody: Equatable {
    public let resourceId: String?
}

extension GetFirewallConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension GetFirewallConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFirewallConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFirewallConfigOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFirewallConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFirewallConfigOutputResponse(firewallConfig: \(String(describing: firewallConfig)))"}
}

extension GetFirewallConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFirewallConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallConfig = output.firewallConfig
        } else {
            self.firewallConfig = nil
        }
    }
}

public struct GetFirewallConfigOutputResponse: Equatable {
    /// <p>Configuration of the firewall behavior provided by DNS Firewall for a single VPC from
    /// 			AmazonVPC. </p>
    public let firewallConfig: FirewallConfig?

    public init (
        firewallConfig: FirewallConfig? = nil
    )
    {
        self.firewallConfig = firewallConfig
    }
}

struct GetFirewallConfigOutputResponseBody: Equatable {
    public let firewallConfig: FirewallConfig?
}

extension GetFirewallConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallConfig = "FirewallConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallConfigDecoded = try containerValues.decodeIfPresent(FirewallConfig.self, forKey: .firewallConfig)
        firewallConfig = firewallConfigDecoded
    }
}

public struct GetFirewallDomainListInputBodyMiddleware: Middleware {
    public let id: String = "GetFirewallDomainListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFirewallDomainListInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFirewallDomainListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFirewallDomainListInput>
    public typealias MOutput = OperationOutput<GetFirewallDomainListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFirewallDomainListOutputError>
}

extension GetFirewallDomainListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFirewallDomainListInput(firewallDomainListId: \(String(describing: firewallDomainListId)))"}
}

extension GetFirewallDomainListInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
    }
}

public struct GetFirewallDomainListInputHeadersMiddleware: Middleware {
    public let id: String = "GetFirewallDomainListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFirewallDomainListInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFirewallDomainListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFirewallDomainListInput>
    public typealias MOutput = OperationOutput<GetFirewallDomainListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFirewallDomainListOutputError>
}

public struct GetFirewallDomainListInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFirewallDomainListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFirewallDomainListInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFirewallDomainListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFirewallDomainListInput>
    public typealias MOutput = OperationOutput<GetFirewallDomainListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFirewallDomainListOutputError>
}

public struct GetFirewallDomainListInput: Equatable {
    /// <p>The ID of the domain list.  </p>
    public let firewallDomainListId: String?

    public init (
        firewallDomainListId: String? = nil
    )
    {
        self.firewallDomainListId = firewallDomainListId
    }
}

struct GetFirewallDomainListInputBody: Equatable {
    public let firewallDomainListId: String?
}

extension GetFirewallDomainListInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
    }
}

extension GetFirewallDomainListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFirewallDomainListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFirewallDomainListOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFirewallDomainListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFirewallDomainListOutputResponse(firewallDomainList: \(String(describing: firewallDomainList)))"}
}

extension GetFirewallDomainListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFirewallDomainListOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallDomainList = output.firewallDomainList
        } else {
            self.firewallDomainList = nil
        }
    }
}

public struct GetFirewallDomainListOutputResponse: Equatable {
    /// <p>The domain list that you requested.  </p>
    public let firewallDomainList: FirewallDomainList?

    public init (
        firewallDomainList: FirewallDomainList? = nil
    )
    {
        self.firewallDomainList = firewallDomainList
    }
}

struct GetFirewallDomainListOutputResponseBody: Equatable {
    public let firewallDomainList: FirewallDomainList?
}

extension GetFirewallDomainListOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallDomainList = "FirewallDomainList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListDecoded = try containerValues.decodeIfPresent(FirewallDomainList.self, forKey: .firewallDomainList)
        firewallDomainList = firewallDomainListDecoded
    }
}

public struct GetFirewallRuleGroupAssociationInputBodyMiddleware: Middleware {
    public let id: String = "GetFirewallRuleGroupAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFirewallRuleGroupAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFirewallRuleGroupAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFirewallRuleGroupAssociationInput>
    public typealias MOutput = OperationOutput<GetFirewallRuleGroupAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFirewallRuleGroupAssociationOutputError>
}

extension GetFirewallRuleGroupAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFirewallRuleGroupAssociationInput(firewallRuleGroupAssociationId: \(String(describing: firewallRuleGroupAssociationId)))"}
}

extension GetFirewallRuleGroupAssociationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupAssociationId = firewallRuleGroupAssociationId {
            try encodeContainer.encode(firewallRuleGroupAssociationId, forKey: .firewallRuleGroupAssociationId)
        }
    }
}

public struct GetFirewallRuleGroupAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "GetFirewallRuleGroupAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFirewallRuleGroupAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFirewallRuleGroupAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFirewallRuleGroupAssociationInput>
    public typealias MOutput = OperationOutput<GetFirewallRuleGroupAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFirewallRuleGroupAssociationOutputError>
}

public struct GetFirewallRuleGroupAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFirewallRuleGroupAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFirewallRuleGroupAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFirewallRuleGroupAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFirewallRuleGroupAssociationInput>
    public typealias MOutput = OperationOutput<GetFirewallRuleGroupAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFirewallRuleGroupAssociationOutputError>
}

public struct GetFirewallRuleGroupAssociationInput: Equatable {
    /// <p>The identifier of the <a>FirewallRuleGroupAssociation</a>. </p>
    public let firewallRuleGroupAssociationId: String?

    public init (
        firewallRuleGroupAssociationId: String? = nil
    )
    {
        self.firewallRuleGroupAssociationId = firewallRuleGroupAssociationId
    }
}

struct GetFirewallRuleGroupAssociationInputBody: Equatable {
    public let firewallRuleGroupAssociationId: String?
}

extension GetFirewallRuleGroupAssociationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallRuleGroupAssociationId)
        firewallRuleGroupAssociationId = firewallRuleGroupAssociationIdDecoded
    }
}

extension GetFirewallRuleGroupAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFirewallRuleGroupAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFirewallRuleGroupAssociationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFirewallRuleGroupAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFirewallRuleGroupAssociationOutputResponse(firewallRuleGroupAssociation: \(String(describing: firewallRuleGroupAssociation)))"}
}

extension GetFirewallRuleGroupAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFirewallRuleGroupAssociationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallRuleGroupAssociation = output.firewallRuleGroupAssociation
        } else {
            self.firewallRuleGroupAssociation = nil
        }
    }
}

public struct GetFirewallRuleGroupAssociationOutputResponse: Equatable {
    /// <p>The association that you requested. </p>
    public let firewallRuleGroupAssociation: FirewallRuleGroupAssociation?

    public init (
        firewallRuleGroupAssociation: FirewallRuleGroupAssociation? = nil
    )
    {
        self.firewallRuleGroupAssociation = firewallRuleGroupAssociation
    }
}

struct GetFirewallRuleGroupAssociationOutputResponseBody: Equatable {
    public let firewallRuleGroupAssociation: FirewallRuleGroupAssociation?
}

extension GetFirewallRuleGroupAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupAssociation = "FirewallRuleGroupAssociation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationDecoded = try containerValues.decodeIfPresent(FirewallRuleGroupAssociation.self, forKey: .firewallRuleGroupAssociation)
        firewallRuleGroupAssociation = firewallRuleGroupAssociationDecoded
    }
}

public struct GetFirewallRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "GetFirewallRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFirewallRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFirewallRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFirewallRuleGroupInput>
    public typealias MOutput = OperationOutput<GetFirewallRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFirewallRuleGroupOutputError>
}

extension GetFirewallRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFirewallRuleGroupInput(firewallRuleGroupId: \(String(describing: firewallRuleGroupId)))"}
}

extension GetFirewallRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
    }
}

public struct GetFirewallRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "GetFirewallRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFirewallRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFirewallRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFirewallRuleGroupInput>
    public typealias MOutput = OperationOutput<GetFirewallRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFirewallRuleGroupOutputError>
}

public struct GetFirewallRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFirewallRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFirewallRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFirewallRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFirewallRuleGroupInput>
    public typealias MOutput = OperationOutput<GetFirewallRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFirewallRuleGroupOutputError>
}

public struct GetFirewallRuleGroupInput: Equatable {
    /// <p>The unique identifier of the firewall rule group. </p>
    public let firewallRuleGroupId: String?

    public init (
        firewallRuleGroupId: String? = nil
    )
    {
        self.firewallRuleGroupId = firewallRuleGroupId
    }
}

struct GetFirewallRuleGroupInputBody: Equatable {
    public let firewallRuleGroupId: String?
}

extension GetFirewallRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
    }
}

extension GetFirewallRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFirewallRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFirewallRuleGroupOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFirewallRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFirewallRuleGroupOutputResponse(firewallRuleGroup: \(String(describing: firewallRuleGroup)))"}
}

extension GetFirewallRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFirewallRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallRuleGroup = output.firewallRuleGroup
        } else {
            self.firewallRuleGroup = nil
        }
    }
}

public struct GetFirewallRuleGroupOutputResponse: Equatable {
    /// <p>A collection of rules used to filter DNS network traffic. </p>
    public let firewallRuleGroup: FirewallRuleGroup?

    public init (
        firewallRuleGroup: FirewallRuleGroup? = nil
    )
    {
        self.firewallRuleGroup = firewallRuleGroup
    }
}

struct GetFirewallRuleGroupOutputResponseBody: Equatable {
    public let firewallRuleGroup: FirewallRuleGroup?
}

extension GetFirewallRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroup = "FirewallRuleGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupDecoded = try containerValues.decodeIfPresent(FirewallRuleGroup.self, forKey: .firewallRuleGroup)
        firewallRuleGroup = firewallRuleGroupDecoded
    }
}

public struct GetFirewallRuleGroupPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetFirewallRuleGroupPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFirewallRuleGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFirewallRuleGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFirewallRuleGroupPolicyInput>
    public typealias MOutput = OperationOutput<GetFirewallRuleGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFirewallRuleGroupPolicyOutputError>
}

extension GetFirewallRuleGroupPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFirewallRuleGroupPolicyInput(arn: \(String(describing: arn)))"}
}

extension GetFirewallRuleGroupPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetFirewallRuleGroupPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetFirewallRuleGroupPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFirewallRuleGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFirewallRuleGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFirewallRuleGroupPolicyInput>
    public typealias MOutput = OperationOutput<GetFirewallRuleGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFirewallRuleGroupPolicyOutputError>
}

public struct GetFirewallRuleGroupPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFirewallRuleGroupPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFirewallRuleGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFirewallRuleGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFirewallRuleGroupPolicyInput>
    public typealias MOutput = OperationOutput<GetFirewallRuleGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFirewallRuleGroupPolicyOutputError>
}

public struct GetFirewallRuleGroupPolicyInput: Equatable {
    /// <p>The ARN (Amazon Resource Name) for the rule group.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetFirewallRuleGroupPolicyInputBody: Equatable {
    public let arn: String?
}

extension GetFirewallRuleGroupPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetFirewallRuleGroupPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFirewallRuleGroupPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFirewallRuleGroupPolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFirewallRuleGroupPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFirewallRuleGroupPolicyOutputResponse(firewallRuleGroupPolicy: \(String(describing: firewallRuleGroupPolicy)))"}
}

extension GetFirewallRuleGroupPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFirewallRuleGroupPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallRuleGroupPolicy = output.firewallRuleGroupPolicy
        } else {
            self.firewallRuleGroupPolicy = nil
        }
    }
}

public struct GetFirewallRuleGroupPolicyOutputResponse: Equatable {
    /// <p>The AWS Identity and Access Management (AWS IAM) policy for sharing the specified rule
    /// 			group. You can use the policy to share the rule group using AWS Resource Access Manager
    /// 			(AWS RAM). </p>
    public let firewallRuleGroupPolicy: String?

    public init (
        firewallRuleGroupPolicy: String? = nil
    )
    {
        self.firewallRuleGroupPolicy = firewallRuleGroupPolicy
    }
}

struct GetFirewallRuleGroupPolicyOutputResponseBody: Equatable {
    public let firewallRuleGroupPolicy: String?
}

extension GetFirewallRuleGroupPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupPolicy = "FirewallRuleGroupPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallRuleGroupPolicy)
        firewallRuleGroupPolicy = firewallRuleGroupPolicyDecoded
    }
}

public struct GetResolverDnssecConfigInputBodyMiddleware: Middleware {
    public let id: String = "GetResolverDnssecConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverDnssecConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverDnssecConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverDnssecConfigInput>
    public typealias MOutput = OperationOutput<GetResolverDnssecConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverDnssecConfigOutputError>
}

extension GetResolverDnssecConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverDnssecConfigInput(resourceId: \(String(describing: resourceId)))"}
}

extension GetResolverDnssecConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct GetResolverDnssecConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetResolverDnssecConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverDnssecConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverDnssecConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverDnssecConfigInput>
    public typealias MOutput = OperationOutput<GetResolverDnssecConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverDnssecConfigOutputError>
}

public struct GetResolverDnssecConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResolverDnssecConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverDnssecConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverDnssecConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverDnssecConfigInput>
    public typealias MOutput = OperationOutput<GetResolverDnssecConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverDnssecConfigOutputError>
}

public struct GetResolverDnssecConfigInput: Equatable {
    /// <p>The ID of the virtual private cloud (VPC) for the DNSSEC validation status.</p>
    public let resourceId: String?

    public init (
        resourceId: String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct GetResolverDnssecConfigInputBody: Equatable {
    public let resourceId: String?
}

extension GetResolverDnssecConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension GetResolverDnssecConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverDnssecConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverDnssecConfigOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverDnssecConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverDnssecConfigOutputResponse(resolverDNSSECConfig: \(String(describing: resolverDNSSECConfig)))"}
}

extension GetResolverDnssecConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResolverDnssecConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverDNSSECConfig = output.resolverDNSSECConfig
        } else {
            self.resolverDNSSECConfig = nil
        }
    }
}

public struct GetResolverDnssecConfigOutputResponse: Equatable {
    /// <p>The information about a configuration for DNSSEC validation.</p>
    public let resolverDNSSECConfig: ResolverDnssecConfig?

    public init (
        resolverDNSSECConfig: ResolverDnssecConfig? = nil
    )
    {
        self.resolverDNSSECConfig = resolverDNSSECConfig
    }
}

struct GetResolverDnssecConfigOutputResponseBody: Equatable {
    public let resolverDNSSECConfig: ResolverDnssecConfig?
}

extension GetResolverDnssecConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverDNSSECConfig = "ResolverDNSSECConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDNSSECConfigDecoded = try containerValues.decodeIfPresent(ResolverDnssecConfig.self, forKey: .resolverDNSSECConfig)
        resolverDNSSECConfig = resolverDNSSECConfigDecoded
    }
}

public struct GetResolverEndpointInputBodyMiddleware: Middleware {
    public let id: String = "GetResolverEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverEndpointInput>
    public typealias MOutput = OperationOutput<GetResolverEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverEndpointOutputError>
}

extension GetResolverEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverEndpointInput(resolverEndpointId: \(String(describing: resolverEndpointId)))"}
}

extension GetResolverEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

public struct GetResolverEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "GetResolverEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverEndpointInput>
    public typealias MOutput = OperationOutput<GetResolverEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverEndpointOutputError>
}

public struct GetResolverEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResolverEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverEndpointInput>
    public typealias MOutput = OperationOutput<GetResolverEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverEndpointOutputError>
}

public struct GetResolverEndpointInput: Equatable {
    /// <p>The ID of the Resolver endpoint that you want to get information about.</p>
    public let resolverEndpointId: String?

    public init (
        resolverEndpointId: String? = nil
    )
    {
        self.resolverEndpointId = resolverEndpointId
    }
}

struct GetResolverEndpointInputBody: Equatable {
    public let resolverEndpointId: String?
}

extension GetResolverEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
    }
}

extension GetResolverEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverEndpointOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverEndpointOutputResponse(resolverEndpoint: \(String(describing: resolverEndpoint)))"}
}

extension GetResolverEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResolverEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct GetResolverEndpointOutputResponse: Equatable {
    /// <p>Information about the Resolver endpoint that you specified in a <code>GetResolverEndpoint</code> request.</p>
    public let resolverEndpoint: ResolverEndpoint?

    public init (
        resolverEndpoint: ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct GetResolverEndpointOutputResponseBody: Equatable {
    public let resolverEndpoint: ResolverEndpoint?
}

extension GetResolverEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

public struct GetResolverQueryLogConfigAssociationInputBodyMiddleware: Middleware {
    public let id: String = "GetResolverQueryLogConfigAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverQueryLogConfigAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverQueryLogConfigAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverQueryLogConfigAssociationInput>
    public typealias MOutput = OperationOutput<GetResolverQueryLogConfigAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverQueryLogConfigAssociationOutputError>
}

extension GetResolverQueryLogConfigAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverQueryLogConfigAssociationInput(resolverQueryLogConfigAssociationId: \(String(describing: resolverQueryLogConfigAssociationId)))"}
}

extension GetResolverQueryLogConfigAssociationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfigAssociationId = "ResolverQueryLogConfigAssociationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverQueryLogConfigAssociationId = resolverQueryLogConfigAssociationId {
            try encodeContainer.encode(resolverQueryLogConfigAssociationId, forKey: .resolverQueryLogConfigAssociationId)
        }
    }
}

public struct GetResolverQueryLogConfigAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "GetResolverQueryLogConfigAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverQueryLogConfigAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverQueryLogConfigAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverQueryLogConfigAssociationInput>
    public typealias MOutput = OperationOutput<GetResolverQueryLogConfigAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverQueryLogConfigAssociationOutputError>
}

public struct GetResolverQueryLogConfigAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResolverQueryLogConfigAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverQueryLogConfigAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverQueryLogConfigAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverQueryLogConfigAssociationInput>
    public typealias MOutput = OperationOutput<GetResolverQueryLogConfigAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverQueryLogConfigAssociationOutputError>
}

public struct GetResolverQueryLogConfigAssociationInput: Equatable {
    /// <p>The ID of the Resolver query logging configuration association that you want to get information about.</p>
    public let resolverQueryLogConfigAssociationId: String?

    public init (
        resolverQueryLogConfigAssociationId: String? = nil
    )
    {
        self.resolverQueryLogConfigAssociationId = resolverQueryLogConfigAssociationId
    }
}

struct GetResolverQueryLogConfigAssociationInputBody: Equatable {
    public let resolverQueryLogConfigAssociationId: String?
}

extension GetResolverQueryLogConfigAssociationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfigAssociationId = "ResolverQueryLogConfigAssociationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigAssociationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverQueryLogConfigAssociationId)
        resolverQueryLogConfigAssociationId = resolverQueryLogConfigAssociationIdDecoded
    }
}

extension GetResolverQueryLogConfigAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverQueryLogConfigAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverQueryLogConfigAssociationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverQueryLogConfigAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverQueryLogConfigAssociationOutputResponse(resolverQueryLogConfigAssociation: \(String(describing: resolverQueryLogConfigAssociation)))"}
}

extension GetResolverQueryLogConfigAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResolverQueryLogConfigAssociationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverQueryLogConfigAssociation = output.resolverQueryLogConfigAssociation
        } else {
            self.resolverQueryLogConfigAssociation = nil
        }
    }
}

public struct GetResolverQueryLogConfigAssociationOutputResponse: Equatable {
    /// <p>Information about the Resolver query logging configuration association that you specified in a <code>GetQueryLogConfigAssociation</code> request.</p>
    public let resolverQueryLogConfigAssociation: ResolverQueryLogConfigAssociation?

    public init (
        resolverQueryLogConfigAssociation: ResolverQueryLogConfigAssociation? = nil
    )
    {
        self.resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociation
    }
}

struct GetResolverQueryLogConfigAssociationOutputResponseBody: Equatable {
    public let resolverQueryLogConfigAssociation: ResolverQueryLogConfigAssociation?
}

extension GetResolverQueryLogConfigAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfigAssociation = "ResolverQueryLogConfigAssociation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigAssociationDecoded = try containerValues.decodeIfPresent(ResolverQueryLogConfigAssociation.self, forKey: .resolverQueryLogConfigAssociation)
        resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociationDecoded
    }
}

public struct GetResolverQueryLogConfigInputBodyMiddleware: Middleware {
    public let id: String = "GetResolverQueryLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverQueryLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverQueryLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverQueryLogConfigInput>
    public typealias MOutput = OperationOutput<GetResolverQueryLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverQueryLogConfigOutputError>
}

extension GetResolverQueryLogConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverQueryLogConfigInput(resolverQueryLogConfigId: \(String(describing: resolverQueryLogConfigId)))"}
}

extension GetResolverQueryLogConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverQueryLogConfigId = resolverQueryLogConfigId {
            try encodeContainer.encode(resolverQueryLogConfigId, forKey: .resolverQueryLogConfigId)
        }
    }
}

public struct GetResolverQueryLogConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetResolverQueryLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverQueryLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverQueryLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverQueryLogConfigInput>
    public typealias MOutput = OperationOutput<GetResolverQueryLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverQueryLogConfigOutputError>
}

public struct GetResolverQueryLogConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResolverQueryLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverQueryLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverQueryLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverQueryLogConfigInput>
    public typealias MOutput = OperationOutput<GetResolverQueryLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverQueryLogConfigOutputError>
}

public struct GetResolverQueryLogConfigInput: Equatable {
    /// <p>The ID of the Resolver query logging configuration that you want to get information about.</p>
    public let resolverQueryLogConfigId: String?

    public init (
        resolverQueryLogConfigId: String? = nil
    )
    {
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
    }
}

struct GetResolverQueryLogConfigInputBody: Equatable {
    public let resolverQueryLogConfigId: String?
}

extension GetResolverQueryLogConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverQueryLogConfigId)
        resolverQueryLogConfigId = resolverQueryLogConfigIdDecoded
    }
}

extension GetResolverQueryLogConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverQueryLogConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverQueryLogConfigOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverQueryLogConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverQueryLogConfigOutputResponse(resolverQueryLogConfig: \(String(describing: resolverQueryLogConfig)))"}
}

extension GetResolverQueryLogConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResolverQueryLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverQueryLogConfig = output.resolverQueryLogConfig
        } else {
            self.resolverQueryLogConfig = nil
        }
    }
}

public struct GetResolverQueryLogConfigOutputResponse: Equatable {
    /// <p>Information about the Resolver query logging configuration that you specified in a <code>GetQueryLogConfig</code> request.</p>
    public let resolverQueryLogConfig: ResolverQueryLogConfig?

    public init (
        resolverQueryLogConfig: ResolverQueryLogConfig? = nil
    )
    {
        self.resolverQueryLogConfig = resolverQueryLogConfig
    }
}

struct GetResolverQueryLogConfigOutputResponseBody: Equatable {
    public let resolverQueryLogConfig: ResolverQueryLogConfig?
}

extension GetResolverQueryLogConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfig = "ResolverQueryLogConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigDecoded = try containerValues.decodeIfPresent(ResolverQueryLogConfig.self, forKey: .resolverQueryLogConfig)
        resolverQueryLogConfig = resolverQueryLogConfigDecoded
    }
}

public struct GetResolverQueryLogConfigPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetResolverQueryLogConfigPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverQueryLogConfigPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverQueryLogConfigPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverQueryLogConfigPolicyInput>
    public typealias MOutput = OperationOutput<GetResolverQueryLogConfigPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverQueryLogConfigPolicyOutputError>
}

extension GetResolverQueryLogConfigPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverQueryLogConfigPolicyInput(arn: \(String(describing: arn)))"}
}

extension GetResolverQueryLogConfigPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetResolverQueryLogConfigPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetResolverQueryLogConfigPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverQueryLogConfigPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverQueryLogConfigPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverQueryLogConfigPolicyInput>
    public typealias MOutput = OperationOutput<GetResolverQueryLogConfigPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverQueryLogConfigPolicyOutputError>
}

public struct GetResolverQueryLogConfigPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResolverQueryLogConfigPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverQueryLogConfigPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverQueryLogConfigPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverQueryLogConfigPolicyInput>
    public typealias MOutput = OperationOutput<GetResolverQueryLogConfigPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverQueryLogConfigPolicyOutputError>
}

public struct GetResolverQueryLogConfigPolicyInput: Equatable {
    /// <p>The ARN of the query logging configuration that you want to get the query logging policy for.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetResolverQueryLogConfigPolicyInputBody: Equatable {
    public let arn: String?
}

extension GetResolverQueryLogConfigPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetResolverQueryLogConfigPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverQueryLogConfigPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverQueryLogConfigPolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverQueryLogConfigPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverQueryLogConfigPolicyOutputResponse(resolverQueryLogConfigPolicy: \(String(describing: resolverQueryLogConfigPolicy)))"}
}

extension GetResolverQueryLogConfigPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResolverQueryLogConfigPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverQueryLogConfigPolicy = output.resolverQueryLogConfigPolicy
        } else {
            self.resolverQueryLogConfigPolicy = nil
        }
    }
}

public struct GetResolverQueryLogConfigPolicyOutputResponse: Equatable {
    /// <p>Information about the query logging policy for the query logging configuration that you specified in a
    /// 			<code>GetResolverQueryLogConfigPolicy</code> request.</p>
    public let resolverQueryLogConfigPolicy: String?

    public init (
        resolverQueryLogConfigPolicy: String? = nil
    )
    {
        self.resolverQueryLogConfigPolicy = resolverQueryLogConfigPolicy
    }
}

struct GetResolverQueryLogConfigPolicyOutputResponseBody: Equatable {
    public let resolverQueryLogConfigPolicy: String?
}

extension GetResolverQueryLogConfigPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverQueryLogConfigPolicy = "ResolverQueryLogConfigPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverQueryLogConfigPolicy)
        resolverQueryLogConfigPolicy = resolverQueryLogConfigPolicyDecoded
    }
}

public struct GetResolverRuleAssociationInputBodyMiddleware: Middleware {
    public let id: String = "GetResolverRuleAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverRuleAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverRuleAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverRuleAssociationInput>
    public typealias MOutput = OperationOutput<GetResolverRuleAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverRuleAssociationOutputError>
}

extension GetResolverRuleAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverRuleAssociationInput(resolverRuleAssociationId: \(String(describing: resolverRuleAssociationId)))"}
}

extension GetResolverRuleAssociationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resolverRuleAssociationId = "ResolverRuleAssociationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverRuleAssociationId = resolverRuleAssociationId {
            try encodeContainer.encode(resolverRuleAssociationId, forKey: .resolverRuleAssociationId)
        }
    }
}

public struct GetResolverRuleAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "GetResolverRuleAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverRuleAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverRuleAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverRuleAssociationInput>
    public typealias MOutput = OperationOutput<GetResolverRuleAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverRuleAssociationOutputError>
}

public struct GetResolverRuleAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResolverRuleAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverRuleAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverRuleAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverRuleAssociationInput>
    public typealias MOutput = OperationOutput<GetResolverRuleAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverRuleAssociationOutputError>
}

public struct GetResolverRuleAssociationInput: Equatable {
    /// <p>The ID of the Resolver rule association that you want to get information about.</p>
    public let resolverRuleAssociationId: String?

    public init (
        resolverRuleAssociationId: String? = nil
    )
    {
        self.resolverRuleAssociationId = resolverRuleAssociationId
    }
}

struct GetResolverRuleAssociationInputBody: Equatable {
    public let resolverRuleAssociationId: String?
}

extension GetResolverRuleAssociationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverRuleAssociationId = "ResolverRuleAssociationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleAssociationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverRuleAssociationId)
        resolverRuleAssociationId = resolverRuleAssociationIdDecoded
    }
}

extension GetResolverRuleAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverRuleAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverRuleAssociationOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverRuleAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverRuleAssociationOutputResponse(resolverRuleAssociation: \(String(describing: resolverRuleAssociation)))"}
}

extension GetResolverRuleAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResolverRuleAssociationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverRuleAssociation = output.resolverRuleAssociation
        } else {
            self.resolverRuleAssociation = nil
        }
    }
}

public struct GetResolverRuleAssociationOutputResponse: Equatable {
    /// <p>Information about the Resolver rule association that you specified in a <code>GetResolverRuleAssociation</code> request.</p>
    public let resolverRuleAssociation: ResolverRuleAssociation?

    public init (
        resolverRuleAssociation: ResolverRuleAssociation? = nil
    )
    {
        self.resolverRuleAssociation = resolverRuleAssociation
    }
}

struct GetResolverRuleAssociationOutputResponseBody: Equatable {
    public let resolverRuleAssociation: ResolverRuleAssociation?
}

extension GetResolverRuleAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverRuleAssociation = "ResolverRuleAssociation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleAssociationDecoded = try containerValues.decodeIfPresent(ResolverRuleAssociation.self, forKey: .resolverRuleAssociation)
        resolverRuleAssociation = resolverRuleAssociationDecoded
    }
}

public struct GetResolverRuleInputBodyMiddleware: Middleware {
    public let id: String = "GetResolverRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverRuleInput>
    public typealias MOutput = OperationOutput<GetResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverRuleOutputError>
}

extension GetResolverRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverRuleInput(resolverRuleId: \(String(describing: resolverRuleId)))"}
}

extension GetResolverRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resolverRuleId = "ResolverRuleId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverRuleId = resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
    }
}

public struct GetResolverRuleInputHeadersMiddleware: Middleware {
    public let id: String = "GetResolverRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverRuleInput>
    public typealias MOutput = OperationOutput<GetResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverRuleOutputError>
}

public struct GetResolverRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResolverRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverRuleInput>
    public typealias MOutput = OperationOutput<GetResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverRuleOutputError>
}

public struct GetResolverRuleInput: Equatable {
    /// <p>The ID of the Resolver rule that you want to get information about.</p>
    public let resolverRuleId: String?

    public init (
        resolverRuleId: String? = nil
    )
    {
        self.resolverRuleId = resolverRuleId
    }
}

struct GetResolverRuleInputBody: Equatable {
    public let resolverRuleId: String?
}

extension GetResolverRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverRuleId = "ResolverRuleId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
    }
}

extension GetResolverRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverRuleOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverRuleOutputResponse(resolverRule: \(String(describing: resolverRule)))"}
}

extension GetResolverRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResolverRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverRule = output.resolverRule
        } else {
            self.resolverRule = nil
        }
    }
}

public struct GetResolverRuleOutputResponse: Equatable {
    /// <p>Information about the Resolver rule that you specified in a <code>GetResolverRule</code> request.</p>
    public let resolverRule: ResolverRule?

    public init (
        resolverRule: ResolverRule? = nil
    )
    {
        self.resolverRule = resolverRule
    }
}

struct GetResolverRuleOutputResponseBody: Equatable {
    public let resolverRule: ResolverRule?
}

extension GetResolverRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverRule = "ResolverRule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleDecoded = try containerValues.decodeIfPresent(ResolverRule.self, forKey: .resolverRule)
        resolverRule = resolverRuleDecoded
    }
}

public struct GetResolverRulePolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetResolverRulePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverRulePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverRulePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverRulePolicyInput>
    public typealias MOutput = OperationOutput<GetResolverRulePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverRulePolicyOutputError>
}

extension GetResolverRulePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverRulePolicyInput(arn: \(String(describing: arn)))"}
}

extension GetResolverRulePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetResolverRulePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetResolverRulePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverRulePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverRulePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverRulePolicyInput>
    public typealias MOutput = OperationOutput<GetResolverRulePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverRulePolicyOutputError>
}

public struct GetResolverRulePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResolverRulePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverRulePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverRulePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverRulePolicyInput>
    public typealias MOutput = OperationOutput<GetResolverRulePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverRulePolicyOutputError>
}

public struct GetResolverRulePolicyInput: Equatable {
    /// <p>The ID of the Resolver rule that you want to get the Resolver rule policy for.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetResolverRulePolicyInputBody: Equatable {
    public let arn: String?
}

extension GetResolverRulePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetResolverRulePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverRulePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverRulePolicyOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverRulePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverRulePolicyOutputResponse(resolverRulePolicy: \(String(describing: resolverRulePolicy)))"}
}

extension GetResolverRulePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResolverRulePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverRulePolicy = output.resolverRulePolicy
        } else {
            self.resolverRulePolicy = nil
        }
    }
}

public struct GetResolverRulePolicyOutputResponse: Equatable {
    /// <p>The Resolver rule policy for the rule that you specified in a <code>GetResolverRulePolicy</code> request.</p>
    public let resolverRulePolicy: String?

    public init (
        resolverRulePolicy: String? = nil
    )
    {
        self.resolverRulePolicy = resolverRulePolicy
    }
}

struct GetResolverRulePolicyOutputResponseBody: Equatable {
    public let resolverRulePolicy: String?
}

extension GetResolverRulePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverRulePolicy = "ResolverRulePolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRulePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverRulePolicy)
        resolverRulePolicy = resolverRulePolicyDecoded
    }
}

public struct ImportFirewallDomainsInputBodyMiddleware: Middleware {
    public let id: String = "ImportFirewallDomainsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportFirewallDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportFirewallDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportFirewallDomainsInput>
    public typealias MOutput = OperationOutput<ImportFirewallDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportFirewallDomainsOutputError>
}

extension ImportFirewallDomainsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportFirewallDomainsInput(domainFileUrl: \(String(describing: domainFileUrl)), firewallDomainListId: \(String(describing: firewallDomainListId)), operation: \(String(describing: operation)))"}
}

extension ImportFirewallDomainsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainFileUrl = "DomainFileUrl"
        case firewallDomainListId = "FirewallDomainListId"
        case operation = "Operation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainFileUrl = domainFileUrl {
            try encodeContainer.encode(domainFileUrl, forKey: .domainFileUrl)
        }
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let operation = operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
    }
}

public struct ImportFirewallDomainsInputHeadersMiddleware: Middleware {
    public let id: String = "ImportFirewallDomainsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportFirewallDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportFirewallDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportFirewallDomainsInput>
    public typealias MOutput = OperationOutput<ImportFirewallDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportFirewallDomainsOutputError>
}

public struct ImportFirewallDomainsInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportFirewallDomainsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportFirewallDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportFirewallDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportFirewallDomainsInput>
    public typealias MOutput = OperationOutput<ImportFirewallDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportFirewallDomainsOutputError>
}

public struct ImportFirewallDomainsInput: Equatable {
    /// <p>The fully qualified URL or URI of the file stored in Amazon Simple Storage Service
    /// 			(Amazon S3) that contains the list of domains to import.</p>
    ///          <p>The file must be in an S3 bucket that's in the same Region
    ///        as your DNS Firewall. The file must be a text file and must contain a single domain per line.</p>
    public let domainFileUrl: String?
    /// <p>The ID of the domain list that you want to modify with the import operation.</p>
    public let firewallDomainListId: String?
    /// <p>What you want DNS Firewall to do with the domains that are listed in the file. This must be set to <code>REPLACE</code>, which updates the domain list to exactly match the list in the file. </p>
    public let operation: FirewallDomainImportOperation?

    public init (
        domainFileUrl: String? = nil,
        firewallDomainListId: String? = nil,
        operation: FirewallDomainImportOperation? = nil
    )
    {
        self.domainFileUrl = domainFileUrl
        self.firewallDomainListId = firewallDomainListId
        self.operation = operation
    }
}

struct ImportFirewallDomainsInputBody: Equatable {
    public let firewallDomainListId: String?
    public let operation: FirewallDomainImportOperation?
    public let domainFileUrl: String?
}

extension ImportFirewallDomainsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainFileUrl = "DomainFileUrl"
        case firewallDomainListId = "FirewallDomainListId"
        case operation = "Operation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(FirewallDomainImportOperation.self, forKey: .operation)
        operation = operationDecoded
        let domainFileUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainFileUrl)
        domainFileUrl = domainFileUrlDecoded
    }
}

extension ImportFirewallDomainsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportFirewallDomainsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportFirewallDomainsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportFirewallDomainsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportFirewallDomainsOutputResponse(id: \(String(describing: id)), name: \(String(describing: name)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

extension ImportFirewallDomainsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImportFirewallDomainsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.id = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct ImportFirewallDomainsOutputResponse: Equatable {
    /// <p>The Id of the firewall domain list that DNS Firewall just updated.</p>
    public let id: String?
    /// <p>The name of the domain list. </p>
    public let name: String?
    /// <p> </p>
    public let status: FirewallDomainListStatus?
    /// <p>Additional information about the status of the list, if available.</p>
    public let statusMessage: String?

    public init (
        id: String? = nil,
        name: String? = nil,
        status: FirewallDomainListStatus? = nil,
        statusMessage: String? = nil
    )
    {
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct ImportFirewallDomainsOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let status: FirewallDomainListStatus?
    public let statusMessage: String?
}

extension ImportFirewallDomainsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FirewallDomainListStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension InternalServiceErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceErrorException(message: \(String(describing: message)))"}
}

extension InternalServiceErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>We encountered an unknown error. Try again in a few minutes.</p>
public struct InternalServiceErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value that you specified for <code>NextToken</code> in a <code>List</code> request isn't valid.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(fieldName: \(String(describing: fieldName)), message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fieldName = output.fieldName
            self.message = output.message
        } else {
            self.fieldName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more parameters in this request are not valid.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>For an <code>InvalidParameterException</code> error, the name of the parameter that's invalid.</p>
    public var fieldName: String?
    public var message: String?

    public init (
        fieldName: String? = nil,
        message: String? = nil
    )
    {
        self.fieldName = fieldName
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
    public let fieldName: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldName = "FieldName"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let fieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
    }
}

extension InvalidPolicyDocument: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPolicyDocument(message: \(String(describing: message)))"}
}

extension InvalidPolicyDocument: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPolicyDocumentBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified Resolver rule policy is invalid.</p>
public struct InvalidPolicyDocument: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPolicyDocumentBody: Equatable {
    public let message: String?
}

extension InvalidPolicyDocumentBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is invalid.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTagException(message: \(String(describing: message)))"}
}

extension InvalidTagException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTagExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified tag is invalid.</p>
public struct InvalidTagException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTagExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IpAddressRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ip = "Ip"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ip = ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let ipDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ip)
        ip = ipDecoded
    }
}

extension IpAddressRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IpAddressRequest(ip: \(String(describing: ip)), subnetId: \(String(describing: subnetId)))"}
}

/// <p>In a
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html">CreateResolverEndpoint</a>
/// 			request, the IP address that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints).
/// 			<code>IpAddressRequest</code> also includes the ID of the subnet that contains the IP address.</p>
public struct IpAddressRequest: Equatable {
    /// <p>The IP address that you want to use for DNS queries.</p>
    public let ip: String?
    /// <p>The ID of the subnet that contains the IP address. </p>
    public let subnetId: String?

    public init (
        ip: String? = nil,
        subnetId: String? = nil
    )
    {
        self.ip = ip
        self.subnetId = subnetId
    }
}

extension IpAddressResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case ip = "Ip"
        case ipId = "IpId"
        case modificationTime = "ModificationTime"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let ip = ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let ipId = ipId {
            try encodeContainer.encode(ipId, forKey: .ipId)
        }
        if let modificationTime = modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipId)
        ipId = ipIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let ipDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ip)
        ip = ipDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IpAddressStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension IpAddressResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IpAddressResponse(creationTime: \(String(describing: creationTime)), ip: \(String(describing: ip)), ipId: \(String(describing: ipId)), modificationTime: \(String(describing: modificationTime)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), subnetId: \(String(describing: subnetId)))"}
}

/// <p>In the response to a
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html">GetResolverEndpoint</a>
/// 			request, information about the IP addresses that the Resolver endpoint uses for DNS queries.</p>
public struct IpAddressResponse: Equatable {
    /// <p>The date and time that the IP address was created, in Unix time format and Coordinated Universal Time (UTC).</p>
    public let creationTime: String?
    /// <p>One IP address that the Resolver endpoint uses for DNS queries.</p>
    public let ip: String?
    /// <p>The ID of one IP address.</p>
    public let ipId: String?
    /// <p>The date and time that the IP address was last modified, in Unix time format and Coordinated Universal Time (UTC).</p>
    public let modificationTime: String?
    /// <p>A status code that gives the current status of the request.</p>
    public let status: IpAddressStatus?
    /// <p>A message that provides additional information about the status of the request.</p>
    public let statusMessage: String?
    /// <p>The ID of one subnet.</p>
    public let subnetId: String?

    public init (
        creationTime: String? = nil,
        ip: String? = nil,
        ipId: String? = nil,
        modificationTime: String? = nil,
        status: IpAddressStatus? = nil,
        statusMessage: String? = nil,
        subnetId: String? = nil
    )
    {
        self.creationTime = creationTime
        self.ip = ip
        self.ipId = ipId
        self.modificationTime = modificationTime
        self.status = status
        self.statusMessage = statusMessage
        self.subnetId = subnetId
    }
}

public enum IpAddressStatus {
    case attached
    case attaching
    case creating
    case deletefailedfasexpired
    case deleting
    case detaching
    case failedcreation
    case failedresourcegone
    case remapattaching
    case remapdetaching
    case sdkUnknown(String)
}

extension IpAddressStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IpAddressStatus] {
        return [
            .attached,
            .attaching,
            .creating,
            .deletefailedfasexpired,
            .deleting,
            .detaching,
            .failedcreation,
            .failedresourcegone,
            .remapattaching,
            .remapdetaching,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .attached: return "ATTACHED"
        case .attaching: return "ATTACHING"
        case .creating: return "CREATING"
        case .deletefailedfasexpired: return "DELETE_FAILED_FAS_EXPIRED"
        case .deleting: return "DELETING"
        case .detaching: return "DETACHING"
        case .failedcreation: return "FAILED_CREATION"
        case .failedresourcegone: return "FAILED_RESOURCE_GONE"
        case .remapattaching: return "REMAP_ATTACHING"
        case .remapdetaching: return "REMAP_DETACHING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IpAddressStatus(rawValue: rawValue) ?? IpAddressStatus.sdkUnknown(rawValue)
    }
}

extension IpAddressUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ip = "Ip"
        case ipId = "IpId"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ip = ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let ipId = ipId {
            try encodeContainer.encode(ipId, forKey: .ipId)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipId)
        ipId = ipIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let ipDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ip)
        ip = ipDecoded
    }
}

extension IpAddressUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IpAddressUpdate(ip: \(String(describing: ip)), ipId: \(String(describing: ipId)), subnetId: \(String(describing: subnetId)))"}
}

/// <p>In an
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverEndpoint.html">UpdateResolverEndpoint</a>
/// 			request, information about an IP address to update.</p>
public struct IpAddressUpdate: Equatable {
    /// <p>The new IP address.</p>
    public let ip: String?
    /// <p>
    ///             <i>Only when removing an IP address from a Resolver endpoint</i>: The ID of the IP address that you want to remove.
    /// 			To get this ID, use
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html">GetResolverEndpoint</a>.</p>
    public let ipId: String?
    /// <p>The ID of the subnet that includes the IP address that you want to update. To get this ID, use
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html">GetResolverEndpoint</a>.</p>
    public let subnetId: String?

    public init (
        ip: String? = nil,
        ipId: String? = nil,
        subnetId: String? = nil
    )
    {
        self.ip = ip
        self.ipId = ipId
        self.subnetId = subnetId
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)), resourceType: \(String(describing: resourceType)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request caused one or more limits to be exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>For a <code>LimitExceededException</code> error, the type of resource that exceeded the current limit.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
    public let resourceType: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct ListFirewallConfigsInputBodyMiddleware: Middleware {
    public let id: String = "ListFirewallConfigsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallConfigsInput>
    public typealias MOutput = OperationOutput<ListFirewallConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallConfigsOutputError>
}

extension ListFirewallConfigsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFirewallConfigsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFirewallConfigsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFirewallConfigsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFirewallConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallConfigsInput>
    public typealias MOutput = OperationOutput<ListFirewallConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallConfigsOutputError>
}

public struct ListFirewallConfigsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFirewallConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallConfigsInput>
    public typealias MOutput = OperationOutput<ListFirewallConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallConfigsOutputError>
}

public struct ListFirewallConfigsInput: Equatable {
    /// <p>The maximum number of objects that you want Resolver to return for this request. If more
    ///             objects are available, in the response, Resolver provides a
    ///            <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    ///          <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
    public let maxResults: Int?
    /// <p>For the first call to this list request, omit this value.</p>
    ///          <p>When you request a list of objects, Resolver returns at most the number of objects
    ///        specified in <code>MaxResults</code>. If more objects are available for retrieval,
    ///            Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
    ///                batch of objects, use the token that was returned for the prior request in your next request.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFirewallConfigsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListFirewallConfigsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallConfigsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFirewallConfigsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFirewallConfigsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFirewallConfigsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFirewallConfigsOutputResponse(firewallConfigs: \(String(describing: firewallConfigs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFirewallConfigsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFirewallConfigsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallConfigs = output.firewallConfigs
            self.nextToken = output.nextToken
        } else {
            self.firewallConfigs = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallConfigsOutputResponse: Equatable {
    /// <p>The configurations for the firewall behavior provided by DNS Firewall for VPCs from
    /// 			Amazon Virtual Private Cloud (Amazon VPC). </p>
    public let firewallConfigs: [FirewallConfig]?
    /// <p>If objects are still available for retrieval, Resolver returns this token in the response.
    ///            To retrieve the next batch of objects, provide this token in your next request.</p>
    public let nextToken: String?

    public init (
        firewallConfigs: [FirewallConfig]? = nil,
        nextToken: String? = nil
    )
    {
        self.firewallConfigs = firewallConfigs
        self.nextToken = nextToken
    }
}

struct ListFirewallConfigsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let firewallConfigs: [FirewallConfig]?
}

extension ListFirewallConfigsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallConfigs = "FirewallConfigs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallConfigsContainer = try containerValues.decodeIfPresent([FirewallConfig?].self, forKey: .firewallConfigs)
        var firewallConfigsDecoded0:[FirewallConfig]? = nil
        if let firewallConfigsContainer = firewallConfigsContainer {
            firewallConfigsDecoded0 = [FirewallConfig]()
            for structure0 in firewallConfigsContainer {
                if let structure0 = structure0 {
                    firewallConfigsDecoded0?.append(structure0)
                }
            }
        }
        firewallConfigs = firewallConfigsDecoded0
    }
}

public struct ListFirewallDomainListsInputBodyMiddleware: Middleware {
    public let id: String = "ListFirewallDomainListsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallDomainListsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallDomainListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallDomainListsInput>
    public typealias MOutput = OperationOutput<ListFirewallDomainListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallDomainListsOutputError>
}

extension ListFirewallDomainListsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFirewallDomainListsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFirewallDomainListsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFirewallDomainListsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFirewallDomainListsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallDomainListsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallDomainListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallDomainListsInput>
    public typealias MOutput = OperationOutput<ListFirewallDomainListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallDomainListsOutputError>
}

public struct ListFirewallDomainListsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFirewallDomainListsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallDomainListsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallDomainListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallDomainListsInput>
    public typealias MOutput = OperationOutput<ListFirewallDomainListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallDomainListsOutputError>
}

public struct ListFirewallDomainListsInput: Equatable {
    /// <p>The maximum number of objects that you want Resolver to return for this request. If more
    ///             objects are available, in the response, Resolver provides a
    ///            <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    ///          <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
    public let maxResults: Int?
    /// <p>For the first call to this list request, omit this value.</p>
    ///          <p>When you request a list of objects, Resolver returns at most the number of objects
    ///        specified in <code>MaxResults</code>. If more objects are available for retrieval,
    ///            Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
    ///                batch of objects, use the token that was returned for the prior request in your next request.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFirewallDomainListsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListFirewallDomainListsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallDomainListsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFirewallDomainListsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFirewallDomainListsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFirewallDomainListsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFirewallDomainListsOutputResponse(firewallDomainLists: \(String(describing: firewallDomainLists)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFirewallDomainListsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFirewallDomainListsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallDomainLists = output.firewallDomainLists
            self.nextToken = output.nextToken
        } else {
            self.firewallDomainLists = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallDomainListsOutputResponse: Equatable {
    /// <p>A list of the domain lists that you have defined.   </p>
    ///          <p>This might be a partial list of the domain lists that you've defined. For information,
    /// 			see <code>MaxResults</code>. </p>
    public let firewallDomainLists: [FirewallDomainListMetadata]?
    /// <p>If objects are still available for retrieval, Resolver returns this token in the response.
    ///            To retrieve the next batch of objects, provide this token in your next request.</p>
    public let nextToken: String?

    public init (
        firewallDomainLists: [FirewallDomainListMetadata]? = nil,
        nextToken: String? = nil
    )
    {
        self.firewallDomainLists = firewallDomainLists
        self.nextToken = nextToken
    }
}

struct ListFirewallDomainListsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let firewallDomainLists: [FirewallDomainListMetadata]?
}

extension ListFirewallDomainListsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallDomainLists = "FirewallDomainLists"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallDomainListsContainer = try containerValues.decodeIfPresent([FirewallDomainListMetadata?].self, forKey: .firewallDomainLists)
        var firewallDomainListsDecoded0:[FirewallDomainListMetadata]? = nil
        if let firewallDomainListsContainer = firewallDomainListsContainer {
            firewallDomainListsDecoded0 = [FirewallDomainListMetadata]()
            for structure0 in firewallDomainListsContainer {
                if let structure0 = structure0 {
                    firewallDomainListsDecoded0?.append(structure0)
                }
            }
        }
        firewallDomainLists = firewallDomainListsDecoded0
    }
}

public struct ListFirewallDomainsInputBodyMiddleware: Middleware {
    public let id: String = "ListFirewallDomainsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallDomainsInput>
    public typealias MOutput = OperationOutput<ListFirewallDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallDomainsOutputError>
}

extension ListFirewallDomainsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFirewallDomainsInput(firewallDomainListId: \(String(describing: firewallDomainListId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFirewallDomainsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFirewallDomainsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFirewallDomainsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallDomainsInput>
    public typealias MOutput = OperationOutput<ListFirewallDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallDomainsOutputError>
}

public struct ListFirewallDomainsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFirewallDomainsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallDomainsInput>
    public typealias MOutput = OperationOutput<ListFirewallDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallDomainsOutputError>
}

public struct ListFirewallDomainsInput: Equatable {
    /// <p>The ID of the domain list whose domains you want to retrieve. </p>
    public let firewallDomainListId: String?
    /// <p>The maximum number of objects that you want Resolver to return for this request. If more
    ///             objects are available, in the response, Resolver provides a
    ///            <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    ///          <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
    public let maxResults: Int?
    /// <p>For the first call to this list request, omit this value.</p>
    ///          <p>When you request a list of objects, Resolver returns at most the number of objects
    ///        specified in <code>MaxResults</code>. If more objects are available for retrieval,
    ///            Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
    ///                batch of objects, use the token that was returned for the prior request in your next request.</p>
    public let nextToken: String?

    public init (
        firewallDomainListId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.firewallDomainListId = firewallDomainListId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFirewallDomainsInputBody: Equatable {
    public let firewallDomainListId: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListFirewallDomainsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallDomainsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFirewallDomainsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFirewallDomainsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFirewallDomainsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFirewallDomainsOutputResponse(domains: \(String(describing: domains)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFirewallDomainsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFirewallDomainsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domains = output.domains
            self.nextToken = output.nextToken
        } else {
            self.domains = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallDomainsOutputResponse: Equatable {
    /// <p>A list of the domains in the firewall domain list.  </p>
    ///          <p>This might be a partial list of the domains that you've defined in the domain list. For
    /// 			information, see <code>MaxResults</code>. </p>
    public let domains: [String]?
    /// <p>If objects are still available for retrieval, Resolver returns this token in the response.
    ///            To retrieve the next batch of objects, provide this token in your next request.</p>
    public let nextToken: String?

    public init (
        domains: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

struct ListFirewallDomainsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let domains: [String]?
}

extension ListFirewallDomainsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domains = "Domains"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let domainsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .domains)
        var domainsDecoded0:[String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
    }
}

public struct ListFirewallRuleGroupAssociationsInputBodyMiddleware: Middleware {
    public let id: String = "ListFirewallRuleGroupAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallRuleGroupAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallRuleGroupAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallRuleGroupAssociationsInput>
    public typealias MOutput = OperationOutput<ListFirewallRuleGroupAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallRuleGroupAssociationsOutputError>
}

extension ListFirewallRuleGroupAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFirewallRuleGroupAssociationsInput(firewallRuleGroupId: \(String(describing: firewallRuleGroupId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), priority: \(String(describing: priority)), status: \(String(describing: status)), vpcId: \(String(describing: vpcId)))"}
}

extension ListFirewallRuleGroupAssociationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case priority = "Priority"
        case status = "Status"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

public struct ListFirewallRuleGroupAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFirewallRuleGroupAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallRuleGroupAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallRuleGroupAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallRuleGroupAssociationsInput>
    public typealias MOutput = OperationOutput<ListFirewallRuleGroupAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallRuleGroupAssociationsOutputError>
}

public struct ListFirewallRuleGroupAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFirewallRuleGroupAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallRuleGroupAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallRuleGroupAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallRuleGroupAssociationsInput>
    public typealias MOutput = OperationOutput<ListFirewallRuleGroupAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallRuleGroupAssociationsOutputError>
}

public struct ListFirewallRuleGroupAssociationsInput: Equatable {
    /// <p>The unique identifier of the firewall rule group that you want to retrieve the associations
    ///            for. Leave this blank to retrieve associations for any rule group. </p>
    public let firewallRuleGroupId: String?
    /// <p>The maximum number of objects that you want Resolver to return for this request. If more
    ///             objects are available, in the response, Resolver provides a
    ///            <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    ///          <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
    public let maxResults: Int?
    /// <p>For the first call to this list request, omit this value.</p>
    ///          <p>When you request a list of objects, Resolver returns at most the number of objects
    ///        specified in <code>MaxResults</code>. If more objects are available for retrieval,
    ///            Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
    ///                batch of objects, use the token that was returned for the prior request in your next request.</p>
    public let nextToken: String?
    /// <p>The setting that determines the processing order of the rule group among the rule
    /// 			groups that are associated with a single VPC. DNS Firewall filters VPC traffic starting
    /// 			from the rule group with the lowest numeric priority setting. </p>
    public let priority: Int?
    /// <p>The association <code>Status</code> setting that you want DNS Firewall to filter on for the list. If you don't specify this, then DNS Firewall returns all associations, regardless of status.</p>
    public let status: FirewallRuleGroupAssociationStatus?
    /// <p>The unique identifier of the VPC that you want to retrieve the associations
    ///            for. Leave this blank to retrieve associations for any VPC. </p>
    public let vpcId: String?

    public init (
        firewallRuleGroupId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        priority: Int? = nil,
        status: FirewallRuleGroupAssociationStatus? = nil,
        vpcId: String? = nil
    )
    {
        self.firewallRuleGroupId = firewallRuleGroupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.priority = priority
        self.status = status
        self.vpcId = vpcId
    }
}

struct ListFirewallRuleGroupAssociationsInputBody: Equatable {
    public let firewallRuleGroupId: String?
    public let vpcId: String?
    public let priority: Int?
    public let status: FirewallRuleGroupAssociationStatus?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListFirewallRuleGroupAssociationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case priority = "Priority"
        case status = "Status"
        case vpcId = "VpcId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FirewallRuleGroupAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallRuleGroupAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFirewallRuleGroupAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFirewallRuleGroupAssociationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFirewallRuleGroupAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFirewallRuleGroupAssociationsOutputResponse(firewallRuleGroupAssociations: \(String(describing: firewallRuleGroupAssociations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFirewallRuleGroupAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFirewallRuleGroupAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallRuleGroupAssociations = output.firewallRuleGroupAssociations
            self.nextToken = output.nextToken
        } else {
            self.firewallRuleGroupAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallRuleGroupAssociationsOutputResponse: Equatable {
    /// <p>A list of your firewall rule group associations.</p>
    ///          <p>This might be a partial list of the associations that you have defined. For information, see <code>MaxResults</code>. </p>
    public let firewallRuleGroupAssociations: [FirewallRuleGroupAssociation]?
    /// <p>If objects are still available for retrieval, Resolver returns this token in the response.
    ///            To retrieve the next batch of objects, provide this token in your next request.</p>
    public let nextToken: String?

    public init (
        firewallRuleGroupAssociations: [FirewallRuleGroupAssociation]? = nil,
        nextToken: String? = nil
    )
    {
        self.firewallRuleGroupAssociations = firewallRuleGroupAssociations
        self.nextToken = nextToken
    }
}

struct ListFirewallRuleGroupAssociationsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let firewallRuleGroupAssociations: [FirewallRuleGroupAssociation]?
}

extension ListFirewallRuleGroupAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupAssociations = "FirewallRuleGroupAssociations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallRuleGroupAssociationsContainer = try containerValues.decodeIfPresent([FirewallRuleGroupAssociation?].self, forKey: .firewallRuleGroupAssociations)
        var firewallRuleGroupAssociationsDecoded0:[FirewallRuleGroupAssociation]? = nil
        if let firewallRuleGroupAssociationsContainer = firewallRuleGroupAssociationsContainer {
            firewallRuleGroupAssociationsDecoded0 = [FirewallRuleGroupAssociation]()
            for structure0 in firewallRuleGroupAssociationsContainer {
                if let structure0 = structure0 {
                    firewallRuleGroupAssociationsDecoded0?.append(structure0)
                }
            }
        }
        firewallRuleGroupAssociations = firewallRuleGroupAssociationsDecoded0
    }
}

public struct ListFirewallRuleGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListFirewallRuleGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListFirewallRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallRuleGroupsOutputError>
}

extension ListFirewallRuleGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFirewallRuleGroupsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFirewallRuleGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFirewallRuleGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFirewallRuleGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListFirewallRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallRuleGroupsOutputError>
}

public struct ListFirewallRuleGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFirewallRuleGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListFirewallRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallRuleGroupsOutputError>
}

public struct ListFirewallRuleGroupsInput: Equatable {
    /// <p>The maximum number of objects that you want Resolver to return for this request. If more
    ///             objects are available, in the response, Resolver provides a
    ///            <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    ///          <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
    public let maxResults: Int?
    /// <p>For the first call to this list request, omit this value.</p>
    ///          <p>When you request a list of objects, Resolver returns at most the number of objects
    ///        specified in <code>MaxResults</code>. If more objects are available for retrieval,
    ///            Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
    ///                batch of objects, use the token that was returned for the prior request in your next request.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFirewallRuleGroupsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListFirewallRuleGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallRuleGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFirewallRuleGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFirewallRuleGroupsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFirewallRuleGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFirewallRuleGroupsOutputResponse(firewallRuleGroups: \(String(describing: firewallRuleGroups)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFirewallRuleGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFirewallRuleGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallRuleGroups = output.firewallRuleGroups
            self.nextToken = output.nextToken
        } else {
            self.firewallRuleGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallRuleGroupsOutputResponse: Equatable {
    /// <p>A list of your firewall rule groups.</p>
    ///          <p>This might be a partial list of the rule groups that you have defined. For information, see <code>MaxResults</code>. </p>
    public let firewallRuleGroups: [FirewallRuleGroupMetadata]?
    /// <p>If objects are still available for retrieval, Resolver returns this token in the response.
    ///            To retrieve the next batch of objects, provide this token in your next request.</p>
    public let nextToken: String?

    public init (
        firewallRuleGroups: [FirewallRuleGroupMetadata]? = nil,
        nextToken: String? = nil
    )
    {
        self.firewallRuleGroups = firewallRuleGroups
        self.nextToken = nextToken
    }
}

struct ListFirewallRuleGroupsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let firewallRuleGroups: [FirewallRuleGroupMetadata]?
}

extension ListFirewallRuleGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroups = "FirewallRuleGroups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallRuleGroupsContainer = try containerValues.decodeIfPresent([FirewallRuleGroupMetadata?].self, forKey: .firewallRuleGroups)
        var firewallRuleGroupsDecoded0:[FirewallRuleGroupMetadata]? = nil
        if let firewallRuleGroupsContainer = firewallRuleGroupsContainer {
            firewallRuleGroupsDecoded0 = [FirewallRuleGroupMetadata]()
            for structure0 in firewallRuleGroupsContainer {
                if let structure0 = structure0 {
                    firewallRuleGroupsDecoded0?.append(structure0)
                }
            }
        }
        firewallRuleGroups = firewallRuleGroupsDecoded0
    }
}

public struct ListFirewallRulesInputBodyMiddleware: Middleware {
    public let id: String = "ListFirewallRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallRulesInput>
    public typealias MOutput = OperationOutput<ListFirewallRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallRulesOutputError>
}

extension ListFirewallRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFirewallRulesInput(action: \(String(describing: action)), firewallRuleGroupId: \(String(describing: firewallRuleGroupId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), priority: \(String(describing: priority)))"}
}

extension ListFirewallRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case priority = "Priority"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }
}

public struct ListFirewallRulesInputHeadersMiddleware: Middleware {
    public let id: String = "ListFirewallRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallRulesInput>
    public typealias MOutput = OperationOutput<ListFirewallRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallRulesOutputError>
}

public struct ListFirewallRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFirewallRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallRulesInput>
    public typealias MOutput = OperationOutput<ListFirewallRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallRulesOutputError>
}

public struct ListFirewallRulesInput: Equatable {
    /// <p>Optional additional filter for the rules to retrieve.</p>
    ///          <p>The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALLOW</code> - Permit the request to go through.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ALERT</code> - Permit the request to go through but send an alert to the logs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BLOCK</code> - Disallow the request. If this is specified, additional handling details are provided in the rule's <code>BlockResponse</code> setting. </p>
    ///             </li>
    ///          </ul>
    public let action: Action?
    /// <p>The unique identifier of the firewall rule group that you want to retrieve the rules for. </p>
    public let firewallRuleGroupId: String?
    /// <p>The maximum number of objects that you want Resolver to return for this request. If more
    ///             objects are available, in the response, Resolver provides a
    ///            <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    ///          <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
    public let maxResults: Int?
    /// <p>For the first call to this list request, omit this value.</p>
    ///          <p>When you request a list of objects, Resolver returns at most the number of objects
    ///        specified in <code>MaxResults</code>. If more objects are available for retrieval,
    ///            Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
    ///                batch of objects, use the token that was returned for the prior request in your next request.</p>
    public let nextToken: String?
    /// <p>Optional additional filter for the rules to retrieve.</p>
    ///          <p>The setting that determines the processing order of the rules in a rule group. DNS Firewall
    ///            processes the rules in a rule group by order of priority, starting from the lowest setting.</p>
    public let priority: Int?

    public init (
        action: Action? = nil,
        firewallRuleGroupId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        priority: Int? = nil
    )
    {
        self.action = action
        self.firewallRuleGroupId = firewallRuleGroupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.priority = priority
    }
}

struct ListFirewallRulesInputBody: Equatable {
    public let firewallRuleGroupId: String?
    public let priority: Int?
    public let action: Action?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListFirewallRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case priority = "Priority"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFirewallRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFirewallRulesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFirewallRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFirewallRulesOutputResponse(firewallRules: \(String(describing: firewallRules)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFirewallRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFirewallRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallRules = output.firewallRules
            self.nextToken = output.nextToken
        } else {
            self.firewallRules = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallRulesOutputResponse: Equatable {
    /// <p>A list of the rules that you have defined.  </p>
    ///          <p>This might be a partial list of the firewall rules that you've defined. For information,
    /// 			see <code>MaxResults</code>. </p>
    public let firewallRules: [FirewallRule]?
    /// <p>If objects are still available for retrieval, Resolver returns this token in the response.
    ///            To retrieve the next batch of objects, provide this token in your next request.</p>
    public let nextToken: String?

    public init (
        firewallRules: [FirewallRule]? = nil,
        nextToken: String? = nil
    )
    {
        self.firewallRules = firewallRules
        self.nextToken = nextToken
    }
}

struct ListFirewallRulesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let firewallRules: [FirewallRule]?
}

extension ListFirewallRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRules = "FirewallRules"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallRulesContainer = try containerValues.decodeIfPresent([FirewallRule?].self, forKey: .firewallRules)
        var firewallRulesDecoded0:[FirewallRule]? = nil
        if let firewallRulesContainer = firewallRulesContainer {
            firewallRulesDecoded0 = [FirewallRule]()
            for structure0 in firewallRulesContainer {
                if let structure0 = structure0 {
                    firewallRulesDecoded0?.append(structure0)
                }
            }
        }
        firewallRules = firewallRulesDecoded0
    }
}

public struct ListResolverDnssecConfigsInputBodyMiddleware: Middleware {
    public let id: String = "ListResolverDnssecConfigsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverDnssecConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverDnssecConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverDnssecConfigsInput>
    public typealias MOutput = OperationOutput<ListResolverDnssecConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverDnssecConfigsOutputError>
}

extension ListResolverDnssecConfigsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolverDnssecConfigsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListResolverDnssecConfigsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListResolverDnssecConfigsInputHeadersMiddleware: Middleware {
    public let id: String = "ListResolverDnssecConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverDnssecConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverDnssecConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverDnssecConfigsInput>
    public typealias MOutput = OperationOutput<ListResolverDnssecConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverDnssecConfigsOutputError>
}

public struct ListResolverDnssecConfigsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResolverDnssecConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverDnssecConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverDnssecConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverDnssecConfigsInput>
    public typealias MOutput = OperationOutput<ListResolverDnssecConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverDnssecConfigsOutputError>
}

public struct ListResolverDnssecConfigsInput: Equatable {
    /// <p>An optional specification to return a subset of objects.</p>
    public let filters: [Filter]?
    /// <p>
    ///             <i>Optional</i>: An integer that specifies the maximum number of DNSSEC configuration results that you want Amazon Route 53 to return.
    /// 			If you don't specify a value for <code>MaxResults</code>, Route 53 returns up to 100 configuration per page.</p>
    public let maxResults: Int?
    /// <p>(Optional) If the current AWS account has more than <code>MaxResults</code> DNSSEC configurations, use <code>NextToken</code>
    /// 			to get the second and subsequent pages of results.</p>
    /// 		       <p>For the first <code>ListResolverDnssecConfigs</code> request, omit this value.</p>
    /// 		       <p>For the second and subsequent requests, get the value of <code>NextToken</code> from the previous response and specify that value
    /// 			for <code>NextToken</code> in the request.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverDnssecConfigsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
    public let filters: [Filter]?
}

extension ListResolverDnssecConfigsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListResolverDnssecConfigsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolverDnssecConfigsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolverDnssecConfigsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolverDnssecConfigsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolverDnssecConfigsOutputResponse(nextToken: \(String(describing: nextToken)), resolverDnssecConfigs: \(String(describing: resolverDnssecConfigs)))"}
}

extension ListResolverDnssecConfigsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResolverDnssecConfigsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resolverDnssecConfigs = output.resolverDnssecConfigs
        } else {
            self.nextToken = nil
            self.resolverDnssecConfigs = nil
        }
    }
}

public struct ListResolverDnssecConfigsOutputResponse: Equatable {
    /// <p>If a response includes the last of the DNSSEC configurations that are associated with the current AWS account,
    /// 			<code>NextToken</code> doesn't appear in the response.</p>
    /// 		       <p>If a response doesn't include the last of the configurations, you can get more configurations by submitting another
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ListResolverDnssecConfigs.html">ListResolverDnssecConfigs</a>
    /// 			request. Get the value of <code>NextToken</code> that Amazon Route 53 returned in the previous response and include it in
    /// 			<code>NextToken</code> in the next request.</p>
    public let nextToken: String?
    /// <p>An array that contains one
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ResolverDnssecConfig.html">ResolverDnssecConfig</a> element
    /// 			for each configuration for DNSSEC validation that is associated with the current AWS account.</p>
    public let resolverDnssecConfigs: [ResolverDnssecConfig]?

    public init (
        nextToken: String? = nil,
        resolverDnssecConfigs: [ResolverDnssecConfig]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolverDnssecConfigs = resolverDnssecConfigs
    }
}

struct ListResolverDnssecConfigsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let resolverDnssecConfigs: [ResolverDnssecConfig]?
}

extension ListResolverDnssecConfigsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resolverDnssecConfigs = "ResolverDnssecConfigs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resolverDnssecConfigsContainer = try containerValues.decodeIfPresent([ResolverDnssecConfig?].self, forKey: .resolverDnssecConfigs)
        var resolverDnssecConfigsDecoded0:[ResolverDnssecConfig]? = nil
        if let resolverDnssecConfigsContainer = resolverDnssecConfigsContainer {
            resolverDnssecConfigsDecoded0 = [ResolverDnssecConfig]()
            for structure0 in resolverDnssecConfigsContainer {
                if let structure0 = structure0 {
                    resolverDnssecConfigsDecoded0?.append(structure0)
                }
            }
        }
        resolverDnssecConfigs = resolverDnssecConfigsDecoded0
    }
}

public struct ListResolverEndpointIpAddressesInputBodyMiddleware: Middleware {
    public let id: String = "ListResolverEndpointIpAddressesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverEndpointIpAddressesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverEndpointIpAddressesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverEndpointIpAddressesInput>
    public typealias MOutput = OperationOutput<ListResolverEndpointIpAddressesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverEndpointIpAddressesOutputError>
}

extension ListResolverEndpointIpAddressesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolverEndpointIpAddressesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resolverEndpointId: \(String(describing: resolverEndpointId)))"}
}

extension ListResolverEndpointIpAddressesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

public struct ListResolverEndpointIpAddressesInputHeadersMiddleware: Middleware {
    public let id: String = "ListResolverEndpointIpAddressesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverEndpointIpAddressesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverEndpointIpAddressesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverEndpointIpAddressesInput>
    public typealias MOutput = OperationOutput<ListResolverEndpointIpAddressesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverEndpointIpAddressesOutputError>
}

public struct ListResolverEndpointIpAddressesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResolverEndpointIpAddressesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverEndpointIpAddressesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverEndpointIpAddressesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverEndpointIpAddressesInput>
    public typealias MOutput = OperationOutput<ListResolverEndpointIpAddressesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverEndpointIpAddressesOutputError>
}

public struct ListResolverEndpointIpAddressesInput: Equatable {
    /// <p>The maximum number of IP addresses that you want to return in the response to a <code>ListResolverEndpointIpAddresses</code> request.
    /// 			If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 IP addresses. </p>
    public let maxResults: Int?
    /// <p>For the first <code>ListResolverEndpointIpAddresses</code> request, omit this value.</p>
    /// 		       <p>If the specified Resolver endpoint has more than <code>MaxResults</code> IP addresses, you can submit another
    /// 			<code>ListResolverEndpointIpAddresses</code> request to get the next group of IP addresses. In the next request, specify the value of
    /// 			<code>NextToken</code> from the previous response. </p>
    public let nextToken: String?
    /// <p>The ID of the Resolver endpoint that you want to get IP addresses for.</p>
    public let resolverEndpointId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resolverEndpointId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolverEndpointId = resolverEndpointId
    }
}

struct ListResolverEndpointIpAddressesInputBody: Equatable {
    public let resolverEndpointId: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListResolverEndpointIpAddressesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResolverEndpointIpAddressesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolverEndpointIpAddressesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolverEndpointIpAddressesOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolverEndpointIpAddressesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolverEndpointIpAddressesOutputResponse(ipAddresses: \(String(describing: ipAddresses)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListResolverEndpointIpAddressesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResolverEndpointIpAddressesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ipAddresses = output.ipAddresses
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.ipAddresses = nil
            self.maxResults = nil
            self.nextToken = nil
        }
    }
}

public struct ListResolverEndpointIpAddressesOutputResponse: Equatable {
    /// <p>Information about the IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward
    /// 			DNS queries to (for inbound endpoints).</p>
    public let ipAddresses: [IpAddressResponse]?
    /// <p>The value that you specified for <code>MaxResults</code> in the request.</p>
    public let maxResults: Int?
    /// <p>If the specified endpoint has more than <code>MaxResults</code> IP addresses, you can submit another
    /// 			<code>ListResolverEndpointIpAddresses</code> request to get the next group of IP addresses. In the next request,
    /// 			specify the value of <code>NextToken</code> from the previous response. </p>
    public let nextToken: String?

    public init (
        ipAddresses: [IpAddressResponse]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.ipAddresses = ipAddresses
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverEndpointIpAddressesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let ipAddresses: [IpAddressResponse]?
}

extension ListResolverEndpointIpAddressesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ipAddresses = "IpAddresses"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([IpAddressResponse?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[IpAddressResponse]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [IpAddressResponse]()
            for structure0 in ipAddressesContainer {
                if let structure0 = structure0 {
                    ipAddressesDecoded0?.append(structure0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
    }
}

public struct ListResolverEndpointsInputBodyMiddleware: Middleware {
    public let id: String = "ListResolverEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverEndpointsInput>
    public typealias MOutput = OperationOutput<ListResolverEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverEndpointsOutputError>
}

extension ListResolverEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolverEndpointsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListResolverEndpointsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListResolverEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "ListResolverEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverEndpointsInput>
    public typealias MOutput = OperationOutput<ListResolverEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverEndpointsOutputError>
}

public struct ListResolverEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResolverEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverEndpointsInput>
    public typealias MOutput = OperationOutput<ListResolverEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverEndpointsOutputError>
}

public struct ListResolverEndpointsInput: Equatable {
    /// <p>An optional specification to return a subset of Resolver endpoints, such as all inbound Resolver endpoints.</p>
    /// 		       <note>
    ///             <p>If you submit a second or subsequent <code>ListResolverEndpoints</code> request and specify the <code>NextToken</code> parameter,
    /// 			you must use the same values for <code>Filters</code>, if any, as in the previous request.</p>
    ///          </note>
    public let filters: [Filter]?
    /// <p>The maximum number of Resolver endpoints that you want to return in the response to a <code>ListResolverEndpoints</code> request.
    /// 			If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 Resolver endpoints. </p>
    public let maxResults: Int?
    /// <p>For the first <code>ListResolverEndpoints</code> request, omit this value.</p>
    /// 		       <p>If you have more than <code>MaxResults</code> Resolver endpoints, you can submit another <code>ListResolverEndpoints</code> request
    /// 			to get the next group of Resolver endpoints. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverEndpointsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
    public let filters: [Filter]?
}

extension ListResolverEndpointsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListResolverEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolverEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolverEndpointsOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolverEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolverEndpointsOutputResponse(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resolverEndpoints: \(String(describing: resolverEndpoints)))"}
}

extension ListResolverEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResolverEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.resolverEndpoints = output.resolverEndpoints
        } else {
            self.maxResults = nil
            self.nextToken = nil
            self.resolverEndpoints = nil
        }
    }
}

public struct ListResolverEndpointsOutputResponse: Equatable {
    /// <p>The value that you specified for <code>MaxResults</code> in the request.</p>
    public let maxResults: Int?
    /// <p>If more than <code>MaxResults</code> IP addresses match the specified criteria, you can submit another <code>ListResolverEndpoint</code> request
    /// 			to get the next group of results. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
    public let nextToken: String?
    /// <p>The Resolver endpoints that were created by using the current AWS account, and that match the specified filters, if any.</p>
    public let resolverEndpoints: [ResolverEndpoint]?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resolverEndpoints: [ResolverEndpoint]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolverEndpoints = resolverEndpoints
    }
}

struct ListResolverEndpointsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let resolverEndpoints: [ResolverEndpoint]?
}

extension ListResolverEndpointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resolverEndpoints = "ResolverEndpoints"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resolverEndpointsContainer = try containerValues.decodeIfPresent([ResolverEndpoint?].self, forKey: .resolverEndpoints)
        var resolverEndpointsDecoded0:[ResolverEndpoint]? = nil
        if let resolverEndpointsContainer = resolverEndpointsContainer {
            resolverEndpointsDecoded0 = [ResolverEndpoint]()
            for structure0 in resolverEndpointsContainer {
                if let structure0 = structure0 {
                    resolverEndpointsDecoded0?.append(structure0)
                }
            }
        }
        resolverEndpoints = resolverEndpointsDecoded0
    }
}

public struct ListResolverQueryLogConfigAssociationsInputBodyMiddleware: Middleware {
    public let id: String = "ListResolverQueryLogConfigAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverQueryLogConfigAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverQueryLogConfigAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverQueryLogConfigAssociationsInput>
    public typealias MOutput = OperationOutput<ListResolverQueryLogConfigAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverQueryLogConfigAssociationsOutputError>
}

extension ListResolverQueryLogConfigAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolverQueryLogConfigAssociationsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)), sortOrder: \(String(describing: sortOrder)))"}
}

extension ListResolverQueryLogConfigAssociationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct ListResolverQueryLogConfigAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListResolverQueryLogConfigAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverQueryLogConfigAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverQueryLogConfigAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverQueryLogConfigAssociationsInput>
    public typealias MOutput = OperationOutput<ListResolverQueryLogConfigAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverQueryLogConfigAssociationsOutputError>
}

public struct ListResolverQueryLogConfigAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResolverQueryLogConfigAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverQueryLogConfigAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverQueryLogConfigAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverQueryLogConfigAssociationsInput>
    public typealias MOutput = OperationOutput<ListResolverQueryLogConfigAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverQueryLogConfigAssociationsOutputError>
}

public struct ListResolverQueryLogConfigAssociationsInput: Equatable {
    /// <p>An optional specification to return a subset of query logging associations.</p>
    /// 		       <note>
    /// 			         <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigAssociations</code> request and specify the <code>NextToken</code> parameter,
    /// 				you must use the same values for <code>Filters</code>, if any, as in the previous request.</p>
    /// 		       </note>
    public let filters: [Filter]?
    /// <p>The maximum number of query logging associations that you want to return in the response to a <code>ListResolverQueryLogConfigAssociations</code> request.
    /// 			If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 query logging associations. </p>
    public let maxResults: Int?
    /// <p>For the first <code>ListResolverQueryLogConfigAssociations</code> request, omit this value.</p>
    /// 		       <p>If there are more than <code>MaxResults</code> query logging associations that match the values that you specify for <code>Filters</code>,
    /// 			you can submit another <code>ListResolverQueryLogConfigAssociations</code> request to get the next group of associations. In the next request, specify the value of
    /// 			<code>NextToken</code> from the previous response. </p>
    public let nextToken: String?
    /// <p>The element that you want Resolver to sort query logging associations by. </p>
    /// 		       <note>
    /// 			         <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigAssociations</code> request and specify the <code>NextToken</code> parameter,
    /// 				you must use the same value for <code>SortBy</code>, if any, as in the previous request.</p>
    /// 		       </note>
    /// 		
    /// 		       <p>Valid values include the following elements:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CreationTime</code>: The ID of the query logging association.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Error</code>: If the value of <code>Status</code> is <code>FAILED</code>, the value of <code>Error</code>
    /// 				indicates the cause: </p>
    /// 				           <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>DESTINATION_NOT_FOUND</code>: The specified destination (for example, an Amazon S3 bucket) was deleted.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>ACCESS_DENIED</code>: Permissions don't allow sending logs to the destination.</p>
    ///                   </li>
    ///                </ul>
    /// 				           <p>If <code>Status</code> is a value other than <code>FAILED</code>, <code>ERROR</code> is null.</p>
    /// 			         </li>
    ///             <li>
    ///                <p>
    ///                   <code>Id</code>: The ID of the query logging association</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ResolverQueryLogConfigId</code>: The ID of the query logging configuration</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ResourceId</code>: The ID of the VPC that is associated with the query logging configuration</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Status</code>: The current status of the configuration. Valid values include the following:</p>
    /// 				
    /// 				           <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>CREATING</code>: Resolver is creating an association between an Amazon VPC and a query logging configuration.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>CREATED</code>: The association between an Amazon VPC and a query logging configuration
    /// 						was successfully created. Resolver is logging queries that originate in the specified VPC.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>DELETING</code>: Resolver is deleting this query logging association.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>FAILED</code>: Resolver either couldn't create or couldn't delete the query logging association.
    /// 						Here are two common causes:</p>
    /// 						               <ul>
    ///                         <li>
    ///                            <p>The specified destination (for example, an Amazon S3 bucket) was deleted.</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>Permissions don't allow sending logs to the destination.</p>
    ///                         </li>
    ///                      </ul>
    /// 					             </li>
    ///                </ul>
    /// 			         </li>
    ///          </ul>
    public let sortBy: String?
    /// <p>If you specified a value for <code>SortBy</code>, the order that you want query logging associations to be listed in,
    /// 			<code>ASCENDING</code> or <code>DESCENDING</code>.</p>
    /// 		       <note>
    /// 			         <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigAssociations</code> request and specify the <code>NextToken</code> parameter,
    /// 				you must use the same value for <code>SortOrder</code>, if any, as in the previous request.</p>
    /// 		       </note>
    public let sortOrder: SortOrder?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: String? = nil,
        sortOrder: SortOrder? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListResolverQueryLogConfigAssociationsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
    public let filters: [Filter]?
    public let sortBy: String?
    public let sortOrder: SortOrder?
}

extension ListResolverQueryLogConfigAssociationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ListResolverQueryLogConfigAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolverQueryLogConfigAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolverQueryLogConfigAssociationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolverQueryLogConfigAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolverQueryLogConfigAssociationsOutputResponse(nextToken: \(String(describing: nextToken)), resolverQueryLogConfigAssociations: \(String(describing: resolverQueryLogConfigAssociations)), totalCount: \(String(describing: totalCount)), totalFilteredCount: \(String(describing: totalFilteredCount)))"}
}

extension ListResolverQueryLogConfigAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResolverQueryLogConfigAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resolverQueryLogConfigAssociations = output.resolverQueryLogConfigAssociations
            self.totalCount = output.totalCount
            self.totalFilteredCount = output.totalFilteredCount
        } else {
            self.nextToken = nil
            self.resolverQueryLogConfigAssociations = nil
            self.totalCount = 0
            self.totalFilteredCount = 0
        }
    }
}

public struct ListResolverQueryLogConfigAssociationsOutputResponse: Equatable {
    /// <p>If there are more than <code>MaxResults</code> query logging associations, you can submit another <code>ListResolverQueryLogConfigAssociations</code> request
    /// 			to get the next group of associations. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
    public let nextToken: String?
    /// <p>A list that contains one <code>ResolverQueryLogConfigAssociations</code> element for each query logging association that matches the
    /// 			values that you specified for <code>Filter</code>.</p>
    public let resolverQueryLogConfigAssociations: [ResolverQueryLogConfigAssociation]?
    /// <p>The total number of query logging associations that were created by the current account in the specified Region. This count can differ from the
    /// 			number of associations that are returned in a <code>ListResolverQueryLogConfigAssociations</code> response, depending on the values that you specify
    /// 			in the request.</p>
    public let totalCount: Int
    /// <p>The total number of query logging associations that were created by the current account in the specified Region and that match the filters
    /// 			that were specified in the <code>ListResolverQueryLogConfigAssociations</code> request. For the total number of associations that were created by the
    /// 			current account in the specified Region, see <code>TotalCount</code>.</p>
    public let totalFilteredCount: Int

    public init (
        nextToken: String? = nil,
        resolverQueryLogConfigAssociations: [ResolverQueryLogConfigAssociation]? = nil,
        totalCount: Int = 0,
        totalFilteredCount: Int = 0
    )
    {
        self.nextToken = nextToken
        self.resolverQueryLogConfigAssociations = resolverQueryLogConfigAssociations
        self.totalCount = totalCount
        self.totalFilteredCount = totalFilteredCount
    }
}

struct ListResolverQueryLogConfigAssociationsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let totalCount: Int
    public let totalFilteredCount: Int
    public let resolverQueryLogConfigAssociations: [ResolverQueryLogConfigAssociation]?
}

extension ListResolverQueryLogConfigAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resolverQueryLogConfigAssociations = "ResolverQueryLogConfigAssociations"
        case totalCount = "TotalCount"
        case totalFilteredCount = "TotalFilteredCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decode(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let totalFilteredCountDecoded = try containerValues.decode(Int.self, forKey: .totalFilteredCount)
        totalFilteredCount = totalFilteredCountDecoded
        let resolverQueryLogConfigAssociationsContainer = try containerValues.decodeIfPresent([ResolverQueryLogConfigAssociation?].self, forKey: .resolverQueryLogConfigAssociations)
        var resolverQueryLogConfigAssociationsDecoded0:[ResolverQueryLogConfigAssociation]? = nil
        if let resolverQueryLogConfigAssociationsContainer = resolverQueryLogConfigAssociationsContainer {
            resolverQueryLogConfigAssociationsDecoded0 = [ResolverQueryLogConfigAssociation]()
            for structure0 in resolverQueryLogConfigAssociationsContainer {
                if let structure0 = structure0 {
                    resolverQueryLogConfigAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resolverQueryLogConfigAssociations = resolverQueryLogConfigAssociationsDecoded0
    }
}

public struct ListResolverQueryLogConfigsInputBodyMiddleware: Middleware {
    public let id: String = "ListResolverQueryLogConfigsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverQueryLogConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverQueryLogConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverQueryLogConfigsInput>
    public typealias MOutput = OperationOutput<ListResolverQueryLogConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverQueryLogConfigsOutputError>
}

extension ListResolverQueryLogConfigsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolverQueryLogConfigsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)), sortOrder: \(String(describing: sortOrder)))"}
}

extension ListResolverQueryLogConfigsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct ListResolverQueryLogConfigsInputHeadersMiddleware: Middleware {
    public let id: String = "ListResolverQueryLogConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverQueryLogConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverQueryLogConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverQueryLogConfigsInput>
    public typealias MOutput = OperationOutput<ListResolverQueryLogConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverQueryLogConfigsOutputError>
}

public struct ListResolverQueryLogConfigsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResolverQueryLogConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverQueryLogConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverQueryLogConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverQueryLogConfigsInput>
    public typealias MOutput = OperationOutput<ListResolverQueryLogConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverQueryLogConfigsOutputError>
}

public struct ListResolverQueryLogConfigsInput: Equatable {
    /// <p>An optional specification to return a subset of query logging configurations.</p>
    /// 		       <note>
    /// 			         <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigs</code> request and specify the <code>NextToken</code> parameter,
    /// 				you must use the same values for <code>Filters</code>, if any, as in the previous request.</p>
    /// 		       </note>
    public let filters: [Filter]?
    /// <p>The maximum number of query logging configurations that you want to return in the response to a <code>ListResolverQueryLogConfigs</code> request.
    /// 			If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 query logging configurations. </p>
    public let maxResults: Int?
    /// <p>For the first <code>ListResolverQueryLogConfigs</code> request, omit this value.</p>
    /// 		       <p>If there are more than <code>MaxResults</code> query logging configurations that match the values that you specify for <code>Filters</code>,
    /// 			you can submit another <code>ListResolverQueryLogConfigs</code> request to get the next group of configurations. In the next request, specify the value of
    /// 			<code>NextToken</code> from the previous response. </p>
    public let nextToken: String?
    /// <p>The element that you want Resolver to sort query logging configurations by. </p>
    /// 		       <note>
    /// 			         <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigs</code> request and specify the <code>NextToken</code> parameter,
    /// 				you must use the same value for <code>SortBy</code>, if any, as in the previous request.</p>
    /// 		       </note>
    /// 		
    /// 		       <p>Valid values include the following elements:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Arn</code>: The ARN of the query logging configuration</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AssociationCount</code>: The number of VPCs that are associated with the specified configuration </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CreationTime</code>: The date and time that Resolver returned when the configuration was created</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CreatorRequestId</code>: The value that was specified for <code>CreatorRequestId</code> when the configuration was created</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DestinationArn</code>: The location that logs are sent to</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Id</code>: The ID of the configuration</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Name</code>: The name of the configuration</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OwnerId</code>: The AWS account number of the account that created the configuration</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ShareStatus</code>: Whether the configuration is shared with other AWS accounts or shared with the current account by
    /// 				another AWS account. Sharing is configured through AWS Resource Access Manager (AWS RAM).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Status</code>: The current status of the configuration. Valid values include the following:</p>
    /// 				
    /// 				           <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>CREATING</code>: Resolver is creating the query logging configuration.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>CREATED</code>: The query logging configuration was successfully created.
    /// 						Resolver is logging queries that originate in the specified VPC.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>DELETING</code>: Resolver is deleting this query logging configuration.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>FAILED</code>: Resolver either couldn't create or couldn't delete the query logging configuration.
    /// 						Here are two common causes:</p>
    /// 						               <ul>
    ///                         <li>
    ///                            <p>The specified destination (for example, an Amazon S3 bucket) was deleted.</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>Permissions don't allow sending logs to the destination.</p>
    ///                         </li>
    ///                      </ul>
    /// 					             </li>
    ///                </ul>
    /// 			         </li>
    ///          </ul>
    public let sortBy: String?
    /// <p>If you specified a value for <code>SortBy</code>, the order that you want query logging configurations to be listed in,
    /// 			<code>ASCENDING</code> or <code>DESCENDING</code>.</p>
    /// 		       <note>
    /// 			         <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigs</code> request and specify the <code>NextToken</code> parameter,
    /// 				you must use the same value for <code>SortOrder</code>, if any, as in the previous request.</p>
    /// 		       </note>
    public let sortOrder: SortOrder?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: String? = nil,
        sortOrder: SortOrder? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListResolverQueryLogConfigsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
    public let filters: [Filter]?
    public let sortBy: String?
    public let sortOrder: SortOrder?
}

extension ListResolverQueryLogConfigsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ListResolverQueryLogConfigsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolverQueryLogConfigsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolverQueryLogConfigsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolverQueryLogConfigsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolverQueryLogConfigsOutputResponse(nextToken: \(String(describing: nextToken)), resolverQueryLogConfigs: \(String(describing: resolverQueryLogConfigs)), totalCount: \(String(describing: totalCount)), totalFilteredCount: \(String(describing: totalFilteredCount)))"}
}

extension ListResolverQueryLogConfigsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResolverQueryLogConfigsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resolverQueryLogConfigs = output.resolverQueryLogConfigs
            self.totalCount = output.totalCount
            self.totalFilteredCount = output.totalFilteredCount
        } else {
            self.nextToken = nil
            self.resolverQueryLogConfigs = nil
            self.totalCount = 0
            self.totalFilteredCount = 0
        }
    }
}

public struct ListResolverQueryLogConfigsOutputResponse: Equatable {
    /// <p>If there are more than <code>MaxResults</code> query logging configurations, you can submit another <code>ListResolverQueryLogConfigs</code> request
    /// 			to get the next group of configurations. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
    public let nextToken: String?
    /// <p>A list that contains one <code>ResolverQueryLogConfig</code> element for each query logging configuration that matches the
    /// 			values that you specified for <code>Filter</code>.</p>
    public let resolverQueryLogConfigs: [ResolverQueryLogConfig]?
    /// <p>The total number of query logging configurations that were created by the current account in the specified Region. This count can differ from the
    /// 			number of query logging configurations that are returned in a <code>ListResolverQueryLogConfigs</code> response, depending on the values that you specify
    /// 			in the request.</p>
    public let totalCount: Int
    /// <p>The total number of query logging configurations that were created by the current account in the specified Region and that match the filters
    /// 			that were specified in the <code>ListResolverQueryLogConfigs</code> request. For the total number of query logging configurations that were created by the
    /// 			current account in the specified Region, see <code>TotalCount</code>.</p>
    public let totalFilteredCount: Int

    public init (
        nextToken: String? = nil,
        resolverQueryLogConfigs: [ResolverQueryLogConfig]? = nil,
        totalCount: Int = 0,
        totalFilteredCount: Int = 0
    )
    {
        self.nextToken = nextToken
        self.resolverQueryLogConfigs = resolverQueryLogConfigs
        self.totalCount = totalCount
        self.totalFilteredCount = totalFilteredCount
    }
}

struct ListResolverQueryLogConfigsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let totalCount: Int
    public let totalFilteredCount: Int
    public let resolverQueryLogConfigs: [ResolverQueryLogConfig]?
}

extension ListResolverQueryLogConfigsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resolverQueryLogConfigs = "ResolverQueryLogConfigs"
        case totalCount = "TotalCount"
        case totalFilteredCount = "TotalFilteredCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decode(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let totalFilteredCountDecoded = try containerValues.decode(Int.self, forKey: .totalFilteredCount)
        totalFilteredCount = totalFilteredCountDecoded
        let resolverQueryLogConfigsContainer = try containerValues.decodeIfPresent([ResolverQueryLogConfig?].self, forKey: .resolverQueryLogConfigs)
        var resolverQueryLogConfigsDecoded0:[ResolverQueryLogConfig]? = nil
        if let resolverQueryLogConfigsContainer = resolverQueryLogConfigsContainer {
            resolverQueryLogConfigsDecoded0 = [ResolverQueryLogConfig]()
            for structure0 in resolverQueryLogConfigsContainer {
                if let structure0 = structure0 {
                    resolverQueryLogConfigsDecoded0?.append(structure0)
                }
            }
        }
        resolverQueryLogConfigs = resolverQueryLogConfigsDecoded0
    }
}

public struct ListResolverRuleAssociationsInputBodyMiddleware: Middleware {
    public let id: String = "ListResolverRuleAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverRuleAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverRuleAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverRuleAssociationsInput>
    public typealias MOutput = OperationOutput<ListResolverRuleAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverRuleAssociationsOutputError>
}

extension ListResolverRuleAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolverRuleAssociationsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListResolverRuleAssociationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListResolverRuleAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListResolverRuleAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverRuleAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverRuleAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverRuleAssociationsInput>
    public typealias MOutput = OperationOutput<ListResolverRuleAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverRuleAssociationsOutputError>
}

public struct ListResolverRuleAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResolverRuleAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverRuleAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverRuleAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverRuleAssociationsInput>
    public typealias MOutput = OperationOutput<ListResolverRuleAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverRuleAssociationsOutputError>
}

public struct ListResolverRuleAssociationsInput: Equatable {
    /// <p>An optional specification to return a subset of Resolver rules, such as Resolver rules that are associated with the same VPC ID.</p>
    /// 		       <note>
    ///             <p>If you submit a second or subsequent <code>ListResolverRuleAssociations</code> request and specify the <code>NextToken</code> parameter,
    /// 			you must use the same values for <code>Filters</code>, if any, as in the previous request.</p>
    ///          </note>
    public let filters: [Filter]?
    /// <p>The maximum number of rule associations that you want to return in the response to a <code>ListResolverRuleAssociations</code> request.
    /// 			If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 rule associations. </p>
    public let maxResults: Int?
    /// <p>For the first <code>ListResolverRuleAssociation</code> request, omit this value.</p>
    /// 		       <p>If you have more than <code>MaxResults</code> rule associations, you can submit another <code>ListResolverRuleAssociation</code> request
    /// 			to get the next group of rule associations. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverRuleAssociationsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
    public let filters: [Filter]?
}

extension ListResolverRuleAssociationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListResolverRuleAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolverRuleAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolverRuleAssociationsOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolverRuleAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolverRuleAssociationsOutputResponse(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resolverRuleAssociations: \(String(describing: resolverRuleAssociations)))"}
}

extension ListResolverRuleAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResolverRuleAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.resolverRuleAssociations = output.resolverRuleAssociations
        } else {
            self.maxResults = nil
            self.nextToken = nil
            self.resolverRuleAssociations = nil
        }
    }
}

public struct ListResolverRuleAssociationsOutputResponse: Equatable {
    /// <p>The value that you specified for <code>MaxResults</code> in the request.</p>
    public let maxResults: Int?
    /// <p>If more than <code>MaxResults</code> rule associations match the specified criteria, you can submit another
    /// 			<code>ListResolverRuleAssociation</code> request to get the next group of results. In the next request, specify the value of
    /// 			<code>NextToken</code> from the previous response. </p>
    public let nextToken: String?
    /// <p>The associations that were created between Resolver rules and VPCs using the current AWS account, and that match the
    /// 			specified filters, if any.</p>
    public let resolverRuleAssociations: [ResolverRuleAssociation]?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resolverRuleAssociations: [ResolverRuleAssociation]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolverRuleAssociations = resolverRuleAssociations
    }
}

struct ListResolverRuleAssociationsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let resolverRuleAssociations: [ResolverRuleAssociation]?
}

extension ListResolverRuleAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resolverRuleAssociations = "ResolverRuleAssociations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resolverRuleAssociationsContainer = try containerValues.decodeIfPresent([ResolverRuleAssociation?].self, forKey: .resolverRuleAssociations)
        var resolverRuleAssociationsDecoded0:[ResolverRuleAssociation]? = nil
        if let resolverRuleAssociationsContainer = resolverRuleAssociationsContainer {
            resolverRuleAssociationsDecoded0 = [ResolverRuleAssociation]()
            for structure0 in resolverRuleAssociationsContainer {
                if let structure0 = structure0 {
                    resolverRuleAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resolverRuleAssociations = resolverRuleAssociationsDecoded0
    }
}

public struct ListResolverRulesInputBodyMiddleware: Middleware {
    public let id: String = "ListResolverRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverRulesInput>
    public typealias MOutput = OperationOutput<ListResolverRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverRulesOutputError>
}

extension ListResolverRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolverRulesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListResolverRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListResolverRulesInputHeadersMiddleware: Middleware {
    public let id: String = "ListResolverRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverRulesInput>
    public typealias MOutput = OperationOutput<ListResolverRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverRulesOutputError>
}

public struct ListResolverRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResolverRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolverRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolverRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolverRulesInput>
    public typealias MOutput = OperationOutput<ListResolverRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolverRulesOutputError>
}

public struct ListResolverRulesInput: Equatable {
    /// <p>An optional specification to return a subset of Resolver rules, such as all Resolver rules that are associated with the same Resolver endpoint.</p>
    /// 		       <note>
    ///             <p>If you submit a second or subsequent <code>ListResolverRules</code> request and specify the <code>NextToken</code> parameter,
    /// 			you must use the same values for <code>Filters</code>, if any, as in the previous request.</p>
    ///          </note>
    public let filters: [Filter]?
    /// <p>The maximum number of Resolver rules that you want to return in the response to a <code>ListResolverRules</code> request.
    /// 			If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 Resolver rules.</p>
    public let maxResults: Int?
    /// <p>For the first <code>ListResolverRules</code> request, omit this value.</p>
    /// 		       <p>If you have more than <code>MaxResults</code> Resolver rules, you can submit another <code>ListResolverRules</code> request
    /// 			to get the next group of Resolver rules. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverRulesInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
    public let filters: [Filter]?
}

extension ListResolverRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListResolverRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolverRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolverRulesOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolverRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolverRulesOutputResponse(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resolverRules: \(String(describing: resolverRules)))"}
}

extension ListResolverRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResolverRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.resolverRules = output.resolverRules
        } else {
            self.maxResults = nil
            self.nextToken = nil
            self.resolverRules = nil
        }
    }
}

public struct ListResolverRulesOutputResponse: Equatable {
    /// <p>The value that you specified for <code>MaxResults</code> in the request.</p>
    public let maxResults: Int?
    /// <p>If more than <code>MaxResults</code> Resolver rules match the specified criteria, you can submit another
    /// 			<code>ListResolverRules</code> request to get the next group of results. In the next request, specify the value of
    /// 			<code>NextToken</code> from the previous response. </p>
    public let nextToken: String?
    /// <p>The Resolver rules that were created using the current AWS account and that match the specified filters, if any.</p>
    public let resolverRules: [ResolverRule]?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resolverRules: [ResolverRule]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolverRules = resolverRules
    }
}

struct ListResolverRulesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let resolverRules: [ResolverRule]?
}

extension ListResolverRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resolverRules = "ResolverRules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resolverRulesContainer = try containerValues.decodeIfPresent([ResolverRule?].self, forKey: .resolverRules)
        var resolverRulesDecoded0:[ResolverRule]? = nil
        if let resolverRulesContainer = resolverRulesContainer {
            resolverRulesDecoded0 = [ResolverRule]()
            for structure0 in resolverRulesContainer {
                if let structure0 = structure0 {
                    resolverRulesDecoded0?.append(structure0)
                }
            }
        }
        resolverRules = resolverRulesDecoded0
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The maximum number of tags that you want to return in the response to a <code>ListTagsForResource</code> request.
    /// 			If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 tags.</p>
    public let maxResults: Int?
    /// <p>For the first <code>ListTagsForResource</code> request, omit this value.</p>
    /// 		       <p>If you have more than <code>MaxResults</code> tags, you can submit another <code>ListTagsForResource</code> request
    /// 			to get the next group of tags for the resource. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) for the resource that you want to list tags for.</p>
    public let resourceArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>If more than <code>MaxResults</code> tags match the specified criteria, you can submit another
    /// 			<code>ListTagsForResource</code> request to get the next group of results. In the next request, specify the value of
    /// 			<code>NextToken</code> from the previous response. </p>
    public let nextToken: String?
    /// <p>The tags that are associated with the resource that you specified in the <code>ListTagsForResource</code> request.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum MutationProtectionStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension MutationProtectionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MutationProtectionStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MutationProtectionStatus(rawValue: rawValue) ?? MutationProtectionStatus.sdkUnknown(rawValue)
    }
}

public struct PutFirewallRuleGroupPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutFirewallRuleGroupPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFirewallRuleGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFirewallRuleGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFirewallRuleGroupPolicyInput>
    public typealias MOutput = OperationOutput<PutFirewallRuleGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFirewallRuleGroupPolicyOutputError>
}

extension PutFirewallRuleGroupPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFirewallRuleGroupPolicyInput(arn: \(String(describing: arn)), firewallRuleGroupPolicy: \(String(describing: firewallRuleGroupPolicy)))"}
}

extension PutFirewallRuleGroupPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case firewallRuleGroupPolicy = "FirewallRuleGroupPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let firewallRuleGroupPolicy = firewallRuleGroupPolicy {
            try encodeContainer.encode(firewallRuleGroupPolicy, forKey: .firewallRuleGroupPolicy)
        }
    }
}

public struct PutFirewallRuleGroupPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutFirewallRuleGroupPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFirewallRuleGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFirewallRuleGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFirewallRuleGroupPolicyInput>
    public typealias MOutput = OperationOutput<PutFirewallRuleGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFirewallRuleGroupPolicyOutputError>
}

public struct PutFirewallRuleGroupPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutFirewallRuleGroupPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFirewallRuleGroupPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFirewallRuleGroupPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFirewallRuleGroupPolicyInput>
    public typealias MOutput = OperationOutput<PutFirewallRuleGroupPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFirewallRuleGroupPolicyOutputError>
}

public struct PutFirewallRuleGroupPolicyInput: Equatable {
    /// <p>The ARN (Amazon Resource Name) for the rule group that you want to share.</p>
    public let arn: String?
    /// <p>The AWS Identity and Access Management (AWS IAM) policy to attach to the rule group.</p>
    public let firewallRuleGroupPolicy: String?

    public init (
        arn: String? = nil,
        firewallRuleGroupPolicy: String? = nil
    )
    {
        self.arn = arn
        self.firewallRuleGroupPolicy = firewallRuleGroupPolicy
    }
}

struct PutFirewallRuleGroupPolicyInputBody: Equatable {
    public let arn: String?
    public let firewallRuleGroupPolicy: String?
}

extension PutFirewallRuleGroupPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case firewallRuleGroupPolicy = "FirewallRuleGroupPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let firewallRuleGroupPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallRuleGroupPolicy)
        firewallRuleGroupPolicy = firewallRuleGroupPolicyDecoded
    }
}

extension PutFirewallRuleGroupPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFirewallRuleGroupPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFirewallRuleGroupPolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFirewallRuleGroupPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFirewallRuleGroupPolicyOutputResponse(returnValue: \(String(describing: returnValue)))"}
}

extension PutFirewallRuleGroupPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutFirewallRuleGroupPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = false
        }
    }
}

public struct PutFirewallRuleGroupPolicyOutputResponse: Equatable {
    /// <p></p>
    public let returnValue: Bool

    public init (
        returnValue: Bool = false
    )
    {
        self.returnValue = returnValue
    }
}

struct PutFirewallRuleGroupPolicyOutputResponseBody: Equatable {
    public let returnValue: Bool
}

extension PutFirewallRuleGroupPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case returnValue = "ReturnValue"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decode(Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
    }
}

public struct PutResolverQueryLogConfigPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutResolverQueryLogConfigPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResolverQueryLogConfigPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResolverQueryLogConfigPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResolverQueryLogConfigPolicyInput>
    public typealias MOutput = OperationOutput<PutResolverQueryLogConfigPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResolverQueryLogConfigPolicyOutputError>
}

extension PutResolverQueryLogConfigPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResolverQueryLogConfigPolicyInput(arn: \(String(describing: arn)), resolverQueryLogConfigPolicy: \(String(describing: resolverQueryLogConfigPolicy)))"}
}

extension PutResolverQueryLogConfigPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case resolverQueryLogConfigPolicy = "ResolverQueryLogConfigPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let resolverQueryLogConfigPolicy = resolverQueryLogConfigPolicy {
            try encodeContainer.encode(resolverQueryLogConfigPolicy, forKey: .resolverQueryLogConfigPolicy)
        }
    }
}

public struct PutResolverQueryLogConfigPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutResolverQueryLogConfigPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResolverQueryLogConfigPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResolverQueryLogConfigPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResolverQueryLogConfigPolicyInput>
    public typealias MOutput = OperationOutput<PutResolverQueryLogConfigPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResolverQueryLogConfigPolicyOutputError>
}

public struct PutResolverQueryLogConfigPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutResolverQueryLogConfigPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResolverQueryLogConfigPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResolverQueryLogConfigPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResolverQueryLogConfigPolicyInput>
    public typealias MOutput = OperationOutput<PutResolverQueryLogConfigPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResolverQueryLogConfigPolicyOutputError>
}

public struct PutResolverQueryLogConfigPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the account that you want to share rules with.</p>
    public let arn: String?
    /// <p>An AWS Identity and Access Management policy statement that lists the query logging configurations that you want to share with another AWS account
    /// 			and the operations that you want the account to be able to perform. You can specify the following operations in the <code>Actions</code> section
    /// 			of the statement:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>route53resolver:AssociateResolverQueryLogConfig</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>route53resolver:DisassociateResolverQueryLogConfig</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>route53resolver:ListResolverQueryLogConfigAssociations</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>route53resolver:ListResolverQueryLogConfigs</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    /// 		
    /// 		       <p>In the <code>Resource</code> section of the statement, you specify the ARNs for the query logging configurations that you want to share
    /// 			with the account that you specified in <code>Arn</code>. </p>
    public let resolverQueryLogConfigPolicy: String?

    public init (
        arn: String? = nil,
        resolverQueryLogConfigPolicy: String? = nil
    )
    {
        self.arn = arn
        self.resolverQueryLogConfigPolicy = resolverQueryLogConfigPolicy
    }
}

struct PutResolverQueryLogConfigPolicyInputBody: Equatable {
    public let arn: String?
    public let resolverQueryLogConfigPolicy: String?
}

extension PutResolverQueryLogConfigPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case resolverQueryLogConfigPolicy = "ResolverQueryLogConfigPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let resolverQueryLogConfigPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverQueryLogConfigPolicy)
        resolverQueryLogConfigPolicy = resolverQueryLogConfigPolicyDecoded
    }
}

extension PutResolverQueryLogConfigPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResolverQueryLogConfigPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyDocument" : self = .invalidPolicyDocument(try InvalidPolicyDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResolverQueryLogConfigPolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidPolicyDocument(InvalidPolicyDocument)
    case invalidRequestException(InvalidRequestException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResolverQueryLogConfigPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResolverQueryLogConfigPolicyOutputResponse(returnValue: \(String(describing: returnValue)))"}
}

extension PutResolverQueryLogConfigPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutResolverQueryLogConfigPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = false
        }
    }
}

/// <p>The response to a <code>PutResolverQueryLogConfigPolicy</code> request.</p>
public struct PutResolverQueryLogConfigPolicyOutputResponse: Equatable {
    /// <p>Whether the <code>PutResolverQueryLogConfigPolicy</code> request was successful.</p>
    public let returnValue: Bool

    public init (
        returnValue: Bool = false
    )
    {
        self.returnValue = returnValue
    }
}

struct PutResolverQueryLogConfigPolicyOutputResponseBody: Equatable {
    public let returnValue: Bool
}

extension PutResolverQueryLogConfigPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case returnValue = "ReturnValue"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decode(Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
    }
}

public struct PutResolverRulePolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutResolverRulePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResolverRulePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResolverRulePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResolverRulePolicyInput>
    public typealias MOutput = OperationOutput<PutResolverRulePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResolverRulePolicyOutputError>
}

extension PutResolverRulePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResolverRulePolicyInput(arn: \(String(describing: arn)), resolverRulePolicy: \(String(describing: resolverRulePolicy)))"}
}

extension PutResolverRulePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case resolverRulePolicy = "ResolverRulePolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let resolverRulePolicy = resolverRulePolicy {
            try encodeContainer.encode(resolverRulePolicy, forKey: .resolverRulePolicy)
        }
    }
}

public struct PutResolverRulePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutResolverRulePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResolverRulePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResolverRulePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResolverRulePolicyInput>
    public typealias MOutput = OperationOutput<PutResolverRulePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResolverRulePolicyOutputError>
}

public struct PutResolverRulePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutResolverRulePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResolverRulePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResolverRulePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResolverRulePolicyInput>
    public typealias MOutput = OperationOutput<PutResolverRulePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResolverRulePolicyOutputError>
}

public struct PutResolverRulePolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the rule that you want to share with another account.</p>
    public let arn: String?
    /// <p>An AWS Identity and Access Management policy statement that lists the rules that you want to share with another AWS account and the operations that you want the account
    /// 			to be able to perform. You can specify the following operations in the <code>Action</code> section of the statement:</p>
    /// 			      <ul>
    ///             <li>
    ///                <p>
    ///                   <code>route53resolver:GetResolverRule</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>route53resolver:AssociateResolverRule</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>route53resolver:DisassociateResolverRule</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>route53resolver:ListResolverRules</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>route53resolver:ListResolverRuleAssociations</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    /// 		
    /// 		       <p>In the <code>Resource</code> section of the statement, specify the ARN for the rule that you want to share with another account. Specify the same ARN
    /// 			that you specified in <code>Arn</code>.</p>
    public let resolverRulePolicy: String?

    public init (
        arn: String? = nil,
        resolverRulePolicy: String? = nil
    )
    {
        self.arn = arn
        self.resolverRulePolicy = resolverRulePolicy
    }
}

struct PutResolverRulePolicyInputBody: Equatable {
    public let arn: String?
    public let resolverRulePolicy: String?
}

extension PutResolverRulePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case resolverRulePolicy = "ResolverRulePolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let resolverRulePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverRulePolicy)
        resolverRulePolicy = resolverRulePolicyDecoded
    }
}

extension PutResolverRulePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResolverRulePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyDocument" : self = .invalidPolicyDocument(try InvalidPolicyDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResolverRulePolicyOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidPolicyDocument(InvalidPolicyDocument)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResolverRulePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResolverRulePolicyOutputResponse(returnValue: \(String(describing: returnValue)))"}
}

extension PutResolverRulePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutResolverRulePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = false
        }
    }
}

/// <p>The response to a <code>PutResolverRulePolicy</code> request.</p>
public struct PutResolverRulePolicyOutputResponse: Equatable {
    /// <p>Whether the <code>PutResolverRulePolicy</code> request was successful.</p>
    public let returnValue: Bool

    public init (
        returnValue: Bool = false
    )
    {
        self.returnValue = returnValue
    }
}

struct PutResolverRulePolicyOutputResponseBody: Equatable {
    public let returnValue: Bool
}

extension PutResolverRulePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case returnValue = "ReturnValue"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decode(Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
    }
}

public enum ResolverDNSSECValidationStatus {
    case disabled
    case disabling
    case enabled
    case enabling
    case sdkUnknown(String)
}

extension ResolverDNSSECValidationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResolverDNSSECValidationStatus] {
        return [
            .disabled,
            .disabling,
            .enabled,
            .enabling,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .disabling: return "DISABLING"
        case .enabled: return "ENABLED"
        case .enabling: return "ENABLING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResolverDNSSECValidationStatus(rawValue: rawValue) ?? ResolverDNSSECValidationStatus.sdkUnknown(rawValue)
    }
}

extension ResolverDnssecConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case ownerId = "OwnerId"
        case resourceId = "ResourceId"
        case validationStatus = "ValidationStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let validationStatus = validationStatus {
            try encodeContainer.encode(validationStatus.rawValue, forKey: .validationStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let validationStatusDecoded = try containerValues.decodeIfPresent(ResolverDNSSECValidationStatus.self, forKey: .validationStatus)
        validationStatus = validationStatusDecoded
    }
}

extension ResolverDnssecConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolverDnssecConfig(id: \(String(describing: id)), ownerId: \(String(describing: ownerId)), resourceId: \(String(describing: resourceId)), validationStatus: \(String(describing: validationStatus)))"}
}

/// <p>A complex type that contains information about a configuration for DNSSEC validation.</p>
public struct ResolverDnssecConfig: Equatable {
    /// <p>The ID for a configuration for DNSSEC validation.</p>
    public let id: String?
    /// <p>The owner account ID of the virtual private cloud (VPC) for a configuration for DNSSEC validation.</p>
    public let ownerId: String?
    /// <p>The ID of the virtual private cloud (VPC) that you're configuring the DNSSEC validation status for.</p>
    public let resourceId: String?
    /// <p>The validation status for a DNSSEC configuration. The status can be one of the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <b>ENABLING:</b> DNSSEC validation is being enabled but is not complete.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>ENABLED:</b> DNSSEC validation is enabled.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>DISABLING:</b> DNSSEC validation is being disabled but is not complete.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>DISABLED</b> DNSSEC validation is disabled.</p>
    ///             </li>
    ///          </ul>
    public let validationStatus: ResolverDNSSECValidationStatus?

    public init (
        id: String? = nil,
        ownerId: String? = nil,
        resourceId: String? = nil,
        validationStatus: ResolverDNSSECValidationStatus? = nil
    )
    {
        self.id = id
        self.ownerId = ownerId
        self.resourceId = resourceId
        self.validationStatus = validationStatus
    }
}

extension ResolverEndpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case direction = "Direction"
        case hostVPCId = "HostVPCId"
        case id = "Id"
        case ipAddressCount = "IpAddressCount"
        case modificationTime = "ModificationTime"
        case name = "Name"
        case securityGroupIds = "SecurityGroupIds"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let direction = direction {
            try encodeContainer.encode(direction.rawValue, forKey: .direction)
        }
        if let hostVPCId = hostVPCId {
            try encodeContainer.encode(hostVPCId, forKey: .hostVPCId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ipAddressCount = ipAddressCount {
            try encodeContainer.encode(ipAddressCount, forKey: .ipAddressCount)
        }
        if let modificationTime = modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let directionDecoded = try containerValues.decodeIfPresent(ResolverEndpointDirection.self, forKey: .direction)
        direction = directionDecoded
        let ipAddressCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .ipAddressCount)
        ipAddressCount = ipAddressCountDecoded
        let hostVPCIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostVPCId)
        hostVPCId = hostVPCIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResolverEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension ResolverEndpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolverEndpoint(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), creatorRequestId: \(String(describing: creatorRequestId)), direction: \(String(describing: direction)), hostVPCId: \(String(describing: hostVPCId)), id: \(String(describing: id)), ipAddressCount: \(String(describing: ipAddressCount)), modificationTime: \(String(describing: modificationTime)), name: \(String(describing: name)), securityGroupIds: \(String(describing: securityGroupIds)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

/// <p>In the response to a
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html">CreateResolverEndpoint</a>,
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverEndpoint.html">DeleteResolverEndpoint</a>,
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html">GetResolverEndpoint</a>,
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html">ListResolverEndpoints</a>,
/// 			or
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverEndpoint.html">UpdateResolverEndpoint</a>
/// 			request, a complex type that contains settings for an existing inbound or outbound Resolver endpoint.</p>
public struct ResolverEndpoint: Equatable {
    /// <p>The ARN (Amazon Resource Name) for the Resolver endpoint.</p>
    public let arn: String?
    /// <p>The date and time that the endpoint was created, in Unix time format and Coordinated Universal Time (UTC).</p>
    public let creationTime: String?
    /// <p>A unique string that identifies the request that created the Resolver endpoint. The
    /// 				<code>CreatorRequestId</code> allows failed requests to be retried without the risk
    /// 			of running the operation twice.</p>
    public let creatorRequestId: String?
    /// <p>Indicates whether the Resolver endpoint allows inbound or outbound DNS queries:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>INBOUND</code>: allows DNS queries to your VPC from your network</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OUTBOUND</code>: allows DNS queries from your VPC to your network</p>
    ///             </li>
    ///          </ul>
    public let direction: ResolverEndpointDirection?
    /// <p>The ID of the VPC that you want to create the Resolver endpoint in.</p>
    public let hostVPCId: String?
    /// <p>The ID of the Resolver endpoint.</p>
    public let id: String?
    /// <p>The number of IP addresses that the Resolver endpoint can use for DNS queries.</p>
    public let ipAddressCount: Int?
    /// <p>The date and time that the endpoint was last modified, in Unix time format and Coordinated Universal Time (UTC).</p>
    public let modificationTime: String?
    /// <p>The name that you assigned to the Resolver endpoint when you submitted a
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html">CreateResolverEndpoint</a>
    /// 			request.</p>
    public let name: String?
    /// <p>The ID of one or more security groups that control access to this VPC. The security group must include one or more inbound rules
    /// 			(for inbound endpoints) or outbound rules (for outbound endpoints). Inbound and outbound rules must allow TCP and UDP access.
    /// 			For inbound access, open port 53. For outbound access, open the port that you're using for DNS queries on your network.</p>
    public let securityGroupIds: [String]?
    /// <p>A code that specifies the current status of the Resolver endpoint. Valid values include the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATING</code>: Resolver is creating and configuring one or more Amazon VPC network interfaces
    /// 				for this endpoint.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OPERATIONAL</code>: The Amazon VPC network interfaces for this endpoint are correctly configured and
    /// 				able to pass inbound or outbound DNS queries between your network and Resolver.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATING</code>: Resolver is associating or disassociating one or more network interfaces
    /// 				with this endpoint.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AUTO_RECOVERING</code>: Resolver is trying to recover one or more of the network interfaces
    /// 				that are associated with this endpoint. During the recovery process, the endpoint functions with limited capacity because of the
    /// 				limit on the number of DNS queries per IP address (per network interface). For the current limit, see
    /// 				<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html#limits-api-entities-resolver">Limits on Route 53 Resolver</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTION_NEEDED</code>: This endpoint is unhealthy, and Resolver can't automatically recover it.
    /// 				To resolve the problem, we recommend that you check each IP address that you associated with the endpoint. For each IP address
    /// 				that isn't available, add another IP address and then delete the IP address that isn't available. (An endpoint must always include
    /// 				at least two IP addresses.) A status of <code>ACTION_NEEDED</code> can have a variety of causes. Here are two common causes:</p>
    /// 				           <ul>
    ///                   <li>
    ///                      <p>One or more of the network interfaces that are associated with the endpoint were deleted using Amazon VPC.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>The network interface couldn't be created for some reason that's outside the control of Resolver.</p>
    ///                   </li>
    ///                </ul>
    /// 			         </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETING</code>: Resolver is deleting this endpoint and the associated network interfaces.</p>
    ///             </li>
    ///          </ul>
    public let status: ResolverEndpointStatus?
    /// <p>A detailed description of the status of the Resolver endpoint.</p>
    public let statusMessage: String?

    public init (
        arn: String? = nil,
        creationTime: String? = nil,
        creatorRequestId: String? = nil,
        direction: ResolverEndpointDirection? = nil,
        hostVPCId: String? = nil,
        id: String? = nil,
        ipAddressCount: Int? = nil,
        modificationTime: String? = nil,
        name: String? = nil,
        securityGroupIds: [String]? = nil,
        status: ResolverEndpointStatus? = nil,
        statusMessage: String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.creatorRequestId = creatorRequestId
        self.direction = direction
        self.hostVPCId = hostVPCId
        self.id = id
        self.ipAddressCount = ipAddressCount
        self.modificationTime = modificationTime
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.status = status
        self.statusMessage = statusMessage
    }
}

public enum ResolverEndpointDirection {
    case inbound
    case outbound
    case sdkUnknown(String)
}

extension ResolverEndpointDirection : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResolverEndpointDirection] {
        return [
            .inbound,
            .outbound,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .inbound: return "INBOUND"
        case .outbound: return "OUTBOUND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResolverEndpointDirection(rawValue: rawValue) ?? ResolverEndpointDirection.sdkUnknown(rawValue)
    }
}

public enum ResolverEndpointStatus {
    case actionneeded
    case autorecovering
    case creating
    case deleting
    case operational
    case updating
    case sdkUnknown(String)
}

extension ResolverEndpointStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResolverEndpointStatus] {
        return [
            .actionneeded,
            .autorecovering,
            .creating,
            .deleting,
            .operational,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .actionneeded: return "ACTION_NEEDED"
        case .autorecovering: return "AUTO_RECOVERING"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .operational: return "OPERATIONAL"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResolverEndpointStatus(rawValue: rawValue) ?? ResolverEndpointStatus.sdkUnknown(rawValue)
    }
}

extension ResolverQueryLogConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case associationCount = "AssociationCount"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case destinationArn = "DestinationArn"
        case id = "Id"
        case name = "Name"
        case ownerId = "OwnerId"
        case shareStatus = "ShareStatus"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if associationCount != 0 {
            try encodeContainer.encode(associationCount, forKey: .associationCount)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let destinationArn = destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let shareStatus = shareStatus {
            try encodeContainer.encode(shareStatus.rawValue, forKey: .shareStatus)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResolverQueryLogConfigStatus.self, forKey: .status)
        status = statusDecoded
        let shareStatusDecoded = try containerValues.decodeIfPresent(ShareStatus.self, forKey: .shareStatus)
        shareStatus = shareStatusDecoded
        let associationCountDecoded = try containerValues.decode(Int.self, forKey: .associationCount)
        associationCount = associationCountDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension ResolverQueryLogConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolverQueryLogConfig(arn: \(String(describing: arn)), associationCount: \(String(describing: associationCount)), creationTime: \(String(describing: creationTime)), creatorRequestId: \(String(describing: creatorRequestId)), destinationArn: \(String(describing: destinationArn)), id: \(String(describing: id)), name: \(String(describing: name)), ownerId: \(String(describing: ownerId)), shareStatus: \(String(describing: shareStatus)), status: \(String(describing: status)))"}
}

/// <p>In the response to a
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverQueryLogConfig.html">CreateResolverQueryLogConfig</a>,
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverQueryLogConfig.html">DeleteResolverQueryLogConfig</a>,
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverQueryLogConfig.html">GetResolverQueryLogConfig</a>,
/// 			or
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigs.html">ListResolverQueryLogConfigs</a>
/// 			request, a complex type that contains settings for one query logging configuration.</p>
public struct ResolverQueryLogConfig: Equatable {
    /// <p>The ARN for the query logging configuration.</p>
    public let arn: String?
    /// <p>The number of VPCs that are associated with the query logging configuration.</p>
    public let associationCount: Int
    /// <p>The date and time that the query logging configuration was created, in Unix time format and Coordinated Universal Time (UTC).</p>
    public let creationTime: String?
    /// <p>A unique string that identifies the request that created the query logging configuration.
    /// 			The <code>CreatorRequestId</code> allows failed requests to be retried without the risk
    /// 			of running the operation twice.</p>
    public let creatorRequestId: String?
    /// <p>The ARN of the resource that you want Resolver to send query logs: an Amazon S3 bucket, a CloudWatch Logs log group, or
    /// 			a Kinesis Data Firehose delivery stream.</p>
    public let destinationArn: String?
    /// <p>The ID for the query logging configuration.</p>
    public let id: String?
    /// <p>The name of the query logging configuration. </p>
    public let name: String?
    /// <p>The AWS account ID for the account that created the query logging configuration. </p>
    public let ownerId: String?
    /// <p>An indication of whether the query logging configuration is shared with other AWS accounts, or was shared with the current account by another
    /// 			AWS account. Sharing is configured through AWS Resource Access Manager (AWS RAM).</p>
    public let shareStatus: ShareStatus?
    /// <p>The status of the specified query logging configuration. Valid values include the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATING</code>: Resolver is creating the query logging configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATED</code>: The query logging configuration was successfully created.
    /// 				Resolver is logging queries that originate in the specified VPC.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETING</code>: Resolver is deleting this query logging configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code>: Resolver can't deliver logs to the location that is specified in the query logging configuration.
    /// 				Here are two common causes:</p>
    /// 				           <ul>
    ///                   <li>
    ///                      <p>The specified destination (for example, an Amazon S3 bucket) was deleted.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Permissions don't allow sending logs to the destination.</p>
    ///                   </li>
    ///                </ul>
    /// 			         </li>
    ///          </ul>
    public let status: ResolverQueryLogConfigStatus?

    public init (
        arn: String? = nil,
        associationCount: Int = 0,
        creationTime: String? = nil,
        creatorRequestId: String? = nil,
        destinationArn: String? = nil,
        id: String? = nil,
        name: String? = nil,
        ownerId: String? = nil,
        shareStatus: ShareStatus? = nil,
        status: ResolverQueryLogConfigStatus? = nil
    )
    {
        self.arn = arn
        self.associationCount = associationCount
        self.creationTime = creationTime
        self.creatorRequestId = creatorRequestId
        self.destinationArn = destinationArn
        self.id = id
        self.name = name
        self.ownerId = ownerId
        self.shareStatus = shareStatus
        self.status = status
    }
}

extension ResolverQueryLogConfigAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case error = "Error"
        case errorMessage = "ErrorMessage"
        case id = "Id"
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
        case resourceId = "ResourceId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let error = error {
            try encodeContainer.encode(error.rawValue, forKey: .error)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let resolverQueryLogConfigId = resolverQueryLogConfigId {
            try encodeContainer.encode(resolverQueryLogConfigId, forKey: .resolverQueryLogConfigId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let resolverQueryLogConfigIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverQueryLogConfigId)
        resolverQueryLogConfigId = resolverQueryLogConfigIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResolverQueryLogConfigAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let errorDecoded = try containerValues.decodeIfPresent(ResolverQueryLogConfigAssociationError.self, forKey: .error)
        error = errorDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension ResolverQueryLogConfigAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolverQueryLogConfigAssociation(creationTime: \(String(describing: creationTime)), error: \(String(describing: error)), errorMessage: \(String(describing: errorMessage)), id: \(String(describing: id)), resolverQueryLogConfigId: \(String(describing: resolverQueryLogConfigId)), resourceId: \(String(describing: resourceId)), status: \(String(describing: status)))"}
}

/// <p>In the response to an
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverQueryLogConfig.html">AssociateResolverQueryLogConfig</a>,
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverQueryLogConfig.html">DisassociateResolverQueryLogConfig</a>,
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverQueryLogConfigAssociation.html">GetResolverQueryLogConfigAssociation</a>,
/// 			or
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigAssociations.html">ListResolverQueryLogConfigAssociations</a>,
/// 			request, a complex type that contains settings for a specified association between an Amazon VPC and a query logging configuration.</p>
public struct ResolverQueryLogConfigAssociation: Equatable {
    /// <p>The date and time that the VPC was associated with the query logging configuration, in Unix time format and Coordinated Universal Time (UTC).</p>
    public let creationTime: String?
    /// <p>If the value of <code>Status</code> is <code>FAILED</code>, the value of <code>Error</code> indicates the cause:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DESTINATION_NOT_FOUND</code>: The specified destination (for example, an Amazon S3 bucket) was deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACCESS_DENIED</code>: Permissions don't allow sending logs to the destination.</p>
    ///             </li>
    ///          </ul>
    /// 		       <p>If the value of <code>Status</code> is a value other than <code>FAILED</code>, <code>Error</code> is null. </p>
    public let error: ResolverQueryLogConfigAssociationError?
    /// <p>Contains additional information about the error. If the value or <code>Error</code> is null, the value of <code>ErrorMessage</code> also is null.</p>
    public let errorMessage: String?
    /// <p>The ID of the query logging association.</p>
    public let id: String?
    /// <p>The ID of the query logging configuration that a VPC is associated with.</p>
    public let resolverQueryLogConfigId: String?
    /// <p>The ID of the Amazon VPC that is associated with the query logging configuration.</p>
    public let resourceId: String?
    /// <p>The status of the specified query logging association. Valid values include the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATING</code>: Resolver is creating an association between an Amazon VPC and a query logging configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATED</code>: The association between an Amazon VPC and a query logging configuration
    /// 				was successfully created. Resolver is logging queries that originate in the specified VPC.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETING</code>: Resolver is deleting this query logging association.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code>: Resolver either couldn't create or couldn't delete the query logging association.</p>
    ///             </li>
    ///          </ul>
    public let status: ResolverQueryLogConfigAssociationStatus?

    public init (
        creationTime: String? = nil,
        error: ResolverQueryLogConfigAssociationError? = nil,
        errorMessage: String? = nil,
        id: String? = nil,
        resolverQueryLogConfigId: String? = nil,
        resourceId: String? = nil,
        status: ResolverQueryLogConfigAssociationStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.error = error
        self.errorMessage = errorMessage
        self.id = id
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
        self.resourceId = resourceId
        self.status = status
    }
}

public enum ResolverQueryLogConfigAssociationError {
    case accessdenied
    case destinationnotfound
    case internalserviceerror
    case `none`
    case sdkUnknown(String)
}

extension ResolverQueryLogConfigAssociationError : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResolverQueryLogConfigAssociationError] {
        return [
            .accessdenied,
            .destinationnotfound,
            .internalserviceerror,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessdenied: return "ACCESS_DENIED"
        case .destinationnotfound: return "DESTINATION_NOT_FOUND"
        case .internalserviceerror: return "INTERNAL_SERVICE_ERROR"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResolverQueryLogConfigAssociationError(rawValue: rawValue) ?? ResolverQueryLogConfigAssociationError.sdkUnknown(rawValue)
    }
}

public enum ResolverQueryLogConfigAssociationStatus {
    case actionneeded
    case active
    case creating
    case deleting
    case failed
    case sdkUnknown(String)
}

extension ResolverQueryLogConfigAssociationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResolverQueryLogConfigAssociationStatus] {
        return [
            .actionneeded,
            .active,
            .creating,
            .deleting,
            .failed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .actionneeded: return "ACTION_NEEDED"
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResolverQueryLogConfigAssociationStatus(rawValue: rawValue) ?? ResolverQueryLogConfigAssociationStatus.sdkUnknown(rawValue)
    }
}

public enum ResolverQueryLogConfigStatus {
    case created
    case creating
    case deleting
    case failed
    case sdkUnknown(String)
}

extension ResolverQueryLogConfigStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResolverQueryLogConfigStatus] {
        return [
            .created,
            .creating,
            .deleting,
            .failed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .created: return "CREATED"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResolverQueryLogConfigStatus(rawValue: rawValue) ?? ResolverQueryLogConfigStatus.sdkUnknown(rawValue)
    }
}

extension ResolverRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case domainName = "DomainName"
        case id = "Id"
        case modificationTime = "ModificationTime"
        case name = "Name"
        case ownerId = "OwnerId"
        case resolverEndpointId = "ResolverEndpointId"
        case ruleType = "RuleType"
        case shareStatus = "ShareStatus"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case targetIps = "TargetIps"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modificationTime = modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
        if let ruleType = ruleType {
            try encodeContainer.encode(ruleType.rawValue, forKey: .ruleType)
        }
        if let shareStatus = shareStatus {
            try encodeContainer.encode(shareStatus.rawValue, forKey: .shareStatus)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let targetIps = targetIps {
            var targetIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetIps)
            for targetlist0 in targetIps {
                try targetIpsContainer.encode(targetlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResolverRuleStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let ruleTypeDecoded = try containerValues.decodeIfPresent(RuleTypeOption.self, forKey: .ruleType)
        ruleType = ruleTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let targetIpsContainer = try containerValues.decodeIfPresent([TargetAddress?].self, forKey: .targetIps)
        var targetIpsDecoded0:[TargetAddress]? = nil
        if let targetIpsContainer = targetIpsContainer {
            targetIpsDecoded0 = [TargetAddress]()
            for structure0 in targetIpsContainer {
                if let structure0 = structure0 {
                    targetIpsDecoded0?.append(structure0)
                }
            }
        }
        targetIps = targetIpsDecoded0
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let shareStatusDecoded = try containerValues.decodeIfPresent(ShareStatus.self, forKey: .shareStatus)
        shareStatus = shareStatusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension ResolverRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolverRule(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), creatorRequestId: \(String(describing: creatorRequestId)), domainName: \(String(describing: domainName)), id: \(String(describing: id)), modificationTime: \(String(describing: modificationTime)), name: \(String(describing: name)), ownerId: \(String(describing: ownerId)), resolverEndpointId: \(String(describing: resolverEndpointId)), ruleType: \(String(describing: ruleType)), shareStatus: \(String(describing: shareStatus)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), targetIps: \(String(describing: targetIps)))"}
}

/// <p>For queries that originate in your VPC, detailed information about a Resolver rule, which specifies how to route DNS queries
/// 			out of the VPC. The <code>ResolverRule</code> parameter appears in the response to a
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html">CreateResolverRule</a>,
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverRule.html">DeleteResolverRule</a>,
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html">GetResolverRule</a>,
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html">ListResolverRules</a>,
/// 			or
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverRule.html">UpdateResolverRule</a> request.</p>
public struct ResolverRule: Equatable {
    /// <p>The ARN (Amazon Resource Name) for the Resolver rule specified by <code>Id</code>.</p>
    public let arn: String?
    /// <p>The date and time that the Resolver rule was created, in Unix time format and Coordinated Universal Time (UTC).</p>
    public let creationTime: String?
    /// <p>A unique string that you specified when you created the Resolver rule.
    /// 				<code>CreatorRequestId</code> identifies the request and allows failed requests to
    /// 			be retried without the risk of running the operation twice. </p>
    public let creatorRequestId: String?
    /// <p>DNS queries for this domain name are forwarded to the IP addresses that are specified in <code>TargetIps</code>. If a query matches
    /// 			multiple Resolver rules (example.com and www.example.com), the query is routed using the Resolver rule that contains the most specific domain name
    /// 			(www.example.com).</p>
    public let domainName: String?
    /// <p>The ID that Resolver assigned to the Resolver rule when you created it.</p>
    public let id: String?
    /// <p>The date and time that the Resolver rule was last updated, in Unix time format and Coordinated Universal Time (UTC).</p>
    public let modificationTime: String?
    /// <p>The name for the Resolver rule, which you specified when you created the Resolver rule.</p>
    public let name: String?
    /// <p>When a rule is shared with another AWS account, the account ID of the account that the rule is shared with.</p>
    public let ownerId: String?
    /// <p>The ID of the endpoint that the rule is associated with.</p>
    public let resolverEndpointId: String?
    /// <p>When you want to forward DNS queries for specified domain name to resolvers on your network, specify <code>FORWARD</code>.</p>
    /// 		       <p>When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for
    /// 			a subdomain of that domain, specify <code>SYSTEM</code>.</p>
    /// 		       <p>For example, to forward DNS queries for example.com to resolvers on your network, you create a rule and specify <code>FORWARD</code>
    /// 			for <code>RuleType</code>. To then have Resolver process queries for apex.example.com, you create a rule and specify
    /// 			<code>SYSTEM</code> for <code>RuleType</code>.</p>
    /// 		       <p>Currently, only Resolver can create rules that have a value of <code>RECURSIVE</code> for <code>RuleType</code>.</p>
    public let ruleType: RuleTypeOption?
    /// <p>Whether the rule is shared and, if so, whether the current account is sharing the rule with
    /// 			another account, or another account is sharing the rule with the current account.</p>
    public let shareStatus: ShareStatus?
    /// <p>A code that specifies the current status of the Resolver rule.</p>
    public let status: ResolverRuleStatus?
    /// <p>A detailed description of the status of a Resolver rule.</p>
    public let statusMessage: String?
    /// <p>An array that contains the IP addresses and ports that an outbound endpoint forwards DNS queries to. Typically,
    /// 			these are the IP addresses of DNS resolvers on your network. Specify IPv4 addresses. IPv6 is not supported.</p>
    public let targetIps: [TargetAddress]?

    public init (
        arn: String? = nil,
        creationTime: String? = nil,
        creatorRequestId: String? = nil,
        domainName: String? = nil,
        id: String? = nil,
        modificationTime: String? = nil,
        name: String? = nil,
        ownerId: String? = nil,
        resolverEndpointId: String? = nil,
        ruleType: RuleTypeOption? = nil,
        shareStatus: ShareStatus? = nil,
        status: ResolverRuleStatus? = nil,
        statusMessage: String? = nil,
        targetIps: [TargetAddress]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.creatorRequestId = creatorRequestId
        self.domainName = domainName
        self.id = id
        self.modificationTime = modificationTime
        self.name = name
        self.ownerId = ownerId
        self.resolverEndpointId = resolverEndpointId
        self.ruleType = ruleType
        self.shareStatus = shareStatus
        self.status = status
        self.statusMessage = statusMessage
        self.targetIps = targetIps
    }
}

extension ResolverRuleAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
        case resolverRuleId = "ResolverRuleId"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case vPCId = "VPCId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolverRuleId = resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let vPCId = vPCId {
            try encodeContainer.encode(vPCId, forKey: .vPCId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let vPCIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vPCId)
        vPCId = vPCIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResolverRuleAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ResolverRuleAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolverRuleAssociation(id: \(String(describing: id)), name: \(String(describing: name)), resolverRuleId: \(String(describing: resolverRuleId)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), vPCId: \(String(describing: vPCId)))"}
}

/// <p>In the response to an
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverRule.html">AssociateResolverRule</a>,
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverRule.html">DisassociateResolverRule</a>,
/// 			or
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html">ListResolverRuleAssociations</a>
/// 			request, provides information about an association between a Resolver rule and a VPC.
/// 			The association determines which DNS queries that originate in the VPC are forwarded to your network. </p>
public struct ResolverRuleAssociation: Equatable {
    /// <p>The ID of the association between a Resolver rule and a VPC. Resolver assigns this value when you submit an
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverRule.html">AssociateResolverRule</a>
    /// 			request.</p>
    public let id: String?
    /// <p>The name of an association between a Resolver rule and a VPC.</p>
    public let name: String?
    /// <p>The ID of the Resolver rule that you associated with the VPC that is specified by <code>VPCId</code>.</p>
    public let resolverRuleId: String?
    /// <p>A code that specifies the current status of the association between a Resolver rule and a VPC.</p>
    public let status: ResolverRuleAssociationStatus?
    /// <p>A detailed description of the status of the association between a Resolver rule and a VPC.</p>
    public let statusMessage: String?
    /// <p>The ID of the VPC that you associated the Resolver rule with.</p>
    public let vPCId: String?

    public init (
        id: String? = nil,
        name: String? = nil,
        resolverRuleId: String? = nil,
        status: ResolverRuleAssociationStatus? = nil,
        statusMessage: String? = nil,
        vPCId: String? = nil
    )
    {
        self.id = id
        self.name = name
        self.resolverRuleId = resolverRuleId
        self.status = status
        self.statusMessage = statusMessage
        self.vPCId = vPCId
    }
}

public enum ResolverRuleAssociationStatus {
    case complete
    case creating
    case deleting
    case failed
    case overridden
    case sdkUnknown(String)
}

extension ResolverRuleAssociationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResolverRuleAssociationStatus] {
        return [
            .complete,
            .creating,
            .deleting,
            .failed,
            .overridden,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "COMPLETE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .overridden: return "OVERRIDDEN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResolverRuleAssociationStatus(rawValue: rawValue) ?? ResolverRuleAssociationStatus.sdkUnknown(rawValue)
    }
}

extension ResolverRuleConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case resolverEndpointId = "ResolverEndpointId"
        case targetIps = "TargetIps"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
        if let targetIps = targetIps {
            var targetIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetIps)
            for targetlist0 in targetIps {
                try targetIpsContainer.encode(targetlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let targetIpsContainer = try containerValues.decodeIfPresent([TargetAddress?].self, forKey: .targetIps)
        var targetIpsDecoded0:[TargetAddress]? = nil
        if let targetIpsContainer = targetIpsContainer {
            targetIpsDecoded0 = [TargetAddress]()
            for structure0 in targetIpsContainer {
                if let structure0 = structure0 {
                    targetIpsDecoded0?.append(structure0)
                }
            }
        }
        targetIps = targetIpsDecoded0
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
    }
}

extension ResolverRuleConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolverRuleConfig(name: \(String(describing: name)), resolverEndpointId: \(String(describing: resolverEndpointId)), targetIps: \(String(describing: targetIps)))"}
}

/// <p>In an
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverRule.html">UpdateResolverRule</a>
/// 			request, information about the changes that you want to make.</p>
public struct ResolverRuleConfig: Equatable {
    /// <p>The new name for the Resolver rule. The name that you specify appears in the Resolver dashboard in the Route 53 console. </p>
    public let name: String?
    /// <p>The ID of the new outbound Resolver endpoint that you want to use to route DNS queries to the IP addresses that you specify in
    /// 			<code>TargetIps</code>.</p>
    public let resolverEndpointId: String?
    /// <p>For DNS queries that originate in your VPC, the new IP addresses that you want to route outbound DNS queries to.</p>
    public let targetIps: [TargetAddress]?

    public init (
        name: String? = nil,
        resolverEndpointId: String? = nil,
        targetIps: [TargetAddress]? = nil
    )
    {
        self.name = name
        self.resolverEndpointId = resolverEndpointId
        self.targetIps = targetIps
    }
}

public enum ResolverRuleStatus {
    case complete
    case deleting
    case failed
    case updating
    case sdkUnknown(String)
}

extension ResolverRuleStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResolverRuleStatus] {
        return [
            .complete,
            .deleting,
            .failed,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "COMPLETE"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResolverRuleStatus(rawValue: rawValue) ?? ResolverRuleStatus.sdkUnknown(rawValue)
    }
}

extension ResourceExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceExistsException(message: \(String(describing: message)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource that you tried to create already exists.</p>
public struct ResourceExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>For a <code>ResourceExistsException</code> error, the type of resource that the error applies to.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct ResourceExistsExceptionBody: Equatable {
    public let message: String?
    public let resourceType: String?
}

extension ResourceExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource that you tried to update or delete is currently in use.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>For a <code>ResourceInUseException</code> error, the type of resource that is currently in use.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
    public let resourceType: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource doesn't exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>For a <code>ResourceNotFoundException</code> error, the type of resource that doesn't exist.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceType: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceUnavailableException(message: \(String(describing: message)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource isn't available.</p>
public struct ResourceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>For a <code>ResourceUnavailableException</code> error, the type of resource that isn't available.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct ResourceUnavailableExceptionBody: Equatable {
    public let message: String?
    public let resourceType: String?
}

extension ResourceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public enum RuleTypeOption {
    case forward
    case recursive
    case system
    case sdkUnknown(String)
}

extension RuleTypeOption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RuleTypeOption] {
        return [
            .forward,
            .recursive,
            .system,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .forward: return "FORWARD"
        case .recursive: return "RECURSIVE"
        case .system: return "SYSTEM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RuleTypeOption(rawValue: rawValue) ?? RuleTypeOption.sdkUnknown(rawValue)
    }
}

public enum ShareStatus {
    case notshared
    case sharedbyme
    case sharedwithme
    case sdkUnknown(String)
}

extension ShareStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ShareStatus] {
        return [
            .notshared,
            .sharedbyme,
            .sharedwithme,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .notshared: return "NOT_SHARED"
        case .sharedbyme: return "SHARED_BY_ME"
        case .sharedwithme: return "SHARED_WITH_ME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ShareStatus(rawValue: rawValue) ?? ShareStatus.sdkUnknown(rawValue)
    }
}

public enum SortOrder {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension SortOrder : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortOrder] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "ASCENDING"
        case .descending: return "DESCENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>One tag that you want to add to the specified resource. A tag consists of a <code>Key</code> (a name for the tag) and a <code>Value</code>.</p>
public struct Tag: Equatable {
    /// <p>The name for the tag. For example, if you want to associate Resolver resources with the account IDs of your customers for billing purposes,
    /// 			the value of <code>Key</code> might be <code>account-id</code>.</p>
    public let key: String?
    /// <p>The value for the tag. For example, if <code>Key</code> is <code>account-id</code>, then <code>Value</code> might be the ID of the
    /// 			customer account that you're creating the resource for.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the resource that you want to add tags to. To get the ARN for a resource, use the applicable
    /// 			<code>Get</code> or <code>List</code> command: </p>
    /// 			      <ul>
    ///             <li>
    /// 					          <p>
    ///                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html">GetResolverEndpoint</a>
    ///                </p>
    /// 				        </li>
    ///             <li>
    /// 					          <p>
    ///                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html">GetResolverRule</a>
    ///                </p>
    /// 				        </li>
    ///             <li>
    /// 					          <p>
    ///                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRuleAssociation.html">GetResolverRuleAssociation</a>
    ///                </p>
    /// 				        </li>
    ///             <li>
    /// 					          <p>
    ///                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html">ListResolverEndpoints</a>
    ///                </p>
    /// 				        </li>
    ///             <li>
    /// 					          <p>
    ///                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html">ListResolverRuleAssociations</a>
    ///                </p>
    /// 				        </li>
    ///             <li>
    /// 					          <p>
    ///                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html">ListResolverRules</a>
    ///                </p>
    /// 				        </li>
    ///          </ul>
    public let resourceArn: String?
    /// <p>The tags that you want to add to the specified resource.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagException" : self = .invalidTagException(try InvalidTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case invalidTagException(InvalidTagException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TargetAddress: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ip = "Ip"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ip = ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ip)
        ip = ipDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
    }
}

extension TargetAddress: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetAddress(ip: \(String(describing: ip)), port: \(String(describing: port)))"}
}

/// <p>In a
/// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html">CreateResolverRule</a>
/// 			request, an array of the IPs that you want to forward DNS queries to.</p>
public struct TargetAddress: Equatable {
    /// <p>One IP address that you want to forward DNS queries to. You can specify only IPv4 addresses.</p>
    public let ip: String?
    /// <p>The port at <code>Ip</code> that you want to forward DNS queries to.</p>
    public let port: Int?

    public init (
        ip: String? = nil,
        port: Int? = nil
    )
    {
        self.ip = ip
        self.port = port
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was throttled. Try again in a few minutes.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnknownResourceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnknownResourceException(message: \(String(describing: message)))"}
}

extension UnknownResourceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnknownResourceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource doesn't exist.</p>
public struct UnknownResourceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnknownResourceExceptionBody: Equatable {
    public let message: String?
}

extension UnknownResourceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the resource that you want to remove tags from. To get the ARN for a resource, use the applicable
    /// 			<code>Get</code> or <code>List</code> command: </p>
    /// 			      <ul>
    ///             <li>
    /// 					          <p>
    ///                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html">GetResolverEndpoint</a>
    ///                </p>
    /// 				        </li>
    ///             <li>
    /// 					          <p>
    ///                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html">GetResolverRule</a>
    ///                </p>
    /// 				        </li>
    ///             <li>
    /// 					          <p>
    ///                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRuleAssociation.html">GetResolverRuleAssociation</a>
    ///                </p>
    /// 				        </li>
    ///             <li>
    /// 					          <p>
    ///                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html">ListResolverEndpoints</a>
    ///                </p>
    /// 				        </li>
    ///             <li>
    /// 					          <p>
    ///                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html">ListResolverRuleAssociations</a>
    ///                </p>
    /// 				        </li>
    ///             <li>
    /// 					          <p>
    ///                   <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html">ListResolverRules</a>
    ///                </p>
    /// 				        </li>
    ///          </ul>
    public let resourceArn: String?
    /// <p>The tags that you want to remove to the specified resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateFirewallConfigInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFirewallConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallConfigInput>
    public typealias MOutput = OperationOutput<UpdateFirewallConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallConfigOutputError>
}

extension UpdateFirewallConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFirewallConfigInput(firewallFailOpen: \(String(describing: firewallFailOpen)), resourceId: \(String(describing: resourceId)))"}
}

extension UpdateFirewallConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallFailOpen = "FirewallFailOpen"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallFailOpen = firewallFailOpen {
            try encodeContainer.encode(firewallFailOpen.rawValue, forKey: .firewallFailOpen)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct UpdateFirewallConfigInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFirewallConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallConfigInput>
    public typealias MOutput = OperationOutput<UpdateFirewallConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallConfigOutputError>
}

public struct UpdateFirewallConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFirewallConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallConfigInput>
    public typealias MOutput = OperationOutput<UpdateFirewallConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallConfigOutputError>
}

public struct UpdateFirewallConfigInput: Equatable {
    /// <p>Determines how Route 53 Resolver handles queries during failures, for example when all traffic that is sent to DNS Firewall fails to receive a reply. </p>
    ///          <ul>
    ///             <li>
    ///                <p>By default, fail open is disabled, which means the failure mode is closed. This approach favors security over availability.
    ///        DNS Firewall blocks queries that it is unable to evaluate properly. </p>
    ///             </li>
    ///             <li>
    ///                <p>If you enable this option, the failure mode is open. This approach favors availability over security. DNS Firewall allows queries to proceed if it
    ///        is unable to properly evaluate them. </p>
    ///             </li>
    ///          </ul>
    ///          <p>This behavior is only enforced for VPCs that have at least one DNS Firewall rule group association. </p>
    public let firewallFailOpen: FirewallFailOpenStatus?
    /// <p>The ID of the VPC that the configuration is for.</p>
    public let resourceId: String?

    public init (
        firewallFailOpen: FirewallFailOpenStatus? = nil,
        resourceId: String? = nil
    )
    {
        self.firewallFailOpen = firewallFailOpen
        self.resourceId = resourceId
    }
}

struct UpdateFirewallConfigInputBody: Equatable {
    public let resourceId: String?
    public let firewallFailOpen: FirewallFailOpenStatus?
}

extension UpdateFirewallConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallFailOpen = "FirewallFailOpen"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let firewallFailOpenDecoded = try containerValues.decodeIfPresent(FirewallFailOpenStatus.self, forKey: .firewallFailOpen)
        firewallFailOpen = firewallFailOpenDecoded
    }
}

extension UpdateFirewallConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFirewallConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFirewallConfigOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFirewallConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFirewallConfigOutputResponse(firewallConfig: \(String(describing: firewallConfig)))"}
}

extension UpdateFirewallConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFirewallConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallConfig = output.firewallConfig
        } else {
            self.firewallConfig = nil
        }
    }
}

public struct UpdateFirewallConfigOutputResponse: Equatable {
    /// <p>Configuration of the firewall behavior provided by DNS Firewall for a single VPC. </p>
    public let firewallConfig: FirewallConfig?

    public init (
        firewallConfig: FirewallConfig? = nil
    )
    {
        self.firewallConfig = firewallConfig
    }
}

struct UpdateFirewallConfigOutputResponseBody: Equatable {
    public let firewallConfig: FirewallConfig?
}

extension UpdateFirewallConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallConfig = "FirewallConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallConfigDecoded = try containerValues.decodeIfPresent(FirewallConfig.self, forKey: .firewallConfig)
        firewallConfig = firewallConfigDecoded
    }
}

public struct UpdateFirewallDomainsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFirewallDomainsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallDomainsInput>
    public typealias MOutput = OperationOutput<UpdateFirewallDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallDomainsOutputError>
}

extension UpdateFirewallDomainsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFirewallDomainsInput(domains: \(String(describing: domains)), firewallDomainListId: \(String(describing: firewallDomainListId)), operation: \(String(describing: operation)))"}
}

extension UpdateFirewallDomainsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domains = "Domains"
        case firewallDomainListId = "FirewallDomainListId"
        case operation = "Operation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for firewalldomains0 in domains {
                try domainsContainer.encode(firewalldomains0)
            }
        }
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let operation = operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
    }
}

public struct UpdateFirewallDomainsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFirewallDomainsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallDomainsInput>
    public typealias MOutput = OperationOutput<UpdateFirewallDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallDomainsOutputError>
}

public struct UpdateFirewallDomainsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFirewallDomainsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallDomainsInput>
    public typealias MOutput = OperationOutput<UpdateFirewallDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallDomainsOutputError>
}

public struct UpdateFirewallDomainsInput: Equatable {
    /// <p>A list of domains to use in the update operation.</p>
    ///          <p>Each domain specification in your domain list must satisfy the following
    /// 	requirements: </p>
    ///          <ul>
    ///             <li>
    ///       	        <p>It can optionally start with <code>*</code> (asterisk).</p>
    ///       	     </li>
    ///             <li>
    ///       	        <p>With the exception of the optional starting asterisk, it must only contain
    ///       	   the following characters: <code>A-Z</code>, <code>a-z</code>,
    ///       	   <code>0-9</code>, <code>-</code> (hyphen).</p>
    ///       	     </li>
    ///             <li>
    ///       	        <p>It must be from 1-255 characters in length. </p>
    ///       	     </li>
    ///          </ul>
    public let domains: [String]?
    /// <p>The ID of the domain list whose domains you want to update. </p>
    public let firewallDomainListId: String?
    /// <p>What you want DNS Firewall to do with the domains that you are providing: </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ADD</code> - Add the domains to the ones that are already in the domain list. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>REMOVE</code> - Search the domain list for the domains and remove them from the list.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>REPLACE</code> - Update the domain list to exactly match the list that you are providing. </p>
    ///             </li>
    ///          </ul>
    public let operation: FirewallDomainUpdateOperation?

    public init (
        domains: [String]? = nil,
        firewallDomainListId: String? = nil,
        operation: FirewallDomainUpdateOperation? = nil
    )
    {
        self.domains = domains
        self.firewallDomainListId = firewallDomainListId
        self.operation = operation
    }
}

struct UpdateFirewallDomainsInputBody: Equatable {
    public let firewallDomainListId: String?
    public let operation: FirewallDomainUpdateOperation?
    public let domains: [String]?
}

extension UpdateFirewallDomainsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domains = "Domains"
        case firewallDomainListId = "FirewallDomainListId"
        case operation = "Operation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(FirewallDomainUpdateOperation.self, forKey: .operation)
        operation = operationDecoded
        let domainsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .domains)
        var domainsDecoded0:[String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
    }
}

extension UpdateFirewallDomainsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFirewallDomainsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFirewallDomainsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFirewallDomainsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFirewallDomainsOutputResponse(id: \(String(describing: id)), name: \(String(describing: name)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

extension UpdateFirewallDomainsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFirewallDomainsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.id = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct UpdateFirewallDomainsOutputResponse: Equatable {
    /// <p>The ID of the firewall domain list that DNS Firewall just updated.</p>
    public let id: String?
    /// <p>The name of the domain list. </p>
    public let name: String?
    /// <p> </p>
    public let status: FirewallDomainListStatus?
    /// <p>Additional information about the status of the list, if available.</p>
    public let statusMessage: String?

    public init (
        id: String? = nil,
        name: String? = nil,
        status: FirewallDomainListStatus? = nil,
        statusMessage: String? = nil
    )
    {
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct UpdateFirewallDomainsOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let status: FirewallDomainListStatus?
    public let statusMessage: String?
}

extension UpdateFirewallDomainsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FirewallDomainListStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

public struct UpdateFirewallRuleGroupAssociationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFirewallRuleGroupAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallRuleGroupAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallRuleGroupAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallRuleGroupAssociationInput>
    public typealias MOutput = OperationOutput<UpdateFirewallRuleGroupAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallRuleGroupAssociationOutputError>
}

extension UpdateFirewallRuleGroupAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFirewallRuleGroupAssociationInput(firewallRuleGroupAssociationId: \(String(describing: firewallRuleGroupAssociationId)), mutationProtection: \(String(describing: mutationProtection)), name: \(String(describing: name)), priority: \(String(describing: priority)))"}
}

extension UpdateFirewallRuleGroupAssociationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
        case mutationProtection = "MutationProtection"
        case name = "Name"
        case priority = "Priority"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupAssociationId = firewallRuleGroupAssociationId {
            try encodeContainer.encode(firewallRuleGroupAssociationId, forKey: .firewallRuleGroupAssociationId)
        }
        if let mutationProtection = mutationProtection {
            try encodeContainer.encode(mutationProtection.rawValue, forKey: .mutationProtection)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }
}

public struct UpdateFirewallRuleGroupAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFirewallRuleGroupAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallRuleGroupAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallRuleGroupAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallRuleGroupAssociationInput>
    public typealias MOutput = OperationOutput<UpdateFirewallRuleGroupAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallRuleGroupAssociationOutputError>
}

public struct UpdateFirewallRuleGroupAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFirewallRuleGroupAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallRuleGroupAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallRuleGroupAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallRuleGroupAssociationInput>
    public typealias MOutput = OperationOutput<UpdateFirewallRuleGroupAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallRuleGroupAssociationOutputError>
}

public struct UpdateFirewallRuleGroupAssociationInput: Equatable {
    /// <p>The identifier of the <a>FirewallRuleGroupAssociation</a>. </p>
    public let firewallRuleGroupAssociationId: String?
    /// <p>If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections. </p>
    public let mutationProtection: MutationProtectionStatus?
    /// <p>The name of the rule group association.</p>
    public let name: String?
    /// <p>The setting that determines the processing order of the rule group among the rule
    /// 			groups that you associate with the specified VPC. DNS Firewall filters VPC traffic
    /// 			starting from the rule group with the lowest numeric priority setting. </p>
    ///          <p>You must specify a unique priority for each rule group that you associate with a single VPC.
    ///            To make it easier to insert rule groups later, leave space between the numbers, for example, use 100, 200, and so on. You
    ///    can change the priority setting for a rule group association after you create it.</p>
    public let priority: Int?

    public init (
        firewallRuleGroupAssociationId: String? = nil,
        mutationProtection: MutationProtectionStatus? = nil,
        name: String? = nil,
        priority: Int? = nil
    )
    {
        self.firewallRuleGroupAssociationId = firewallRuleGroupAssociationId
        self.mutationProtection = mutationProtection
        self.name = name
        self.priority = priority
    }
}

struct UpdateFirewallRuleGroupAssociationInputBody: Equatable {
    public let firewallRuleGroupAssociationId: String?
    public let priority: Int?
    public let mutationProtection: MutationProtectionStatus?
    public let name: String?
}

extension UpdateFirewallRuleGroupAssociationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
        case mutationProtection = "MutationProtection"
        case name = "Name"
        case priority = "Priority"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallRuleGroupAssociationId)
        firewallRuleGroupAssociationId = firewallRuleGroupAssociationIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
        let mutationProtectionDecoded = try containerValues.decodeIfPresent(MutationProtectionStatus.self, forKey: .mutationProtection)
        mutationProtection = mutationProtectionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateFirewallRuleGroupAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFirewallRuleGroupAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFirewallRuleGroupAssociationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFirewallRuleGroupAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFirewallRuleGroupAssociationOutputResponse(firewallRuleGroupAssociation: \(String(describing: firewallRuleGroupAssociation)))"}
}

extension UpdateFirewallRuleGroupAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFirewallRuleGroupAssociationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallRuleGroupAssociation = output.firewallRuleGroupAssociation
        } else {
            self.firewallRuleGroupAssociation = nil
        }
    }
}

public struct UpdateFirewallRuleGroupAssociationOutputResponse: Equatable {
    /// <p>The association that you just updated. </p>
    public let firewallRuleGroupAssociation: FirewallRuleGroupAssociation?

    public init (
        firewallRuleGroupAssociation: FirewallRuleGroupAssociation? = nil
    )
    {
        self.firewallRuleGroupAssociation = firewallRuleGroupAssociation
    }
}

struct UpdateFirewallRuleGroupAssociationOutputResponseBody: Equatable {
    public let firewallRuleGroupAssociation: FirewallRuleGroupAssociation?
}

extension UpdateFirewallRuleGroupAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRuleGroupAssociation = "FirewallRuleGroupAssociation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationDecoded = try containerValues.decodeIfPresent(FirewallRuleGroupAssociation.self, forKey: .firewallRuleGroupAssociation)
        firewallRuleGroupAssociation = firewallRuleGroupAssociationDecoded
    }
}

public struct UpdateFirewallRuleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFirewallRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallRuleInput>
    public typealias MOutput = OperationOutput<UpdateFirewallRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallRuleOutputError>
}

extension UpdateFirewallRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFirewallRuleInput(action: \(String(describing: action)), blockOverrideDnsType: \(String(describing: blockOverrideDnsType)), blockOverrideDomain: \(String(describing: blockOverrideDomain)), blockOverrideTtl: \(String(describing: blockOverrideTtl)), blockResponse: \(String(describing: blockResponse)), firewallDomainListId: \(String(describing: firewallDomainListId)), firewallRuleGroupId: \(String(describing: firewallRuleGroupId)), name: \(String(describing: name)), priority: \(String(describing: priority)))"}
}

extension UpdateFirewallRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case blockOverrideDnsType = "BlockOverrideDnsType"
        case blockOverrideDomain = "BlockOverrideDomain"
        case blockOverrideTtl = "BlockOverrideTtl"
        case blockResponse = "BlockResponse"
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case name = "Name"
        case priority = "Priority"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let blockOverrideDnsType = blockOverrideDnsType {
            try encodeContainer.encode(blockOverrideDnsType.rawValue, forKey: .blockOverrideDnsType)
        }
        if let blockOverrideDomain = blockOverrideDomain {
            try encodeContainer.encode(blockOverrideDomain, forKey: .blockOverrideDomain)
        }
        if let blockOverrideTtl = blockOverrideTtl {
            try encodeContainer.encode(blockOverrideTtl, forKey: .blockOverrideTtl)
        }
        if let blockResponse = blockResponse {
            try encodeContainer.encode(blockResponse.rawValue, forKey: .blockResponse)
        }
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }
}

public struct UpdateFirewallRuleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFirewallRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallRuleInput>
    public typealias MOutput = OperationOutput<UpdateFirewallRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallRuleOutputError>
}

public struct UpdateFirewallRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFirewallRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallRuleInput>
    public typealias MOutput = OperationOutput<UpdateFirewallRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallRuleOutputError>
}

public struct UpdateFirewallRuleInput: Equatable {
    /// <p>The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALLOW</code> - Permit the request to go through.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ALERT</code> - Permit the request to go through but send an alert to the logs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BLOCK</code> - Disallow the request. This option requires additional details in the rule's <code>BlockResponse</code>. </p>
    ///             </li>
    ///          </ul>
    public let action: Action?
    /// <p>The DNS record's type. This determines the format of the record value that you provided in <code>BlockOverrideDomain</code>. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
    public let blockOverrideDnsType: BlockOverrideDnsType?
    /// <p>The custom DNS record to send back in response to the query. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
    public let blockOverrideDomain: String?
    /// <p>The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
    public let blockOverrideTtl: Int?
    /// <p>The way that you want DNS Firewall to block the request. Used for the rule action setting <code>BLOCK</code>.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NODATA</code> - Respond indicating that the query was successful, but no response is available for it.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NXDOMAIN</code> - Respond indicating that the domain name that's in the query doesn't exist.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OVERRIDE</code> - Provide a custom override in the response. This option requires custom handling details in the rule's <code>BlockOverride*</code> settings. </p>
    ///             </li>
    ///          </ul>
    public let blockResponse: BlockResponse?
    /// <p>The ID of the domain list to use in the rule.  </p>
    public let firewallDomainListId: String?
    /// <p>The unique identifier of the firewall rule group for the rule. </p>
    public let firewallRuleGroupId: String?
    /// <p>The name of the rule.</p>
    public let name: String?
    /// <p>The setting that determines the processing order of the rule in the rule group. DNS Firewall
    ///            processes the rules in a rule group by order of priority, starting from the lowest setting.</p>
    ///          <p>You must specify a unique priority for each rule in a rule group.
    ///            To make it easier to insert rules later, leave space between the numbers, for example, use 100, 200, and so on. You
    ///    can change the priority setting for the rules in a rule group at any time.</p>
    public let priority: Int?

    public init (
        action: Action? = nil,
        blockOverrideDnsType: BlockOverrideDnsType? = nil,
        blockOverrideDomain: String? = nil,
        blockOverrideTtl: Int? = nil,
        blockResponse: BlockResponse? = nil,
        firewallDomainListId: String? = nil,
        firewallRuleGroupId: String? = nil,
        name: String? = nil,
        priority: Int? = nil
    )
    {
        self.action = action
        self.blockOverrideDnsType = blockOverrideDnsType
        self.blockOverrideDomain = blockOverrideDomain
        self.blockOverrideTtl = blockOverrideTtl
        self.blockResponse = blockResponse
        self.firewallDomainListId = firewallDomainListId
        self.firewallRuleGroupId = firewallRuleGroupId
        self.name = name
        self.priority = priority
    }
}

struct UpdateFirewallRuleInputBody: Equatable {
    public let firewallRuleGroupId: String?
    public let firewallDomainListId: String?
    public let priority: Int?
    public let action: Action?
    public let blockResponse: BlockResponse?
    public let blockOverrideDomain: String?
    public let blockOverrideDnsType: BlockOverrideDnsType?
    public let blockOverrideTtl: Int?
    public let name: String?
}

extension UpdateFirewallRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case blockOverrideDnsType = "BlockOverrideDnsType"
        case blockOverrideDomain = "BlockOverrideDomain"
        case blockOverrideTtl = "BlockOverrideTtl"
        case blockResponse = "BlockResponse"
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case name = "Name"
        case priority = "Priority"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let blockResponseDecoded = try containerValues.decodeIfPresent(BlockResponse.self, forKey: .blockResponse)
        blockResponse = blockResponseDecoded
        let blockOverrideDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .blockOverrideDomain)
        blockOverrideDomain = blockOverrideDomainDecoded
        let blockOverrideDnsTypeDecoded = try containerValues.decodeIfPresent(BlockOverrideDnsType.self, forKey: .blockOverrideDnsType)
        blockOverrideDnsType = blockOverrideDnsTypeDecoded
        let blockOverrideTtlDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .blockOverrideTtl)
        blockOverrideTtl = blockOverrideTtlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateFirewallRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFirewallRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFirewallRuleOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFirewallRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFirewallRuleOutputResponse(firewallRule: \(String(describing: firewallRule)))"}
}

extension UpdateFirewallRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFirewallRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallRule = output.firewallRule
        } else {
            self.firewallRule = nil
        }
    }
}

public struct UpdateFirewallRuleOutputResponse: Equatable {
    /// <p>The firewall rule that you just updated. </p>
    public let firewallRule: FirewallRule?

    public init (
        firewallRule: FirewallRule? = nil
    )
    {
        self.firewallRule = firewallRule
    }
}

struct UpdateFirewallRuleOutputResponseBody: Equatable {
    public let firewallRule: FirewallRule?
}

extension UpdateFirewallRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallRule = "FirewallRule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleDecoded = try containerValues.decodeIfPresent(FirewallRule.self, forKey: .firewallRule)
        firewallRule = firewallRuleDecoded
    }
}

public struct UpdateResolverDnssecConfigInputBodyMiddleware: Middleware {
    public let id: String = "UpdateResolverDnssecConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResolverDnssecConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResolverDnssecConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResolverDnssecConfigInput>
    public typealias MOutput = OperationOutput<UpdateResolverDnssecConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResolverDnssecConfigOutputError>
}

extension UpdateResolverDnssecConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResolverDnssecConfigInput(resourceId: \(String(describing: resourceId)), validation: \(String(describing: validation)))"}
}

extension UpdateResolverDnssecConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case validation = "Validation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let validation = validation {
            try encodeContainer.encode(validation.rawValue, forKey: .validation)
        }
    }
}

public struct UpdateResolverDnssecConfigInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateResolverDnssecConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResolverDnssecConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResolverDnssecConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResolverDnssecConfigInput>
    public typealias MOutput = OperationOutput<UpdateResolverDnssecConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResolverDnssecConfigOutputError>
}

public struct UpdateResolverDnssecConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateResolverDnssecConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResolverDnssecConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResolverDnssecConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResolverDnssecConfigInput>
    public typealias MOutput = OperationOutput<UpdateResolverDnssecConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResolverDnssecConfigOutputError>
}

public struct UpdateResolverDnssecConfigInput: Equatable {
    /// <p>The ID of the virtual private cloud (VPC) that you're updating the DNSSEC validation status for.</p>
    public let resourceId: String?
    /// <p>The new value that you are specifying for DNSSEC validation for the VPC. The value can be <code>ENABLE</code>
    /// 			or <code>DISABLE</code>. Be aware that it can take time for a validation status change to be completed.</p>
    public let validation: Validation?

    public init (
        resourceId: String? = nil,
        validation: Validation? = nil
    )
    {
        self.resourceId = resourceId
        self.validation = validation
    }
}

struct UpdateResolverDnssecConfigInputBody: Equatable {
    public let resourceId: String?
    public let validation: Validation?
}

extension UpdateResolverDnssecConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case validation = "Validation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let validationDecoded = try containerValues.decodeIfPresent(Validation.self, forKey: .validation)
        validation = validationDecoded
    }
}

extension UpdateResolverDnssecConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResolverDnssecConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResolverDnssecConfigOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResolverDnssecConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResolverDnssecConfigOutputResponse(resolverDNSSECConfig: \(String(describing: resolverDNSSECConfig)))"}
}

extension UpdateResolverDnssecConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateResolverDnssecConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverDNSSECConfig = output.resolverDNSSECConfig
        } else {
            self.resolverDNSSECConfig = nil
        }
    }
}

public struct UpdateResolverDnssecConfigOutputResponse: Equatable {
    /// <p>A complex type that contains settings for the specified DNSSEC configuration.</p>
    public let resolverDNSSECConfig: ResolverDnssecConfig?

    public init (
        resolverDNSSECConfig: ResolverDnssecConfig? = nil
    )
    {
        self.resolverDNSSECConfig = resolverDNSSECConfig
    }
}

struct UpdateResolverDnssecConfigOutputResponseBody: Equatable {
    public let resolverDNSSECConfig: ResolverDnssecConfig?
}

extension UpdateResolverDnssecConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverDNSSECConfig = "ResolverDNSSECConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDNSSECConfigDecoded = try containerValues.decodeIfPresent(ResolverDnssecConfig.self, forKey: .resolverDNSSECConfig)
        resolverDNSSECConfig = resolverDNSSECConfigDecoded
    }
}

public struct UpdateResolverEndpointInputBodyMiddleware: Middleware {
    public let id: String = "UpdateResolverEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResolverEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResolverEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResolverEndpointInput>
    public typealias MOutput = OperationOutput<UpdateResolverEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResolverEndpointOutputError>
}

extension UpdateResolverEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResolverEndpointInput(name: \(String(describing: name)), resolverEndpointId: \(String(describing: resolverEndpointId)))"}
}

extension UpdateResolverEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

public struct UpdateResolverEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateResolverEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResolverEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResolverEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResolverEndpointInput>
    public typealias MOutput = OperationOutput<UpdateResolverEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResolverEndpointOutputError>
}

public struct UpdateResolverEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateResolverEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResolverEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResolverEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResolverEndpointInput>
    public typealias MOutput = OperationOutput<UpdateResolverEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResolverEndpointOutputError>
}

public struct UpdateResolverEndpointInput: Equatable {
    /// <p>The name of the Resolver endpoint that you want to update.</p>
    public let name: String?
    /// <p>The ID of the Resolver endpoint that you want to update.</p>
    public let resolverEndpointId: String?

    public init (
        name: String? = nil,
        resolverEndpointId: String? = nil
    )
    {
        self.name = name
        self.resolverEndpointId = resolverEndpointId
    }
}

struct UpdateResolverEndpointInputBody: Equatable {
    public let resolverEndpointId: String?
    public let name: String?
}

extension UpdateResolverEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateResolverEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResolverEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResolverEndpointOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResolverEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResolverEndpointOutputResponse(resolverEndpoint: \(String(describing: resolverEndpoint)))"}
}

extension UpdateResolverEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateResolverEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct UpdateResolverEndpointOutputResponse: Equatable {
    /// <p>The response to an <code>UpdateResolverEndpoint</code> request.</p>
    public let resolverEndpoint: ResolverEndpoint?

    public init (
        resolverEndpoint: ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct UpdateResolverEndpointOutputResponseBody: Equatable {
    public let resolverEndpoint: ResolverEndpoint?
}

extension UpdateResolverEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

public struct UpdateResolverRuleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateResolverRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResolverRuleInput>
    public typealias MOutput = OperationOutput<UpdateResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResolverRuleOutputError>
}

extension UpdateResolverRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResolverRuleInput(config: \(String(describing: config)), resolverRuleId: \(String(describing: resolverRuleId)))"}
}

extension UpdateResolverRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case config = "Config"
        case resolverRuleId = "ResolverRuleId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = config {
            try encodeContainer.encode(config, forKey: .config)
        }
        if let resolverRuleId = resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
    }
}

public struct UpdateResolverRuleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateResolverRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResolverRuleInput>
    public typealias MOutput = OperationOutput<UpdateResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResolverRuleOutputError>
}

public struct UpdateResolverRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateResolverRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResolverRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResolverRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResolverRuleInput>
    public typealias MOutput = OperationOutput<UpdateResolverRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResolverRuleOutputError>
}

public struct UpdateResolverRuleInput: Equatable {
    /// <p>The new settings for the Resolver rule.</p>
    public let config: ResolverRuleConfig?
    /// <p>The ID of the Resolver rule that you want to update.</p>
    public let resolverRuleId: String?

    public init (
        config: ResolverRuleConfig? = nil,
        resolverRuleId: String? = nil
    )
    {
        self.config = config
        self.resolverRuleId = resolverRuleId
    }
}

struct UpdateResolverRuleInputBody: Equatable {
    public let resolverRuleId: String?
    public let config: ResolverRuleConfig?
}

extension UpdateResolverRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case config = "Config"
        case resolverRuleId = "ResolverRuleId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
        let configDecoded = try containerValues.decodeIfPresent(ResolverRuleConfig.self, forKey: .config)
        config = configDecoded
    }
}

extension UpdateResolverRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResolverRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResolverRuleOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResolverRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResolverRuleOutputResponse(resolverRule: \(String(describing: resolverRule)))"}
}

extension UpdateResolverRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateResolverRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolverRule = output.resolverRule
        } else {
            self.resolverRule = nil
        }
    }
}

public struct UpdateResolverRuleOutputResponse: Equatable {
    /// <p>The response to an <code>UpdateResolverRule</code> request.</p>
    public let resolverRule: ResolverRule?

    public init (
        resolverRule: ResolverRule? = nil
    )
    {
        self.resolverRule = resolverRule
    }
}

struct UpdateResolverRuleOutputResponseBody: Equatable {
    public let resolverRule: ResolverRule?
}

extension UpdateResolverRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolverRule = "ResolverRule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleDecoded = try containerValues.decodeIfPresent(ResolverRule.self, forKey: .resolverRule)
        resolverRule = resolverRuleDecoded
    }
}

public enum Validation {
    case disable
    case enable
    case sdkUnknown(String)
}

extension Validation : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Validation] {
        return [
            .disable,
            .enable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disable: return "DISABLE"
        case .enable: return "ENABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Validation(rawValue: rawValue) ?? Validation.sdkUnknown(rawValue)
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
