// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AssociateApprovedOriginInputBodyMiddleware: Middleware {
    public let id: String = "AssociateApprovedOriginInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateApprovedOriginInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateApprovedOriginOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateApprovedOriginInput>
    public typealias MOutput = OperationOutput<AssociateApprovedOriginOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateApprovedOriginOutputError>
}

extension AssociateApprovedOriginInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateApprovedOriginInput(instanceId: \(String(describing: instanceId)), origin: \(String(describing: origin)))"}
}

extension AssociateApprovedOriginInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case origin = "Origin"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let origin = origin {
            try encodeContainer.encode(origin, forKey: .origin)
        }
    }
}

public struct AssociateApprovedOriginInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateApprovedOriginInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateApprovedOriginInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateApprovedOriginOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateApprovedOriginInput>
    public typealias MOutput = OperationOutput<AssociateApprovedOriginOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateApprovedOriginOutputError>
}

public struct AssociateApprovedOriginInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateApprovedOriginInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateApprovedOriginInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateApprovedOriginOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateApprovedOriginInput>
    public typealias MOutput = OperationOutput<AssociateApprovedOriginOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateApprovedOriginOutputError>
}

public struct AssociateApprovedOriginInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The domain to add to your allow list.</p>
    public let origin: String?

    public init (
        instanceId: String? = nil,
        origin: String? = nil
    )
    {
        self.instanceId = instanceId
        self.origin = origin
    }
}

struct AssociateApprovedOriginInputBody: Equatable {
    public let origin: String?
}

extension AssociateApprovedOriginInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case origin = "Origin"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originDecoded = try containerValues.decodeIfPresent(String.self, forKey: .origin)
        origin = originDecoded
    }
}

extension AssociateApprovedOriginOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateApprovedOriginOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateApprovedOriginOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateApprovedOriginOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateApprovedOriginOutputResponse()"}
}

extension AssociateApprovedOriginOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateApprovedOriginOutputResponse: Equatable {

    public init() {}
}

struct AssociateApprovedOriginOutputResponseBody: Equatable {
}

extension AssociateApprovedOriginOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateInstanceStorageConfigInputBodyMiddleware: Middleware {
    public let id: String = "AssociateInstanceStorageConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateInstanceStorageConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateInstanceStorageConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateInstanceStorageConfigInput>
    public typealias MOutput = OperationOutput<AssociateInstanceStorageConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateInstanceStorageConfigOutputError>
}

extension AssociateInstanceStorageConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateInstanceStorageConfigInput(instanceId: \(String(describing: instanceId)), resourceType: \(String(describing: resourceType)), storageConfig: \(String(describing: storageConfig)))"}
}

extension AssociateInstanceStorageConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceType = "ResourceType"
        case storageConfig = "StorageConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let storageConfig = storageConfig {
            try encodeContainer.encode(storageConfig, forKey: .storageConfig)
        }
    }
}

public struct AssociateInstanceStorageConfigInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateInstanceStorageConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateInstanceStorageConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateInstanceStorageConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateInstanceStorageConfigInput>
    public typealias MOutput = OperationOutput<AssociateInstanceStorageConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateInstanceStorageConfigOutputError>
}

public struct AssociateInstanceStorageConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateInstanceStorageConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateInstanceStorageConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateInstanceStorageConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateInstanceStorageConfigInput>
    public typealias MOutput = OperationOutput<AssociateInstanceStorageConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateInstanceStorageConfigOutputError>
}

public struct AssociateInstanceStorageConfigInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>A valid resource type.</p>
    public let resourceType: InstanceStorageResourceType?
    /// <p>A valid storage type.</p>
    public let storageConfig: InstanceStorageConfig?

    public init (
        instanceId: String? = nil,
        resourceType: InstanceStorageResourceType? = nil,
        storageConfig: InstanceStorageConfig? = nil
    )
    {
        self.instanceId = instanceId
        self.resourceType = resourceType
        self.storageConfig = storageConfig
    }
}

struct AssociateInstanceStorageConfigInputBody: Equatable {
    public let resourceType: InstanceStorageResourceType?
    public let storageConfig: InstanceStorageConfig?
}

extension AssociateInstanceStorageConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceType = "ResourceType"
        case storageConfig = "StorageConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(InstanceStorageResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let storageConfigDecoded = try containerValues.decodeIfPresent(InstanceStorageConfig.self, forKey: .storageConfig)
        storageConfig = storageConfigDecoded
    }
}

extension AssociateInstanceStorageConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateInstanceStorageConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateInstanceStorageConfigOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateInstanceStorageConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateInstanceStorageConfigOutputResponse(associationId: \(String(describing: associationId)))"}
}

extension AssociateInstanceStorageConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateInstanceStorageConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associationId = output.associationId
        } else {
            self.associationId = nil
        }
    }
}

public struct AssociateInstanceStorageConfigOutputResponse: Equatable {
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    public let associationId: String?

    public init (
        associationId: String? = nil
    )
    {
        self.associationId = associationId
    }
}

struct AssociateInstanceStorageConfigOutputResponseBody: Equatable {
    public let associationId: String?
}

extension AssociateInstanceStorageConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
    }
}

public struct AssociateLambdaFunctionInputBodyMiddleware: Middleware {
    public let id: String = "AssociateLambdaFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateLambdaFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateLambdaFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateLambdaFunctionInput>
    public typealias MOutput = OperationOutput<AssociateLambdaFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateLambdaFunctionOutputError>
}

extension AssociateLambdaFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateLambdaFunctionInput(functionArn: \(String(describing: functionArn)), instanceId: \(String(describing: instanceId)))"}
}

extension AssociateLambdaFunctionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case functionArn = "FunctionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
    }
}

public struct AssociateLambdaFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateLambdaFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateLambdaFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateLambdaFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateLambdaFunctionInput>
    public typealias MOutput = OperationOutput<AssociateLambdaFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateLambdaFunctionOutputError>
}

public struct AssociateLambdaFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateLambdaFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateLambdaFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateLambdaFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateLambdaFunctionInput>
    public typealias MOutput = OperationOutput<AssociateLambdaFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateLambdaFunctionOutputError>
}

public struct AssociateLambdaFunctionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the Lambda function being associated. Maximum number of characters allowed is
    ///    140.</p>
    public let functionArn: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        functionArn: String? = nil,
        instanceId: String? = nil
    )
    {
        self.functionArn = functionArn
        self.instanceId = instanceId
    }
}

struct AssociateLambdaFunctionInputBody: Equatable {
    public let functionArn: String?
}

extension AssociateLambdaFunctionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functionArn = "FunctionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
    }
}

extension AssociateLambdaFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateLambdaFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateLambdaFunctionOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateLambdaFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateLambdaFunctionOutputResponse()"}
}

extension AssociateLambdaFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateLambdaFunctionOutputResponse: Equatable {

    public init() {}
}

struct AssociateLambdaFunctionOutputResponseBody: Equatable {
}

extension AssociateLambdaFunctionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateLexBotInputBodyMiddleware: Middleware {
    public let id: String = "AssociateLexBotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateLexBotInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateLexBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateLexBotInput>
    public typealias MOutput = OperationOutput<AssociateLexBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateLexBotOutputError>
}

extension AssociateLexBotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateLexBotInput(instanceId: \(String(describing: instanceId)), lexBot: \(String(describing: lexBot)))"}
}

extension AssociateLexBotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lexBot = "LexBot"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lexBot = lexBot {
            try encodeContainer.encode(lexBot, forKey: .lexBot)
        }
    }
}

public struct AssociateLexBotInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateLexBotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateLexBotInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateLexBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateLexBotInput>
    public typealias MOutput = OperationOutput<AssociateLexBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateLexBotOutputError>
}

public struct AssociateLexBotInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateLexBotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateLexBotInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateLexBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateLexBotInput>
    public typealias MOutput = OperationOutput<AssociateLexBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateLexBotOutputError>
}

public struct AssociateLexBotInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The Amazon Lex box to associate with the instance.</p>
    public let lexBot: LexBot?

    public init (
        instanceId: String? = nil,
        lexBot: LexBot? = nil
    )
    {
        self.instanceId = instanceId
        self.lexBot = lexBot
    }
}

struct AssociateLexBotInputBody: Equatable {
    public let lexBot: LexBot?
}

extension AssociateLexBotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lexBot = "LexBot"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexBotDecoded = try containerValues.decodeIfPresent(LexBot.self, forKey: .lexBot)
        lexBot = lexBotDecoded
    }
}

extension AssociateLexBotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateLexBotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateLexBotOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateLexBotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateLexBotOutputResponse()"}
}

extension AssociateLexBotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateLexBotOutputResponse: Equatable {

    public init() {}
}

struct AssociateLexBotOutputResponseBody: Equatable {
}

extension AssociateLexBotOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateQueueQuickConnectsInputBodyMiddleware: Middleware {
    public let id: String = "AssociateQueueQuickConnectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateQueueQuickConnectsInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateQueueQuickConnectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateQueueQuickConnectsInput>
    public typealias MOutput = OperationOutput<AssociateQueueQuickConnectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateQueueQuickConnectsOutputError>
}

extension AssociateQueueQuickConnectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateQueueQuickConnectsInput(instanceId: \(String(describing: instanceId)), queueId: \(String(describing: queueId)), quickConnectIds: \(String(describing: quickConnectIds)))"}
}

extension AssociateQueueQuickConnectsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case quickConnectIds = "QuickConnectIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quickConnectIds = quickConnectIds {
            var quickConnectIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .quickConnectIds)
            for quickconnectslist0 in quickConnectIds {
                try quickConnectIdsContainer.encode(quickconnectslist0)
            }
        }
    }
}

public struct AssociateQueueQuickConnectsInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateQueueQuickConnectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateQueueQuickConnectsInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateQueueQuickConnectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateQueueQuickConnectsInput>
    public typealias MOutput = OperationOutput<AssociateQueueQuickConnectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateQueueQuickConnectsOutputError>
}

public struct AssociateQueueQuickConnectsInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateQueueQuickConnectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateQueueQuickConnectsInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateQueueQuickConnectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateQueueQuickConnectsInput>
    public typealias MOutput = OperationOutput<AssociateQueueQuickConnectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateQueueQuickConnectsOutputError>
}

public struct AssociateQueueQuickConnectsInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier for the queue.</p>
    public let queueId: String?
    /// <p>The quick connects to associate with this queue.</p>
    public let quickConnectIds: [String]?

    public init (
        instanceId: String? = nil,
        queueId: String? = nil,
        quickConnectIds: [String]? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
        self.quickConnectIds = quickConnectIds
    }
}

struct AssociateQueueQuickConnectsInputBody: Equatable {
    public let quickConnectIds: [String]?
}

extension AssociateQueueQuickConnectsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case quickConnectIds = "QuickConnectIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .quickConnectIds)
        var quickConnectIdsDecoded0:[String]? = nil
        if let quickConnectIdsContainer = quickConnectIdsContainer {
            quickConnectIdsDecoded0 = [String]()
            for string0 in quickConnectIdsContainer {
                if let string0 = string0 {
                    quickConnectIdsDecoded0?.append(string0)
                }
            }
        }
        quickConnectIds = quickConnectIdsDecoded0
    }
}

extension AssociateQueueQuickConnectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateQueueQuickConnectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateQueueQuickConnectsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateQueueQuickConnectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateQueueQuickConnectsOutputResponse()"}
}

extension AssociateQueueQuickConnectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateQueueQuickConnectsOutputResponse: Equatable {

    public init() {}
}

struct AssociateQueueQuickConnectsOutputResponseBody: Equatable {
}

extension AssociateQueueQuickConnectsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateRoutingProfileQueuesInputBodyMiddleware: Middleware {
    public let id: String = "AssociateRoutingProfileQueuesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateRoutingProfileQueuesInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateRoutingProfileQueuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateRoutingProfileQueuesInput>
    public typealias MOutput = OperationOutput<AssociateRoutingProfileQueuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateRoutingProfileQueuesOutputError>
}

extension AssociateRoutingProfileQueuesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateRoutingProfileQueuesInput(instanceId: \(String(describing: instanceId)), queueConfigs: \(String(describing: queueConfigs)), routingProfileId: \(String(describing: routingProfileId)))"}
}

extension AssociateRoutingProfileQueuesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case queueConfigs = "QueueConfigs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queueConfigs = queueConfigs {
            var queueConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queueConfigs)
            for routingprofilequeueconfiglist0 in queueConfigs {
                try queueConfigsContainer.encode(routingprofilequeueconfiglist0)
            }
        }
    }
}

public struct AssociateRoutingProfileQueuesInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateRoutingProfileQueuesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateRoutingProfileQueuesInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateRoutingProfileQueuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateRoutingProfileQueuesInput>
    public typealias MOutput = OperationOutput<AssociateRoutingProfileQueuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateRoutingProfileQueuesOutputError>
}

public struct AssociateRoutingProfileQueuesInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateRoutingProfileQueuesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateRoutingProfileQueuesInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateRoutingProfileQueuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateRoutingProfileQueuesInput>
    public typealias MOutput = OperationOutput<AssociateRoutingProfileQueuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateRoutingProfileQueuesOutputError>
}

public struct AssociateRoutingProfileQueuesInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The queues to associate with this routing profile.</p>
    public let queueConfigs: [RoutingProfileQueueConfig]?
    /// <p>The identifier of the routing profile.</p>
    public let routingProfileId: String?

    public init (
        instanceId: String? = nil,
        queueConfigs: [RoutingProfileQueueConfig]? = nil,
        routingProfileId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueConfigs = queueConfigs
        self.routingProfileId = routingProfileId
    }
}

struct AssociateRoutingProfileQueuesInputBody: Equatable {
    public let queueConfigs: [RoutingProfileQueueConfig]?
}

extension AssociateRoutingProfileQueuesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case queueConfigs = "QueueConfigs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueConfigsContainer = try containerValues.decodeIfPresent([RoutingProfileQueueConfig?].self, forKey: .queueConfigs)
        var queueConfigsDecoded0:[RoutingProfileQueueConfig]? = nil
        if let queueConfigsContainer = queueConfigsContainer {
            queueConfigsDecoded0 = [RoutingProfileQueueConfig]()
            for structure0 in queueConfigsContainer {
                if let structure0 = structure0 {
                    queueConfigsDecoded0?.append(structure0)
                }
            }
        }
        queueConfigs = queueConfigsDecoded0
    }
}

extension AssociateRoutingProfileQueuesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateRoutingProfileQueuesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateRoutingProfileQueuesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateRoutingProfileQueuesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateRoutingProfileQueuesOutputResponse()"}
}

extension AssociateRoutingProfileQueuesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateRoutingProfileQueuesOutputResponse: Equatable {

    public init() {}
}

struct AssociateRoutingProfileQueuesOutputResponseBody: Equatable {
}

extension AssociateRoutingProfileQueuesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateSecurityKeyInputBodyMiddleware: Middleware {
    public let id: String = "AssociateSecurityKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSecurityKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSecurityKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSecurityKeyInput>
    public typealias MOutput = OperationOutput<AssociateSecurityKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSecurityKeyOutputError>
}

extension AssociateSecurityKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateSecurityKeyInput(instanceId: \(String(describing: instanceId)), key: \(String(describing: key)))"}
}

extension AssociateSecurityKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }
}

public struct AssociateSecurityKeyInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateSecurityKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSecurityKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSecurityKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSecurityKeyInput>
    public typealias MOutput = OperationOutput<AssociateSecurityKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSecurityKeyOutputError>
}

public struct AssociateSecurityKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateSecurityKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSecurityKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSecurityKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSecurityKeyInput>
    public typealias MOutput = OperationOutput<AssociateSecurityKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSecurityKeyOutputError>
}

public struct AssociateSecurityKeyInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>A valid security key in PEM format.</p>
    public let key: String?

    public init (
        instanceId: String? = nil,
        key: String? = nil
    )
    {
        self.instanceId = instanceId
        self.key = key
    }
}

struct AssociateSecurityKeyInputBody: Equatable {
    public let key: String?
}

extension AssociateSecurityKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
    }
}

extension AssociateSecurityKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateSecurityKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateSecurityKeyOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateSecurityKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateSecurityKeyOutputResponse(associationId: \(String(describing: associationId)))"}
}

extension AssociateSecurityKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateSecurityKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associationId = output.associationId
        } else {
            self.associationId = nil
        }
    }
}

public struct AssociateSecurityKeyOutputResponse: Equatable {
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    public let associationId: String?

    public init (
        associationId: String? = nil
    )
    {
        self.associationId = associationId
    }
}

struct AssociateSecurityKeyOutputResponseBody: Equatable {
    public let associationId: String?
}

extension AssociateSecurityKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
    }
}

extension Attribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeType = "AttributeType"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeType = attributeType {
            try encodeContainer.encode(attributeType.rawValue, forKey: .attributeType)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeTypeDecoded = try containerValues.decodeIfPresent(InstanceAttributeType.self, forKey: .attributeType)
        attributeType = attributeTypeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Attribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Attribute(attributeType: \(String(describing: attributeType)), value: \(String(describing: value)))"}
}

/// <p>A toggle for an individual feature at the instance level.</p>
public struct Attribute: Equatable {
    /// <p>The type of attribute.</p>
    public let attributeType: InstanceAttributeType?
    /// <p>The value of the attribute.</p>
    public let value: String?

    public init (
        attributeType: InstanceAttributeType? = nil,
        value: String? = nil
    )
    {
        self.attributeType = attributeType
        self.value = value
    }
}

public enum Channel {
    case chat
    case task
    case voice
    case sdkUnknown(String)
}

extension Channel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Channel] {
        return [
            .chat,
            .task,
            .voice,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .chat: return "CHAT"
        case .task: return "TASK"
        case .voice: return "VOICE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Channel(rawValue: rawValue) ?? Channel.sdkUnknown(rawValue)
    }
}

extension ChatMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
        case contentType = "ContentType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
    }
}

extension ChatMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChatMessage(content: \(String(describing: content)), contentType: \(String(describing: contentType)))"}
}

/// <p>A chat message.</p>
public struct ChatMessage: Equatable {
    /// <p>The content of the chat message.</p>
    public let content: String?
    /// <p>The type of the content. Supported types are text and plain.</p>
    public let contentType: String?

    public init (
        content: String? = nil,
        contentType: String? = nil
    )
    {
        self.content = content
        self.contentType = contentType
    }
}

public enum Comparison {
    case lt
    case sdkUnknown(String)
}

extension Comparison : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Comparison] {
        return [
            .lt,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lt: return "LT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Comparison(rawValue: rawValue) ?? Comparison.sdkUnknown(rawValue)
    }
}

extension ContactFlow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case content = "Content"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ContactFlowType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ContactFlow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContactFlow(arn: \(String(describing: arn)), content: \(String(describing: content)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

/// <p>Contains information about a contact flow.</p>
public struct ContactFlow: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact flow.</p>
    public let arn: String?
    /// <p>The content of the contact flow.</p>
    public let content: String?
    /// <p>The description of the contact flow.</p>
    public let description: String?
    /// <p>The identifier of the contact flow.</p>
    public let id: String?
    /// <p>The name of the contact flow.</p>
    public let name: String?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?
    /// <p>The type of the contact flow. For descriptions of the available types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose a Contact Flow Type</a> in the <i>Amazon Connect Administrator
    ///    Guide</i>.</p>
    public let type: ContactFlowType?

    public init (
        arn: String? = nil,
        content: String? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil,
        type: ContactFlowType? = nil
    )
    {
        self.arn = arn
        self.content = content
        self.description = description
        self.id = id
        self.name = name
        self.tags = tags
        self.type = type
    }
}

extension ContactFlowNotPublishedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContactFlowNotPublishedException(message: \(String(describing: message)))"}
}

extension ContactFlowNotPublishedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ContactFlowNotPublishedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The contact flow has not been published.</p>
public struct ContactFlowNotPublishedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ContactFlowNotPublishedExceptionBody: Equatable {
    public let message: String?
}

extension ContactFlowNotPublishedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ContactFlowSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case contactFlowType = "ContactFlowType"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let contactFlowType = contactFlowType {
            try encodeContainer.encode(contactFlowType.rawValue, forKey: .contactFlowType)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let contactFlowTypeDecoded = try containerValues.decodeIfPresent(ContactFlowType.self, forKey: .contactFlowType)
        contactFlowType = contactFlowTypeDecoded
    }
}

extension ContactFlowSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContactFlowSummary(arn: \(String(describing: arn)), contactFlowType: \(String(describing: contactFlowType)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Contains summary information about a contact flow.</p>
///          <p>You can also create and update contact flows using the <a href="https://docs.aws.amazon.com/connect/latest/adminguide/flow-language.html">Amazon Connect
///    Flow language</a>.</p>
public struct ContactFlowSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact flow.</p>
    public let arn: String?
    /// <p>The type of contact flow.</p>
    public let contactFlowType: ContactFlowType?
    /// <p>The identifier of the contact flow.</p>
    public let id: String?
    /// <p>The name of the contact flow.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        contactFlowType: ContactFlowType? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.contactFlowType = contactFlowType
        self.id = id
        self.name = name
    }
}

public enum ContactFlowType {
    case agentHold
    case agentTransfer
    case agentWhisper
    case contactFlow
    case customerHold
    case customerQueue
    case customerWhisper
    case outboundWhisper
    case queueTransfer
    case sdkUnknown(String)
}

extension ContactFlowType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContactFlowType] {
        return [
            .agentHold,
            .agentTransfer,
            .agentWhisper,
            .contactFlow,
            .customerHold,
            .customerQueue,
            .customerWhisper,
            .outboundWhisper,
            .queueTransfer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .agentHold: return "AGENT_HOLD"
        case .agentTransfer: return "AGENT_TRANSFER"
        case .agentWhisper: return "AGENT_WHISPER"
        case .contactFlow: return "CONTACT_FLOW"
        case .customerHold: return "CUSTOMER_HOLD"
        case .customerQueue: return "CUSTOMER_QUEUE"
        case .customerWhisper: return "CUSTOMER_WHISPER"
        case .outboundWhisper: return "OUTBOUND_WHISPER"
        case .queueTransfer: return "QUEUE_TRANSFER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContactFlowType(rawValue: rawValue) ?? ContactFlowType.sdkUnknown(rawValue)
    }
}

extension ContactNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContactNotFoundException(message: \(String(describing: message)))"}
}

extension ContactNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ContactNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The contact with the specified ID is not active or does not exist.</p>
public struct ContactNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ContactNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ContactNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateContactFlowInputBodyMiddleware: Middleware {
    public let id: String = "CreateContactFlowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactFlowInput>
    public typealias MOutput = OperationOutput<CreateContactFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactFlowOutputError>
}

extension CreateContactFlowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateContactFlowInput(content: \(String(describing: content)), description: \(String(describing: description)), instanceId: \(String(describing: instanceId)), name: \(String(describing: name)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateContactFlowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateContactFlowInputHeadersMiddleware: Middleware {
    public let id: String = "CreateContactFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactFlowInput>
    public typealias MOutput = OperationOutput<CreateContactFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactFlowOutputError>
}

public struct CreateContactFlowInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateContactFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContactFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContactFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContactFlowInput>
    public typealias MOutput = OperationOutput<CreateContactFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContactFlowOutputError>
}

public struct CreateContactFlowInput: Equatable {
    /// <p>The content of the contact flow. </p>
    public let content: String?
    /// <p>The description of the contact flow. </p>
    public let description: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The name of the contact flow.</p>
    public let name: String?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?
    /// <p>The type of the contact flow. For descriptions of the available types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose a Contact Flow Type</a> in the <i>Amazon Connect Administrator
    ///    Guide</i>.</p>
    public let type: ContactFlowType?

    public init (
        content: String? = nil,
        description: String? = nil,
        instanceId: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil,
        type: ContactFlowType? = nil
    )
    {
        self.content = content
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.tags = tags
        self.type = type
    }
}

struct CreateContactFlowInputBody: Equatable {
    public let name: String?
    public let type: ContactFlowType?
    public let description: String?
    public let content: String?
    public let tags: [String:String]?
}

extension CreateContactFlowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ContactFlowType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateContactFlowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContactFlowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContactFlowException" : self = .invalidContactFlowException(try InvalidContactFlowException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContactFlowOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidContactFlowException(InvalidContactFlowException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContactFlowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateContactFlowOutputResponse(contactFlowArn: \(String(describing: contactFlowArn)), contactFlowId: \(String(describing: contactFlowId)))"}
}

extension CreateContactFlowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateContactFlowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contactFlowArn = output.contactFlowArn
            self.contactFlowId = output.contactFlowId
        } else {
            self.contactFlowArn = nil
            self.contactFlowId = nil
        }
    }
}

public struct CreateContactFlowOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the contact flow.</p>
    public let contactFlowArn: String?
    /// <p>The identifier of the contact flow.</p>
    public let contactFlowId: String?

    public init (
        contactFlowArn: String? = nil,
        contactFlowId: String? = nil
    )
    {
        self.contactFlowArn = contactFlowArn
        self.contactFlowId = contactFlowId
    }
}

struct CreateContactFlowOutputResponseBody: Equatable {
    public let contactFlowId: String?
    public let contactFlowArn: String?
}

extension CreateContactFlowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactFlowArn = "ContactFlowArn"
        case contactFlowId = "ContactFlowId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let contactFlowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactFlowArn)
        contactFlowArn = contactFlowArnDecoded
    }
}

public struct CreateInstanceInputBodyMiddleware: Middleware {
    public let id: String = "CreateInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInstanceInput>
    public typealias MOutput = OperationOutput<CreateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInstanceOutputError>
}

extension CreateInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInstanceInput(clientToken: \(String(describing: clientToken)), directoryId: \(String(describing: directoryId)), identityManagementType: \(String(describing: identityManagementType)), inboundCallsEnabled: \(String(describing: inboundCallsEnabled)), instanceAlias: \(String(describing: instanceAlias)), outboundCallsEnabled: \(String(describing: outboundCallsEnabled)))"}
}

extension CreateInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case directoryId = "DirectoryId"
        case identityManagementType = "IdentityManagementType"
        case inboundCallsEnabled = "InboundCallsEnabled"
        case instanceAlias = "InstanceAlias"
        case outboundCallsEnabled = "OutboundCallsEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let identityManagementType = identityManagementType {
            try encodeContainer.encode(identityManagementType.rawValue, forKey: .identityManagementType)
        }
        if let inboundCallsEnabled = inboundCallsEnabled {
            try encodeContainer.encode(inboundCallsEnabled, forKey: .inboundCallsEnabled)
        }
        if let instanceAlias = instanceAlias {
            try encodeContainer.encode(instanceAlias, forKey: .instanceAlias)
        }
        if let outboundCallsEnabled = outboundCallsEnabled {
            try encodeContainer.encode(outboundCallsEnabled, forKey: .outboundCallsEnabled)
        }
    }
}

public struct CreateInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInstanceInput>
    public typealias MOutput = OperationOutput<CreateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInstanceOutputError>
}

public struct CreateInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInstanceInput>
    public typealias MOutput = OperationOutput<CreateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInstanceOutputError>
}

public struct CreateInstanceInput: Equatable {
    /// <p>The idempotency token.</p>
    public let clientToken: String?
    /// <p>The identifier for the directory.</p>
    public let directoryId: String?
    /// <p>The type of identity management for your Amazon Connect users.</p>
    public let identityManagementType: DirectoryType?
    /// <p>Your contact center handles incoming contacts.</p>
    public let inboundCallsEnabled: Bool?
    /// <p>The name for your instance.</p>
    public let instanceAlias: String?
    /// <p>Your contact center allows outbound calls.</p>
    public let outboundCallsEnabled: Bool?

    public init (
        clientToken: String? = nil,
        directoryId: String? = nil,
        identityManagementType: DirectoryType? = nil,
        inboundCallsEnabled: Bool? = nil,
        instanceAlias: String? = nil,
        outboundCallsEnabled: Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.directoryId = directoryId
        self.identityManagementType = identityManagementType
        self.inboundCallsEnabled = inboundCallsEnabled
        self.instanceAlias = instanceAlias
        self.outboundCallsEnabled = outboundCallsEnabled
    }
}

struct CreateInstanceInputBody: Equatable {
    public let clientToken: String?
    public let identityManagementType: DirectoryType?
    public let instanceAlias: String?
    public let directoryId: String?
    public let inboundCallsEnabled: Bool?
    public let outboundCallsEnabled: Bool?
}

extension CreateInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case directoryId = "DirectoryId"
        case identityManagementType = "IdentityManagementType"
        case inboundCallsEnabled = "InboundCallsEnabled"
        case instanceAlias = "InstanceAlias"
        case outboundCallsEnabled = "OutboundCallsEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let identityManagementTypeDecoded = try containerValues.decodeIfPresent(DirectoryType.self, forKey: .identityManagementType)
        identityManagementType = identityManagementTypeDecoded
        let instanceAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceAlias)
        instanceAlias = instanceAliasDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let inboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .inboundCallsEnabled)
        inboundCallsEnabled = inboundCallsEnabledDecoded
        let outboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .outboundCallsEnabled)
        outboundCallsEnabled = outboundCallsEnabledDecoded
    }
}

extension CreateInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInstanceOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInstanceOutputResponse(arn: \(String(describing: arn)), id: \(String(describing: id)))"}
}

extension CreateInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateInstanceOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the instance.</p>
    public let arn: String?
    /// <p>The identifier for the instance.</p>
    public let id: String?

    public init (
        arn: String? = nil,
        id: String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateInstanceOutputResponseBody: Equatable {
    public let id: String?
    public let arn: String?
}

extension CreateInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct CreateIntegrationAssociationInputBodyMiddleware: Middleware {
    public let id: String = "CreateIntegrationAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIntegrationAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIntegrationAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIntegrationAssociationInput>
    public typealias MOutput = OperationOutput<CreateIntegrationAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIntegrationAssociationOutputError>
}

extension CreateIntegrationAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIntegrationAssociationInput(instanceId: \(String(describing: instanceId)), integrationArn: \(String(describing: integrationArn)), integrationType: \(String(describing: integrationType)), sourceApplicationName: \(String(describing: sourceApplicationName)), sourceApplicationUrl: \(String(describing: sourceApplicationUrl)), sourceType: \(String(describing: sourceType)), tags: \(String(describing: tags)))"}
}

extension CreateIntegrationAssociationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case integrationArn = "IntegrationArn"
        case integrationType = "IntegrationType"
        case sourceApplicationName = "SourceApplicationName"
        case sourceApplicationUrl = "SourceApplicationUrl"
        case sourceType = "SourceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let integrationArn = integrationArn {
            try encodeContainer.encode(integrationArn, forKey: .integrationArn)
        }
        if let integrationType = integrationType {
            try encodeContainer.encode(integrationType.rawValue, forKey: .integrationType)
        }
        if let sourceApplicationName = sourceApplicationName {
            try encodeContainer.encode(sourceApplicationName, forKey: .sourceApplicationName)
        }
        if let sourceApplicationUrl = sourceApplicationUrl {
            try encodeContainer.encode(sourceApplicationUrl, forKey: .sourceApplicationUrl)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateIntegrationAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateIntegrationAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIntegrationAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIntegrationAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIntegrationAssociationInput>
    public typealias MOutput = OperationOutput<CreateIntegrationAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIntegrationAssociationOutputError>
}

public struct CreateIntegrationAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateIntegrationAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIntegrationAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIntegrationAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIntegrationAssociationInput>
    public typealias MOutput = OperationOutput<CreateIntegrationAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIntegrationAssociationOutputError>
}

public struct CreateIntegrationAssociationInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The Amazon Resource Name (ARN) of the integration.</p>
    public let integrationArn: String?
    /// <p>The type of information to be ingested.</p>
    public let integrationType: IntegrationType?
    /// <p>The name of the external application.</p>
    public let sourceApplicationName: String?
    /// <p>The URL for the external application.</p>
    public let sourceApplicationUrl: String?
    /// <p>The type of the data source.</p>
    public let sourceType: SourceType?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?

    public init (
        instanceId: String? = nil,
        integrationArn: String? = nil,
        integrationType: IntegrationType? = nil,
        sourceApplicationName: String? = nil,
        sourceApplicationUrl: String? = nil,
        sourceType: SourceType? = nil,
        tags: [String:String]? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationArn = integrationArn
        self.integrationType = integrationType
        self.sourceApplicationName = sourceApplicationName
        self.sourceApplicationUrl = sourceApplicationUrl
        self.sourceType = sourceType
        self.tags = tags
    }
}

struct CreateIntegrationAssociationInputBody: Equatable {
    public let integrationType: IntegrationType?
    public let integrationArn: String?
    public let sourceApplicationUrl: String?
    public let sourceApplicationName: String?
    public let sourceType: SourceType?
    public let tags: [String:String]?
}

extension CreateIntegrationAssociationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case integrationArn = "IntegrationArn"
        case integrationType = "IntegrationType"
        case sourceApplicationName = "SourceApplicationName"
        case sourceApplicationUrl = "SourceApplicationUrl"
        case sourceType = "SourceType"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integrationTypeDecoded = try containerValues.decodeIfPresent(IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationArn)
        integrationArn = integrationArnDecoded
        let sourceApplicationUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceApplicationUrl)
        sourceApplicationUrl = sourceApplicationUrlDecoded
        let sourceApplicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceApplicationName)
        sourceApplicationName = sourceApplicationNameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIntegrationAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIntegrationAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIntegrationAssociationOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIntegrationAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIntegrationAssociationOutputResponse(integrationAssociationArn: \(String(describing: integrationAssociationArn)), integrationAssociationId: \(String(describing: integrationAssociationId)))"}
}

extension CreateIntegrationAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateIntegrationAssociationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.integrationAssociationArn = output.integrationAssociationArn
            self.integrationAssociationId = output.integrationAssociationId
        } else {
            self.integrationAssociationArn = nil
            self.integrationAssociationId = nil
        }
    }
}

public struct CreateIntegrationAssociationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the association.</p>
    public let integrationAssociationArn: String?
    /// <p>The identifier for the association.</p>
    public let integrationAssociationId: String?

    public init (
        integrationAssociationArn: String? = nil,
        integrationAssociationId: String? = nil
    )
    {
        self.integrationAssociationArn = integrationAssociationArn
        self.integrationAssociationId = integrationAssociationId
    }
}

struct CreateIntegrationAssociationOutputResponseBody: Equatable {
    public let integrationAssociationId: String?
    public let integrationAssociationArn: String?
}

extension CreateIntegrationAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case integrationAssociationArn = "IntegrationAssociationArn"
        case integrationAssociationId = "IntegrationAssociationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integrationAssociationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationAssociationId)
        integrationAssociationId = integrationAssociationIdDecoded
        let integrationAssociationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationAssociationArn)
        integrationAssociationArn = integrationAssociationArnDecoded
    }
}

public struct CreateQueueInputBodyMiddleware: Middleware {
    public let id: String = "CreateQueueInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateQueueInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateQueueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateQueueInput>
    public typealias MOutput = OperationOutput<CreateQueueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateQueueOutputError>
}

extension CreateQueueInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateQueueInput(description: \(String(describing: description)), hoursOfOperationId: \(String(describing: hoursOfOperationId)), instanceId: \(String(describing: instanceId)), maxContacts: \(String(describing: maxContacts)), name: \(String(describing: name)), outboundCallerConfig: \(String(describing: outboundCallerConfig)), quickConnectIds: \(String(describing: quickConnectIds)), tags: \(String(describing: tags)))"}
}

extension CreateQueueInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case hoursOfOperationId = "HoursOfOperationId"
        case maxContacts = "MaxContacts"
        case name = "Name"
        case outboundCallerConfig = "OutboundCallerConfig"
        case quickConnectIds = "QuickConnectIds"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hoursOfOperationId = hoursOfOperationId {
            try encodeContainer.encode(hoursOfOperationId, forKey: .hoursOfOperationId)
        }
        if maxContacts != 0 {
            try encodeContainer.encode(maxContacts, forKey: .maxContacts)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outboundCallerConfig = outboundCallerConfig {
            try encodeContainer.encode(outboundCallerConfig, forKey: .outboundCallerConfig)
        }
        if let quickConnectIds = quickConnectIds {
            var quickConnectIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .quickConnectIds)
            for quickconnectslist0 in quickConnectIds {
                try quickConnectIdsContainer.encode(quickconnectslist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateQueueInputHeadersMiddleware: Middleware {
    public let id: String = "CreateQueueInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateQueueInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateQueueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateQueueInput>
    public typealias MOutput = OperationOutput<CreateQueueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateQueueOutputError>
}

public struct CreateQueueInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateQueueInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateQueueInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateQueueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateQueueInput>
    public typealias MOutput = OperationOutput<CreateQueueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateQueueOutputError>
}

public struct CreateQueueInput: Equatable {
    /// <p>The description of the queue.</p>
    public let description: String?
    /// <p>The identifier for the hours of operation.</p>
    public let hoursOfOperationId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
    public let maxContacts: Int
    /// <p>The name of the queue.</p>
    public let name: String?
    /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
    public let outboundCallerConfig: OutboundCallerConfig?
    /// <p>The quick connects available to agents who are working the queue.</p>
    public let quickConnectIds: [String]?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        hoursOfOperationId: String? = nil,
        instanceId: String? = nil,
        maxContacts: Int = 0,
        name: String? = nil,
        outboundCallerConfig: OutboundCallerConfig? = nil,
        quickConnectIds: [String]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
        self.maxContacts = maxContacts
        self.name = name
        self.outboundCallerConfig = outboundCallerConfig
        self.quickConnectIds = quickConnectIds
        self.tags = tags
    }
}

struct CreateQueueInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let outboundCallerConfig: OutboundCallerConfig?
    public let hoursOfOperationId: String?
    public let maxContacts: Int
    public let quickConnectIds: [String]?
    public let tags: [String:String]?
}

extension CreateQueueInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case hoursOfOperationId = "HoursOfOperationId"
        case maxContacts = "MaxContacts"
        case name = "Name"
        case outboundCallerConfig = "OutboundCallerConfig"
        case quickConnectIds = "QuickConnectIds"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let outboundCallerConfigDecoded = try containerValues.decodeIfPresent(OutboundCallerConfig.self, forKey: .outboundCallerConfig)
        outboundCallerConfig = outboundCallerConfigDecoded
        let hoursOfOperationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hoursOfOperationId)
        hoursOfOperationId = hoursOfOperationIdDecoded
        let maxContactsDecoded = try containerValues.decode(Int.self, forKey: .maxContacts)
        maxContacts = maxContactsDecoded
        let quickConnectIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .quickConnectIds)
        var quickConnectIdsDecoded0:[String]? = nil
        if let quickConnectIdsContainer = quickConnectIdsContainer {
            quickConnectIdsDecoded0 = [String]()
            for string0 in quickConnectIdsContainer {
                if let string0 = string0 {
                    quickConnectIdsDecoded0?.append(string0)
                }
            }
        }
        quickConnectIds = quickConnectIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateQueueOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateQueueOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateQueueOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateQueueOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateQueueOutputResponse(queueArn: \(String(describing: queueArn)), queueId: \(String(describing: queueId)))"}
}

extension CreateQueueOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateQueueOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.queueArn = output.queueArn
            self.queueId = output.queueId
        } else {
            self.queueArn = nil
            self.queueId = nil
        }
    }
}

public struct CreateQueueOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the queue.</p>
    public let queueArn: String?
    /// <p>The identifier for the queue.</p>
    public let queueId: String?

    public init (
        queueArn: String? = nil,
        queueId: String? = nil
    )
    {
        self.queueArn = queueArn
        self.queueId = queueId
    }
}

struct CreateQueueOutputResponseBody: Equatable {
    public let queueArn: String?
    public let queueId: String?
}

extension CreateQueueOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case queueArn = "QueueArn"
        case queueId = "QueueId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queueArn)
        queueArn = queueArnDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queueId)
        queueId = queueIdDecoded
    }
}

public struct CreateQuickConnectInputBodyMiddleware: Middleware {
    public let id: String = "CreateQuickConnectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateQuickConnectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateQuickConnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateQuickConnectInput>
    public typealias MOutput = OperationOutput<CreateQuickConnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateQuickConnectOutputError>
}

extension CreateQuickConnectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateQuickConnectInput(description: \(String(describing: description)), instanceId: \(String(describing: instanceId)), name: \(String(describing: name)), quickConnectConfig: \(String(describing: quickConnectConfig)), tags: \(String(describing: tags)))"}
}

extension CreateQuickConnectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case quickConnectConfig = "QuickConnectConfig"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quickConnectConfig = quickConnectConfig {
            try encodeContainer.encode(quickConnectConfig, forKey: .quickConnectConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateQuickConnectInputHeadersMiddleware: Middleware {
    public let id: String = "CreateQuickConnectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateQuickConnectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateQuickConnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateQuickConnectInput>
    public typealias MOutput = OperationOutput<CreateQuickConnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateQuickConnectOutputError>
}

public struct CreateQuickConnectInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateQuickConnectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateQuickConnectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateQuickConnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateQuickConnectInput>
    public typealias MOutput = OperationOutput<CreateQuickConnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateQuickConnectOutputError>
}

public struct CreateQuickConnectInput: Equatable {
    /// <p>The description of the quick connect.</p>
    public let description: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The name of the quick connect.</p>
    public let name: String?
    /// <p>Configuration settings for the quick connect.</p>
    public let quickConnectConfig: QuickConnectConfig?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        instanceId: String? = nil,
        name: String? = nil,
        quickConnectConfig: QuickConnectConfig? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.quickConnectConfig = quickConnectConfig
        self.tags = tags
    }
}

struct CreateQuickConnectInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let quickConnectConfig: QuickConnectConfig?
    public let tags: [String:String]?
}

extension CreateQuickConnectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case quickConnectConfig = "QuickConnectConfig"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let quickConnectConfigDecoded = try containerValues.decodeIfPresent(QuickConnectConfig.self, forKey: .quickConnectConfig)
        quickConnectConfig = quickConnectConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateQuickConnectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateQuickConnectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateQuickConnectOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateQuickConnectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateQuickConnectOutputResponse(quickConnectARN: \(String(describing: quickConnectARN)), quickConnectId: \(String(describing: quickConnectId)))"}
}

extension CreateQuickConnectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateQuickConnectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.quickConnectARN = output.quickConnectARN
            self.quickConnectId = output.quickConnectId
        } else {
            self.quickConnectARN = nil
            self.quickConnectId = nil
        }
    }
}

public struct CreateQuickConnectOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the quick connect. </p>
    public let quickConnectARN: String?
    /// <p>The identifier for the quick connect.</p>
    public let quickConnectId: String?

    public init (
        quickConnectARN: String? = nil,
        quickConnectId: String? = nil
    )
    {
        self.quickConnectARN = quickConnectARN
        self.quickConnectId = quickConnectId
    }
}

struct CreateQuickConnectOutputResponseBody: Equatable {
    public let quickConnectARN: String?
    public let quickConnectId: String?
}

extension CreateQuickConnectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case quickConnectARN = "QuickConnectARN"
        case quickConnectId = "QuickConnectId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quickConnectARN)
        quickConnectARN = quickConnectARNDecoded
        let quickConnectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quickConnectId)
        quickConnectId = quickConnectIdDecoded
    }
}

public struct CreateRoutingProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateRoutingProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRoutingProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRoutingProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRoutingProfileInput>
    public typealias MOutput = OperationOutput<CreateRoutingProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRoutingProfileOutputError>
}

extension CreateRoutingProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRoutingProfileInput(defaultOutboundQueueId: \(String(describing: defaultOutboundQueueId)), description: \(String(describing: description)), instanceId: \(String(describing: instanceId)), mediaConcurrencies: \(String(describing: mediaConcurrencies)), name: \(String(describing: name)), queueConfigs: \(String(describing: queueConfigs)), tags: \(String(describing: tags)))"}
}

extension CreateRoutingProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultOutboundQueueId = "DefaultOutboundQueueId"
        case description = "Description"
        case mediaConcurrencies = "MediaConcurrencies"
        case name = "Name"
        case queueConfigs = "QueueConfigs"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultOutboundQueueId = defaultOutboundQueueId {
            try encodeContainer.encode(defaultOutboundQueueId, forKey: .defaultOutboundQueueId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mediaConcurrencies = mediaConcurrencies {
            var mediaConcurrenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaConcurrencies)
            for mediaconcurrencies0 in mediaConcurrencies {
                try mediaConcurrenciesContainer.encode(mediaconcurrencies0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queueConfigs = queueConfigs {
            var queueConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queueConfigs)
            for routingprofilequeueconfiglist0 in queueConfigs {
                try queueConfigsContainer.encode(routingprofilequeueconfiglist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRoutingProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRoutingProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRoutingProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRoutingProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRoutingProfileInput>
    public typealias MOutput = OperationOutput<CreateRoutingProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRoutingProfileOutputError>
}

public struct CreateRoutingProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRoutingProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRoutingProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRoutingProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRoutingProfileInput>
    public typealias MOutput = OperationOutput<CreateRoutingProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRoutingProfileOutputError>
}

public struct CreateRoutingProfileInput: Equatable {
    /// <p>The default outbound queue for the routing profile.</p>
    public let defaultOutboundQueueId: String?
    /// <p>Description of the routing profile. Must not be more than 250 characters.</p>
    public let description: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The channels that agents can handle in the Contact Control Panel (CCP) for this routing
    ///    profile.</p>
    public let mediaConcurrencies: [MediaConcurrency]?
    /// <p>The name of the routing profile. Must not be more than 127 characters.</p>
    public let name: String?
    /// <p>The inbound queues associated with the routing profile. If no queue is added, the agent can
    ///    make only outbound calls.</p>
    public let queueConfigs: [RoutingProfileQueueConfig]?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?

    public init (
        defaultOutboundQueueId: String? = nil,
        description: String? = nil,
        instanceId: String? = nil,
        mediaConcurrencies: [MediaConcurrency]? = nil,
        name: String? = nil,
        queueConfigs: [RoutingProfileQueueConfig]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.defaultOutboundQueueId = defaultOutboundQueueId
        self.description = description
        self.instanceId = instanceId
        self.mediaConcurrencies = mediaConcurrencies
        self.name = name
        self.queueConfigs = queueConfigs
        self.tags = tags
    }
}

struct CreateRoutingProfileInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let defaultOutboundQueueId: String?
    public let queueConfigs: [RoutingProfileQueueConfig]?
    public let mediaConcurrencies: [MediaConcurrency]?
    public let tags: [String:String]?
}

extension CreateRoutingProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultOutboundQueueId = "DefaultOutboundQueueId"
        case description = "Description"
        case mediaConcurrencies = "MediaConcurrencies"
        case name = "Name"
        case queueConfigs = "QueueConfigs"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let defaultOutboundQueueIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultOutboundQueueId)
        defaultOutboundQueueId = defaultOutboundQueueIdDecoded
        let queueConfigsContainer = try containerValues.decodeIfPresent([RoutingProfileQueueConfig?].self, forKey: .queueConfigs)
        var queueConfigsDecoded0:[RoutingProfileQueueConfig]? = nil
        if let queueConfigsContainer = queueConfigsContainer {
            queueConfigsDecoded0 = [RoutingProfileQueueConfig]()
            for structure0 in queueConfigsContainer {
                if let structure0 = structure0 {
                    queueConfigsDecoded0?.append(structure0)
                }
            }
        }
        queueConfigs = queueConfigsDecoded0
        let mediaConcurrenciesContainer = try containerValues.decodeIfPresent([MediaConcurrency?].self, forKey: .mediaConcurrencies)
        var mediaConcurrenciesDecoded0:[MediaConcurrency]? = nil
        if let mediaConcurrenciesContainer = mediaConcurrenciesContainer {
            mediaConcurrenciesDecoded0 = [MediaConcurrency]()
            for structure0 in mediaConcurrenciesContainer {
                if let structure0 = structure0 {
                    mediaConcurrenciesDecoded0?.append(structure0)
                }
            }
        }
        mediaConcurrencies = mediaConcurrenciesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRoutingProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRoutingProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRoutingProfileOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRoutingProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRoutingProfileOutputResponse(routingProfileArn: \(String(describing: routingProfileArn)), routingProfileId: \(String(describing: routingProfileId)))"}
}

extension CreateRoutingProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRoutingProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.routingProfileArn = output.routingProfileArn
            self.routingProfileId = output.routingProfileId
        } else {
            self.routingProfileArn = nil
            self.routingProfileId = nil
        }
    }
}

public struct CreateRoutingProfileOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
    public let routingProfileArn: String?
    /// <p>The identifier of the routing profile.</p>
    public let routingProfileId: String?

    public init (
        routingProfileArn: String? = nil,
        routingProfileId: String? = nil
    )
    {
        self.routingProfileArn = routingProfileArn
        self.routingProfileId = routingProfileId
    }
}

struct CreateRoutingProfileOutputResponseBody: Equatable {
    public let routingProfileArn: String?
    public let routingProfileId: String?
}

extension CreateRoutingProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case routingProfileArn = "RoutingProfileArn"
        case routingProfileId = "RoutingProfileId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routingProfileArn)
        routingProfileArn = routingProfileArnDecoded
        let routingProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routingProfileId)
        routingProfileId = routingProfileIdDecoded
    }
}

public struct CreateUseCaseInputBodyMiddleware: Middleware {
    public let id: String = "CreateUseCaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUseCaseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUseCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUseCaseInput>
    public typealias MOutput = OperationOutput<CreateUseCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUseCaseOutputError>
}

extension CreateUseCaseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUseCaseInput(instanceId: \(String(describing: instanceId)), integrationAssociationId: \(String(describing: integrationAssociationId)), tags: \(String(describing: tags)), useCaseType: \(String(describing: useCaseType)))"}
}

extension CreateUseCaseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
        case useCaseType = "UseCaseType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let useCaseType = useCaseType {
            try encodeContainer.encode(useCaseType.rawValue, forKey: .useCaseType)
        }
    }
}

public struct CreateUseCaseInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUseCaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUseCaseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUseCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUseCaseInput>
    public typealias MOutput = OperationOutput<CreateUseCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUseCaseOutputError>
}

public struct CreateUseCaseInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUseCaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUseCaseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUseCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUseCaseInput>
    public typealias MOutput = OperationOutput<CreateUseCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUseCaseOutputError>
}

public struct CreateUseCaseInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier for the AppIntegration association.</p>
    public let integrationAssociationId: String?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?
    /// <p>The type of use case to associate to the AppIntegration association. Each AppIntegration
    ///    association can have only one of each use case type.</p>
    public let useCaseType: UseCaseType?

    public init (
        instanceId: String? = nil,
        integrationAssociationId: String? = nil,
        tags: [String:String]? = nil,
        useCaseType: UseCaseType? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationAssociationId = integrationAssociationId
        self.tags = tags
        self.useCaseType = useCaseType
    }
}

struct CreateUseCaseInputBody: Equatable {
    public let useCaseType: UseCaseType?
    public let tags: [String:String]?
}

extension CreateUseCaseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
        case useCaseType = "UseCaseType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let useCaseTypeDecoded = try containerValues.decodeIfPresent(UseCaseType.self, forKey: .useCaseType)
        useCaseType = useCaseTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateUseCaseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUseCaseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUseCaseOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUseCaseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUseCaseOutputResponse(useCaseArn: \(String(describing: useCaseArn)), useCaseId: \(String(describing: useCaseId)))"}
}

extension CreateUseCaseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUseCaseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.useCaseArn = output.useCaseArn
            self.useCaseId = output.useCaseId
        } else {
            self.useCaseArn = nil
            self.useCaseId = nil
        }
    }
}

public struct CreateUseCaseOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the use case.</p>
    public let useCaseArn: String?
    /// <p>The identifier of the use case.</p>
    public let useCaseId: String?

    public init (
        useCaseArn: String? = nil,
        useCaseId: String? = nil
    )
    {
        self.useCaseArn = useCaseArn
        self.useCaseId = useCaseId
    }
}

struct CreateUseCaseOutputResponseBody: Equatable {
    public let useCaseId: String?
    public let useCaseArn: String?
}

extension CreateUseCaseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case useCaseArn = "UseCaseArn"
        case useCaseId = "UseCaseId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let useCaseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .useCaseId)
        useCaseId = useCaseIdDecoded
        let useCaseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .useCaseArn)
        useCaseArn = useCaseArnDecoded
    }
}

public struct CreateUserHierarchyGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateUserHierarchyGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserHierarchyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserHierarchyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserHierarchyGroupInput>
    public typealias MOutput = OperationOutput<CreateUserHierarchyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserHierarchyGroupOutputError>
}

extension CreateUserHierarchyGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserHierarchyGroupInput(instanceId: \(String(describing: instanceId)), name: \(String(describing: name)), parentGroupId: \(String(describing: parentGroupId)))"}
}

extension CreateUserHierarchyGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case parentGroupId = "ParentGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentGroupId = parentGroupId {
            try encodeContainer.encode(parentGroupId, forKey: .parentGroupId)
        }
    }
}

public struct CreateUserHierarchyGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUserHierarchyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserHierarchyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserHierarchyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserHierarchyGroupInput>
    public typealias MOutput = OperationOutput<CreateUserHierarchyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserHierarchyGroupOutputError>
}

public struct CreateUserHierarchyGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUserHierarchyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserHierarchyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserHierarchyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserHierarchyGroupInput>
    public typealias MOutput = OperationOutput<CreateUserHierarchyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserHierarchyGroupOutputError>
}

public struct CreateUserHierarchyGroupInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The name of the user hierarchy group. Must not be more than 100 characters.</p>
    public let name: String?
    /// <p>The identifier for the parent hierarchy group. The user hierarchy is created at level one if
    ///    the parent group ID is null.</p>
    public let parentGroupId: String?

    public init (
        instanceId: String? = nil,
        name: String? = nil,
        parentGroupId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.name = name
        self.parentGroupId = parentGroupId
    }
}

struct CreateUserHierarchyGroupInputBody: Equatable {
    public let name: String?
    public let parentGroupId: String?
}

extension CreateUserHierarchyGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case parentGroupId = "ParentGroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let parentGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentGroupId)
        parentGroupId = parentGroupIdDecoded
    }
}

extension CreateUserHierarchyGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserHierarchyGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserHierarchyGroupOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserHierarchyGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserHierarchyGroupOutputResponse(hierarchyGroupArn: \(String(describing: hierarchyGroupArn)), hierarchyGroupId: \(String(describing: hierarchyGroupId)))"}
}

extension CreateUserHierarchyGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUserHierarchyGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hierarchyGroupArn = output.hierarchyGroupArn
            self.hierarchyGroupId = output.hierarchyGroupId
        } else {
            self.hierarchyGroupArn = nil
            self.hierarchyGroupId = nil
        }
    }
}

public struct CreateUserHierarchyGroupOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the hierarchy group. </p>
    public let hierarchyGroupArn: String?
    /// <p>The identifier of the hierarchy group.</p>
    public let hierarchyGroupId: String?

    public init (
        hierarchyGroupArn: String? = nil,
        hierarchyGroupId: String? = nil
    )
    {
        self.hierarchyGroupArn = hierarchyGroupArn
        self.hierarchyGroupId = hierarchyGroupId
    }
}

struct CreateUserHierarchyGroupOutputResponseBody: Equatable {
    public let hierarchyGroupId: String?
    public let hierarchyGroupArn: String?
}

extension CreateUserHierarchyGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hierarchyGroupArn = "HierarchyGroupArn"
        case hierarchyGroupId = "HierarchyGroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hierarchyGroupId)
        hierarchyGroupId = hierarchyGroupIdDecoded
        let hierarchyGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hierarchyGroupArn)
        hierarchyGroupArn = hierarchyGroupArnDecoded
    }
}

public struct CreateUserInputBodyMiddleware: Middleware {
    public let id: String = "CreateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

extension CreateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserInput(directoryUserId: \(String(describing: directoryUserId)), hierarchyGroupId: \(String(describing: hierarchyGroupId)), identityInfo: \(String(describing: identityInfo)), instanceId: \(String(describing: instanceId)), password: \(String(describing: password)), phoneConfig: \(String(describing: phoneConfig)), routingProfileId: \(String(describing: routingProfileId)), securityProfileIds: \(String(describing: securityProfileIds)), tags: \(String(describing: tags)), username: \(String(describing: username)))"}
}

extension CreateUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryUserId = "DirectoryUserId"
        case hierarchyGroupId = "HierarchyGroupId"
        case identityInfo = "IdentityInfo"
        case password = "Password"
        case phoneConfig = "PhoneConfig"
        case routingProfileId = "RoutingProfileId"
        case securityProfileIds = "SecurityProfileIds"
        case tags = "Tags"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryUserId = directoryUserId {
            try encodeContainer.encode(directoryUserId, forKey: .directoryUserId)
        }
        if let hierarchyGroupId = hierarchyGroupId {
            try encodeContainer.encode(hierarchyGroupId, forKey: .hierarchyGroupId)
        }
        if let identityInfo = identityInfo {
            try encodeContainer.encode(identityInfo, forKey: .identityInfo)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let phoneConfig = phoneConfig {
            try encodeContainer.encode(phoneConfig, forKey: .phoneConfig)
        }
        if let routingProfileId = routingProfileId {
            try encodeContainer.encode(routingProfileId, forKey: .routingProfileId)
        }
        if let securityProfileIds = securityProfileIds {
            var securityProfileIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityProfileIds)
            for securityprofileids0 in securityProfileIds {
                try securityProfileIdsContainer.encode(securityprofileids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct CreateUserInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

public struct CreateUserInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

public struct CreateUserInput: Equatable {
    /// <p>The identifier of the user account in the directory used for identity management. If Amazon Connect
    ///    cannot access the directory, you can specify this identifier to authenticate users. If you
    ///    include the identifier, we assume that Amazon Connect cannot access the directory. Otherwise, the identity
    ///    information is used to authenticate users from your directory.</p>
    ///          <p>This parameter is required if you are using an existing directory for identity management in
    ///    Amazon Connect when Amazon Connect cannot access your directory to authenticate users. If you are using SAML for
    ///    identity management and include this parameter, an error is returned.</p>
    public let directoryUserId: String?
    /// <p>The identifier of the hierarchy group for the user.</p>
    public let hierarchyGroupId: String?
    /// <p>The information about the identity of the user.</p>
    public let identityInfo: UserIdentityInfo?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The password for the user account. A password is required if you are using Amazon Connect for
    ///    identity management. Otherwise, it is an error to include a password.</p>
    public let password: String?
    /// <p>The phone settings for the user.</p>
    public let phoneConfig: UserPhoneConfig?
    /// <p>The identifier of the routing profile for the user.</p>
    public let routingProfileId: String?
    /// <p>The identifier of the security profile for the user.</p>
    public let securityProfileIds: [String]?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?
    /// <p>The user name for the account. For instances not using SAML for identity management, the
    ///    user name can include up to 20 characters. If you are using SAML for identity management, the
    ///    user name can include up to 64 characters from [a-zA-Z0-9_-.\@]+.</p>
    public let username: String?

    public init (
        directoryUserId: String? = nil,
        hierarchyGroupId: String? = nil,
        identityInfo: UserIdentityInfo? = nil,
        instanceId: String? = nil,
        password: String? = nil,
        phoneConfig: UserPhoneConfig? = nil,
        routingProfileId: String? = nil,
        securityProfileIds: [String]? = nil,
        tags: [String:String]? = nil,
        username: String? = nil
    )
    {
        self.directoryUserId = directoryUserId
        self.hierarchyGroupId = hierarchyGroupId
        self.identityInfo = identityInfo
        self.instanceId = instanceId
        self.password = password
        self.phoneConfig = phoneConfig
        self.routingProfileId = routingProfileId
        self.securityProfileIds = securityProfileIds
        self.tags = tags
        self.username = username
    }
}

struct CreateUserInputBody: Equatable {
    public let username: String?
    public let password: String?
    public let identityInfo: UserIdentityInfo?
    public let phoneConfig: UserPhoneConfig?
    public let directoryUserId: String?
    public let securityProfileIds: [String]?
    public let routingProfileId: String?
    public let hierarchyGroupId: String?
    public let tags: [String:String]?
}

extension CreateUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryUserId = "DirectoryUserId"
        case hierarchyGroupId = "HierarchyGroupId"
        case identityInfo = "IdentityInfo"
        case password = "Password"
        case phoneConfig = "PhoneConfig"
        case routingProfileId = "RoutingProfileId"
        case securityProfileIds = "SecurityProfileIds"
        case tags = "Tags"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let identityInfoDecoded = try containerValues.decodeIfPresent(UserIdentityInfo.self, forKey: .identityInfo)
        identityInfo = identityInfoDecoded
        let phoneConfigDecoded = try containerValues.decodeIfPresent(UserPhoneConfig.self, forKey: .phoneConfig)
        phoneConfig = phoneConfigDecoded
        let directoryUserIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryUserId)
        directoryUserId = directoryUserIdDecoded
        let securityProfileIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityProfileIds)
        var securityProfileIdsDecoded0:[String]? = nil
        if let securityProfileIdsContainer = securityProfileIdsContainer {
            securityProfileIdsDecoded0 = [String]()
            for string0 in securityProfileIdsContainer {
                if let string0 = string0 {
                    securityProfileIdsDecoded0?.append(string0)
                }
            }
        }
        securityProfileIds = securityProfileIdsDecoded0
        let routingProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routingProfileId)
        routingProfileId = routingProfileIdDecoded
        let hierarchyGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hierarchyGroupId)
        hierarchyGroupId = hierarchyGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserOutputResponse(userArn: \(String(describing: userArn)), userId: \(String(describing: userId)))"}
}

extension CreateUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userArn = output.userArn
            self.userId = output.userId
        } else {
            self.userArn = nil
            self.userId = nil
        }
    }
}

public struct CreateUserOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the user account.</p>
    public let userArn: String?
    /// <p>The identifier of the user account.</p>
    public let userId: String?

    public init (
        userArn: String? = nil,
        userId: String? = nil
    )
    {
        self.userArn = userArn
        self.userId = userId
    }
}

struct CreateUserOutputResponseBody: Equatable {
    public let userId: String?
    public let userArn: String?
}

extension CreateUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userArn = "UserArn"
        case userId = "UserId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension Credentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case accessTokenExpiration = "AccessTokenExpiration"
        case refreshToken = "RefreshToken"
        case refreshTokenExpiration = "RefreshTokenExpiration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let accessTokenExpiration = accessTokenExpiration {
            try encodeContainer.encode(accessTokenExpiration.timeIntervalSince1970, forKey: .accessTokenExpiration)
        }
        if let refreshToken = refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
        if let refreshTokenExpiration = refreshTokenExpiration {
            try encodeContainer.encode(refreshTokenExpiration.timeIntervalSince1970, forKey: .refreshTokenExpiration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let accessTokenExpirationDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .accessTokenExpiration)
        accessTokenExpiration = accessTokenExpirationDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let refreshTokenExpirationDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .refreshTokenExpiration)
        refreshTokenExpiration = refreshTokenExpirationDecoded
    }
}

extension Credentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Credentials(accessToken: \(String(describing: accessToken)), accessTokenExpiration: \(String(describing: accessTokenExpiration)), refreshToken: \(String(describing: refreshToken)), refreshTokenExpiration: \(String(describing: refreshTokenExpiration)))"}
}

/// <p>Contains credentials to use for federation.</p>
public struct Credentials: Equatable {
    /// <p>An access token generated for a federated user to access Amazon Connect.</p>
    public let accessToken: String?
    /// <p>A token generated with an expiration time for the session a user is logged in to
    ///    Amazon Connect.</p>
    public let accessTokenExpiration: Date?
    /// <p>Renews a token generated for a user to access the Amazon Connect instance.</p>
    public let refreshToken: String?
    /// <p>Renews the expiration timer for a generated token.</p>
    public let refreshTokenExpiration: Date?

    public init (
        accessToken: String? = nil,
        accessTokenExpiration: Date? = nil,
        refreshToken: String? = nil,
        refreshTokenExpiration: Date? = nil
    )
    {
        self.accessToken = accessToken
        self.accessTokenExpiration = accessTokenExpiration
        self.refreshToken = refreshToken
        self.refreshTokenExpiration = refreshTokenExpiration
    }
}

extension CurrentMetric: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case unit = "Unit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(CurrentMetricName.self, forKey: .name)
        name = nameDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Unit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension CurrentMetric: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CurrentMetric(name: \(String(describing: name)), unit: \(String(describing: unit)))"}
}

/// <p>Contains information about a real-time metric. For a description of each metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html">Real-time Metrics Definitions</a> in the <i>Amazon Connect Administrator
///    Guide</i>.</p>
public struct CurrentMetric: Equatable {
    /// <p>The name of the metric.</p>
    public let name: CurrentMetricName?
    /// <p>The unit for the metric.</p>
    public let unit: Unit?

    public init (
        name: CurrentMetricName? = nil,
        unit: Unit? = nil
    )
    {
        self.name = name
        self.unit = unit
    }
}

extension CurrentMetricData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metric = "Metric"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(CurrentMetric.self, forKey: .metric)
        metric = metricDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension CurrentMetricData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CurrentMetricData(metric: \(String(describing: metric)), value: \(String(describing: value)))"}
}

/// <p>Contains the data for a real-time metric.</p>
public struct CurrentMetricData: Equatable {
    /// <p>Information about the metric.</p>
    public let metric: CurrentMetric?
    /// <p>The value of the metric.</p>
    public let value: Double?

    public init (
        metric: CurrentMetric? = nil,
        value: Double? = nil
    )
    {
        self.metric = metric
        self.value = value
    }
}

/// <p>The current metric names.</p>
public enum CurrentMetricName {
    case agentsAfterContactWork
    case agentsAvailable
    case agentsError
    case agentsNonProductive
    case agentsOnline
    case agentsOnCall
    case agentsOnContact
    case agentsStaffed
    case contactsInQueue
    case contactsScheduled
    case oldestContactAge
    case slotsActive
    case slotsAvailable
    case sdkUnknown(String)
}

extension CurrentMetricName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CurrentMetricName] {
        return [
            .agentsAfterContactWork,
            .agentsAvailable,
            .agentsError,
            .agentsNonProductive,
            .agentsOnline,
            .agentsOnCall,
            .agentsOnContact,
            .agentsStaffed,
            .contactsInQueue,
            .contactsScheduled,
            .oldestContactAge,
            .slotsActive,
            .slotsAvailable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .agentsAfterContactWork: return "AGENTS_AFTER_CONTACT_WORK"
        case .agentsAvailable: return "AGENTS_AVAILABLE"
        case .agentsError: return "AGENTS_ERROR"
        case .agentsNonProductive: return "AGENTS_NON_PRODUCTIVE"
        case .agentsOnline: return "AGENTS_ONLINE"
        case .agentsOnCall: return "AGENTS_ON_CALL"
        case .agentsOnContact: return "AGENTS_ON_CONTACT"
        case .agentsStaffed: return "AGENTS_STAFFED"
        case .contactsInQueue: return "CONTACTS_IN_QUEUE"
        case .contactsScheduled: return "CONTACTS_SCHEDULED"
        case .oldestContactAge: return "OLDEST_CONTACT_AGE"
        case .slotsActive: return "SLOTS_ACTIVE"
        case .slotsAvailable: return "SLOTS_AVAILABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CurrentMetricName(rawValue: rawValue) ?? CurrentMetricName.sdkUnknown(rawValue)
    }
}

extension CurrentMetricResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case collections = "Collections"
        case dimensions = "Dimensions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collections = collections {
            var collectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .collections)
            for currentmetricdatacollections0 in collections {
                try collectionsContainer.encode(currentmetricdatacollections0)
            }
        }
        if let dimensions = dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsDecoded = try containerValues.decodeIfPresent(Dimensions.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let collectionsContainer = try containerValues.decodeIfPresent([CurrentMetricData?].self, forKey: .collections)
        var collectionsDecoded0:[CurrentMetricData]? = nil
        if let collectionsContainer = collectionsContainer {
            collectionsDecoded0 = [CurrentMetricData]()
            for structure0 in collectionsContainer {
                if let structure0 = structure0 {
                    collectionsDecoded0?.append(structure0)
                }
            }
        }
        collections = collectionsDecoded0
    }
}

extension CurrentMetricResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CurrentMetricResult(collections: \(String(describing: collections)), dimensions: \(String(describing: dimensions)))"}
}

/// <p>Contains information about a set of real-time metrics.</p>
public struct CurrentMetricResult: Equatable {
    /// <p>The set of metrics.</p>
    public let collections: [CurrentMetricData]?
    /// <p>The dimensions for the metrics.</p>
    public let dimensions: Dimensions?

    public init (
        collections: [CurrentMetricData]? = nil,
        dimensions: Dimensions? = nil
    )
    {
        self.collections = collections
        self.dimensions = dimensions
    }
}

extension DeleteInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInstanceInput(instanceId: \(String(describing: instanceId)))"}
}

extension DeleteInstanceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstanceInput>
    public typealias MOutput = OperationOutput<DeleteInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstanceOutputError>
}

public struct DeleteInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstanceInput>
    public typealias MOutput = OperationOutput<DeleteInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstanceOutputError>
}

public struct DeleteInstanceInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        instanceId: String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct DeleteInstanceInputBody: Equatable {
}

extension DeleteInstanceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInstanceOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInstanceOutputResponse()"}
}

extension DeleteInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInstanceOutputResponse: Equatable {

    public init() {}
}

struct DeleteInstanceOutputResponseBody: Equatable {
}

extension DeleteInstanceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteIntegrationAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIntegrationAssociationInput(instanceId: \(String(describing: instanceId)), integrationAssociationId: \(String(describing: integrationAssociationId)))"}
}

extension DeleteIntegrationAssociationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteIntegrationAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIntegrationAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIntegrationAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIntegrationAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIntegrationAssociationInput>
    public typealias MOutput = OperationOutput<DeleteIntegrationAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIntegrationAssociationOutputError>
}

public struct DeleteIntegrationAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIntegrationAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIntegrationAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIntegrationAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIntegrationAssociationInput>
    public typealias MOutput = OperationOutput<DeleteIntegrationAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIntegrationAssociationOutputError>
}

public struct DeleteIntegrationAssociationInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier for the AppIntegration association.</p>
    public let integrationAssociationId: String?

    public init (
        instanceId: String? = nil,
        integrationAssociationId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationAssociationId = integrationAssociationId
    }
}

struct DeleteIntegrationAssociationInputBody: Equatable {
}

extension DeleteIntegrationAssociationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteIntegrationAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIntegrationAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIntegrationAssociationOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIntegrationAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIntegrationAssociationOutputResponse()"}
}

extension DeleteIntegrationAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIntegrationAssociationOutputResponse: Equatable {

    public init() {}
}

struct DeleteIntegrationAssociationOutputResponseBody: Equatable {
}

extension DeleteIntegrationAssociationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteQuickConnectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteQuickConnectInput(instanceId: \(String(describing: instanceId)), quickConnectId: \(String(describing: quickConnectId)))"}
}

extension DeleteQuickConnectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteQuickConnectInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteQuickConnectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteQuickConnectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteQuickConnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteQuickConnectInput>
    public typealias MOutput = OperationOutput<DeleteQuickConnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteQuickConnectOutputError>
}

public struct DeleteQuickConnectInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteQuickConnectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteQuickConnectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteQuickConnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteQuickConnectInput>
    public typealias MOutput = OperationOutput<DeleteQuickConnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteQuickConnectOutputError>
}

public struct DeleteQuickConnectInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier for the quick connect.</p>
    public let quickConnectId: String?

    public init (
        instanceId: String? = nil,
        quickConnectId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.quickConnectId = quickConnectId
    }
}

struct DeleteQuickConnectInputBody: Equatable {
}

extension DeleteQuickConnectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteQuickConnectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteQuickConnectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteQuickConnectOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteQuickConnectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteQuickConnectOutputResponse()"}
}

extension DeleteQuickConnectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteQuickConnectOutputResponse: Equatable {

    public init() {}
}

struct DeleteQuickConnectOutputResponseBody: Equatable {
}

extension DeleteQuickConnectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUseCaseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUseCaseInput(instanceId: \(String(describing: instanceId)), integrationAssociationId: \(String(describing: integrationAssociationId)), useCaseId: \(String(describing: useCaseId)))"}
}

extension DeleteUseCaseInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteUseCaseInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUseCaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUseCaseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUseCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUseCaseInput>
    public typealias MOutput = OperationOutput<DeleteUseCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUseCaseOutputError>
}

public struct DeleteUseCaseInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUseCaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUseCaseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUseCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUseCaseInput>
    public typealias MOutput = OperationOutput<DeleteUseCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUseCaseOutputError>
}

public struct DeleteUseCaseInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier for the AppIntegration association.</p>
    public let integrationAssociationId: String?
    /// <p>The identifier for the use case.</p>
    public let useCaseId: String?

    public init (
        instanceId: String? = nil,
        integrationAssociationId: String? = nil,
        useCaseId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationAssociationId = integrationAssociationId
        self.useCaseId = useCaseId
    }
}

struct DeleteUseCaseInputBody: Equatable {
}

extension DeleteUseCaseInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUseCaseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUseCaseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUseCaseOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUseCaseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUseCaseOutputResponse()"}
}

extension DeleteUseCaseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUseCaseOutputResponse: Equatable {

    public init() {}
}

struct DeleteUseCaseOutputResponseBody: Equatable {
}

extension DeleteUseCaseOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUserHierarchyGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserHierarchyGroupInput(hierarchyGroupId: \(String(describing: hierarchyGroupId)), instanceId: \(String(describing: instanceId)))"}
}

extension DeleteUserHierarchyGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteUserHierarchyGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserHierarchyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserHierarchyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserHierarchyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserHierarchyGroupInput>
    public typealias MOutput = OperationOutput<DeleteUserHierarchyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserHierarchyGroupOutputError>
}

public struct DeleteUserHierarchyGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserHierarchyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserHierarchyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserHierarchyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserHierarchyGroupInput>
    public typealias MOutput = OperationOutput<DeleteUserHierarchyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserHierarchyGroupOutputError>
}

public struct DeleteUserHierarchyGroupInput: Equatable {
    /// <p>The identifier of the hierarchy group.</p>
    public let hierarchyGroupId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        hierarchyGroupId: String? = nil,
        instanceId: String? = nil
    )
    {
        self.hierarchyGroupId = hierarchyGroupId
        self.instanceId = instanceId
    }
}

struct DeleteUserHierarchyGroupInputBody: Equatable {
}

extension DeleteUserHierarchyGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUserHierarchyGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserHierarchyGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserHierarchyGroupOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserHierarchyGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserHierarchyGroupOutputResponse()"}
}

extension DeleteUserHierarchyGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserHierarchyGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserHierarchyGroupOutputResponseBody: Equatable {
}

extension DeleteUserHierarchyGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserInput(instanceId: \(String(describing: instanceId)), userId: \(String(describing: userId)))"}
}

extension DeleteUserInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteUserInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier of the user.</p>
    public let userId: String?

    public init (
        instanceId: String? = nil,
        userId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.userId = userId
    }
}

struct DeleteUserInputBody: Equatable {
}

extension DeleteUserInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserOutputResponse()"}
}

extension DeleteUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserOutputResponseBody: Equatable {
}

extension DeleteUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeContactFlowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeContactFlowInput(contactFlowId: \(String(describing: contactFlowId)), instanceId: \(String(describing: instanceId)))"}
}

extension DescribeContactFlowInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeContactFlowInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeContactFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeContactFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeContactFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeContactFlowInput>
    public typealias MOutput = OperationOutput<DescribeContactFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeContactFlowOutputError>
}

public struct DescribeContactFlowInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeContactFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeContactFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeContactFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeContactFlowInput>
    public typealias MOutput = OperationOutput<DescribeContactFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeContactFlowOutputError>
}

public struct DescribeContactFlowInput: Equatable {
    /// <p>The identifier of the contact flow.</p>
    public let contactFlowId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        contactFlowId: String? = nil,
        instanceId: String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.instanceId = instanceId
    }
}

struct DescribeContactFlowInputBody: Equatable {
}

extension DescribeContactFlowInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeContactFlowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeContactFlowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContactFlowNotPublishedException" : self = .contactFlowNotPublishedException(try ContactFlowNotPublishedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeContactFlowOutputError: Equatable {
    case contactFlowNotPublishedException(ContactFlowNotPublishedException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeContactFlowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeContactFlowOutputResponse(contactFlow: \(String(describing: contactFlow)))"}
}

extension DescribeContactFlowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeContactFlowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contactFlow = output.contactFlow
        } else {
            self.contactFlow = nil
        }
    }
}

public struct DescribeContactFlowOutputResponse: Equatable {
    /// <p>Information about the contact flow.</p>
    public let contactFlow: ContactFlow?

    public init (
        contactFlow: ContactFlow? = nil
    )
    {
        self.contactFlow = contactFlow
    }
}

struct DescribeContactFlowOutputResponseBody: Equatable {
    public let contactFlow: ContactFlow?
}

extension DescribeContactFlowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactFlow = "ContactFlow"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactFlowDecoded = try containerValues.decodeIfPresent(ContactFlow.self, forKey: .contactFlow)
        contactFlow = contactFlowDecoded
    }
}

extension DescribeHoursOfOperationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHoursOfOperationInput(hoursOfOperationId: \(String(describing: hoursOfOperationId)), instanceId: \(String(describing: instanceId)))"}
}

extension DescribeHoursOfOperationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeHoursOfOperationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeHoursOfOperationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHoursOfOperationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHoursOfOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHoursOfOperationInput>
    public typealias MOutput = OperationOutput<DescribeHoursOfOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHoursOfOperationOutputError>
}

public struct DescribeHoursOfOperationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeHoursOfOperationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHoursOfOperationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHoursOfOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHoursOfOperationInput>
    public typealias MOutput = OperationOutput<DescribeHoursOfOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHoursOfOperationOutputError>
}

public struct DescribeHoursOfOperationInput: Equatable {
    /// <p>The identifier for the hours of operation.</p>
    public let hoursOfOperationId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        hoursOfOperationId: String? = nil,
        instanceId: String? = nil
    )
    {
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
    }
}

struct DescribeHoursOfOperationInputBody: Equatable {
}

extension DescribeHoursOfOperationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeHoursOfOperationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHoursOfOperationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHoursOfOperationOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHoursOfOperationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHoursOfOperationOutputResponse(hoursOfOperation: \(String(describing: hoursOfOperation)))"}
}

extension DescribeHoursOfOperationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeHoursOfOperationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hoursOfOperation = output.hoursOfOperation
        } else {
            self.hoursOfOperation = nil
        }
    }
}

public struct DescribeHoursOfOperationOutputResponse: Equatable {
    /// <p>The hours of operation.</p>
    public let hoursOfOperation: HoursOfOperation?

    public init (
        hoursOfOperation: HoursOfOperation? = nil
    )
    {
        self.hoursOfOperation = hoursOfOperation
    }
}

struct DescribeHoursOfOperationOutputResponseBody: Equatable {
    public let hoursOfOperation: HoursOfOperation?
}

extension DescribeHoursOfOperationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hoursOfOperation = "HoursOfOperation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursOfOperationDecoded = try containerValues.decodeIfPresent(HoursOfOperation.self, forKey: .hoursOfOperation)
        hoursOfOperation = hoursOfOperationDecoded
    }
}

extension DescribeInstanceAttributeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstanceAttributeInput(attributeType: \(String(describing: attributeType)), instanceId: \(String(describing: instanceId)))"}
}

extension DescribeInstanceAttributeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeInstanceAttributeInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInstanceAttributeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceAttributeInput>
    public typealias MOutput = OperationOutput<DescribeInstanceAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceAttributeOutputError>
}

public struct DescribeInstanceAttributeInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInstanceAttributeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceAttributeInput>
    public typealias MOutput = OperationOutput<DescribeInstanceAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceAttributeOutputError>
}

public struct DescribeInstanceAttributeInput: Equatable {
    /// <p>The type of attribute.</p>
    public let attributeType: InstanceAttributeType?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        attributeType: InstanceAttributeType? = nil,
        instanceId: String? = nil
    )
    {
        self.attributeType = attributeType
        self.instanceId = instanceId
    }
}

struct DescribeInstanceAttributeInputBody: Equatable {
}

extension DescribeInstanceAttributeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeInstanceAttributeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstanceAttributeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstanceAttributeOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceAttributeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstanceAttributeOutputResponse(attribute: \(String(describing: attribute)))"}
}

extension DescribeInstanceAttributeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInstanceAttributeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attribute = output.attribute
        } else {
            self.attribute = nil
        }
    }
}

public struct DescribeInstanceAttributeOutputResponse: Equatable {
    /// <p>The
    ///    type
    ///    of attribute.</p>
    public let attribute: Attribute?

    public init (
        attribute: Attribute? = nil
    )
    {
        self.attribute = attribute
    }
}

struct DescribeInstanceAttributeOutputResponseBody: Equatable {
    public let attribute: Attribute?
}

extension DescribeInstanceAttributeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(Attribute.self, forKey: .attribute)
        attribute = attributeDecoded
    }
}

extension DescribeInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstanceInput(instanceId: \(String(describing: instanceId)))"}
}

extension DescribeInstanceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceInput>
    public typealias MOutput = OperationOutput<DescribeInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceOutputError>
}

public struct DescribeInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceInput>
    public typealias MOutput = OperationOutput<DescribeInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceOutputError>
}

public struct DescribeInstanceInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        instanceId: String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct DescribeInstanceInputBody: Equatable {
}

extension DescribeInstanceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstanceOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstanceOutputResponse(instance: \(String(describing: instance)))"}
}

extension DescribeInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instance = output.instance
        } else {
            self.instance = nil
        }
    }
}

public struct DescribeInstanceOutputResponse: Equatable {
    /// <p>The name of the instance.</p>
    public let instance: Instance?

    public init (
        instance: Instance? = nil
    )
    {
        self.instance = instance
    }
}

struct DescribeInstanceOutputResponseBody: Equatable {
    public let instance: Instance?
}

extension DescribeInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instance = "Instance"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceDecoded = try containerValues.decodeIfPresent(Instance.self, forKey: .instance)
        instance = instanceDecoded
    }
}

extension DescribeInstanceStorageConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstanceStorageConfigInput(associationId: \(String(describing: associationId)), instanceId: \(String(describing: instanceId)), resourceType: \(String(describing: resourceType)))"}
}

extension DescribeInstanceStorageConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeInstanceStorageConfigInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInstanceStorageConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceStorageConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceStorageConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceStorageConfigInput>
    public typealias MOutput = OperationOutput<DescribeInstanceStorageConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceStorageConfigOutputError>
}

public struct DescribeInstanceStorageConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInstanceStorageConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceStorageConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceStorageConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = URLQueryItem(name: "resourceType".urlPercentEncoding(), value: String(resourceType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceStorageConfigInput>
    public typealias MOutput = OperationOutput<DescribeInstanceStorageConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceStorageConfigOutputError>
}

public struct DescribeInstanceStorageConfigInput: Equatable {
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    public let associationId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>A valid resource type.</p>
    public let resourceType: InstanceStorageResourceType?

    public init (
        associationId: String? = nil,
        instanceId: String? = nil,
        resourceType: InstanceStorageResourceType? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
        self.resourceType = resourceType
    }
}

struct DescribeInstanceStorageConfigInputBody: Equatable {
}

extension DescribeInstanceStorageConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeInstanceStorageConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstanceStorageConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstanceStorageConfigOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceStorageConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstanceStorageConfigOutputResponse(storageConfig: \(String(describing: storageConfig)))"}
}

extension DescribeInstanceStorageConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInstanceStorageConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.storageConfig = output.storageConfig
        } else {
            self.storageConfig = nil
        }
    }
}

public struct DescribeInstanceStorageConfigOutputResponse: Equatable {
    /// <p>A valid storage type.</p>
    public let storageConfig: InstanceStorageConfig?

    public init (
        storageConfig: InstanceStorageConfig? = nil
    )
    {
        self.storageConfig = storageConfig
    }
}

struct DescribeInstanceStorageConfigOutputResponseBody: Equatable {
    public let storageConfig: InstanceStorageConfig?
}

extension DescribeInstanceStorageConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case storageConfig = "StorageConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageConfigDecoded = try containerValues.decodeIfPresent(InstanceStorageConfig.self, forKey: .storageConfig)
        storageConfig = storageConfigDecoded
    }
}

extension DescribeQueueInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeQueueInput(instanceId: \(String(describing: instanceId)), queueId: \(String(describing: queueId)))"}
}

extension DescribeQueueInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeQueueInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeQueueInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeQueueInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeQueueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeQueueInput>
    public typealias MOutput = OperationOutput<DescribeQueueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeQueueOutputError>
}

public struct DescribeQueueInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeQueueInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeQueueInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeQueueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeQueueInput>
    public typealias MOutput = OperationOutput<DescribeQueueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeQueueOutputError>
}

public struct DescribeQueueInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier for the queue.</p>
    public let queueId: String?

    public init (
        instanceId: String? = nil,
        queueId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
    }
}

struct DescribeQueueInputBody: Equatable {
}

extension DescribeQueueInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeQueueOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeQueueOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeQueueOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeQueueOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeQueueOutputResponse(queue: \(String(describing: queue)))"}
}

extension DescribeQueueOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeQueueOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.queue = output.queue
        } else {
            self.queue = nil
        }
    }
}

public struct DescribeQueueOutputResponse: Equatable {
    /// <p>The name of the queue.</p>
    public let queue: Queue?

    public init (
        queue: Queue? = nil
    )
    {
        self.queue = queue
    }
}

struct DescribeQueueOutputResponseBody: Equatable {
    public let queue: Queue?
}

extension DescribeQueueOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case queue = "Queue"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueDecoded = try containerValues.decodeIfPresent(Queue.self, forKey: .queue)
        queue = queueDecoded
    }
}

extension DescribeQuickConnectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeQuickConnectInput(instanceId: \(String(describing: instanceId)), quickConnectId: \(String(describing: quickConnectId)))"}
}

extension DescribeQuickConnectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeQuickConnectInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeQuickConnectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeQuickConnectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeQuickConnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeQuickConnectInput>
    public typealias MOutput = OperationOutput<DescribeQuickConnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeQuickConnectOutputError>
}

public struct DescribeQuickConnectInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeQuickConnectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeQuickConnectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeQuickConnectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeQuickConnectInput>
    public typealias MOutput = OperationOutput<DescribeQuickConnectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeQuickConnectOutputError>
}

public struct DescribeQuickConnectInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier for the quick connect.</p>
    public let quickConnectId: String?

    public init (
        instanceId: String? = nil,
        quickConnectId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.quickConnectId = quickConnectId
    }
}

struct DescribeQuickConnectInputBody: Equatable {
}

extension DescribeQuickConnectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeQuickConnectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeQuickConnectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeQuickConnectOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeQuickConnectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeQuickConnectOutputResponse(quickConnect: \(String(describing: quickConnect)))"}
}

extension DescribeQuickConnectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeQuickConnectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.quickConnect = output.quickConnect
        } else {
            self.quickConnect = nil
        }
    }
}

public struct DescribeQuickConnectOutputResponse: Equatable {
    /// <p>Information about the quick connect.</p>
    public let quickConnect: QuickConnect?

    public init (
        quickConnect: QuickConnect? = nil
    )
    {
        self.quickConnect = quickConnect
    }
}

struct DescribeQuickConnectOutputResponseBody: Equatable {
    public let quickConnect: QuickConnect?
}

extension DescribeQuickConnectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case quickConnect = "QuickConnect"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectDecoded = try containerValues.decodeIfPresent(QuickConnect.self, forKey: .quickConnect)
        quickConnect = quickConnectDecoded
    }
}

extension DescribeRoutingProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRoutingProfileInput(instanceId: \(String(describing: instanceId)), routingProfileId: \(String(describing: routingProfileId)))"}
}

extension DescribeRoutingProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeRoutingProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRoutingProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRoutingProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRoutingProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRoutingProfileInput>
    public typealias MOutput = OperationOutput<DescribeRoutingProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRoutingProfileOutputError>
}

public struct DescribeRoutingProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRoutingProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRoutingProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRoutingProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRoutingProfileInput>
    public typealias MOutput = OperationOutput<DescribeRoutingProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRoutingProfileOutputError>
}

public struct DescribeRoutingProfileInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier of the routing profile.</p>
    public let routingProfileId: String?

    public init (
        instanceId: String? = nil,
        routingProfileId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.routingProfileId = routingProfileId
    }
}

struct DescribeRoutingProfileInputBody: Equatable {
}

extension DescribeRoutingProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeRoutingProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRoutingProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRoutingProfileOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRoutingProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRoutingProfileOutputResponse(routingProfile: \(String(describing: routingProfile)))"}
}

extension DescribeRoutingProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRoutingProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.routingProfile = output.routingProfile
        } else {
            self.routingProfile = nil
        }
    }
}

public struct DescribeRoutingProfileOutputResponse: Equatable {
    /// <p>The routing profile.</p>
    public let routingProfile: RoutingProfile?

    public init (
        routingProfile: RoutingProfile? = nil
    )
    {
        self.routingProfile = routingProfile
    }
}

struct DescribeRoutingProfileOutputResponseBody: Equatable {
    public let routingProfile: RoutingProfile?
}

extension DescribeRoutingProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case routingProfile = "RoutingProfile"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingProfileDecoded = try containerValues.decodeIfPresent(RoutingProfile.self, forKey: .routingProfile)
        routingProfile = routingProfileDecoded
    }
}

extension DescribeUserHierarchyGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserHierarchyGroupInput(hierarchyGroupId: \(String(describing: hierarchyGroupId)), instanceId: \(String(describing: instanceId)))"}
}

extension DescribeUserHierarchyGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeUserHierarchyGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUserHierarchyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserHierarchyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserHierarchyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserHierarchyGroupInput>
    public typealias MOutput = OperationOutput<DescribeUserHierarchyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserHierarchyGroupOutputError>
}

public struct DescribeUserHierarchyGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUserHierarchyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserHierarchyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserHierarchyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserHierarchyGroupInput>
    public typealias MOutput = OperationOutput<DescribeUserHierarchyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserHierarchyGroupOutputError>
}

public struct DescribeUserHierarchyGroupInput: Equatable {
    /// <p>The identifier of the hierarchy group.</p>
    public let hierarchyGroupId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        hierarchyGroupId: String? = nil,
        instanceId: String? = nil
    )
    {
        self.hierarchyGroupId = hierarchyGroupId
        self.instanceId = instanceId
    }
}

struct DescribeUserHierarchyGroupInputBody: Equatable {
}

extension DescribeUserHierarchyGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeUserHierarchyGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserHierarchyGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserHierarchyGroupOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserHierarchyGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserHierarchyGroupOutputResponse(hierarchyGroup: \(String(describing: hierarchyGroup)))"}
}

extension DescribeUserHierarchyGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUserHierarchyGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hierarchyGroup = output.hierarchyGroup
        } else {
            self.hierarchyGroup = nil
        }
    }
}

public struct DescribeUserHierarchyGroupOutputResponse: Equatable {
    /// <p>Information about the hierarchy group.</p>
    public let hierarchyGroup: HierarchyGroup?

    public init (
        hierarchyGroup: HierarchyGroup? = nil
    )
    {
        self.hierarchyGroup = hierarchyGroup
    }
}

struct DescribeUserHierarchyGroupOutputResponseBody: Equatable {
    public let hierarchyGroup: HierarchyGroup?
}

extension DescribeUserHierarchyGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hierarchyGroup = "HierarchyGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyGroupDecoded = try containerValues.decodeIfPresent(HierarchyGroup.self, forKey: .hierarchyGroup)
        hierarchyGroup = hierarchyGroupDecoded
    }
}

extension DescribeUserHierarchyStructureInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserHierarchyStructureInput(instanceId: \(String(describing: instanceId)))"}
}

extension DescribeUserHierarchyStructureInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeUserHierarchyStructureInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUserHierarchyStructureInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserHierarchyStructureInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserHierarchyStructureOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserHierarchyStructureInput>
    public typealias MOutput = OperationOutput<DescribeUserHierarchyStructureOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserHierarchyStructureOutputError>
}

public struct DescribeUserHierarchyStructureInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUserHierarchyStructureInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserHierarchyStructureInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserHierarchyStructureOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserHierarchyStructureInput>
    public typealias MOutput = OperationOutput<DescribeUserHierarchyStructureOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserHierarchyStructureOutputError>
}

public struct DescribeUserHierarchyStructureInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        instanceId: String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct DescribeUserHierarchyStructureInputBody: Equatable {
}

extension DescribeUserHierarchyStructureInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeUserHierarchyStructureOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserHierarchyStructureOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserHierarchyStructureOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserHierarchyStructureOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserHierarchyStructureOutputResponse(hierarchyStructure: \(String(describing: hierarchyStructure)))"}
}

extension DescribeUserHierarchyStructureOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUserHierarchyStructureOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hierarchyStructure = output.hierarchyStructure
        } else {
            self.hierarchyStructure = nil
        }
    }
}

public struct DescribeUserHierarchyStructureOutputResponse: Equatable {
    /// <p>Information about the hierarchy structure.</p>
    public let hierarchyStructure: HierarchyStructure?

    public init (
        hierarchyStructure: HierarchyStructure? = nil
    )
    {
        self.hierarchyStructure = hierarchyStructure
    }
}

struct DescribeUserHierarchyStructureOutputResponseBody: Equatable {
    public let hierarchyStructure: HierarchyStructure?
}

extension DescribeUserHierarchyStructureOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hierarchyStructure = "HierarchyStructure"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyStructureDecoded = try containerValues.decodeIfPresent(HierarchyStructure.self, forKey: .hierarchyStructure)
        hierarchyStructure = hierarchyStructureDecoded
    }
}

extension DescribeUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserInput(instanceId: \(String(describing: instanceId)), userId: \(String(describing: userId)))"}
}

extension DescribeUserInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeUserInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserInput>
    public typealias MOutput = OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserOutputError>
}

public struct DescribeUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserInput>
    public typealias MOutput = OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserOutputError>
}

public struct DescribeUserInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier of the user account.</p>
    public let userId: String?

    public init (
        instanceId: String? = nil,
        userId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.userId = userId
    }
}

struct DescribeUserInputBody: Equatable {
}

extension DescribeUserInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserOutputResponse(user: \(String(describing: user)))"}
}

extension DescribeUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct DescribeUserOutputResponse: Equatable {
    /// <p>Information about the user account and configuration settings.</p>
    public let user: User?

    public init (
        user: User? = nil
    )
    {
        self.user = user
    }
}

struct DescribeUserOutputResponseBody: Equatable {
    public let user: User?
}

extension DescribeUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case user = "User"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(User.self, forKey: .user)
        user = userDecoded
    }
}

extension DestinationNotAllowedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DestinationNotAllowedException(message: \(String(describing: message)))"}
}

extension DestinationNotAllowedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DestinationNotAllowedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Outbound calls to the destination number are not allowed.</p>
public struct DestinationNotAllowedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message about the outbound calls.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DestinationNotAllowedExceptionBody: Equatable {
    public let message: String?
}

extension DestinationNotAllowedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Dimensions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channel = "Channel"
        case queue = "Queue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if let queue = queue {
            try encodeContainer.encode(queue, forKey: .queue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueDecoded = try containerValues.decodeIfPresent(QueueReference.self, forKey: .queue)
        queue = queueDecoded
        let channelDecoded = try containerValues.decodeIfPresent(Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension Dimensions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Dimensions(channel: \(String(describing: channel)), queue: \(String(describing: queue)))"}
}

/// <p>Contains information about the dimensions for a set of metrics.</p>
public struct Dimensions: Equatable {
    /// <p>The channel used for grouping and filters.</p>
    public let channel: Channel?
    /// <p>Information about the queue for which metrics are returned.</p>
    public let queue: QueueReference?

    public init (
        channel: Channel? = nil,
        queue: QueueReference? = nil
    )
    {
        self.channel = channel
        self.queue = queue
    }
}

public enum DirectoryType {
    case connectManaged
    case existingDirectory
    case saml
    case sdkUnknown(String)
}

extension DirectoryType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DirectoryType] {
        return [
            .connectManaged,
            .existingDirectory,
            .saml,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .connectManaged: return "CONNECT_MANAGED"
        case .existingDirectory: return "EXISTING_DIRECTORY"
        case .saml: return "SAML"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DirectoryType(rawValue: rawValue) ?? DirectoryType.sdkUnknown(rawValue)
    }
}

extension DisassociateApprovedOriginInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateApprovedOriginInput(instanceId: \(String(describing: instanceId)), origin: \(String(describing: origin)))"}
}

extension DisassociateApprovedOriginInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateApprovedOriginInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateApprovedOriginInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateApprovedOriginInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateApprovedOriginOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateApprovedOriginInput>
    public typealias MOutput = OperationOutput<DisassociateApprovedOriginOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateApprovedOriginOutputError>
}

public struct DisassociateApprovedOriginInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateApprovedOriginInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateApprovedOriginInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateApprovedOriginOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let origin = input.operationInput.origin {
            let originQueryItem = URLQueryItem(name: "origin".urlPercentEncoding(), value: String(origin).urlPercentEncoding())
            input.builder.withQueryItem(originQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateApprovedOriginInput>
    public typealias MOutput = OperationOutput<DisassociateApprovedOriginOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateApprovedOriginOutputError>
}

public struct DisassociateApprovedOriginInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The domain URL of the integrated application.</p>
    public let origin: String?

    public init (
        instanceId: String? = nil,
        origin: String? = nil
    )
    {
        self.instanceId = instanceId
        self.origin = origin
    }
}

struct DisassociateApprovedOriginInputBody: Equatable {
}

extension DisassociateApprovedOriginInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateApprovedOriginOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateApprovedOriginOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateApprovedOriginOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateApprovedOriginOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateApprovedOriginOutputResponse()"}
}

extension DisassociateApprovedOriginOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateApprovedOriginOutputResponse: Equatable {

    public init() {}
}

struct DisassociateApprovedOriginOutputResponseBody: Equatable {
}

extension DisassociateApprovedOriginOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateInstanceStorageConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateInstanceStorageConfigInput(associationId: \(String(describing: associationId)), instanceId: \(String(describing: instanceId)), resourceType: \(String(describing: resourceType)))"}
}

extension DisassociateInstanceStorageConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateInstanceStorageConfigInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateInstanceStorageConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateInstanceStorageConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateInstanceStorageConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateInstanceStorageConfigInput>
    public typealias MOutput = OperationOutput<DisassociateInstanceStorageConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateInstanceStorageConfigOutputError>
}

public struct DisassociateInstanceStorageConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateInstanceStorageConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateInstanceStorageConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateInstanceStorageConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = URLQueryItem(name: "resourceType".urlPercentEncoding(), value: String(resourceType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateInstanceStorageConfigInput>
    public typealias MOutput = OperationOutput<DisassociateInstanceStorageConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateInstanceStorageConfigOutputError>
}

public struct DisassociateInstanceStorageConfigInput: Equatable {
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    public let associationId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>A valid resource type.</p>
    public let resourceType: InstanceStorageResourceType?

    public init (
        associationId: String? = nil,
        instanceId: String? = nil,
        resourceType: InstanceStorageResourceType? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
        self.resourceType = resourceType
    }
}

struct DisassociateInstanceStorageConfigInputBody: Equatable {
}

extension DisassociateInstanceStorageConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateInstanceStorageConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateInstanceStorageConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateInstanceStorageConfigOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateInstanceStorageConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateInstanceStorageConfigOutputResponse()"}
}

extension DisassociateInstanceStorageConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateInstanceStorageConfigOutputResponse: Equatable {

    public init() {}
}

struct DisassociateInstanceStorageConfigOutputResponseBody: Equatable {
}

extension DisassociateInstanceStorageConfigOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateLambdaFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateLambdaFunctionInput(functionArn: \(String(describing: functionArn)), instanceId: \(String(describing: instanceId)))"}
}

extension DisassociateLambdaFunctionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateLambdaFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateLambdaFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateLambdaFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateLambdaFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateLambdaFunctionInput>
    public typealias MOutput = OperationOutput<DisassociateLambdaFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateLambdaFunctionOutputError>
}

public struct DisassociateLambdaFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateLambdaFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateLambdaFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateLambdaFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let functionArn = input.operationInput.functionArn {
            let functionArnQueryItem = URLQueryItem(name: "functionArn".urlPercentEncoding(), value: String(functionArn).urlPercentEncoding())
            input.builder.withQueryItem(functionArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateLambdaFunctionInput>
    public typealias MOutput = OperationOutput<DisassociateLambdaFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateLambdaFunctionOutputError>
}

public struct DisassociateLambdaFunctionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Lambda function being disassociated.</p>
    public let functionArn: String?
    /// <p>The identifier of the Amazon Connect instance..</p>
    public let instanceId: String?

    public init (
        functionArn: String? = nil,
        instanceId: String? = nil
    )
    {
        self.functionArn = functionArn
        self.instanceId = instanceId
    }
}

struct DisassociateLambdaFunctionInputBody: Equatable {
}

extension DisassociateLambdaFunctionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateLambdaFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateLambdaFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateLambdaFunctionOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateLambdaFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateLambdaFunctionOutputResponse()"}
}

extension DisassociateLambdaFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateLambdaFunctionOutputResponse: Equatable {

    public init() {}
}

struct DisassociateLambdaFunctionOutputResponseBody: Equatable {
}

extension DisassociateLambdaFunctionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateLexBotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateLexBotInput(botName: \(String(describing: botName)), instanceId: \(String(describing: instanceId)), lexRegion: \(String(describing: lexRegion)))"}
}

extension DisassociateLexBotInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateLexBotInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateLexBotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateLexBotInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateLexBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateLexBotInput>
    public typealias MOutput = OperationOutput<DisassociateLexBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateLexBotOutputError>
}

public struct DisassociateLexBotInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateLexBotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateLexBotInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateLexBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let lexRegion = input.operationInput.lexRegion {
            let lexRegionQueryItem = URLQueryItem(name: "lexRegion".urlPercentEncoding(), value: String(lexRegion).urlPercentEncoding())
            input.builder.withQueryItem(lexRegionQueryItem)
        }
        if let botName = input.operationInput.botName {
            let botNameQueryItem = URLQueryItem(name: "botName".urlPercentEncoding(), value: String(botName).urlPercentEncoding())
            input.builder.withQueryItem(botNameQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateLexBotInput>
    public typealias MOutput = OperationOutput<DisassociateLexBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateLexBotOutputError>
}

public struct DisassociateLexBotInput: Equatable {
    /// <p>The name of the Amazon Lex bot. Maximum character limit of 50.</p>
    public let botName: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The Region in which the Amazon Lex bot has been created.</p>
    public let lexRegion: String?

    public init (
        botName: String? = nil,
        instanceId: String? = nil,
        lexRegion: String? = nil
    )
    {
        self.botName = botName
        self.instanceId = instanceId
        self.lexRegion = lexRegion
    }
}

struct DisassociateLexBotInputBody: Equatable {
}

extension DisassociateLexBotInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateLexBotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateLexBotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateLexBotOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateLexBotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateLexBotOutputResponse()"}
}

extension DisassociateLexBotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateLexBotOutputResponse: Equatable {

    public init() {}
}

struct DisassociateLexBotOutputResponseBody: Equatable {
}

extension DisassociateLexBotOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateQueueQuickConnectsInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateQueueQuickConnectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateQueueQuickConnectsInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateQueueQuickConnectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateQueueQuickConnectsInput>
    public typealias MOutput = OperationOutput<DisassociateQueueQuickConnectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateQueueQuickConnectsOutputError>
}

extension DisassociateQueueQuickConnectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateQueueQuickConnectsInput(instanceId: \(String(describing: instanceId)), queueId: \(String(describing: queueId)), quickConnectIds: \(String(describing: quickConnectIds)))"}
}

extension DisassociateQueueQuickConnectsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case quickConnectIds = "QuickConnectIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quickConnectIds = quickConnectIds {
            var quickConnectIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .quickConnectIds)
            for quickconnectslist0 in quickConnectIds {
                try quickConnectIdsContainer.encode(quickconnectslist0)
            }
        }
    }
}

public struct DisassociateQueueQuickConnectsInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateQueueQuickConnectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateQueueQuickConnectsInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateQueueQuickConnectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateQueueQuickConnectsInput>
    public typealias MOutput = OperationOutput<DisassociateQueueQuickConnectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateQueueQuickConnectsOutputError>
}

public struct DisassociateQueueQuickConnectsInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateQueueQuickConnectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateQueueQuickConnectsInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateQueueQuickConnectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateQueueQuickConnectsInput>
    public typealias MOutput = OperationOutput<DisassociateQueueQuickConnectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateQueueQuickConnectsOutputError>
}

public struct DisassociateQueueQuickConnectsInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier for the queue.</p>
    public let queueId: String?
    /// <p>The quick connects to disassociate from the queue.</p>
    public let quickConnectIds: [String]?

    public init (
        instanceId: String? = nil,
        queueId: String? = nil,
        quickConnectIds: [String]? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
        self.quickConnectIds = quickConnectIds
    }
}

struct DisassociateQueueQuickConnectsInputBody: Equatable {
    public let quickConnectIds: [String]?
}

extension DisassociateQueueQuickConnectsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case quickConnectIds = "QuickConnectIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .quickConnectIds)
        var quickConnectIdsDecoded0:[String]? = nil
        if let quickConnectIdsContainer = quickConnectIdsContainer {
            quickConnectIdsDecoded0 = [String]()
            for string0 in quickConnectIdsContainer {
                if let string0 = string0 {
                    quickConnectIdsDecoded0?.append(string0)
                }
            }
        }
        quickConnectIds = quickConnectIdsDecoded0
    }
}

extension DisassociateQueueQuickConnectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateQueueQuickConnectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateQueueQuickConnectsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateQueueQuickConnectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateQueueQuickConnectsOutputResponse()"}
}

extension DisassociateQueueQuickConnectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateQueueQuickConnectsOutputResponse: Equatable {

    public init() {}
}

struct DisassociateQueueQuickConnectsOutputResponseBody: Equatable {
}

extension DisassociateQueueQuickConnectsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateRoutingProfileQueuesInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateRoutingProfileQueuesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateRoutingProfileQueuesInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateRoutingProfileQueuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateRoutingProfileQueuesInput>
    public typealias MOutput = OperationOutput<DisassociateRoutingProfileQueuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateRoutingProfileQueuesOutputError>
}

extension DisassociateRoutingProfileQueuesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateRoutingProfileQueuesInput(instanceId: \(String(describing: instanceId)), queueReferences: \(String(describing: queueReferences)), routingProfileId: \(String(describing: routingProfileId)))"}
}

extension DisassociateRoutingProfileQueuesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case queueReferences = "QueueReferences"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queueReferences = queueReferences {
            var queueReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queueReferences)
            for routingprofilequeuereferencelist0 in queueReferences {
                try queueReferencesContainer.encode(routingprofilequeuereferencelist0)
            }
        }
    }
}

public struct DisassociateRoutingProfileQueuesInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateRoutingProfileQueuesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateRoutingProfileQueuesInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateRoutingProfileQueuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateRoutingProfileQueuesInput>
    public typealias MOutput = OperationOutput<DisassociateRoutingProfileQueuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateRoutingProfileQueuesOutputError>
}

public struct DisassociateRoutingProfileQueuesInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateRoutingProfileQueuesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateRoutingProfileQueuesInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateRoutingProfileQueuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateRoutingProfileQueuesInput>
    public typealias MOutput = OperationOutput<DisassociateRoutingProfileQueuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateRoutingProfileQueuesOutputError>
}

public struct DisassociateRoutingProfileQueuesInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The queues to disassociate from this routing profile.</p>
    public let queueReferences: [RoutingProfileQueueReference]?
    /// <p>The identifier of the routing profile.</p>
    public let routingProfileId: String?

    public init (
        instanceId: String? = nil,
        queueReferences: [RoutingProfileQueueReference]? = nil,
        routingProfileId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueReferences = queueReferences
        self.routingProfileId = routingProfileId
    }
}

struct DisassociateRoutingProfileQueuesInputBody: Equatable {
    public let queueReferences: [RoutingProfileQueueReference]?
}

extension DisassociateRoutingProfileQueuesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case queueReferences = "QueueReferences"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueReferencesContainer = try containerValues.decodeIfPresent([RoutingProfileQueueReference?].self, forKey: .queueReferences)
        var queueReferencesDecoded0:[RoutingProfileQueueReference]? = nil
        if let queueReferencesContainer = queueReferencesContainer {
            queueReferencesDecoded0 = [RoutingProfileQueueReference]()
            for structure0 in queueReferencesContainer {
                if let structure0 = structure0 {
                    queueReferencesDecoded0?.append(structure0)
                }
            }
        }
        queueReferences = queueReferencesDecoded0
    }
}

extension DisassociateRoutingProfileQueuesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateRoutingProfileQueuesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateRoutingProfileQueuesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateRoutingProfileQueuesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateRoutingProfileQueuesOutputResponse()"}
}

extension DisassociateRoutingProfileQueuesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateRoutingProfileQueuesOutputResponse: Equatable {

    public init() {}
}

struct DisassociateRoutingProfileQueuesOutputResponseBody: Equatable {
}

extension DisassociateRoutingProfileQueuesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateSecurityKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateSecurityKeyInput(associationId: \(String(describing: associationId)), instanceId: \(String(describing: instanceId)))"}
}

extension DisassociateSecurityKeyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateSecurityKeyInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateSecurityKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateSecurityKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateSecurityKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateSecurityKeyInput>
    public typealias MOutput = OperationOutput<DisassociateSecurityKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateSecurityKeyOutputError>
}

public struct DisassociateSecurityKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateSecurityKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateSecurityKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateSecurityKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateSecurityKeyInput>
    public typealias MOutput = OperationOutput<DisassociateSecurityKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateSecurityKeyOutputError>
}

public struct DisassociateSecurityKeyInput: Equatable {
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    public let associationId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        associationId: String? = nil,
        instanceId: String? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
    }
}

struct DisassociateSecurityKeyInputBody: Equatable {
}

extension DisassociateSecurityKeyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateSecurityKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateSecurityKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateSecurityKeyOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateSecurityKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateSecurityKeyOutputResponse()"}
}

extension DisassociateSecurityKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateSecurityKeyOutputResponse: Equatable {

    public init() {}
}

struct DisassociateSecurityKeyOutputResponseBody: Equatable {
}

extension DisassociateSecurityKeyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DuplicateResourceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateResourceException(message: \(String(describing: message)))"}
}

extension DuplicateResourceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DuplicateResourceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource with the specified name already exists.</p>
public struct DuplicateResourceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateResourceExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateResourceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EncryptionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionType = "EncryptionType"
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension EncryptionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionConfig(encryptionType: \(String(describing: encryptionType)), keyId: \(String(describing: keyId)))"}
}

/// <p>The encryption configuration.</p>
public struct EncryptionConfig: Equatable {
    /// <p>The type of encryption.</p>
    public let encryptionType: EncryptionType?
    /// <p>The identifier of the encryption key.</p>
    public let keyId: String?

    public init (
        encryptionType: EncryptionType? = nil,
        keyId: String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.keyId = keyId
    }
}

public enum EncryptionType {
    case kms
    case sdkUnknown(String)
}

extension EncryptionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionType] {
        return [
            .kms,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .kms: return "KMS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
    }
}

extension Filters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channels = "Channels"
        case queues = "Queues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channels = channels {
            var channelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channels)
            for channels0 in channels {
                try channelsContainer.encode(channels0.rawValue)
            }
        }
        if let queues = queues {
            var queuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queues)
            for queues0 in queues {
                try queuesContainer.encode(queues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .queues)
        var queuesDecoded0:[String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let channelsContainer = try containerValues.decodeIfPresent([Channel?].self, forKey: .channels)
        var channelsDecoded0:[Channel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [Channel]()
            for string0 in channelsContainer {
                if let string0 = string0 {
                    channelsDecoded0?.append(string0)
                }
            }
        }
        channels = channelsDecoded0
    }
}

extension Filters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filters(channels: \(String(describing: channels)), queues: \(String(describing: queues)))"}
}

/// <p>Contains the filter to apply when retrieving metrics.</p>
public struct Filters: Equatable {
    /// <p>The channel to use to filter the metrics.</p>
    public let channels: [Channel]?
    /// <p>The queues to use to filter the metrics. You can specify up to 100 queues per
    ///    request.</p>
    public let queues: [String]?

    public init (
        channels: [Channel]? = nil,
        queues: [String]? = nil
    )
    {
        self.channels = channels
        self.queues = queues
    }
}

extension GetContactAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContactAttributesInput(initialContactId: \(String(describing: initialContactId)), instanceId: \(String(describing: instanceId)))"}
}

extension GetContactAttributesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetContactAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "GetContactAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactAttributesInput>
    public typealias MOutput = OperationOutput<GetContactAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactAttributesOutputError>
}

public struct GetContactAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetContactAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContactAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContactAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContactAttributesInput>
    public typealias MOutput = OperationOutput<GetContactAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContactAttributesOutputError>
}

public struct GetContactAttributesInput: Equatable {
    /// <p>The identifier of the initial contact.</p>
    public let initialContactId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        initialContactId: String? = nil,
        instanceId: String? = nil
    )
    {
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

struct GetContactAttributesInputBody: Equatable {
}

extension GetContactAttributesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetContactAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContactAttributesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContactAttributesOutputResponse(attributes: \(String(describing: attributes)))"}
}

extension GetContactAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetContactAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct GetContactAttributesOutputResponse: Equatable {
    /// <p>Information about the attributes.</p>
    public let attributes: [String:String]?

    public init (
        attributes: [String:String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetContactAttributesOutputResponseBody: Equatable {
    public let attributes: [String:String]?
}

extension GetContactAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

public struct GetCurrentMetricDataInputBodyMiddleware: Middleware {
    public let id: String = "GetCurrentMetricDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCurrentMetricDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCurrentMetricDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCurrentMetricDataInput>
    public typealias MOutput = OperationOutput<GetCurrentMetricDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCurrentMetricDataOutputError>
}

extension GetCurrentMetricDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCurrentMetricDataInput(currentMetrics: \(String(describing: currentMetrics)), filters: \(String(describing: filters)), groupings: \(String(describing: groupings)), instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetCurrentMetricDataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentMetrics = "CurrentMetrics"
        case filters = "Filters"
        case groupings = "Groupings"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentMetrics = currentMetrics {
            var currentMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .currentMetrics)
            for currentmetrics0 in currentMetrics {
                try currentMetricsContainer.encode(currentmetrics0)
            }
        }
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupings = groupings {
            var groupingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupings)
            for groupings0 in groupings {
                try groupingsContainer.encode(groupings0.rawValue)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetCurrentMetricDataInputHeadersMiddleware: Middleware {
    public let id: String = "GetCurrentMetricDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCurrentMetricDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCurrentMetricDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCurrentMetricDataInput>
    public typealias MOutput = OperationOutput<GetCurrentMetricDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCurrentMetricDataOutputError>
}

public struct GetCurrentMetricDataInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCurrentMetricDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCurrentMetricDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCurrentMetricDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCurrentMetricDataInput>
    public typealias MOutput = OperationOutput<GetCurrentMetricDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCurrentMetricDataOutputError>
}

public struct GetCurrentMetricDataInput: Equatable {
    /// <p>The metrics to retrieve. Specify the name and unit for each metric. The following metrics
    ///    are available. For a description of all the metrics, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html">Real-time Metrics
    ///     Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    ///          <dl>
    ///             <dt>AGENTS_AFTER_CONTACT_WORK</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#aftercallwork-real-time">ACW</a>
    ///                </p>
    ///
    ///             </dd>
    ///             <dt>AGENTS_AVAILABLE</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#available-real-time">Available</a>
    ///                </p>
    ///             </dd>
    ///             <dt>AGENTS_ERROR</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#error-real-time">Error</a>
    ///                </p>
    ///             </dd>
    ///             <dt>AGENTS_NON_PRODUCTIVE</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#non-productive-time-real-time">NPT (Non-Productive Time)</a>
    ///                </p>
    ///             </dd>
    ///             <dt>AGENTS_ON_CALL</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time">On
    ///        contact</a>
    ///                </p>
    ///             </dd>
    ///             <dt>AGENTS_ON_CONTACT</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time">On
    ///        contact</a>
    ///                </p>
    ///             </dd>
    ///             <dt>AGENTS_ONLINE</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#online-real-time">Online</a>
    ///                </p>
    ///             </dd>
    ///             <dt>AGENTS_STAFFED</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#staffed-real-time">Staffed</a>
    ///                </p>
    ///             </dd>
    ///             <dt>CONTACTS_IN_QUEUE</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#in-queue-real-time">In
    ///        queue</a>
    ///                </p>
    ///             </dd>
    ///             <dt>CONTACTS_SCHEDULED</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#scheduled-real-time">Scheduled</a>
    ///                </p>
    ///             </dd>
    ///             <dt>OLDEST_CONTACT_AGE</dt>
    ///             <dd>
    ///                <p>Unit: SECONDS</p>
    ///                <p>When you use groupings, Unit says SECONDS but the Value is returned in MILLISECONDS. For
    ///       example, if you get a response like this:</p>
    ///                <p>
    ///                   <code>{ "Metric": { "Name": "OLDEST_CONTACT_AGE", "Unit": "SECONDS" }, "Value": 24113.0
    ///       </code>}</p>
    ///                <p>The actual OLDEST_CONTACT_AGE is 24 seconds.</p>
    ///
    ///                <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#oldest-real-time">Oldest</a>
    ///                </p>
    ///             </dd>
    ///             <dt>SLOTS_ACTIVE</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#active-real-time">Active</a>
    ///                </p>
    ///             </dd>
    ///             <dt>SLOTS_AVAILABLE</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Name in real-time metrics report: <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#availability-real-time">Availability</a>
    ///                </p>
    ///             </dd>
    ///          </dl>
    public let currentMetrics: [CurrentMetric]?
    /// <p>The queues, up to 100, or channels, to use to filter the metrics returned. Metric data is
    ///    retrieved only for the resources associated with the queues or channels included in the filter.
    ///    You can include both queue IDs and queue ARNs in the same request. VOICE, CHAT, and TASK channels are supported.</p>
    public let filters: Filters?
    /// <p>The grouping applied to the metrics returned. For example, when grouped by
    ///     <code>QUEUE</code>, the metrics returned apply to each queue rather than aggregated for all
    ///    queues. If you group by <code>CHANNEL</code>, you should include a Channels filter.
    ///    VOICE, CHAT, and TASK channels are supported.</p>
    ///          <p>If no <code>Grouping</code> is included in the request, a summary of metrics is
    ///    returned.</p>
    public let groupings: [Grouping]?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    ///          <p>The token expires after 5 minutes from the time it is created. Subsequent requests that use
    ///    the token must use the same request parameters as the request that generated the token.</p>
    public let nextToken: String?

    public init (
        currentMetrics: [CurrentMetric]? = nil,
        filters: Filters? = nil,
        groupings: [Grouping]? = nil,
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.currentMetrics = currentMetrics
        self.filters = filters
        self.groupings = groupings
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetCurrentMetricDataInputBody: Equatable {
    public let filters: Filters?
    public let groupings: [Grouping]?
    public let currentMetrics: [CurrentMetric]?
    public let nextToken: String?
    public let maxResults: Int
}

extension GetCurrentMetricDataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case currentMetrics = "CurrentMetrics"
        case filters = "Filters"
        case groupings = "Groupings"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(Filters.self, forKey: .filters)
        filters = filtersDecoded
        let groupingsContainer = try containerValues.decodeIfPresent([Grouping?].self, forKey: .groupings)
        var groupingsDecoded0:[Grouping]? = nil
        if let groupingsContainer = groupingsContainer {
            groupingsDecoded0 = [Grouping]()
            for string0 in groupingsContainer {
                if let string0 = string0 {
                    groupingsDecoded0?.append(string0)
                }
            }
        }
        groupings = groupingsDecoded0
        let currentMetricsContainer = try containerValues.decodeIfPresent([CurrentMetric?].self, forKey: .currentMetrics)
        var currentMetricsDecoded0:[CurrentMetric]? = nil
        if let currentMetricsContainer = currentMetricsContainer {
            currentMetricsDecoded0 = [CurrentMetric]()
            for structure0 in currentMetricsContainer {
                if let structure0 = structure0 {
                    currentMetricsDecoded0?.append(structure0)
                }
            }
        }
        currentMetrics = currentMetricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetCurrentMetricDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCurrentMetricDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCurrentMetricDataOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCurrentMetricDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCurrentMetricDataOutputResponse(dataSnapshotTime: \(String(describing: dataSnapshotTime)), metricResults: \(String(describing: metricResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetCurrentMetricDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCurrentMetricDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataSnapshotTime = output.dataSnapshotTime
            self.metricResults = output.metricResults
            self.nextToken = output.nextToken
        } else {
            self.dataSnapshotTime = nil
            self.metricResults = nil
            self.nextToken = nil
        }
    }
}

public struct GetCurrentMetricDataOutputResponse: Equatable {
    /// <p>The time at which the metrics were retrieved and cached for pagination.</p>
    public let dataSnapshotTime: Date?
    /// <p>Information about the real-time metrics.</p>
    public let metricResults: [CurrentMetricResult]?
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    ///          <p>The token expires after 5 minutes from the time it is created. Subsequent requests that use
    ///    the token must use the same request parameters as the request that generated the token.</p>
    public let nextToken: String?

    public init (
        dataSnapshotTime: Date? = nil,
        metricResults: [CurrentMetricResult]? = nil,
        nextToken: String? = nil
    )
    {
        self.dataSnapshotTime = dataSnapshotTime
        self.metricResults = metricResults
        self.nextToken = nextToken
    }
}

struct GetCurrentMetricDataOutputResponseBody: Equatable {
    public let nextToken: String?
    public let metricResults: [CurrentMetricResult]?
    public let dataSnapshotTime: Date?
}

extension GetCurrentMetricDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSnapshotTime = "DataSnapshotTime"
        case metricResults = "MetricResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let metricResultsContainer = try containerValues.decodeIfPresent([CurrentMetricResult?].self, forKey: .metricResults)
        var metricResultsDecoded0:[CurrentMetricResult]? = nil
        if let metricResultsContainer = metricResultsContainer {
            metricResultsDecoded0 = [CurrentMetricResult]()
            for structure0 in metricResultsContainer {
                if let structure0 = structure0 {
                    metricResultsDecoded0?.append(structure0)
                }
            }
        }
        metricResults = metricResultsDecoded0
        let dataSnapshotTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dataSnapshotTime)
        dataSnapshotTime = dataSnapshotTimeDecoded
    }
}

extension GetFederationTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFederationTokenInput(instanceId: \(String(describing: instanceId)))"}
}

extension GetFederationTokenInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFederationTokenInputHeadersMiddleware: Middleware {
    public let id: String = "GetFederationTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFederationTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFederationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFederationTokenInput>
    public typealias MOutput = OperationOutput<GetFederationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFederationTokenOutputError>
}

public struct GetFederationTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFederationTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFederationTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFederationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFederationTokenInput>
    public typealias MOutput = OperationOutput<GetFederationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFederationTokenOutputError>
}

public struct GetFederationTokenInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        instanceId: String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct GetFederationTokenInputBody: Equatable {
}

extension GetFederationTokenInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFederationTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFederationTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFederationTokenOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFederationTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFederationTokenOutputResponse(credentials: \(String(describing: credentials)))"}
}

extension GetFederationTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFederationTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.credentials = output.credentials
        } else {
            self.credentials = nil
        }
    }
}

public struct GetFederationTokenOutputResponse: Equatable {
    /// <p>The credentials to use for federation.</p>
    public let credentials: Credentials?

    public init (
        credentials: Credentials? = nil
    )
    {
        self.credentials = credentials
    }
}

struct GetFederationTokenOutputResponseBody: Equatable {
    public let credentials: Credentials?
}

extension GetFederationTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case credentials = "Credentials"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsDecoded = try containerValues.decodeIfPresent(Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
    }
}

public struct GetMetricDataInputBodyMiddleware: Middleware {
    public let id: String = "GetMetricDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMetricDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMetricDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMetricDataInput>
    public typealias MOutput = OperationOutput<GetMetricDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMetricDataOutputError>
}

extension GetMetricDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMetricDataInput(endTime: \(String(describing: endTime)), filters: \(String(describing: filters)), groupings: \(String(describing: groupings)), historicalMetrics: \(String(describing: historicalMetrics)), instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), startTime: \(String(describing: startTime)))"}
}

extension GetMetricDataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case filters = "Filters"
        case groupings = "Groupings"
        case historicalMetrics = "HistoricalMetrics"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupings = groupings {
            var groupingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupings)
            for groupings0 in groupings {
                try groupingsContainer.encode(groupings0.rawValue)
            }
        }
        if let historicalMetrics = historicalMetrics {
            var historicalMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .historicalMetrics)
            for historicalmetrics0 in historicalMetrics {
                try historicalMetricsContainer.encode(historicalmetrics0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct GetMetricDataInputHeadersMiddleware: Middleware {
    public let id: String = "GetMetricDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMetricDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMetricDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMetricDataInput>
    public typealias MOutput = OperationOutput<GetMetricDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMetricDataOutputError>
}

public struct GetMetricDataInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMetricDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMetricDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMetricDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMetricDataInput>
    public typealias MOutput = OperationOutput<GetMetricDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMetricDataOutputError>
}

public struct GetMetricDataInput: Equatable {
    /// <p>The timestamp, in UNIX Epoch time format, at which to end the reporting interval for the
    ///    retrieval of historical metrics data. The time must be specified using an interval of 5 minutes,
    ///    such as 11:00, 11:05, 11:10, and must be later than the start time timestamp.</p>
    ///          <p>The time range between the start and end time must be less than 24 hours.</p>
    public let endTime: Date?
    /// <p>The queues, up to 100, or channels, to use to filter the metrics returned. Metric data is
    ///    retrieved only for the resources associated with the queues or channels included in the filter.
    ///    You can include both queue IDs and queue ARNs in the same request. VOICE, CHAT, and TASK channels are supported.</p>
    ///          <note>
    ///             <p>To filter by <code>Queues</code>, enter the queue
    ///     ID/ARN, not the name of the queue.</p>
    ///          </note>
    public let filters: Filters?
    /// <p>The grouping applied to the metrics returned. For example, when results are grouped by
    ///    queue, the metrics returned are grouped by queue. The values returned apply to the metrics for
    ///    each queue rather than aggregated for all queues.</p>
    ///
    ///          <p>If no grouping is specified, a summary of metrics for all queues is returned.</p>
    public let groupings: [Grouping]?
    /// <p>The metrics to retrieve. Specify the name, unit, and statistic for each metric. The
    ///    following historical metrics are available. For a description of each metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical Metrics Definitions</a> in the <i>Amazon Connect Administrator
    ///    Guide</i>.</p>
    ///          <dl>
    ///             <dt>ABANDON_TIME</dt>
    ///             <dd>
    ///                <p>Unit: SECONDS</p>
    ///                <p>Statistic: AVG</p>
    ///             </dd>
    ///             <dt>AFTER_CONTACT_WORK_TIME</dt>
    ///             <dd>
    ///                <p>Unit: SECONDS</p>
    ///                <p>Statistic: AVG</p>
    ///             </dd>
    ///             <dt>API_CONTACTS_HANDLED</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Statistic: SUM</p>
    ///             </dd>
    ///             <dt>CALLBACK_CONTACTS_HANDLED</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Statistic: SUM</p>
    ///             </dd>
    ///             <dt>CONTACTS_ABANDONED</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Statistic: SUM</p>
    ///             </dd>
    ///             <dt>CONTACTS_AGENT_HUNG_UP_FIRST</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Statistic: SUM</p>
    ///             </dd>
    ///             <dt>CONTACTS_CONSULTED</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Statistic: SUM</p>
    ///             </dd>
    ///             <dt>CONTACTS_HANDLED</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Statistic: SUM</p>
    ///             </dd>
    ///             <dt>CONTACTS_HANDLED_INCOMING</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Statistic: SUM</p>
    ///             </dd>
    ///             <dt>CONTACTS_HANDLED_OUTBOUND</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Statistic: SUM</p>
    ///             </dd>
    ///             <dt>CONTACTS_HOLD_ABANDONS</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Statistic: SUM</p>
    ///             </dd>
    ///             <dt>CONTACTS_MISSED</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Statistic: SUM</p>
    ///             </dd>
    ///             <dt>CONTACTS_QUEUED</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Statistic: SUM</p>
    ///             </dd>
    ///             <dt>CONTACTS_TRANSFERRED_IN</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Statistic: SUM</p>
    ///             </dd>
    ///             <dt>CONTACTS_TRANSFERRED_IN_FROM_QUEUE</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Statistic: SUM</p>
    ///             </dd>
    ///             <dt>CONTACTS_TRANSFERRED_OUT</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Statistic: SUM</p>
    ///             </dd>
    ///             <dt>CONTACTS_TRANSFERRED_OUT_FROM_QUEUE</dt>
    ///             <dd>
    ///                <p>Unit: COUNT</p>
    ///                <p>Statistic: SUM</p>
    ///             </dd>
    ///             <dt>HANDLE_TIME</dt>
    ///             <dd>
    ///                <p>Unit: SECONDS</p>
    ///                <p>Statistic: AVG</p>
    ///             </dd>
    ///             <dt>HOLD_TIME</dt>
    ///             <dd>
    ///                <p>Unit: SECONDS</p>
    ///                <p>Statistic: AVG</p>
    ///             </dd>
    ///             <dt>INTERACTION_AND_HOLD_TIME</dt>
    ///             <dd>
    ///                <p>Unit: SECONDS</p>
    ///                <p>Statistic: AVG</p>
    ///             </dd>
    ///             <dt>INTERACTION_TIME</dt>
    ///             <dd>
    ///                <p>Unit: SECONDS</p>
    ///                <p>Statistic: AVG</p>
    ///             </dd>
    ///             <dt>OCCUPANCY</dt>
    ///             <dd>
    ///                <p>Unit: PERCENT</p>
    ///                <p>Statistic: AVG</p>
    ///             </dd>
    ///             <dt>QUEUE_ANSWER_TIME</dt>
    ///             <dd>
    ///                <p>Unit: SECONDS</p>
    ///                <p>Statistic: AVG</p>
    ///             </dd>
    ///             <dt>QUEUED_TIME</dt>
    ///             <dd>
    ///                <p>Unit: SECONDS</p>
    ///                <p>Statistic: MAX</p>
    ///             </dd>
    ///             <dt>SERVICE_LEVEL</dt>
    ///             <dd>
    ///                <p>You can include up to 20 SERVICE_LEVEL metrics in a request.</p>
    ///                <p>Unit: PERCENT</p>
    ///                <p>Statistic: AVG</p>
    ///                <p>Threshold: For <code>ThresholdValue</code>, enter any whole number from 1 to 604800
    ///       (inclusive), in seconds. For <code>Comparison</code>, you must enter <code>LT</code> (for
    ///       "Less than"). </p>
    ///             </dd>
    ///          </dl>
    public let historicalMetrics: [HistoricalMetric]?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The timestamp, in UNIX Epoch time format, at which to start the reporting interval for the
    ///    retrieval of historical metrics data. The time must be specified using a multiple of 5 minutes,
    ///    such as 10:05, 10:10, 10:15.</p>
    ///          <p>The start time cannot be earlier than 24 hours before the time of the request. Historical
    ///    metrics are available only for 24 hours.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        filters: Filters? = nil,
        groupings: [Grouping]? = nil,
        historicalMetrics: [HistoricalMetric]? = nil,
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.filters = filters
        self.groupings = groupings
        self.historicalMetrics = historicalMetrics
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct GetMetricDataInputBody: Equatable {
    public let startTime: Date?
    public let endTime: Date?
    public let filters: Filters?
    public let groupings: [Grouping]?
    public let historicalMetrics: [HistoricalMetric]?
    public let nextToken: String?
    public let maxResults: Int
}

extension GetMetricDataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case filters = "Filters"
        case groupings = "Groupings"
        case historicalMetrics = "HistoricalMetrics"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(Filters.self, forKey: .filters)
        filters = filtersDecoded
        let groupingsContainer = try containerValues.decodeIfPresent([Grouping?].self, forKey: .groupings)
        var groupingsDecoded0:[Grouping]? = nil
        if let groupingsContainer = groupingsContainer {
            groupingsDecoded0 = [Grouping]()
            for string0 in groupingsContainer {
                if let string0 = string0 {
                    groupingsDecoded0?.append(string0)
                }
            }
        }
        groupings = groupingsDecoded0
        let historicalMetricsContainer = try containerValues.decodeIfPresent([HistoricalMetric?].self, forKey: .historicalMetrics)
        var historicalMetricsDecoded0:[HistoricalMetric]? = nil
        if let historicalMetricsContainer = historicalMetricsContainer {
            historicalMetricsDecoded0 = [HistoricalMetric]()
            for structure0 in historicalMetricsContainer {
                if let structure0 = structure0 {
                    historicalMetricsDecoded0?.append(structure0)
                }
            }
        }
        historicalMetrics = historicalMetricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetMetricDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMetricDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMetricDataOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMetricDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMetricDataOutputResponse(metricResults: \(String(describing: metricResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetMetricDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMetricDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metricResults = output.metricResults
            self.nextToken = output.nextToken
        } else {
            self.metricResults = nil
            self.nextToken = nil
        }
    }
}

public struct GetMetricDataOutputResponse: Equatable {
    /// <p>Information about the historical metrics.</p>
    ///          <p>If no grouping is specified, a summary of metric data is returned.</p>
    public let metricResults: [HistoricalMetricResult]?
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    ///          <p>The token expires after 5 minutes from the time it is created. Subsequent requests that use
    ///    the token must use the same request parameters as the request that generated the token.</p>
    public let nextToken: String?

    public init (
        metricResults: [HistoricalMetricResult]? = nil,
        nextToken: String? = nil
    )
    {
        self.metricResults = metricResults
        self.nextToken = nextToken
    }
}

struct GetMetricDataOutputResponseBody: Equatable {
    public let nextToken: String?
    public let metricResults: [HistoricalMetricResult]?
}

extension GetMetricDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metricResults = "MetricResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let metricResultsContainer = try containerValues.decodeIfPresent([HistoricalMetricResult?].self, forKey: .metricResults)
        var metricResultsDecoded0:[HistoricalMetricResult]? = nil
        if let metricResultsContainer = metricResultsContainer {
            metricResultsDecoded0 = [HistoricalMetricResult]()
            for structure0 in metricResultsContainer {
                if let structure0 = structure0 {
                    metricResultsDecoded0?.append(structure0)
                }
            }
        }
        metricResults = metricResultsDecoded0
    }
}

public enum Grouping {
    case channel
    case queue
    case sdkUnknown(String)
}

extension Grouping : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Grouping] {
        return [
            .channel,
            .queue,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .channel: return "CHANNEL"
        case .queue: return "QUEUE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Grouping(rawValue: rawValue) ?? Grouping.sdkUnknown(rawValue)
    }
}

extension HierarchyGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case hierarchyPath = "HierarchyPath"
        case id = "Id"
        case levelId = "LevelId"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let hierarchyPath = hierarchyPath {
            try encodeContainer.encode(hierarchyPath, forKey: .hierarchyPath)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let levelId = levelId {
            try encodeContainer.encode(levelId, forKey: .levelId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let levelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .levelId)
        levelId = levelIdDecoded
        let hierarchyPathDecoded = try containerValues.decodeIfPresent(HierarchyPath.self, forKey: .hierarchyPath)
        hierarchyPath = hierarchyPathDecoded
    }
}

extension HierarchyGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HierarchyGroup(arn: \(String(describing: arn)), hierarchyPath: \(String(describing: hierarchyPath)), id: \(String(describing: id)), levelId: \(String(describing: levelId)), name: \(String(describing: name)))"}
}

/// <p>Contains information about a hierarchy group.</p>
public struct HierarchyGroup: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
    public let arn: String?
    /// <p>Information about the levels in the hierarchy group.</p>
    public let hierarchyPath: HierarchyPath?
    /// <p>The identifier of the hierarchy group.</p>
    public let id: String?
    /// <p>The identifier of the level in the hierarchy group.</p>
    public let levelId: String?
    /// <p>The name of the hierarchy group.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        hierarchyPath: HierarchyPath? = nil,
        id: String? = nil,
        levelId: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.hierarchyPath = hierarchyPath
        self.id = id
        self.levelId = levelId
        self.name = name
    }
}

extension HierarchyGroupSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension HierarchyGroupSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HierarchyGroupSummary(arn: \(String(describing: arn)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Contains summary information about a hierarchy group.</p>
public struct HierarchyGroupSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the hierarchy group.</p>
    public let arn: String?
    /// <p>The identifier of the hierarchy group.</p>
    public let id: String?
    /// <p>The name of the hierarchy group.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
    }
}

extension HierarchyLevel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension HierarchyLevel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HierarchyLevel(arn: \(String(describing: arn)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Contains information about a hierarchy level.</p>
public struct HierarchyLevel: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the hierarchy level.</p>
    public let arn: String?
    /// <p>The identifier of the hierarchy level.</p>
    public let id: String?
    /// <p>The name of the hierarchy level.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
    }
}

extension HierarchyLevelUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension HierarchyLevelUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HierarchyLevelUpdate(name: \(String(describing: name)))"}
}

/// <p>Contains information about the hierarchy level to update.</p>
public struct HierarchyLevelUpdate: Equatable {
    /// <p>The name of the user hierarchy level. Must not be more than 50 characters.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension HierarchyPath: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case levelFive = "LevelFive"
        case levelFour = "LevelFour"
        case levelOne = "LevelOne"
        case levelThree = "LevelThree"
        case levelTwo = "LevelTwo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let levelFive = levelFive {
            try encodeContainer.encode(levelFive, forKey: .levelFive)
        }
        if let levelFour = levelFour {
            try encodeContainer.encode(levelFour, forKey: .levelFour)
        }
        if let levelOne = levelOne {
            try encodeContainer.encode(levelOne, forKey: .levelOne)
        }
        if let levelThree = levelThree {
            try encodeContainer.encode(levelThree, forKey: .levelThree)
        }
        if let levelTwo = levelTwo {
            try encodeContainer.encode(levelTwo, forKey: .levelTwo)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let levelOneDecoded = try containerValues.decodeIfPresent(HierarchyGroupSummary.self, forKey: .levelOne)
        levelOne = levelOneDecoded
        let levelTwoDecoded = try containerValues.decodeIfPresent(HierarchyGroupSummary.self, forKey: .levelTwo)
        levelTwo = levelTwoDecoded
        let levelThreeDecoded = try containerValues.decodeIfPresent(HierarchyGroupSummary.self, forKey: .levelThree)
        levelThree = levelThreeDecoded
        let levelFourDecoded = try containerValues.decodeIfPresent(HierarchyGroupSummary.self, forKey: .levelFour)
        levelFour = levelFourDecoded
        let levelFiveDecoded = try containerValues.decodeIfPresent(HierarchyGroupSummary.self, forKey: .levelFive)
        levelFive = levelFiveDecoded
    }
}

extension HierarchyPath: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HierarchyPath(levelFive: \(String(describing: levelFive)), levelFour: \(String(describing: levelFour)), levelOne: \(String(describing: levelOne)), levelThree: \(String(describing: levelThree)), levelTwo: \(String(describing: levelTwo)))"}
}

/// <p>Contains information about the levels of a hierarchy group.</p>
public struct HierarchyPath: Equatable {
    /// <p>Information about level five.</p>
    public let levelFive: HierarchyGroupSummary?
    /// <p>Information about level four.</p>
    public let levelFour: HierarchyGroupSummary?
    /// <p>Information about level one.</p>
    public let levelOne: HierarchyGroupSummary?
    /// <p>Information about level three.</p>
    public let levelThree: HierarchyGroupSummary?
    /// <p>Information about level two.</p>
    public let levelTwo: HierarchyGroupSummary?

    public init (
        levelFive: HierarchyGroupSummary? = nil,
        levelFour: HierarchyGroupSummary? = nil,
        levelOne: HierarchyGroupSummary? = nil,
        levelThree: HierarchyGroupSummary? = nil,
        levelTwo: HierarchyGroupSummary? = nil
    )
    {
        self.levelFive = levelFive
        self.levelFour = levelFour
        self.levelOne = levelOne
        self.levelThree = levelThree
        self.levelTwo = levelTwo
    }
}

extension HierarchyStructure: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case levelFive = "LevelFive"
        case levelFour = "LevelFour"
        case levelOne = "LevelOne"
        case levelThree = "LevelThree"
        case levelTwo = "LevelTwo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let levelFive = levelFive {
            try encodeContainer.encode(levelFive, forKey: .levelFive)
        }
        if let levelFour = levelFour {
            try encodeContainer.encode(levelFour, forKey: .levelFour)
        }
        if let levelOne = levelOne {
            try encodeContainer.encode(levelOne, forKey: .levelOne)
        }
        if let levelThree = levelThree {
            try encodeContainer.encode(levelThree, forKey: .levelThree)
        }
        if let levelTwo = levelTwo {
            try encodeContainer.encode(levelTwo, forKey: .levelTwo)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let levelOneDecoded = try containerValues.decodeIfPresent(HierarchyLevel.self, forKey: .levelOne)
        levelOne = levelOneDecoded
        let levelTwoDecoded = try containerValues.decodeIfPresent(HierarchyLevel.self, forKey: .levelTwo)
        levelTwo = levelTwoDecoded
        let levelThreeDecoded = try containerValues.decodeIfPresent(HierarchyLevel.self, forKey: .levelThree)
        levelThree = levelThreeDecoded
        let levelFourDecoded = try containerValues.decodeIfPresent(HierarchyLevel.self, forKey: .levelFour)
        levelFour = levelFourDecoded
        let levelFiveDecoded = try containerValues.decodeIfPresent(HierarchyLevel.self, forKey: .levelFive)
        levelFive = levelFiveDecoded
    }
}

extension HierarchyStructure: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HierarchyStructure(levelFive: \(String(describing: levelFive)), levelFour: \(String(describing: levelFour)), levelOne: \(String(describing: levelOne)), levelThree: \(String(describing: levelThree)), levelTwo: \(String(describing: levelTwo)))"}
}

/// <p>Contains information about a hierarchy structure.</p>
public struct HierarchyStructure: Equatable {
    /// <p>Information about level five.</p>
    public let levelFive: HierarchyLevel?
    /// <p>Information about level four.</p>
    public let levelFour: HierarchyLevel?
    /// <p>Information about level one.</p>
    public let levelOne: HierarchyLevel?
    /// <p>Information about level three.</p>
    public let levelThree: HierarchyLevel?
    /// <p>Information about level two.</p>
    public let levelTwo: HierarchyLevel?

    public init (
        levelFive: HierarchyLevel? = nil,
        levelFour: HierarchyLevel? = nil,
        levelOne: HierarchyLevel? = nil,
        levelThree: HierarchyLevel? = nil,
        levelTwo: HierarchyLevel? = nil
    )
    {
        self.levelFive = levelFive
        self.levelFour = levelFour
        self.levelOne = levelOne
        self.levelThree = levelThree
        self.levelTwo = levelTwo
    }
}

extension HierarchyStructureUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case levelFive = "LevelFive"
        case levelFour = "LevelFour"
        case levelOne = "LevelOne"
        case levelThree = "LevelThree"
        case levelTwo = "LevelTwo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let levelFive = levelFive {
            try encodeContainer.encode(levelFive, forKey: .levelFive)
        }
        if let levelFour = levelFour {
            try encodeContainer.encode(levelFour, forKey: .levelFour)
        }
        if let levelOne = levelOne {
            try encodeContainer.encode(levelOne, forKey: .levelOne)
        }
        if let levelThree = levelThree {
            try encodeContainer.encode(levelThree, forKey: .levelThree)
        }
        if let levelTwo = levelTwo {
            try encodeContainer.encode(levelTwo, forKey: .levelTwo)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let levelOneDecoded = try containerValues.decodeIfPresent(HierarchyLevelUpdate.self, forKey: .levelOne)
        levelOne = levelOneDecoded
        let levelTwoDecoded = try containerValues.decodeIfPresent(HierarchyLevelUpdate.self, forKey: .levelTwo)
        levelTwo = levelTwoDecoded
        let levelThreeDecoded = try containerValues.decodeIfPresent(HierarchyLevelUpdate.self, forKey: .levelThree)
        levelThree = levelThreeDecoded
        let levelFourDecoded = try containerValues.decodeIfPresent(HierarchyLevelUpdate.self, forKey: .levelFour)
        levelFour = levelFourDecoded
        let levelFiveDecoded = try containerValues.decodeIfPresent(HierarchyLevelUpdate.self, forKey: .levelFive)
        levelFive = levelFiveDecoded
    }
}

extension HierarchyStructureUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HierarchyStructureUpdate(levelFive: \(String(describing: levelFive)), levelFour: \(String(describing: levelFour)), levelOne: \(String(describing: levelOne)), levelThree: \(String(describing: levelThree)), levelTwo: \(String(describing: levelTwo)))"}
}

/// <p>Contains information about the level hierarchy to update.</p>
public struct HierarchyStructureUpdate: Equatable {
    /// <p>The update for level five.</p>
    public let levelFive: HierarchyLevelUpdate?
    /// <p>The update for level four.</p>
    public let levelFour: HierarchyLevelUpdate?
    /// <p>The
    ///    update
    ///    for level one.</p>
    public let levelOne: HierarchyLevelUpdate?
    /// <p>The update for level three.</p>
    public let levelThree: HierarchyLevelUpdate?
    /// <p>The update for level two.</p>
    public let levelTwo: HierarchyLevelUpdate?

    public init (
        levelFive: HierarchyLevelUpdate? = nil,
        levelFour: HierarchyLevelUpdate? = nil,
        levelOne: HierarchyLevelUpdate? = nil,
        levelThree: HierarchyLevelUpdate? = nil,
        levelTwo: HierarchyLevelUpdate? = nil
    )
    {
        self.levelFive = levelFive
        self.levelFour = levelFour
        self.levelOne = levelOne
        self.levelThree = levelThree
        self.levelTwo = levelTwo
    }
}

extension HistoricalMetric: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case statistic = "Statistic"
        case threshold = "Threshold"
        case unit = "Unit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let statistic = statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
        if let threshold = threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(HistoricalMetricName.self, forKey: .name)
        name = nameDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Threshold.self, forKey: .threshold)
        threshold = thresholdDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(Statistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Unit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension HistoricalMetric: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HistoricalMetric(name: \(String(describing: name)), statistic: \(String(describing: statistic)), threshold: \(String(describing: threshold)), unit: \(String(describing: unit)))"}
}

/// <p>Contains information about a historical metric. For a description of each metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical Metrics Definitions</a> in the <i>Amazon Connect Administrator
///    Guide</i>.</p>
public struct HistoricalMetric: Equatable {
    /// <p>The name of the metric.</p>
    public let name: HistoricalMetricName?
    /// <p>The statistic for the metric.</p>
    public let statistic: Statistic?
    /// <p>The threshold for the metric, used with service level metrics.</p>
    public let threshold: Threshold?
    /// <p>The unit for the metric.</p>
    public let unit: Unit?

    public init (
        name: HistoricalMetricName? = nil,
        statistic: Statistic? = nil,
        threshold: Threshold? = nil,
        unit: Unit? = nil
    )
    {
        self.name = name
        self.statistic = statistic
        self.threshold = threshold
        self.unit = unit
    }
}

extension HistoricalMetricData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metric = "Metric"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(HistoricalMetric.self, forKey: .metric)
        metric = metricDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension HistoricalMetricData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HistoricalMetricData(metric: \(String(describing: metric)), value: \(String(describing: value)))"}
}

/// <p>Contains the data for a historical metric.</p>
public struct HistoricalMetricData: Equatable {
    /// <p>Information about the metric.</p>
    public let metric: HistoricalMetric?
    /// <p>The value of the metric.</p>
    public let value: Double?

    public init (
        metric: HistoricalMetric? = nil,
        value: Double? = nil
    )
    {
        self.metric = metric
        self.value = value
    }
}

/// <p>The historical metric names.</p>
public enum HistoricalMetricName {
    case abandonTime
    case afterContactWorkTime
    case apiContactsHandled
    case callbackContactsHandled
    case contactsAbandoned
    case contactsAgentHungUpFirst
    case contactsConsulted
    case contactsHandled
    case contactsHandledIncoming
    case contactsHandledOutbound
    case contactsHoldAbandons
    case contactsMissed
    case contactsQueued
    case contactsTransferredIn
    case contactsTransferredInFromQueue
    case contactsTransferredOut
    case contactsTransferredOutFromQueue
    case handleTime
    case holdTime
    case interactionAndHoldTime
    case interactionTime
    case occupancy
    case queuedTime
    case queueAnswerTime
    case serviceLevel
    case sdkUnknown(String)
}

extension HistoricalMetricName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HistoricalMetricName] {
        return [
            .abandonTime,
            .afterContactWorkTime,
            .apiContactsHandled,
            .callbackContactsHandled,
            .contactsAbandoned,
            .contactsAgentHungUpFirst,
            .contactsConsulted,
            .contactsHandled,
            .contactsHandledIncoming,
            .contactsHandledOutbound,
            .contactsHoldAbandons,
            .contactsMissed,
            .contactsQueued,
            .contactsTransferredIn,
            .contactsTransferredInFromQueue,
            .contactsTransferredOut,
            .contactsTransferredOutFromQueue,
            .handleTime,
            .holdTime,
            .interactionAndHoldTime,
            .interactionTime,
            .occupancy,
            .queuedTime,
            .queueAnswerTime,
            .serviceLevel,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .abandonTime: return "ABANDON_TIME"
        case .afterContactWorkTime: return "AFTER_CONTACT_WORK_TIME"
        case .apiContactsHandled: return "API_CONTACTS_HANDLED"
        case .callbackContactsHandled: return "CALLBACK_CONTACTS_HANDLED"
        case .contactsAbandoned: return "CONTACTS_ABANDONED"
        case .contactsAgentHungUpFirst: return "CONTACTS_AGENT_HUNG_UP_FIRST"
        case .contactsConsulted: return "CONTACTS_CONSULTED"
        case .contactsHandled: return "CONTACTS_HANDLED"
        case .contactsHandledIncoming: return "CONTACTS_HANDLED_INCOMING"
        case .contactsHandledOutbound: return "CONTACTS_HANDLED_OUTBOUND"
        case .contactsHoldAbandons: return "CONTACTS_HOLD_ABANDONS"
        case .contactsMissed: return "CONTACTS_MISSED"
        case .contactsQueued: return "CONTACTS_QUEUED"
        case .contactsTransferredIn: return "CONTACTS_TRANSFERRED_IN"
        case .contactsTransferredInFromQueue: return "CONTACTS_TRANSFERRED_IN_FROM_QUEUE"
        case .contactsTransferredOut: return "CONTACTS_TRANSFERRED_OUT"
        case .contactsTransferredOutFromQueue: return "CONTACTS_TRANSFERRED_OUT_FROM_QUEUE"
        case .handleTime: return "HANDLE_TIME"
        case .holdTime: return "HOLD_TIME"
        case .interactionAndHoldTime: return "INTERACTION_AND_HOLD_TIME"
        case .interactionTime: return "INTERACTION_TIME"
        case .occupancy: return "OCCUPANCY"
        case .queuedTime: return "QUEUED_TIME"
        case .queueAnswerTime: return "QUEUE_ANSWER_TIME"
        case .serviceLevel: return "SERVICE_LEVEL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HistoricalMetricName(rawValue: rawValue) ?? HistoricalMetricName.sdkUnknown(rawValue)
    }
}

extension HistoricalMetricResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case collections = "Collections"
        case dimensions = "Dimensions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collections = collections {
            var collectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .collections)
            for historicalmetricdatacollections0 in collections {
                try collectionsContainer.encode(historicalmetricdatacollections0)
            }
        }
        if let dimensions = dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsDecoded = try containerValues.decodeIfPresent(Dimensions.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let collectionsContainer = try containerValues.decodeIfPresent([HistoricalMetricData?].self, forKey: .collections)
        var collectionsDecoded0:[HistoricalMetricData]? = nil
        if let collectionsContainer = collectionsContainer {
            collectionsDecoded0 = [HistoricalMetricData]()
            for structure0 in collectionsContainer {
                if let structure0 = structure0 {
                    collectionsDecoded0?.append(structure0)
                }
            }
        }
        collections = collectionsDecoded0
    }
}

extension HistoricalMetricResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HistoricalMetricResult(collections: \(String(describing: collections)), dimensions: \(String(describing: dimensions)))"}
}

/// <p>Contains information about the historical metrics retrieved.</p>
public struct HistoricalMetricResult: Equatable {
    /// <p>The set of metrics.</p>
    public let collections: [HistoricalMetricData]?
    /// <p>The dimension for the metrics.</p>
    public let dimensions: Dimensions?

    public init (
        collections: [HistoricalMetricData]? = nil,
        dimensions: Dimensions? = nil
    )
    {
        self.collections = collections
        self.dimensions = dimensions
    }
}

extension HoursOfOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case config = "Config"
        case description = "Description"
        case hoursOfOperationArn = "HoursOfOperationArn"
        case hoursOfOperationId = "HoursOfOperationId"
        case name = "Name"
        case tags = "Tags"
        case timeZone = "TimeZone"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = config {
            var configContainer = encodeContainer.nestedUnkeyedContainer(forKey: .config)
            for hoursofoperationconfiglist0 in config {
                try configContainer.encode(hoursofoperationconfiglist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hoursOfOperationArn = hoursOfOperationArn {
            try encodeContainer.encode(hoursOfOperationArn, forKey: .hoursOfOperationArn)
        }
        if let hoursOfOperationId = hoursOfOperationId {
            try encodeContainer.encode(hoursOfOperationId, forKey: .hoursOfOperationId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let timeZone = timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursOfOperationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hoursOfOperationId)
        hoursOfOperationId = hoursOfOperationIdDecoded
        let hoursOfOperationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hoursOfOperationArn)
        hoursOfOperationArn = hoursOfOperationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let configContainer = try containerValues.decodeIfPresent([HoursOfOperationConfig?].self, forKey: .config)
        var configDecoded0:[HoursOfOperationConfig]? = nil
        if let configContainer = configContainer {
            configDecoded0 = [HoursOfOperationConfig]()
            for structure0 in configContainer {
                if let structure0 = structure0 {
                    configDecoded0?.append(structure0)
                }
            }
        }
        config = configDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension HoursOfOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HoursOfOperation(config: \(String(describing: config)), description: \(String(describing: description)), hoursOfOperationArn: \(String(describing: hoursOfOperationArn)), hoursOfOperationId: \(String(describing: hoursOfOperationId)), name: \(String(describing: name)), tags: \(String(describing: tags)), timeZone: \(String(describing: timeZone)))"}
}

/// <p>Information about of the hours of operation.</p>
public struct HoursOfOperation: Equatable {
    /// <p>Configuration information for the hours of operation.</p>
    public let config: [HoursOfOperationConfig]?
    /// <p>The description for the hours of operation.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) for the hours of operation.</p>
    public let hoursOfOperationArn: String?
    /// <p>The identifier for the hours of operation.</p>
    public let hoursOfOperationId: String?
    /// <p>The name for the hours of operation.</p>
    public let name: String?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?
    /// <p>The time zone for the hours of operation.</p>
    public let timeZone: String?

    public init (
        config: [HoursOfOperationConfig]? = nil,
        description: String? = nil,
        hoursOfOperationArn: String? = nil,
        hoursOfOperationId: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil,
        timeZone: String? = nil
    )
    {
        self.config = config
        self.description = description
        self.hoursOfOperationArn = hoursOfOperationArn
        self.hoursOfOperationId = hoursOfOperationId
        self.name = name
        self.tags = tags
        self.timeZone = timeZone
    }
}

extension HoursOfOperationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case day = "Day"
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let day = day {
            try encodeContainer.encode(day.rawValue, forKey: .day)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dayDecoded = try containerValues.decodeIfPresent(HoursOfOperationDays.self, forKey: .day)
        day = dayDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(HoursOfOperationTimeSlice.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(HoursOfOperationTimeSlice.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension HoursOfOperationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HoursOfOperationConfig(day: \(String(describing: day)), endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)))"}
}

/// <p>Contains information about the hours of operation.</p>
public struct HoursOfOperationConfig: Equatable {
    /// <p>The day that the hours of operation applies to.</p>
    public let day: HoursOfOperationDays?
    /// <p>The end time that your contact center is closes.</p>
    public let endTime: HoursOfOperationTimeSlice?
    /// <p>The start time that your contact center is open.</p>
    public let startTime: HoursOfOperationTimeSlice?

    public init (
        day: HoursOfOperationDays? = nil,
        endTime: HoursOfOperationTimeSlice? = nil,
        startTime: HoursOfOperationTimeSlice? = nil
    )
    {
        self.day = day
        self.endTime = endTime
        self.startTime = startTime
    }
}

public enum HoursOfOperationDays {
    case friday
    case monday
    case saturday
    case sunday
    case thursday
    case tuesday
    case wednesday
    case sdkUnknown(String)
}

extension HoursOfOperationDays : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HoursOfOperationDays] {
        return [
            .friday,
            .monday,
            .saturday,
            .sunday,
            .thursday,
            .tuesday,
            .wednesday,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .friday: return "FRIDAY"
        case .monday: return "MONDAY"
        case .saturday: return "SATURDAY"
        case .sunday: return "SUNDAY"
        case .thursday: return "THURSDAY"
        case .tuesday: return "TUESDAY"
        case .wednesday: return "WEDNESDAY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HoursOfOperationDays(rawValue: rawValue) ?? HoursOfOperationDays.sdkUnknown(rawValue)
    }
}

extension HoursOfOperationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension HoursOfOperationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HoursOfOperationSummary(arn: \(String(describing: arn)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Contains summary information about hours of operation for a contact center.</p>
public struct HoursOfOperationSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the hours of operation.</p>
    public let arn: String?
    /// <p>The identifier of the hours of operation.</p>
    public let id: String?
    /// <p>The name of the hours of operation.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
    }
}

extension HoursOfOperationTimeSlice: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hours = "Hours"
        case minutes = "Minutes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if hours != 0 {
            try encodeContainer.encode(hours, forKey: .hours)
        }
        if minutes != 0 {
            try encodeContainer.encode(minutes, forKey: .minutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursDecoded = try containerValues.decode(Int.self, forKey: .hours)
        hours = hoursDecoded
        let minutesDecoded = try containerValues.decode(Int.self, forKey: .minutes)
        minutes = minutesDecoded
    }
}

extension HoursOfOperationTimeSlice: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HoursOfOperationTimeSlice(hours: \(String(describing: hours)), minutes: \(String(describing: minutes)))"}
}

/// <p>The start time or end time for an hours of operation.</p>
public struct HoursOfOperationTimeSlice: Equatable {
    /// <p>The hours.</p>
    public let hours: Int
    /// <p>The minutes.</p>
    public let minutes: Int

    public init (
        hours: Int = 0,
        minutes: Int = 0
    )
    {
        self.hours = hours
        self.minutes = minutes
    }
}

extension Instance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case id = "Id"
        case identityManagementType = "IdentityManagementType"
        case inboundCallsEnabled = "InboundCallsEnabled"
        case instanceAlias = "InstanceAlias"
        case instanceStatus = "InstanceStatus"
        case outboundCallsEnabled = "OutboundCallsEnabled"
        case serviceRole = "ServiceRole"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identityManagementType = identityManagementType {
            try encodeContainer.encode(identityManagementType.rawValue, forKey: .identityManagementType)
        }
        if let inboundCallsEnabled = inboundCallsEnabled {
            try encodeContainer.encode(inboundCallsEnabled, forKey: .inboundCallsEnabled)
        }
        if let instanceAlias = instanceAlias {
            try encodeContainer.encode(instanceAlias, forKey: .instanceAlias)
        }
        if let instanceStatus = instanceStatus {
            try encodeContainer.encode(instanceStatus.rawValue, forKey: .instanceStatus)
        }
        if let outboundCallsEnabled = outboundCallsEnabled {
            try encodeContainer.encode(outboundCallsEnabled, forKey: .outboundCallsEnabled)
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let identityManagementTypeDecoded = try containerValues.decodeIfPresent(DirectoryType.self, forKey: .identityManagementType)
        identityManagementType = identityManagementTypeDecoded
        let instanceAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceAlias)
        instanceAlias = instanceAliasDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let instanceStatusDecoded = try containerValues.decodeIfPresent(InstanceStatus.self, forKey: .instanceStatus)
        instanceStatus = instanceStatusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(InstanceStatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let inboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .inboundCallsEnabled)
        inboundCallsEnabled = inboundCallsEnabledDecoded
        let outboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .outboundCallsEnabled)
        outboundCallsEnabled = outboundCallsEnabledDecoded
    }
}

extension Instance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Instance(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), id: \(String(describing: id)), identityManagementType: \(String(describing: identityManagementType)), inboundCallsEnabled: \(String(describing: inboundCallsEnabled)), instanceAlias: \(String(describing: instanceAlias)), instanceStatus: \(String(describing: instanceStatus)), outboundCallsEnabled: \(String(describing: outboundCallsEnabled)), serviceRole: \(String(describing: serviceRole)), statusReason: \(String(describing: statusReason)))"}
}

/// <p>The Amazon Connect instance.</p>
public struct Instance: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the instance.</p>
    public let arn: String?
    /// <p>When the instance was created.</p>
    public let createdTime: Date?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let id: String?
    /// <p>The identity management type.</p>
    public let identityManagementType: DirectoryType?
    /// <p>Whether inbound calls are enabled.</p>
    public let inboundCallsEnabled: Bool?
    /// <p>The alias of instance.</p>
    public let instanceAlias: String?
    /// <p>The state of the instance.</p>
    public let instanceStatus: InstanceStatus?
    /// <p>Whether outbound calls are enabled.</p>
    public let outboundCallsEnabled: Bool?
    /// <p>The service role of the instance.</p>
    public let serviceRole: String?
    /// <p>Relevant
    ///    details why the instance was not successfully created. </p>
    public let statusReason: InstanceStatusReason?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil,
        id: String? = nil,
        identityManagementType: DirectoryType? = nil,
        inboundCallsEnabled: Bool? = nil,
        instanceAlias: String? = nil,
        instanceStatus: InstanceStatus? = nil,
        outboundCallsEnabled: Bool? = nil,
        serviceRole: String? = nil,
        statusReason: InstanceStatusReason? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.id = id
        self.identityManagementType = identityManagementType
        self.inboundCallsEnabled = inboundCallsEnabled
        self.instanceAlias = instanceAlias
        self.instanceStatus = instanceStatus
        self.outboundCallsEnabled = outboundCallsEnabled
        self.serviceRole = serviceRole
        self.statusReason = statusReason
    }
}

public enum InstanceAttributeType {
    case autoResolveBestVoices
    case contactflowLogs
    case contactLens
    case earlyMedia
    case inboundCalls
    case outboundCalls
    case useCustomTtsVoices
    case sdkUnknown(String)
}

extension InstanceAttributeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InstanceAttributeType] {
        return [
            .autoResolveBestVoices,
            .contactflowLogs,
            .contactLens,
            .earlyMedia,
            .inboundCalls,
            .outboundCalls,
            .useCustomTtsVoices,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .autoResolveBestVoices: return "AUTO_RESOLVE_BEST_VOICES"
        case .contactflowLogs: return "CONTACTFLOW_LOGS"
        case .contactLens: return "CONTACT_LENS"
        case .earlyMedia: return "EARLY_MEDIA"
        case .inboundCalls: return "INBOUND_CALLS"
        case .outboundCalls: return "OUTBOUND_CALLS"
        case .useCustomTtsVoices: return "USE_CUSTOM_TTS_VOICES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InstanceAttributeType(rawValue: rawValue) ?? InstanceAttributeType.sdkUnknown(rawValue)
    }
}

public enum InstanceStatus {
    case active
    case creationFailed
    case creationInProgress
    case sdkUnknown(String)
}

extension InstanceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InstanceStatus] {
        return [
            .active,
            .creationFailed,
            .creationInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creationFailed: return "CREATION_FAILED"
        case .creationInProgress: return "CREATION_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InstanceStatus(rawValue: rawValue) ?? InstanceStatus.sdkUnknown(rawValue)
    }
}

extension InstanceStatusReason: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InstanceStatusReason: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceStatusReason(message: \(String(describing: message)))"}
}

/// <p>Relevant
///    details why the instance was not successfully created.</p>
public struct InstanceStatusReason: Equatable {
    /// <p>The message.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

extension InstanceStorageConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case kinesisFirehoseConfig = "KinesisFirehoseConfig"
        case kinesisStreamConfig = "KinesisStreamConfig"
        case kinesisVideoStreamConfig = "KinesisVideoStreamConfig"
        case s3Config = "S3Config"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let kinesisFirehoseConfig = kinesisFirehoseConfig {
            try encodeContainer.encode(kinesisFirehoseConfig, forKey: .kinesisFirehoseConfig)
        }
        if let kinesisStreamConfig = kinesisStreamConfig {
            try encodeContainer.encode(kinesisStreamConfig, forKey: .kinesisStreamConfig)
        }
        if let kinesisVideoStreamConfig = kinesisVideoStreamConfig {
            try encodeContainer.encode(kinesisVideoStreamConfig, forKey: .kinesisVideoStreamConfig)
        }
        if let s3Config = s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let s3ConfigDecoded = try containerValues.decodeIfPresent(S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
        let kinesisVideoStreamConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoStreamConfig.self, forKey: .kinesisVideoStreamConfig)
        kinesisVideoStreamConfig = kinesisVideoStreamConfigDecoded
        let kinesisStreamConfigDecoded = try containerValues.decodeIfPresent(KinesisStreamConfig.self, forKey: .kinesisStreamConfig)
        kinesisStreamConfig = kinesisStreamConfigDecoded
        let kinesisFirehoseConfigDecoded = try containerValues.decodeIfPresent(KinesisFirehoseConfig.self, forKey: .kinesisFirehoseConfig)
        kinesisFirehoseConfig = kinesisFirehoseConfigDecoded
    }
}

extension InstanceStorageConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceStorageConfig(associationId: \(String(describing: associationId)), kinesisFirehoseConfig: \(String(describing: kinesisFirehoseConfig)), kinesisStreamConfig: \(String(describing: kinesisStreamConfig)), kinesisVideoStreamConfig: \(String(describing: kinesisVideoStreamConfig)), s3Config: \(String(describing: s3Config)), storageType: \(String(describing: storageType)))"}
}

/// <p>The storage configuration for the instance.</p>
public struct InstanceStorageConfig: Equatable {
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    public let associationId: String?
    /// <p>The configuration of the Kinesis Firehose delivery stream.</p>
    public let kinesisFirehoseConfig: KinesisFirehoseConfig?
    /// <p>The configuration of the Kinesis data stream.</p>
    public let kinesisStreamConfig: KinesisStreamConfig?
    /// <p>The configuration of the Kinesis video stream.</p>
    public let kinesisVideoStreamConfig: KinesisVideoStreamConfig?
    /// <p>The S3 bucket
    ///    configuration.</p>
    public let s3Config: S3Config?
    /// <p>A valid storage type.</p>
    public let storageType: StorageType?

    public init (
        associationId: String? = nil,
        kinesisFirehoseConfig: KinesisFirehoseConfig? = nil,
        kinesisStreamConfig: KinesisStreamConfig? = nil,
        kinesisVideoStreamConfig: KinesisVideoStreamConfig? = nil,
        s3Config: S3Config? = nil,
        storageType: StorageType? = nil
    )
    {
        self.associationId = associationId
        self.kinesisFirehoseConfig = kinesisFirehoseConfig
        self.kinesisStreamConfig = kinesisStreamConfig
        self.kinesisVideoStreamConfig = kinesisVideoStreamConfig
        self.s3Config = s3Config
        self.storageType = storageType
    }
}

public enum InstanceStorageResourceType {
    case agentEvents
    case callRecordings
    case chatTranscripts
    case contactTraceRecords
    case mediaStreams
    case scheduledReports
    case sdkUnknown(String)
}

extension InstanceStorageResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InstanceStorageResourceType] {
        return [
            .agentEvents,
            .callRecordings,
            .chatTranscripts,
            .contactTraceRecords,
            .mediaStreams,
            .scheduledReports,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .agentEvents: return "AGENT_EVENTS"
        case .callRecordings: return "CALL_RECORDINGS"
        case .chatTranscripts: return "CHAT_TRANSCRIPTS"
        case .contactTraceRecords: return "CONTACT_TRACE_RECORDS"
        case .mediaStreams: return "MEDIA_STREAMS"
        case .scheduledReports: return "SCHEDULED_REPORTS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InstanceStorageResourceType(rawValue: rawValue) ?? InstanceStorageResourceType.sdkUnknown(rawValue)
    }
}

extension InstanceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case id = "Id"
        case identityManagementType = "IdentityManagementType"
        case inboundCallsEnabled = "InboundCallsEnabled"
        case instanceAlias = "InstanceAlias"
        case instanceStatus = "InstanceStatus"
        case outboundCallsEnabled = "OutboundCallsEnabled"
        case serviceRole = "ServiceRole"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identityManagementType = identityManagementType {
            try encodeContainer.encode(identityManagementType.rawValue, forKey: .identityManagementType)
        }
        if let inboundCallsEnabled = inboundCallsEnabled {
            try encodeContainer.encode(inboundCallsEnabled, forKey: .inboundCallsEnabled)
        }
        if let instanceAlias = instanceAlias {
            try encodeContainer.encode(instanceAlias, forKey: .instanceAlias)
        }
        if let instanceStatus = instanceStatus {
            try encodeContainer.encode(instanceStatus.rawValue, forKey: .instanceStatus)
        }
        if let outboundCallsEnabled = outboundCallsEnabled {
            try encodeContainer.encode(outboundCallsEnabled, forKey: .outboundCallsEnabled)
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let identityManagementTypeDecoded = try containerValues.decodeIfPresent(DirectoryType.self, forKey: .identityManagementType)
        identityManagementType = identityManagementTypeDecoded
        let instanceAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceAlias)
        instanceAlias = instanceAliasDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let instanceStatusDecoded = try containerValues.decodeIfPresent(InstanceStatus.self, forKey: .instanceStatus)
        instanceStatus = instanceStatusDecoded
        let inboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .inboundCallsEnabled)
        inboundCallsEnabled = inboundCallsEnabledDecoded
        let outboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .outboundCallsEnabled)
        outboundCallsEnabled = outboundCallsEnabledDecoded
    }
}

extension InstanceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceSummary(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), id: \(String(describing: id)), identityManagementType: \(String(describing: identityManagementType)), inboundCallsEnabled: \(String(describing: inboundCallsEnabled)), instanceAlias: \(String(describing: instanceAlias)), instanceStatus: \(String(describing: instanceStatus)), outboundCallsEnabled: \(String(describing: outboundCallsEnabled)), serviceRole: \(String(describing: serviceRole)))"}
}

/// <p>Information about the instance.</p>
public struct InstanceSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the instance.</p>
    public let arn: String?
    /// <p>When the instance was created.</p>
    public let createdTime: Date?
    /// <p>The identifier of the instance.</p>
    public let id: String?
    /// <p>The identity management type of the instance.</p>
    public let identityManagementType: DirectoryType?
    /// <p>Whether inbound calls are enabled.</p>
    public let inboundCallsEnabled: Bool?
    /// <p>The alias of the instance.</p>
    public let instanceAlias: String?
    /// <p>The state of the instance.</p>
    public let instanceStatus: InstanceStatus?
    /// <p>Whether outbound calls are enabled.</p>
    public let outboundCallsEnabled: Bool?
    /// <p>The service role of the instance.</p>
    public let serviceRole: String?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil,
        id: String? = nil,
        identityManagementType: DirectoryType? = nil,
        inboundCallsEnabled: Bool? = nil,
        instanceAlias: String? = nil,
        instanceStatus: InstanceStatus? = nil,
        outboundCallsEnabled: Bool? = nil,
        serviceRole: String? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.id = id
        self.identityManagementType = identityManagementType
        self.inboundCallsEnabled = inboundCallsEnabled
        self.instanceAlias = instanceAlias
        self.instanceStatus = instanceStatus
        self.outboundCallsEnabled = outboundCallsEnabled
        self.serviceRole = serviceRole
    }
}

extension IntegrationAssociationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case integrationArn = "IntegrationArn"
        case integrationAssociationArn = "IntegrationAssociationArn"
        case integrationAssociationId = "IntegrationAssociationId"
        case integrationType = "IntegrationType"
        case sourceApplicationName = "SourceApplicationName"
        case sourceApplicationUrl = "SourceApplicationUrl"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let integrationArn = integrationArn {
            try encodeContainer.encode(integrationArn, forKey: .integrationArn)
        }
        if let integrationAssociationArn = integrationAssociationArn {
            try encodeContainer.encode(integrationAssociationArn, forKey: .integrationAssociationArn)
        }
        if let integrationAssociationId = integrationAssociationId {
            try encodeContainer.encode(integrationAssociationId, forKey: .integrationAssociationId)
        }
        if let integrationType = integrationType {
            try encodeContainer.encode(integrationType.rawValue, forKey: .integrationType)
        }
        if let sourceApplicationName = sourceApplicationName {
            try encodeContainer.encode(sourceApplicationName, forKey: .sourceApplicationName)
        }
        if let sourceApplicationUrl = sourceApplicationUrl {
            try encodeContainer.encode(sourceApplicationUrl, forKey: .sourceApplicationUrl)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integrationAssociationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationAssociationId)
        integrationAssociationId = integrationAssociationIdDecoded
        let integrationAssociationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationAssociationArn)
        integrationAssociationArn = integrationAssociationArnDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationArn)
        integrationArn = integrationArnDecoded
        let sourceApplicationUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceApplicationUrl)
        sourceApplicationUrl = sourceApplicationUrlDecoded
        let sourceApplicationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceApplicationName)
        sourceApplicationName = sourceApplicationNameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
    }
}

extension IntegrationAssociationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntegrationAssociationSummary(instanceId: \(String(describing: instanceId)), integrationArn: \(String(describing: integrationArn)), integrationAssociationArn: \(String(describing: integrationAssociationArn)), integrationAssociationId: \(String(describing: integrationAssociationId)), integrationType: \(String(describing: integrationType)), sourceApplicationName: \(String(describing: sourceApplicationName)), sourceApplicationUrl: \(String(describing: sourceApplicationUrl)), sourceType: \(String(describing: sourceType)))"}
}

/// <p>Contains summary information about the associated AppIntegrations.</p>
public struct IntegrationAssociationSummary: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The Amazon Resource Name (ARN) for the AppIntegration.</p>
    public let integrationArn: String?
    /// <p>The Amazon Resource Name (ARN) for the AppIntegration association.</p>
    public let integrationAssociationArn: String?
    /// <p>The identifier for the AppIntegration association.</p>
    public let integrationAssociationId: String?
    /// <p>The integration type.</p>
    public let integrationType: IntegrationType?
    /// <p>The user-provided, friendly name for the external application.</p>
    public let sourceApplicationName: String?
    /// <p>The URL for the external application.</p>
    public let sourceApplicationUrl: String?
    /// <p>The name of the source.</p>
    public let sourceType: SourceType?

    public init (
        instanceId: String? = nil,
        integrationArn: String? = nil,
        integrationAssociationArn: String? = nil,
        integrationAssociationId: String? = nil,
        integrationType: IntegrationType? = nil,
        sourceApplicationName: String? = nil,
        sourceApplicationUrl: String? = nil,
        sourceType: SourceType? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationArn = integrationArn
        self.integrationAssociationArn = integrationAssociationArn
        self.integrationAssociationId = integrationAssociationId
        self.integrationType = integrationType
        self.sourceApplicationName = sourceApplicationName
        self.sourceApplicationUrl = sourceApplicationUrl
        self.sourceType = sourceType
    }
}

public enum IntegrationType {
    case event
    case sdkUnknown(String)
}

extension IntegrationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IntegrationType] {
        return [
            .event,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .event: return "EVENT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IntegrationType(rawValue: rawValue) ?? IntegrationType.sdkUnknown(rawValue)
    }
}

extension InternalServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceException(message: \(String(describing: message)))"}
}

extension InternalServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request processing failed because of an error or failure with the service.</p>
public struct InternalServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidContactFlowException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidContactFlowException(problems: \(String(describing: problems)))"}
}

extension InvalidContactFlowException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidContactFlowExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.problems = output.problems
        } else {
            self.problems = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The contact flow is not valid.</p>
public struct InvalidContactFlowException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The problems with the contact flow. Please fix before trying again.</p>
    public var problems: [ProblemDetail]?

    public init (
        problems: [ProblemDetail]? = nil
    )
    {
        self.problems = problems
    }
}

struct InvalidContactFlowExceptionBody: Equatable {
    public let problems: [ProblemDetail]?
}

extension InvalidContactFlowExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case problems
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemsContainer = try containerValues.decodeIfPresent([ProblemDetail?].self, forKey: .problems)
        var problemsDecoded0:[ProblemDetail]? = nil
        if let problemsContainer = problemsContainer {
            problemsDecoded0 = [ProblemDetail]()
            for structure0 in problemsContainer {
                if let structure0 = structure0 {
                    problemsDecoded0?.append(structure0)
                }
            }
        }
        problems = problemsDecoded0
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more of the specified parameters are not valid.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message about the parameters.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is not valid.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message about the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisFirehoseConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firehoseArn = "FirehoseArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firehoseArn = firehoseArn {
            try encodeContainer.encode(firehoseArn, forKey: .firehoseArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firehoseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firehoseArn)
        firehoseArn = firehoseArnDecoded
    }
}

extension KinesisFirehoseConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseConfig(firehoseArn: \(String(describing: firehoseArn)))"}
}

/// <p>Configuration information of a Kinesis Data Firehose delivery stream.</p>
public struct KinesisFirehoseConfig: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the delivery stream.</p>
    public let firehoseArn: String?

    public init (
        firehoseArn: String? = nil
    )
    {
        self.firehoseArn = firehoseArn
    }
}

extension KinesisStreamConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case streamArn = "StreamArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamArn = streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
    }
}

extension KinesisStreamConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisStreamConfig(streamArn: \(String(describing: streamArn)))"}
}

/// <p>Configuration information of a Kinesis data stream.</p>
public struct KinesisStreamConfig: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the data stream.</p>
    public let streamArn: String?

    public init (
        streamArn: String? = nil
    )
    {
        self.streamArn = streamArn
    }
}

extension KinesisVideoStreamConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionConfig = "EncryptionConfig"
        case prefix = "Prefix"
        case retentionPeriodHours = "RetentionPeriodHours"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfig = encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
        if retentionPeriodHours != 0 {
            try encodeContainer.encode(retentionPeriodHours, forKey: .retentionPeriodHours)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let retentionPeriodHoursDecoded = try containerValues.decode(Int.self, forKey: .retentionPeriodHours)
        retentionPeriodHours = retentionPeriodHoursDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
    }
}

extension KinesisVideoStreamConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisVideoStreamConfig(encryptionConfig: \(String(describing: encryptionConfig)), prefix: \(String(describing: prefix)), retentionPeriodHours: \(String(describing: retentionPeriodHours)))"}
}

/// <p>Configuration information of a Kinesis video stream.</p>
public struct KinesisVideoStreamConfig: Equatable {
    /// <p>The encryption configuration.</p>
    public let encryptionConfig: EncryptionConfig?
    /// <p>The prefix of the video stream.</p>
    public let prefix: String?
    /// <p>The number of hours data is retained in the stream. Kinesis Video Streams retains the data
    ///    in a data store that is associated with the stream.</p>
    ///          <p>The default value is 0, indicating that the stream does not persist data.</p>
    public let retentionPeriodHours: Int

    public init (
        encryptionConfig: EncryptionConfig? = nil,
        prefix: String? = nil,
        retentionPeriodHours: Int = 0
    )
    {
        self.encryptionConfig = encryptionConfig
        self.prefix = prefix
        self.retentionPeriodHours = retentionPeriodHours
    }
}

extension LexBot: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lexRegion = "LexRegion"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lexRegion = lexRegion {
            try encodeContainer.encode(lexRegion, forKey: .lexRegion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let lexRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lexRegion)
        lexRegion = lexRegionDecoded
    }
}

extension LexBot: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LexBot(lexRegion: \(String(describing: lexRegion)), name: \(String(describing: name)))"}
}

/// <p>Configuration information of an Amazon Lex bot.</p>
public struct LexBot: Equatable {
    /// <p>The Region that the Amazon Lex bot was created in.</p>
    public let lexRegion: String?
    /// <p>The name of the Amazon Lex bot.</p>
    public let name: String?

    public init (
        lexRegion: String? = nil,
        name: String? = nil
    )
    {
        self.lexRegion = lexRegion
        self.name = name
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The allowed limit for the resource has been exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message about the limit.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApprovedOriginsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApprovedOriginsInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApprovedOriginsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListApprovedOriginsInputHeadersMiddleware: Middleware {
    public let id: String = "ListApprovedOriginsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApprovedOriginsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApprovedOriginsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApprovedOriginsInput>
    public typealias MOutput = OperationOutput<ListApprovedOriginsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApprovedOriginsOutputError>
}

public struct ListApprovedOriginsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListApprovedOriginsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApprovedOriginsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApprovedOriginsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApprovedOriginsInput>
    public typealias MOutput = OperationOutput<ListApprovedOriginsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApprovedOriginsOutputError>
}

public struct ListApprovedOriginsInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApprovedOriginsInputBody: Equatable {
}

extension ListApprovedOriginsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListApprovedOriginsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApprovedOriginsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApprovedOriginsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApprovedOriginsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApprovedOriginsOutputResponse(nextToken: \(String(describing: nextToken)), origins: \(String(describing: origins)))"}
}

extension ListApprovedOriginsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListApprovedOriginsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.origins = output.origins
        } else {
            self.nextToken = nil
            self.origins = nil
        }
    }
}

public struct ListApprovedOriginsOutputResponse: Equatable {
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?
    /// <p>The approved origins.</p>
    public let origins: [String]?

    public init (
        nextToken: String? = nil,
        origins: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.origins = origins
    }
}

struct ListApprovedOriginsOutputResponseBody: Equatable {
    public let origins: [String]?
    public let nextToken: String?
}

extension ListApprovedOriginsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case origins = "Origins"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .origins)
        var originsDecoded0:[String]? = nil
        if let originsContainer = originsContainer {
            originsDecoded0 = [String]()
            for string0 in originsContainer {
                if let string0 = string0 {
                    originsDecoded0?.append(string0)
                }
            }
        }
        origins = originsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListContactFlowsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContactFlowsInput(contactFlowTypes: \(String(describing: contactFlowTypes)), instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListContactFlowsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListContactFlowsInputHeadersMiddleware: Middleware {
    public let id: String = "ListContactFlowsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContactFlowsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContactFlowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContactFlowsInput>
    public typealias MOutput = OperationOutput<ListContactFlowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContactFlowsOutputError>
}

public struct ListContactFlowsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListContactFlowsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContactFlowsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContactFlowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let contactFlowTypes = input.operationInput.contactFlowTypes {
            contactFlowTypes.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "contactFlowTypes".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContactFlowsInput>
    public typealias MOutput = OperationOutput<ListContactFlowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContactFlowsOutputError>
}

public struct ListContactFlowsInput: Equatable {
    /// <p>The type of contact flow.</p>
    public let contactFlowTypes: [ContactFlowType]?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        contactFlowTypes: [ContactFlowType]? = nil,
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.contactFlowTypes = contactFlowTypes
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListContactFlowsInputBody: Equatable {
}

extension ListContactFlowsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListContactFlowsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContactFlowsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContactFlowsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContactFlowsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContactFlowsOutputResponse(contactFlowSummaryList: \(String(describing: contactFlowSummaryList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListContactFlowsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListContactFlowsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contactFlowSummaryList = output.contactFlowSummaryList
            self.nextToken = output.nextToken
        } else {
            self.contactFlowSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListContactFlowsOutputResponse: Equatable {
    /// <p>Information about the contact flows.</p>
    public let contactFlowSummaryList: [ContactFlowSummary]?
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?

    public init (
        contactFlowSummaryList: [ContactFlowSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.contactFlowSummaryList = contactFlowSummaryList
        self.nextToken = nextToken
    }
}

struct ListContactFlowsOutputResponseBody: Equatable {
    public let contactFlowSummaryList: [ContactFlowSummary]?
    public let nextToken: String?
}

extension ListContactFlowsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactFlowSummaryList = "ContactFlowSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactFlowSummaryListContainer = try containerValues.decodeIfPresent([ContactFlowSummary?].self, forKey: .contactFlowSummaryList)
        var contactFlowSummaryListDecoded0:[ContactFlowSummary]? = nil
        if let contactFlowSummaryListContainer = contactFlowSummaryListContainer {
            contactFlowSummaryListDecoded0 = [ContactFlowSummary]()
            for structure0 in contactFlowSummaryListContainer {
                if let structure0 = structure0 {
                    contactFlowSummaryListDecoded0?.append(structure0)
                }
            }
        }
        contactFlowSummaryList = contactFlowSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHoursOfOperationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHoursOfOperationsInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListHoursOfOperationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListHoursOfOperationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListHoursOfOperationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHoursOfOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHoursOfOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHoursOfOperationsInput>
    public typealias MOutput = OperationOutput<ListHoursOfOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHoursOfOperationsOutputError>
}

public struct ListHoursOfOperationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListHoursOfOperationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHoursOfOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHoursOfOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHoursOfOperationsInput>
    public typealias MOutput = OperationOutput<ListHoursOfOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHoursOfOperationsOutputError>
}

public struct ListHoursOfOperationsInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListHoursOfOperationsInputBody: Equatable {
}

extension ListHoursOfOperationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListHoursOfOperationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHoursOfOperationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHoursOfOperationsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHoursOfOperationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHoursOfOperationsOutputResponse(hoursOfOperationSummaryList: \(String(describing: hoursOfOperationSummaryList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListHoursOfOperationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListHoursOfOperationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hoursOfOperationSummaryList = output.hoursOfOperationSummaryList
            self.nextToken = output.nextToken
        } else {
            self.hoursOfOperationSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListHoursOfOperationsOutputResponse: Equatable {
    /// <p>Information about the hours of operation.</p>
    public let hoursOfOperationSummaryList: [HoursOfOperationSummary]?
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?

    public init (
        hoursOfOperationSummaryList: [HoursOfOperationSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.hoursOfOperationSummaryList = hoursOfOperationSummaryList
        self.nextToken = nextToken
    }
}

struct ListHoursOfOperationsOutputResponseBody: Equatable {
    public let hoursOfOperationSummaryList: [HoursOfOperationSummary]?
    public let nextToken: String?
}

extension ListHoursOfOperationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hoursOfOperationSummaryList = "HoursOfOperationSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursOfOperationSummaryListContainer = try containerValues.decodeIfPresent([HoursOfOperationSummary?].self, forKey: .hoursOfOperationSummaryList)
        var hoursOfOperationSummaryListDecoded0:[HoursOfOperationSummary]? = nil
        if let hoursOfOperationSummaryListContainer = hoursOfOperationSummaryListContainer {
            hoursOfOperationSummaryListDecoded0 = [HoursOfOperationSummary]()
            for structure0 in hoursOfOperationSummaryListContainer {
                if let structure0 = structure0 {
                    hoursOfOperationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        hoursOfOperationSummaryList = hoursOfOperationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstanceAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstanceAttributesInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInstanceAttributesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListInstanceAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "ListInstanceAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstanceAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstanceAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstanceAttributesInput>
    public typealias MOutput = OperationOutput<ListInstanceAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstanceAttributesOutputError>
}

public struct ListInstanceAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInstanceAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstanceAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstanceAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstanceAttributesInput>
    public typealias MOutput = OperationOutput<ListInstanceAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstanceAttributesOutputError>
}

public struct ListInstanceAttributesInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstanceAttributesInputBody: Equatable {
}

extension ListInstanceAttributesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListInstanceAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstanceAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstanceAttributesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstanceAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstanceAttributesOutputResponse(attributes: \(String(describing: attributes)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInstanceAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInstanceAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
            self.nextToken = output.nextToken
        } else {
            self.attributes = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstanceAttributesOutputResponse: Equatable {
    /// <p>The attribute types.</p>
    public let attributes: [Attribute]?
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?

    public init (
        attributes: [Attribute]? = nil,
        nextToken: String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

struct ListInstanceAttributesOutputResponseBody: Equatable {
    public let attributes: [Attribute]?
    public let nextToken: String?
}

extension ListInstanceAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstanceStorageConfigsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstanceStorageConfigsInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceType: \(String(describing: resourceType)))"}
}

extension ListInstanceStorageConfigsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListInstanceStorageConfigsInputHeadersMiddleware: Middleware {
    public let id: String = "ListInstanceStorageConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstanceStorageConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstanceStorageConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstanceStorageConfigsInput>
    public typealias MOutput = OperationOutput<ListInstanceStorageConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstanceStorageConfigsOutputError>
}

public struct ListInstanceStorageConfigsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInstanceStorageConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstanceStorageConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstanceStorageConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = URLQueryItem(name: "resourceType".urlPercentEncoding(), value: String(resourceType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstanceStorageConfigsInput>
    public typealias MOutput = OperationOutput<ListInstanceStorageConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstanceStorageConfigsOutputError>
}

public struct ListInstanceStorageConfigsInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>A valid resource type.</p>
    public let resourceType: InstanceStorageResourceType?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        resourceType: InstanceStorageResourceType? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListInstanceStorageConfigsInputBody: Equatable {
}

extension ListInstanceStorageConfigsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListInstanceStorageConfigsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstanceStorageConfigsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstanceStorageConfigsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstanceStorageConfigsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstanceStorageConfigsOutputResponse(nextToken: \(String(describing: nextToken)), storageConfigs: \(String(describing: storageConfigs)))"}
}

extension ListInstanceStorageConfigsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInstanceStorageConfigsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.storageConfigs = output.storageConfigs
        } else {
            self.nextToken = nil
            self.storageConfigs = nil
        }
    }
}

public struct ListInstanceStorageConfigsOutputResponse: Equatable {
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?
    /// <p>A valid storage type.</p>
    public let storageConfigs: [InstanceStorageConfig]?

    public init (
        nextToken: String? = nil,
        storageConfigs: [InstanceStorageConfig]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageConfigs = storageConfigs
    }
}

struct ListInstanceStorageConfigsOutputResponseBody: Equatable {
    public let storageConfigs: [InstanceStorageConfig]?
    public let nextToken: String?
}

extension ListInstanceStorageConfigsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case storageConfigs = "StorageConfigs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageConfigsContainer = try containerValues.decodeIfPresent([InstanceStorageConfig?].self, forKey: .storageConfigs)
        var storageConfigsDecoded0:[InstanceStorageConfig]? = nil
        if let storageConfigsContainer = storageConfigsContainer {
            storageConfigsDecoded0 = [InstanceStorageConfig]()
            for structure0 in storageConfigsContainer {
                if let structure0 = structure0 {
                    storageConfigsDecoded0?.append(structure0)
                }
            }
        }
        storageConfigs = storageConfigsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstancesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInstancesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "ListInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstancesInput>
    public typealias MOutput = OperationOutput<ListInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstancesOutputError>
}

public struct ListInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstancesInput>
    public typealias MOutput = OperationOutput<ListInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstancesOutputError>
}

public struct ListInstancesInput: Equatable {
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstancesInputBody: Equatable {
}

extension ListInstancesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstancesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstancesOutputResponse(instanceSummaryList: \(String(describing: instanceSummaryList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceSummaryList = output.instanceSummaryList
            self.nextToken = output.nextToken
        } else {
            self.instanceSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstancesOutputResponse: Equatable {
    /// <p>Information about the instances.</p>
    public let instanceSummaryList: [InstanceSummary]?
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?

    public init (
        instanceSummaryList: [InstanceSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.instanceSummaryList = instanceSummaryList
        self.nextToken = nextToken
    }
}

struct ListInstancesOutputResponseBody: Equatable {
    public let instanceSummaryList: [InstanceSummary]?
    public let nextToken: String?
}

extension ListInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceSummaryList = "InstanceSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceSummaryListContainer = try containerValues.decodeIfPresent([InstanceSummary?].self, forKey: .instanceSummaryList)
        var instanceSummaryListDecoded0:[InstanceSummary]? = nil
        if let instanceSummaryListContainer = instanceSummaryListContainer {
            instanceSummaryListDecoded0 = [InstanceSummary]()
            for structure0 in instanceSummaryListContainer {
                if let structure0 = structure0 {
                    instanceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        instanceSummaryList = instanceSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIntegrationAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIntegrationAssociationsInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIntegrationAssociationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListIntegrationAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListIntegrationAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIntegrationAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIntegrationAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIntegrationAssociationsInput>
    public typealias MOutput = OperationOutput<ListIntegrationAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIntegrationAssociationsOutputError>
}

public struct ListIntegrationAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIntegrationAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIntegrationAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIntegrationAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIntegrationAssociationsInput>
    public typealias MOutput = OperationOutput<ListIntegrationAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIntegrationAssociationsOutputError>
}

public struct ListIntegrationAssociationsInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIntegrationAssociationsInputBody: Equatable {
}

extension ListIntegrationAssociationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListIntegrationAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIntegrationAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIntegrationAssociationsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIntegrationAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIntegrationAssociationsOutputResponse(integrationAssociationSummaryList: \(String(describing: integrationAssociationSummaryList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIntegrationAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIntegrationAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.integrationAssociationSummaryList = output.integrationAssociationSummaryList
            self.nextToken = output.nextToken
        } else {
            self.integrationAssociationSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListIntegrationAssociationsOutputResponse: Equatable {
    /// <p>The AppIntegration associations.</p>
    public let integrationAssociationSummaryList: [IntegrationAssociationSummary]?
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?

    public init (
        integrationAssociationSummaryList: [IntegrationAssociationSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.integrationAssociationSummaryList = integrationAssociationSummaryList
        self.nextToken = nextToken
    }
}

struct ListIntegrationAssociationsOutputResponseBody: Equatable {
    public let integrationAssociationSummaryList: [IntegrationAssociationSummary]?
    public let nextToken: String?
}

extension ListIntegrationAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case integrationAssociationSummaryList = "IntegrationAssociationSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integrationAssociationSummaryListContainer = try containerValues.decodeIfPresent([IntegrationAssociationSummary?].self, forKey: .integrationAssociationSummaryList)
        var integrationAssociationSummaryListDecoded0:[IntegrationAssociationSummary]? = nil
        if let integrationAssociationSummaryListContainer = integrationAssociationSummaryListContainer {
            integrationAssociationSummaryListDecoded0 = [IntegrationAssociationSummary]()
            for structure0 in integrationAssociationSummaryListContainer {
                if let structure0 = structure0 {
                    integrationAssociationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        integrationAssociationSummaryList = integrationAssociationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLambdaFunctionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLambdaFunctionsInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLambdaFunctionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListLambdaFunctionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLambdaFunctionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLambdaFunctionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLambdaFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLambdaFunctionsInput>
    public typealias MOutput = OperationOutput<ListLambdaFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLambdaFunctionsOutputError>
}

public struct ListLambdaFunctionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLambdaFunctionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLambdaFunctionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLambdaFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLambdaFunctionsInput>
    public typealias MOutput = OperationOutput<ListLambdaFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLambdaFunctionsOutputError>
}

public struct ListLambdaFunctionsInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLambdaFunctionsInputBody: Equatable {
}

extension ListLambdaFunctionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListLambdaFunctionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLambdaFunctionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLambdaFunctionsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLambdaFunctionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLambdaFunctionsOutputResponse(lambdaFunctions: \(String(describing: lambdaFunctions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLambdaFunctionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLambdaFunctionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lambdaFunctions = output.lambdaFunctions
            self.nextToken = output.nextToken
        } else {
            self.lambdaFunctions = nil
            self.nextToken = nil
        }
    }
}

public struct ListLambdaFunctionsOutputResponse: Equatable {
    /// <p>The Lambdafunction ARNs associated with the specified instance.</p>
    public let lambdaFunctions: [String]?
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?

    public init (
        lambdaFunctions: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.lambdaFunctions = lambdaFunctions
        self.nextToken = nextToken
    }
}

struct ListLambdaFunctionsOutputResponseBody: Equatable {
    public let lambdaFunctions: [String]?
    public let nextToken: String?
}

extension ListLambdaFunctionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lambdaFunctions = "LambdaFunctions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .lambdaFunctions)
        var lambdaFunctionsDecoded0:[String]? = nil
        if let lambdaFunctionsContainer = lambdaFunctionsContainer {
            lambdaFunctionsDecoded0 = [String]()
            for string0 in lambdaFunctionsContainer {
                if let string0 = string0 {
                    lambdaFunctionsDecoded0?.append(string0)
                }
            }
        }
        lambdaFunctions = lambdaFunctionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLexBotsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLexBotsInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLexBotsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListLexBotsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLexBotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLexBotsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLexBotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLexBotsInput>
    public typealias MOutput = OperationOutput<ListLexBotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLexBotsOutputError>
}

public struct ListLexBotsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLexBotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLexBotsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLexBotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLexBotsInput>
    public typealias MOutput = OperationOutput<ListLexBotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLexBotsOutputError>
}

public struct ListLexBotsInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLexBotsInputBody: Equatable {
}

extension ListLexBotsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListLexBotsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLexBotsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLexBotsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLexBotsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLexBotsOutputResponse(lexBots: \(String(describing: lexBots)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLexBotsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLexBotsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lexBots = output.lexBots
            self.nextToken = output.nextToken
        } else {
            self.lexBots = nil
            self.nextToken = nil
        }
    }
}

public struct ListLexBotsOutputResponse: Equatable {
    /// <p>The names and Regions of the Amazon Lex bots associated with the specified instance.</p>
    public let lexBots: [LexBot]?
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?

    public init (
        lexBots: [LexBot]? = nil,
        nextToken: String? = nil
    )
    {
        self.lexBots = lexBots
        self.nextToken = nextToken
    }
}

struct ListLexBotsOutputResponseBody: Equatable {
    public let lexBots: [LexBot]?
    public let nextToken: String?
}

extension ListLexBotsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lexBots = "LexBots"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexBotsContainer = try containerValues.decodeIfPresent([LexBot?].self, forKey: .lexBots)
        var lexBotsDecoded0:[LexBot]? = nil
        if let lexBotsContainer = lexBotsContainer {
            lexBotsDecoded0 = [LexBot]()
            for structure0 in lexBotsContainer {
                if let structure0 = structure0 {
                    lexBotsDecoded0?.append(structure0)
                }
            }
        }
        lexBots = lexBotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPhoneNumbersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPhoneNumbersInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), phoneNumberCountryCodes: \(String(describing: phoneNumberCountryCodes)), phoneNumberTypes: \(String(describing: phoneNumberTypes)))"}
}

extension ListPhoneNumbersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPhoneNumbersInputHeadersMiddleware: Middleware {
    public let id: String = "ListPhoneNumbersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPhoneNumbersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPhoneNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPhoneNumbersInput>
    public typealias MOutput = OperationOutput<ListPhoneNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPhoneNumbersOutputError>
}

public struct ListPhoneNumbersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPhoneNumbersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPhoneNumbersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPhoneNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let phoneNumberTypes = input.operationInput.phoneNumberTypes {
            phoneNumberTypes.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "phoneNumberTypes".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let phoneNumberCountryCodes = input.operationInput.phoneNumberCountryCodes {
            phoneNumberCountryCodes.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "phoneNumberCountryCodes".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPhoneNumbersInput>
    public typealias MOutput = OperationOutput<ListPhoneNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPhoneNumbersOutputError>
}

public struct ListPhoneNumbersInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The ISO country code.</p>
    public let phoneNumberCountryCodes: [PhoneNumberCountryCode]?
    /// <p>The type of phone number.</p>
    public let phoneNumberTypes: [PhoneNumberType]?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        phoneNumberCountryCodes: [PhoneNumberCountryCode]? = nil,
        phoneNumberTypes: [PhoneNumberType]? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.phoneNumberCountryCodes = phoneNumberCountryCodes
        self.phoneNumberTypes = phoneNumberTypes
    }
}

struct ListPhoneNumbersInputBody: Equatable {
}

extension ListPhoneNumbersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPhoneNumbersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPhoneNumbersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPhoneNumbersOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPhoneNumbersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPhoneNumbersOutputResponse(nextToken: \(String(describing: nextToken)), phoneNumberSummaryList: \(String(describing: phoneNumberSummaryList)))"}
}

extension ListPhoneNumbersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPhoneNumbersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.phoneNumberSummaryList = output.phoneNumberSummaryList
        } else {
            self.nextToken = nil
            self.phoneNumberSummaryList = nil
        }
    }
}

public struct ListPhoneNumbersOutputResponse: Equatable {
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Information about the phone numbers.</p>
    public let phoneNumberSummaryList: [PhoneNumberSummary]?

    public init (
        nextToken: String? = nil,
        phoneNumberSummaryList: [PhoneNumberSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumberSummaryList = phoneNumberSummaryList
    }
}

struct ListPhoneNumbersOutputResponseBody: Equatable {
    public let phoneNumberSummaryList: [PhoneNumberSummary]?
    public let nextToken: String?
}

extension ListPhoneNumbersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case phoneNumberSummaryList = "PhoneNumberSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberSummaryListContainer = try containerValues.decodeIfPresent([PhoneNumberSummary?].self, forKey: .phoneNumberSummaryList)
        var phoneNumberSummaryListDecoded0:[PhoneNumberSummary]? = nil
        if let phoneNumberSummaryListContainer = phoneNumberSummaryListContainer {
            phoneNumberSummaryListDecoded0 = [PhoneNumberSummary]()
            for structure0 in phoneNumberSummaryListContainer {
                if let structure0 = structure0 {
                    phoneNumberSummaryListDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberSummaryList = phoneNumberSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPromptsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPromptsInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPromptsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPromptsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPromptsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPromptsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPromptsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPromptsInput>
    public typealias MOutput = OperationOutput<ListPromptsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPromptsOutputError>
}

public struct ListPromptsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPromptsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPromptsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPromptsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPromptsInput>
    public typealias MOutput = OperationOutput<ListPromptsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPromptsOutputError>
}

public struct ListPromptsInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous response in
    ///    the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPromptsInputBody: Equatable {
}

extension ListPromptsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPromptsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPromptsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPromptsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPromptsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPromptsOutputResponse(nextToken: \(String(describing: nextToken)), promptSummaryList: \(String(describing: promptSummaryList)))"}
}

extension ListPromptsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPromptsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.promptSummaryList = output.promptSummaryList
        } else {
            self.nextToken = nil
            self.promptSummaryList = nil
        }
    }
}

public struct ListPromptsOutputResponse: Equatable {
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Information about the prompts.</p>
    public let promptSummaryList: [PromptSummary]?

    public init (
        nextToken: String? = nil,
        promptSummaryList: [PromptSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.promptSummaryList = promptSummaryList
    }
}

struct ListPromptsOutputResponseBody: Equatable {
    public let promptSummaryList: [PromptSummary]?
    public let nextToken: String?
}

extension ListPromptsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case promptSummaryList = "PromptSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let promptSummaryListContainer = try containerValues.decodeIfPresent([PromptSummary?].self, forKey: .promptSummaryList)
        var promptSummaryListDecoded0:[PromptSummary]? = nil
        if let promptSummaryListContainer = promptSummaryListContainer {
            promptSummaryListDecoded0 = [PromptSummary]()
            for structure0 in promptSummaryListContainer {
                if let structure0 = structure0 {
                    promptSummaryListDecoded0?.append(structure0)
                }
            }
        }
        promptSummaryList = promptSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListQueueQuickConnectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListQueueQuickConnectsInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), queueId: \(String(describing: queueId)))"}
}

extension ListQueueQuickConnectsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListQueueQuickConnectsInputHeadersMiddleware: Middleware {
    public let id: String = "ListQueueQuickConnectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQueueQuickConnectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQueueQuickConnectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQueueQuickConnectsInput>
    public typealias MOutput = OperationOutput<ListQueueQuickConnectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQueueQuickConnectsOutputError>
}

public struct ListQueueQuickConnectsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListQueueQuickConnectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQueueQuickConnectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQueueQuickConnectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQueueQuickConnectsInput>
    public typealias MOutput = OperationOutput<ListQueueQuickConnectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQueueQuickConnectsOutputError>
}

public struct ListQueueQuickConnectsInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The identifier for the queue.</p>
    public let queueId: String?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        queueId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

struct ListQueueQuickConnectsInputBody: Equatable {
}

extension ListQueueQuickConnectsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListQueueQuickConnectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQueueQuickConnectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListQueueQuickConnectsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQueueQuickConnectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListQueueQuickConnectsOutputResponse(nextToken: \(String(describing: nextToken)), quickConnectSummaryList: \(String(describing: quickConnectSummaryList)))"}
}

extension ListQueueQuickConnectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListQueueQuickConnectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.quickConnectSummaryList = output.quickConnectSummaryList
        } else {
            self.nextToken = nil
            self.quickConnectSummaryList = nil
        }
    }
}

public struct ListQueueQuickConnectsOutputResponse: Equatable {
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Information about the quick connects.</p>
    public let quickConnectSummaryList: [QuickConnectSummary]?

    public init (
        nextToken: String? = nil,
        quickConnectSummaryList: [QuickConnectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.quickConnectSummaryList = quickConnectSummaryList
    }
}

struct ListQueueQuickConnectsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let quickConnectSummaryList: [QuickConnectSummary]?
}

extension ListQueueQuickConnectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case quickConnectSummaryList = "QuickConnectSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let quickConnectSummaryListContainer = try containerValues.decodeIfPresent([QuickConnectSummary?].self, forKey: .quickConnectSummaryList)
        var quickConnectSummaryListDecoded0:[QuickConnectSummary]? = nil
        if let quickConnectSummaryListContainer = quickConnectSummaryListContainer {
            quickConnectSummaryListDecoded0 = [QuickConnectSummary]()
            for structure0 in quickConnectSummaryListContainer {
                if let structure0 = structure0 {
                    quickConnectSummaryListDecoded0?.append(structure0)
                }
            }
        }
        quickConnectSummaryList = quickConnectSummaryListDecoded0
    }
}

extension ListQueuesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListQueuesInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), queueTypes: \(String(describing: queueTypes)))"}
}

extension ListQueuesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListQueuesInputHeadersMiddleware: Middleware {
    public let id: String = "ListQueuesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQueuesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQueuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQueuesInput>
    public typealias MOutput = OperationOutput<ListQueuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQueuesOutputError>
}

public struct ListQueuesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListQueuesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQueuesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQueuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let queueTypes = input.operationInput.queueTypes {
            queueTypes.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "queueTypes".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQueuesInput>
    public typealias MOutput = OperationOutput<ListQueuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQueuesOutputError>
}

public struct ListQueuesInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The type of queue.</p>
    public let queueTypes: [QueueType]?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        queueTypes: [QueueType]? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueTypes = queueTypes
    }
}

struct ListQueuesInputBody: Equatable {
}

extension ListQueuesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListQueuesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQueuesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListQueuesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQueuesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListQueuesOutputResponse(nextToken: \(String(describing: nextToken)), queueSummaryList: \(String(describing: queueSummaryList)))"}
}

extension ListQueuesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListQueuesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.queueSummaryList = output.queueSummaryList
        } else {
            self.nextToken = nil
            self.queueSummaryList = nil
        }
    }
}

public struct ListQueuesOutputResponse: Equatable {
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Information about the queues.</p>
    public let queueSummaryList: [QueueSummary]?

    public init (
        nextToken: String? = nil,
        queueSummaryList: [QueueSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.queueSummaryList = queueSummaryList
    }
}

struct ListQueuesOutputResponseBody: Equatable {
    public let queueSummaryList: [QueueSummary]?
    public let nextToken: String?
}

extension ListQueuesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case queueSummaryList = "QueueSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueSummaryListContainer = try containerValues.decodeIfPresent([QueueSummary?].self, forKey: .queueSummaryList)
        var queueSummaryListDecoded0:[QueueSummary]? = nil
        if let queueSummaryListContainer = queueSummaryListContainer {
            queueSummaryListDecoded0 = [QueueSummary]()
            for structure0 in queueSummaryListContainer {
                if let structure0 = structure0 {
                    queueSummaryListDecoded0?.append(structure0)
                }
            }
        }
        queueSummaryList = queueSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListQuickConnectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListQuickConnectsInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), quickConnectTypes: \(String(describing: quickConnectTypes)))"}
}

extension ListQuickConnectsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListQuickConnectsInputHeadersMiddleware: Middleware {
    public let id: String = "ListQuickConnectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQuickConnectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQuickConnectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQuickConnectsInput>
    public typealias MOutput = OperationOutput<ListQuickConnectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQuickConnectsOutputError>
}

public struct ListQuickConnectsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListQuickConnectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQuickConnectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQuickConnectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let quickConnectTypes = input.operationInput.quickConnectTypes {
            quickConnectTypes.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "QuickConnectTypes".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQuickConnectsInput>
    public typealias MOutput = OperationOutput<ListQuickConnectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQuickConnectsOutputError>
}

public struct ListQuickConnectsInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are
    ///    prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).</p>
    public let quickConnectTypes: [QuickConnectType]?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        quickConnectTypes: [QuickConnectType]? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quickConnectTypes = quickConnectTypes
    }
}

struct ListQuickConnectsInputBody: Equatable {
}

extension ListQuickConnectsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListQuickConnectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQuickConnectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListQuickConnectsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQuickConnectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListQuickConnectsOutputResponse(nextToken: \(String(describing: nextToken)), quickConnectSummaryList: \(String(describing: quickConnectSummaryList)))"}
}

extension ListQuickConnectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListQuickConnectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.quickConnectSummaryList = output.quickConnectSummaryList
        } else {
            self.nextToken = nil
            self.quickConnectSummaryList = nil
        }
    }
}

public struct ListQuickConnectsOutputResponse: Equatable {
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Information about the quick connects.</p>
    public let quickConnectSummaryList: [QuickConnectSummary]?

    public init (
        nextToken: String? = nil,
        quickConnectSummaryList: [QuickConnectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.quickConnectSummaryList = quickConnectSummaryList
    }
}

struct ListQuickConnectsOutputResponseBody: Equatable {
    public let quickConnectSummaryList: [QuickConnectSummary]?
    public let nextToken: String?
}

extension ListQuickConnectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case quickConnectSummaryList = "QuickConnectSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectSummaryListContainer = try containerValues.decodeIfPresent([QuickConnectSummary?].self, forKey: .quickConnectSummaryList)
        var quickConnectSummaryListDecoded0:[QuickConnectSummary]? = nil
        if let quickConnectSummaryListContainer = quickConnectSummaryListContainer {
            quickConnectSummaryListDecoded0 = [QuickConnectSummary]()
            for structure0 in quickConnectSummaryListContainer {
                if let structure0 = structure0 {
                    quickConnectSummaryListDecoded0?.append(structure0)
                }
            }
        }
        quickConnectSummaryList = quickConnectSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRoutingProfileQueuesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRoutingProfileQueuesInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), routingProfileId: \(String(describing: routingProfileId)))"}
}

extension ListRoutingProfileQueuesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRoutingProfileQueuesInputHeadersMiddleware: Middleware {
    public let id: String = "ListRoutingProfileQueuesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRoutingProfileQueuesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRoutingProfileQueuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRoutingProfileQueuesInput>
    public typealias MOutput = OperationOutput<ListRoutingProfileQueuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRoutingProfileQueuesOutputError>
}

public struct ListRoutingProfileQueuesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRoutingProfileQueuesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRoutingProfileQueuesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRoutingProfileQueuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRoutingProfileQueuesInput>
    public typealias MOutput = OperationOutput<ListRoutingProfileQueuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRoutingProfileQueuesOutputError>
}

public struct ListRoutingProfileQueuesInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The identifier of the routing profile.</p>
    public let routingProfileId: String?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        routingProfileId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.routingProfileId = routingProfileId
    }
}

struct ListRoutingProfileQueuesInputBody: Equatable {
}

extension ListRoutingProfileQueuesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRoutingProfileQueuesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRoutingProfileQueuesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRoutingProfileQueuesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRoutingProfileQueuesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRoutingProfileQueuesOutputResponse(nextToken: \(String(describing: nextToken)), routingProfileQueueConfigSummaryList: \(String(describing: routingProfileQueueConfigSummaryList)))"}
}

extension ListRoutingProfileQueuesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRoutingProfileQueuesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.routingProfileQueueConfigSummaryList = output.routingProfileQueueConfigSummaryList
        } else {
            self.nextToken = nil
            self.routingProfileQueueConfigSummaryList = nil
        }
    }
}

public struct ListRoutingProfileQueuesOutputResponse: Equatable {
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Information about the routing profiles.</p>
    public let routingProfileQueueConfigSummaryList: [RoutingProfileQueueConfigSummary]?

    public init (
        nextToken: String? = nil,
        routingProfileQueueConfigSummaryList: [RoutingProfileQueueConfigSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.routingProfileQueueConfigSummaryList = routingProfileQueueConfigSummaryList
    }
}

struct ListRoutingProfileQueuesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let routingProfileQueueConfigSummaryList: [RoutingProfileQueueConfigSummary]?
}

extension ListRoutingProfileQueuesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case routingProfileQueueConfigSummaryList = "RoutingProfileQueueConfigSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let routingProfileQueueConfigSummaryListContainer = try containerValues.decodeIfPresent([RoutingProfileQueueConfigSummary?].self, forKey: .routingProfileQueueConfigSummaryList)
        var routingProfileQueueConfigSummaryListDecoded0:[RoutingProfileQueueConfigSummary]? = nil
        if let routingProfileQueueConfigSummaryListContainer = routingProfileQueueConfigSummaryListContainer {
            routingProfileQueueConfigSummaryListDecoded0 = [RoutingProfileQueueConfigSummary]()
            for structure0 in routingProfileQueueConfigSummaryListContainer {
                if let structure0 = structure0 {
                    routingProfileQueueConfigSummaryListDecoded0?.append(structure0)
                }
            }
        }
        routingProfileQueueConfigSummaryList = routingProfileQueueConfigSummaryListDecoded0
    }
}

extension ListRoutingProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRoutingProfilesInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRoutingProfilesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRoutingProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "ListRoutingProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRoutingProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRoutingProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRoutingProfilesInput>
    public typealias MOutput = OperationOutput<ListRoutingProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRoutingProfilesOutputError>
}

public struct ListRoutingProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRoutingProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRoutingProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRoutingProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRoutingProfilesInput>
    public typealias MOutput = OperationOutput<ListRoutingProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRoutingProfilesOutputError>
}

public struct ListRoutingProfilesInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRoutingProfilesInputBody: Equatable {
}

extension ListRoutingProfilesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRoutingProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRoutingProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRoutingProfilesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRoutingProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRoutingProfilesOutputResponse(nextToken: \(String(describing: nextToken)), routingProfileSummaryList: \(String(describing: routingProfileSummaryList)))"}
}

extension ListRoutingProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRoutingProfilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.routingProfileSummaryList = output.routingProfileSummaryList
        } else {
            self.nextToken = nil
            self.routingProfileSummaryList = nil
        }
    }
}

public struct ListRoutingProfilesOutputResponse: Equatable {
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Information about the routing profiles.</p>
    public let routingProfileSummaryList: [RoutingProfileSummary]?

    public init (
        nextToken: String? = nil,
        routingProfileSummaryList: [RoutingProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.routingProfileSummaryList = routingProfileSummaryList
    }
}

struct ListRoutingProfilesOutputResponseBody: Equatable {
    public let routingProfileSummaryList: [RoutingProfileSummary]?
    public let nextToken: String?
}

extension ListRoutingProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case routingProfileSummaryList = "RoutingProfileSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingProfileSummaryListContainer = try containerValues.decodeIfPresent([RoutingProfileSummary?].self, forKey: .routingProfileSummaryList)
        var routingProfileSummaryListDecoded0:[RoutingProfileSummary]? = nil
        if let routingProfileSummaryListContainer = routingProfileSummaryListContainer {
            routingProfileSummaryListDecoded0 = [RoutingProfileSummary]()
            for structure0 in routingProfileSummaryListContainer {
                if let structure0 = structure0 {
                    routingProfileSummaryListDecoded0?.append(structure0)
                }
            }
        }
        routingProfileSummaryList = routingProfileSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSecurityKeysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSecurityKeysInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSecurityKeysInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSecurityKeysInputHeadersMiddleware: Middleware {
    public let id: String = "ListSecurityKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecurityKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecurityKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecurityKeysInput>
    public typealias MOutput = OperationOutput<ListSecurityKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecurityKeysOutputError>
}

public struct ListSecurityKeysInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSecurityKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecurityKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecurityKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecurityKeysInput>
    public typealias MOutput = OperationOutput<ListSecurityKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecurityKeysOutputError>
}

public struct ListSecurityKeysInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSecurityKeysInputBody: Equatable {
}

extension ListSecurityKeysInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSecurityKeysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecurityKeysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSecurityKeysOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecurityKeysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSecurityKeysOutputResponse(nextToken: \(String(describing: nextToken)), securityKeys: \(String(describing: securityKeys)))"}
}

extension ListSecurityKeysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSecurityKeysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.securityKeys = output.securityKeys
        } else {
            self.nextToken = nil
            self.securityKeys = nil
        }
    }
}

public struct ListSecurityKeysOutputResponse: Equatable {
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?
    /// <p>The security keys.</p>
    public let securityKeys: [SecurityKey]?

    public init (
        nextToken: String? = nil,
        securityKeys: [SecurityKey]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityKeys = securityKeys
    }
}

struct ListSecurityKeysOutputResponseBody: Equatable {
    public let securityKeys: [SecurityKey]?
    public let nextToken: String?
}

extension ListSecurityKeysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case securityKeys = "SecurityKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityKeysContainer = try containerValues.decodeIfPresent([SecurityKey?].self, forKey: .securityKeys)
        var securityKeysDecoded0:[SecurityKey]? = nil
        if let securityKeysContainer = securityKeysContainer {
            securityKeysDecoded0 = [SecurityKey]()
            for structure0 in securityKeysContainer {
                if let structure0 = structure0 {
                    securityKeysDecoded0?.append(structure0)
                }
            }
        }
        securityKeys = securityKeysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSecurityProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSecurityProfilesInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSecurityProfilesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSecurityProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "ListSecurityProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecurityProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecurityProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecurityProfilesInput>
    public typealias MOutput = OperationOutput<ListSecurityProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecurityProfilesOutputError>
}

public struct ListSecurityProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSecurityProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecurityProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecurityProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecurityProfilesInput>
    public typealias MOutput = OperationOutput<ListSecurityProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecurityProfilesOutputError>
}

public struct ListSecurityProfilesInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSecurityProfilesInputBody: Equatable {
}

extension ListSecurityProfilesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSecurityProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecurityProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSecurityProfilesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecurityProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSecurityProfilesOutputResponse(nextToken: \(String(describing: nextToken)), securityProfileSummaryList: \(String(describing: securityProfileSummaryList)))"}
}

extension ListSecurityProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSecurityProfilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.securityProfileSummaryList = output.securityProfileSummaryList
        } else {
            self.nextToken = nil
            self.securityProfileSummaryList = nil
        }
    }
}

public struct ListSecurityProfilesOutputResponse: Equatable {
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Information about the security profiles.</p>
    public let securityProfileSummaryList: [SecurityProfileSummary]?

    public init (
        nextToken: String? = nil,
        securityProfileSummaryList: [SecurityProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityProfileSummaryList = securityProfileSummaryList
    }
}

struct ListSecurityProfilesOutputResponseBody: Equatable {
    public let securityProfileSummaryList: [SecurityProfileSummary]?
    public let nextToken: String?
}

extension ListSecurityProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case securityProfileSummaryList = "SecurityProfileSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileSummaryListContainer = try containerValues.decodeIfPresent([SecurityProfileSummary?].self, forKey: .securityProfileSummaryList)
        var securityProfileSummaryListDecoded0:[SecurityProfileSummary]? = nil
        if let securityProfileSummaryListContainer = securityProfileSummaryListContainer {
            securityProfileSummaryListDecoded0 = [SecurityProfileSummary]()
            for structure0 in securityProfileSummaryListContainer {
                if let structure0 = structure0 {
                    securityProfileSummaryListDecoded0?.append(structure0)
                }
            }
        }
        securityProfileSummaryList = securityProfileSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>Information about the tags.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListUseCasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUseCasesInput(instanceId: \(String(describing: instanceId)), integrationAssociationId: \(String(describing: integrationAssociationId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListUseCasesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListUseCasesInputHeadersMiddleware: Middleware {
    public let id: String = "ListUseCasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUseCasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUseCasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUseCasesInput>
    public typealias MOutput = OperationOutput<ListUseCasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUseCasesOutputError>
}

public struct ListUseCasesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUseCasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUseCasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUseCasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUseCasesInput>
    public typealias MOutput = OperationOutput<ListUseCasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUseCasesOutputError>
}

/// <p>Provides summary information about the use cases for the specified Amazon Connect AppIntegration
///    association.</p>
public struct ListUseCasesInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier for the integration association.</p>
    public let integrationAssociationId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        instanceId: String? = nil,
        integrationAssociationId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationAssociationId = integrationAssociationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUseCasesInputBody: Equatable {
}

extension ListUseCasesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListUseCasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUseCasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUseCasesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUseCasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUseCasesOutputResponse(nextToken: \(String(describing: nextToken)), useCaseSummaryList: \(String(describing: useCaseSummaryList)))"}
}

extension ListUseCasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUseCasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.useCaseSummaryList = output.useCaseSummaryList
        } else {
            self.nextToken = nil
            self.useCaseSummaryList = nil
        }
    }
}

public struct ListUseCasesOutputResponse: Equatable {
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?
    /// <p>The use cases.</p>
    public let useCaseSummaryList: [UseCase]?

    public init (
        nextToken: String? = nil,
        useCaseSummaryList: [UseCase]? = nil
    )
    {
        self.nextToken = nextToken
        self.useCaseSummaryList = useCaseSummaryList
    }
}

struct ListUseCasesOutputResponseBody: Equatable {
    public let useCaseSummaryList: [UseCase]?
    public let nextToken: String?
}

extension ListUseCasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case useCaseSummaryList = "UseCaseSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let useCaseSummaryListContainer = try containerValues.decodeIfPresent([UseCase?].self, forKey: .useCaseSummaryList)
        var useCaseSummaryListDecoded0:[UseCase]? = nil
        if let useCaseSummaryListContainer = useCaseSummaryListContainer {
            useCaseSummaryListDecoded0 = [UseCase]()
            for structure0 in useCaseSummaryListContainer {
                if let structure0 = structure0 {
                    useCaseSummaryListDecoded0?.append(structure0)
                }
            }
        }
        useCaseSummaryList = useCaseSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUserHierarchyGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUserHierarchyGroupsInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListUserHierarchyGroupsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListUserHierarchyGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListUserHierarchyGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserHierarchyGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserHierarchyGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserHierarchyGroupsInput>
    public typealias MOutput = OperationOutput<ListUserHierarchyGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserHierarchyGroupsOutputError>
}

public struct ListUserHierarchyGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUserHierarchyGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserHierarchyGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserHierarchyGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserHierarchyGroupsInput>
    public typealias MOutput = OperationOutput<ListUserHierarchyGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserHierarchyGroupsOutputError>
}

public struct ListUserHierarchyGroupsInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserHierarchyGroupsInputBody: Equatable {
}

extension ListUserHierarchyGroupsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListUserHierarchyGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUserHierarchyGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUserHierarchyGroupsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserHierarchyGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUserHierarchyGroupsOutputResponse(nextToken: \(String(describing: nextToken)), userHierarchyGroupSummaryList: \(String(describing: userHierarchyGroupSummaryList)))"}
}

extension ListUserHierarchyGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUserHierarchyGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.userHierarchyGroupSummaryList = output.userHierarchyGroupSummaryList
        } else {
            self.nextToken = nil
            self.userHierarchyGroupSummaryList = nil
        }
    }
}

public struct ListUserHierarchyGroupsOutputResponse: Equatable {
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Information about the hierarchy groups.</p>
    public let userHierarchyGroupSummaryList: [HierarchyGroupSummary]?

    public init (
        nextToken: String? = nil,
        userHierarchyGroupSummaryList: [HierarchyGroupSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userHierarchyGroupSummaryList = userHierarchyGroupSummaryList
    }
}

struct ListUserHierarchyGroupsOutputResponseBody: Equatable {
    public let userHierarchyGroupSummaryList: [HierarchyGroupSummary]?
    public let nextToken: String?
}

extension ListUserHierarchyGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case userHierarchyGroupSummaryList = "UserHierarchyGroupSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userHierarchyGroupSummaryListContainer = try containerValues.decodeIfPresent([HierarchyGroupSummary?].self, forKey: .userHierarchyGroupSummaryList)
        var userHierarchyGroupSummaryListDecoded0:[HierarchyGroupSummary]? = nil
        if let userHierarchyGroupSummaryListContainer = userHierarchyGroupSummaryListContainer {
            userHierarchyGroupSummaryListDecoded0 = [HierarchyGroupSummary]()
            for structure0 in userHierarchyGroupSummaryListContainer {
                if let structure0 = structure0 {
                    userHierarchyGroupSummaryListDecoded0?.append(structure0)
                }
            }
        }
        userHierarchyGroupSummaryList = userHierarchyGroupSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUsersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsersInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListUsersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListUsersInputHeadersMiddleware: Middleware {
    public let id: String = "ListUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

public struct ListUsersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

public struct ListUsersInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsersInputBody: Equatable {
}

extension ListUsersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListUsersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsersOutputResponse(nextToken: \(String(describing: nextToken)), userSummaryList: \(String(describing: userSummaryList)))"}
}

extension ListUsersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.userSummaryList = output.userSummaryList
        } else {
            self.nextToken = nil
            self.userSummaryList = nil
        }
    }
}

public struct ListUsersOutputResponse: Equatable {
    /// <p>If there are additional results, this is the token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Information about the users.</p>
    public let userSummaryList: [UserSummary]?

    public init (
        nextToken: String? = nil,
        userSummaryList: [UserSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userSummaryList = userSummaryList
    }
}

struct ListUsersOutputResponseBody: Equatable {
    public let userSummaryList: [UserSummary]?
    public let nextToken: String?
}

extension ListUsersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case userSummaryList = "UserSummaryList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSummaryListContainer = try containerValues.decodeIfPresent([UserSummary?].self, forKey: .userSummaryList)
        var userSummaryListDecoded0:[UserSummary]? = nil
        if let userSummaryListContainer = userSummaryListContainer {
            userSummaryListDecoded0 = [UserSummary]()
            for structure0 in userSummaryListContainer {
                if let structure0 = structure0 {
                    userSummaryListDecoded0?.append(structure0)
                }
            }
        }
        userSummaryList = userSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MediaConcurrency: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channel = "Channel"
        case concurrency = "Concurrency"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if concurrency != 0 {
            try encodeContainer.encode(concurrency, forKey: .concurrency)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(Channel.self, forKey: .channel)
        channel = channelDecoded
        let concurrencyDecoded = try containerValues.decode(Int.self, forKey: .concurrency)
        concurrency = concurrencyDecoded
    }
}

extension MediaConcurrency: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MediaConcurrency(channel: \(String(describing: channel)), concurrency: \(String(describing: concurrency)))"}
}

/// <p>Contains information about which channels are supported, and how many contacts an agent can
///    have on a channel simultaneously.</p>
public struct MediaConcurrency: Equatable {
    /// <p>The channels that agents can handle in the Contact Control Panel (CCP).</p>
    public let channel: Channel?
    /// <p>The number of contacts an agent can have on a channel simultaneously.</p>
    ///          <p>Valid Range for <code>VOICE</code>: Minimum value of 1. Maximum value of 1.</p>
    ///          <p>Valid Range for <code>CHAT</code>: Minimum value of 1. Maximum value of 5.</p>
    ///          <p>Valid Range for <code>TASK</code>: Minimum value of 1. Maximum value of 10.</p>
    public let concurrency: Int

    public init (
        channel: Channel? = nil,
        concurrency: Int = 0
    )
    {
        self.channel = channel
        self.concurrency = concurrency
    }
}

extension OutboundCallerConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case outboundCallerIdName = "OutboundCallerIdName"
        case outboundCallerIdNumberId = "OutboundCallerIdNumberId"
        case outboundFlowId = "OutboundFlowId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outboundCallerIdName = outboundCallerIdName {
            try encodeContainer.encode(outboundCallerIdName, forKey: .outboundCallerIdName)
        }
        if let outboundCallerIdNumberId = outboundCallerIdNumberId {
            try encodeContainer.encode(outboundCallerIdNumberId, forKey: .outboundCallerIdNumberId)
        }
        if let outboundFlowId = outboundFlowId {
            try encodeContainer.encode(outboundFlowId, forKey: .outboundFlowId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outboundCallerIdNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outboundCallerIdName)
        outboundCallerIdName = outboundCallerIdNameDecoded
        let outboundCallerIdNumberIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outboundCallerIdNumberId)
        outboundCallerIdNumberId = outboundCallerIdNumberIdDecoded
        let outboundFlowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outboundFlowId)
        outboundFlowId = outboundFlowIdDecoded
    }
}

extension OutboundCallerConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutboundCallerConfig(outboundCallerIdName: \(String(describing: outboundCallerIdName)), outboundCallerIdNumberId: \(String(describing: outboundCallerIdNumberId)), outboundFlowId: \(String(describing: outboundFlowId)))"}
}

/// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
public struct OutboundCallerConfig: Equatable {
    /// <p>The caller ID name.</p>
    public let outboundCallerIdName: String?
    /// <p>The caller ID number.</p>
    public let outboundCallerIdNumberId: String?
    /// <p>The outbound whisper flow to be used during an outbound call.</p>
    public let outboundFlowId: String?

    public init (
        outboundCallerIdName: String? = nil,
        outboundCallerIdNumberId: String? = nil,
        outboundFlowId: String? = nil
    )
    {
        self.outboundCallerIdName = outboundCallerIdName
        self.outboundCallerIdNumberId = outboundCallerIdNumberId
        self.outboundFlowId = outboundFlowId
    }
}

extension OutboundContactNotPermittedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutboundContactNotPermittedException(message: \(String(describing: message)))"}
}

extension OutboundContactNotPermittedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OutboundContactNotPermittedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The contact is not permitted.</p>
public struct OutboundContactNotPermittedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message about the contact.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OutboundContactNotPermittedExceptionBody: Equatable {
    public let message: String?
}

extension OutboundContactNotPermittedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParticipantDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName = "DisplayName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension ParticipantDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParticipantDetails(displayName: \(String(describing: displayName)))"}
}

/// <p>The customer's details.</p>
public struct ParticipantDetails: Equatable {
    /// <p>Display name of the participant.</p>
    public let displayName: String?

    public init (
        displayName: String? = nil
    )
    {
        self.displayName = displayName
    }
}

public enum PhoneNumberCountryCode {
    case ad
    case ae
    case af
    case ag
    case ai
    case al
    case am
    case an
    case ao
    case aq
    case ar
    case `as`
    case at
    case au
    case aw
    case az
    case ba
    case bb
    case bd
    case be
    case bf
    case bg
    case bh
    case bi
    case bj
    case bl
    case bm
    case bn
    case bo
    case br
    case bs
    case bt
    case bw
    case by
    case bz
    case ca
    case cc
    case cd
    case cf
    case cg
    case ch
    case ci
    case ck
    case cl
    case cm
    case cn
    case co
    case cr
    case cu
    case cv
    case cw
    case cx
    case cy
    case cz
    case de
    case dj
    case dk
    case dm
    case `do`
    case dz
    case ec
    case ee
    case eg
    case eh
    case er
    case es
    case et
    case fi
    case fj
    case fk
    case fm
    case fo
    case fr
    case ga
    case gb
    case gd
    case ge
    case gg
    case gh
    case gi
    case gl
    case gm
    case gn
    case gq
    case gr
    case gt
    case gu
    case gw
    case gy
    case hk
    case hn
    case hr
    case ht
    case hu
    case id
    case ie
    case il
    case im
    case `in`
    case io
    case iq
    case ir
    case `is`
    case it
    case je
    case jm
    case jo
    case jp
    case ke
    case kg
    case kh
    case ki
    case km
    case kn
    case kp
    case kr
    case kw
    case ky
    case kz
    case la
    case lb
    case lc
    case li
    case lk
    case lr
    case ls
    case lt
    case lu
    case lv
    case ly
    case ma
    case mc
    case md
    case me
    case mf
    case mg
    case mh
    case mk
    case ml
    case mm
    case mn
    case mo
    case mp
    case mr
    case ms
    case mt
    case mu
    case mv
    case mw
    case mx
    case my
    case mz
    case na
    case nc
    case ne
    case ng
    case ni
    case nl
    case no
    case np
    case nr
    case nu
    case nz
    case om
    case pa
    case pe
    case pf
    case pg
    case ph
    case pk
    case pl
    case pm
    case pn
    case pr
    case pt
    case pw
    case py
    case qa
    case re
    case ro
    case rs
    case ru
    case rw
    case sa
    case sb
    case sc
    case sd
    case se
    case sg
    case sh
    case si
    case sj
    case sk
    case sl
    case sm
    case sn
    case so
    case sr
    case st
    case sv
    case sx
    case sy
    case sz
    case tc
    case td
    case tg
    case th
    case tj
    case tk
    case tl
    case tm
    case tn
    case to
    case tr
    case tt
    case tv
    case tw
    case tz
    case ua
    case ug
    case us
    case uy
    case uz
    case va
    case vc
    case ve
    case vg
    case vi
    case vn
    case vu
    case wf
    case ws
    case ye
    case yt
    case za
    case zm
    case zw
    case sdkUnknown(String)
}

extension PhoneNumberCountryCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PhoneNumberCountryCode] {
        return [
            .ad,
            .ae,
            .af,
            .ag,
            .ai,
            .al,
            .am,
            .an,
            .ao,
            .aq,
            .ar,
            .as,
            .at,
            .au,
            .aw,
            .az,
            .ba,
            .bb,
            .bd,
            .be,
            .bf,
            .bg,
            .bh,
            .bi,
            .bj,
            .bl,
            .bm,
            .bn,
            .bo,
            .br,
            .bs,
            .bt,
            .bw,
            .by,
            .bz,
            .ca,
            .cc,
            .cd,
            .cf,
            .cg,
            .ch,
            .ci,
            .ck,
            .cl,
            .cm,
            .cn,
            .co,
            .cr,
            .cu,
            .cv,
            .cw,
            .cx,
            .cy,
            .cz,
            .de,
            .dj,
            .dk,
            .dm,
            .do,
            .dz,
            .ec,
            .ee,
            .eg,
            .eh,
            .er,
            .es,
            .et,
            .fi,
            .fj,
            .fk,
            .fm,
            .fo,
            .fr,
            .ga,
            .gb,
            .gd,
            .ge,
            .gg,
            .gh,
            .gi,
            .gl,
            .gm,
            .gn,
            .gq,
            .gr,
            .gt,
            .gu,
            .gw,
            .gy,
            .hk,
            .hn,
            .hr,
            .ht,
            .hu,
            .id,
            .ie,
            .il,
            .im,
            .in,
            .io,
            .iq,
            .ir,
            .is,
            .it,
            .je,
            .jm,
            .jo,
            .jp,
            .ke,
            .kg,
            .kh,
            .ki,
            .km,
            .kn,
            .kp,
            .kr,
            .kw,
            .ky,
            .kz,
            .la,
            .lb,
            .lc,
            .li,
            .lk,
            .lr,
            .ls,
            .lt,
            .lu,
            .lv,
            .ly,
            .ma,
            .mc,
            .md,
            .me,
            .mf,
            .mg,
            .mh,
            .mk,
            .ml,
            .mm,
            .mn,
            .mo,
            .mp,
            .mr,
            .ms,
            .mt,
            .mu,
            .mv,
            .mw,
            .mx,
            .my,
            .mz,
            .na,
            .nc,
            .ne,
            .ng,
            .ni,
            .nl,
            .no,
            .np,
            .nr,
            .nu,
            .nz,
            .om,
            .pa,
            .pe,
            .pf,
            .pg,
            .ph,
            .pk,
            .pl,
            .pm,
            .pn,
            .pr,
            .pt,
            .pw,
            .py,
            .qa,
            .re,
            .ro,
            .rs,
            .ru,
            .rw,
            .sa,
            .sb,
            .sc,
            .sd,
            .se,
            .sg,
            .sh,
            .si,
            .sj,
            .sk,
            .sl,
            .sm,
            .sn,
            .so,
            .sr,
            .st,
            .sv,
            .sx,
            .sy,
            .sz,
            .tc,
            .td,
            .tg,
            .th,
            .tj,
            .tk,
            .tl,
            .tm,
            .tn,
            .to,
            .tr,
            .tt,
            .tv,
            .tw,
            .tz,
            .ua,
            .ug,
            .us,
            .uy,
            .uz,
            .va,
            .vc,
            .ve,
            .vg,
            .vi,
            .vn,
            .vu,
            .wf,
            .ws,
            .ye,
            .yt,
            .za,
            .zm,
            .zw,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ad: return "AD"
        case .ae: return "AE"
        case .af: return "AF"
        case .ag: return "AG"
        case .ai: return "AI"
        case .al: return "AL"
        case .am: return "AM"
        case .an: return "AN"
        case .ao: return "AO"
        case .aq: return "AQ"
        case .ar: return "AR"
        case .as: return "AS"
        case .at: return "AT"
        case .au: return "AU"
        case .aw: return "AW"
        case .az: return "AZ"
        case .ba: return "BA"
        case .bb: return "BB"
        case .bd: return "BD"
        case .be: return "BE"
        case .bf: return "BF"
        case .bg: return "BG"
        case .bh: return "BH"
        case .bi: return "BI"
        case .bj: return "BJ"
        case .bl: return "BL"
        case .bm: return "BM"
        case .bn: return "BN"
        case .bo: return "BO"
        case .br: return "BR"
        case .bs: return "BS"
        case .bt: return "BT"
        case .bw: return "BW"
        case .by: return "BY"
        case .bz: return "BZ"
        case .ca: return "CA"
        case .cc: return "CC"
        case .cd: return "CD"
        case .cf: return "CF"
        case .cg: return "CG"
        case .ch: return "CH"
        case .ci: return "CI"
        case .ck: return "CK"
        case .cl: return "CL"
        case .cm: return "CM"
        case .cn: return "CN"
        case .co: return "CO"
        case .cr: return "CR"
        case .cu: return "CU"
        case .cv: return "CV"
        case .cw: return "CW"
        case .cx: return "CX"
        case .cy: return "CY"
        case .cz: return "CZ"
        case .de: return "DE"
        case .dj: return "DJ"
        case .dk: return "DK"
        case .dm: return "DM"
        case .do: return "DO"
        case .dz: return "DZ"
        case .ec: return "EC"
        case .ee: return "EE"
        case .eg: return "EG"
        case .eh: return "EH"
        case .er: return "ER"
        case .es: return "ES"
        case .et: return "ET"
        case .fi: return "FI"
        case .fj: return "FJ"
        case .fk: return "FK"
        case .fm: return "FM"
        case .fo: return "FO"
        case .fr: return "FR"
        case .ga: return "GA"
        case .gb: return "GB"
        case .gd: return "GD"
        case .ge: return "GE"
        case .gg: return "GG"
        case .gh: return "GH"
        case .gi: return "GI"
        case .gl: return "GL"
        case .gm: return "GM"
        case .gn: return "GN"
        case .gq: return "GQ"
        case .gr: return "GR"
        case .gt: return "GT"
        case .gu: return "GU"
        case .gw: return "GW"
        case .gy: return "GY"
        case .hk: return "HK"
        case .hn: return "HN"
        case .hr: return "HR"
        case .ht: return "HT"
        case .hu: return "HU"
        case .id: return "ID"
        case .ie: return "IE"
        case .il: return "IL"
        case .im: return "IM"
        case .in: return "IN"
        case .io: return "IO"
        case .iq: return "IQ"
        case .ir: return "IR"
        case .is: return "IS"
        case .it: return "IT"
        case .je: return "JE"
        case .jm: return "JM"
        case .jo: return "JO"
        case .jp: return "JP"
        case .ke: return "KE"
        case .kg: return "KG"
        case .kh: return "KH"
        case .ki: return "KI"
        case .km: return "KM"
        case .kn: return "KN"
        case .kp: return "KP"
        case .kr: return "KR"
        case .kw: return "KW"
        case .ky: return "KY"
        case .kz: return "KZ"
        case .la: return "LA"
        case .lb: return "LB"
        case .lc: return "LC"
        case .li: return "LI"
        case .lk: return "LK"
        case .lr: return "LR"
        case .ls: return "LS"
        case .lt: return "LT"
        case .lu: return "LU"
        case .lv: return "LV"
        case .ly: return "LY"
        case .ma: return "MA"
        case .mc: return "MC"
        case .md: return "MD"
        case .me: return "ME"
        case .mf: return "MF"
        case .mg: return "MG"
        case .mh: return "MH"
        case .mk: return "MK"
        case .ml: return "ML"
        case .mm: return "MM"
        case .mn: return "MN"
        case .mo: return "MO"
        case .mp: return "MP"
        case .mr: return "MR"
        case .ms: return "MS"
        case .mt: return "MT"
        case .mu: return "MU"
        case .mv: return "MV"
        case .mw: return "MW"
        case .mx: return "MX"
        case .my: return "MY"
        case .mz: return "MZ"
        case .na: return "NA"
        case .nc: return "NC"
        case .ne: return "NE"
        case .ng: return "NG"
        case .ni: return "NI"
        case .nl: return "NL"
        case .no: return "NO"
        case .np: return "NP"
        case .nr: return "NR"
        case .nu: return "NU"
        case .nz: return "NZ"
        case .om: return "OM"
        case .pa: return "PA"
        case .pe: return "PE"
        case .pf: return "PF"
        case .pg: return "PG"
        case .ph: return "PH"
        case .pk: return "PK"
        case .pl: return "PL"
        case .pm: return "PM"
        case .pn: return "PN"
        case .pr: return "PR"
        case .pt: return "PT"
        case .pw: return "PW"
        case .py: return "PY"
        case .qa: return "QA"
        case .re: return "RE"
        case .ro: return "RO"
        case .rs: return "RS"
        case .ru: return "RU"
        case .rw: return "RW"
        case .sa: return "SA"
        case .sb: return "SB"
        case .sc: return "SC"
        case .sd: return "SD"
        case .se: return "SE"
        case .sg: return "SG"
        case .sh: return "SH"
        case .si: return "SI"
        case .sj: return "SJ"
        case .sk: return "SK"
        case .sl: return "SL"
        case .sm: return "SM"
        case .sn: return "SN"
        case .so: return "SO"
        case .sr: return "SR"
        case .st: return "ST"
        case .sv: return "SV"
        case .sx: return "SX"
        case .sy: return "SY"
        case .sz: return "SZ"
        case .tc: return "TC"
        case .td: return "TD"
        case .tg: return "TG"
        case .th: return "TH"
        case .tj: return "TJ"
        case .tk: return "TK"
        case .tl: return "TL"
        case .tm: return "TM"
        case .tn: return "TN"
        case .to: return "TO"
        case .tr: return "TR"
        case .tt: return "TT"
        case .tv: return "TV"
        case .tw: return "TW"
        case .tz: return "TZ"
        case .ua: return "UA"
        case .ug: return "UG"
        case .us: return "US"
        case .uy: return "UY"
        case .uz: return "UZ"
        case .va: return "VA"
        case .vc: return "VC"
        case .ve: return "VE"
        case .vg: return "VG"
        case .vi: return "VI"
        case .vn: return "VN"
        case .vu: return "VU"
        case .wf: return "WF"
        case .ws: return "WS"
        case .ye: return "YE"
        case .yt: return "YT"
        case .za: return "ZA"
        case .zm: return "ZM"
        case .zw: return "ZW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PhoneNumberCountryCode(rawValue: rawValue) ?? PhoneNumberCountryCode.sdkUnknown(rawValue)
    }
}

extension PhoneNumberQuickConnectConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension PhoneNumberQuickConnectConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PhoneNumberQuickConnectConfig(phoneNumber: \(String(describing: phoneNumber)))"}
}

/// <p>Contains information about a phone number for a quick connect.</p>
public struct PhoneNumberQuickConnectConfig: Equatable {
    /// <p>The phone number in E.164 format.</p>
    public let phoneNumber: String?

    public init (
        phoneNumber: String? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

extension PhoneNumberSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case phoneNumber = "PhoneNumber"
        case phoneNumberCountryCode = "PhoneNumberCountryCode"
        case phoneNumberType = "PhoneNumberType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumberCountryCode = phoneNumberCountryCode {
            try encodeContainer.encode(phoneNumberCountryCode.rawValue, forKey: .phoneNumberCountryCode)
        }
        if let phoneNumberType = phoneNumberType {
            try encodeContainer.encode(phoneNumberType.rawValue, forKey: .phoneNumberType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumberTypeDecoded = try containerValues.decodeIfPresent(PhoneNumberType.self, forKey: .phoneNumberType)
        phoneNumberType = phoneNumberTypeDecoded
        let phoneNumberCountryCodeDecoded = try containerValues.decodeIfPresent(PhoneNumberCountryCode.self, forKey: .phoneNumberCountryCode)
        phoneNumberCountryCode = phoneNumberCountryCodeDecoded
    }
}

extension PhoneNumberSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PhoneNumberSummary(arn: \(String(describing: arn)), id: \(String(describing: id)), phoneNumber: \(String(describing: phoneNumber)), phoneNumberCountryCode: \(String(describing: phoneNumberCountryCode)), phoneNumberType: \(String(describing: phoneNumberType)))"}
}

/// <p>Contains summary information about a phone number for a contact center.</p>
public struct PhoneNumberSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the phone number.</p>
    public let arn: String?
    /// <p>The identifier of the phone number.</p>
    public let id: String?
    /// <p>The phone number.</p>
    public let phoneNumber: String?
    /// <p>The ISO country code.</p>
    public let phoneNumberCountryCode: PhoneNumberCountryCode?
    /// <p>The type of phone number.</p>
    public let phoneNumberType: PhoneNumberType?

    public init (
        arn: String? = nil,
        id: String? = nil,
        phoneNumber: String? = nil,
        phoneNumberCountryCode: PhoneNumberCountryCode? = nil,
        phoneNumberType: PhoneNumberType? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.phoneNumber = phoneNumber
        self.phoneNumberCountryCode = phoneNumberCountryCode
        self.phoneNumberType = phoneNumberType
    }
}

public enum PhoneNumberType {
    case did
    case tollFree
    case sdkUnknown(String)
}

extension PhoneNumberType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PhoneNumberType] {
        return [
            .did,
            .tollFree,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .did: return "DID"
        case .tollFree: return "TOLL_FREE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PhoneNumberType(rawValue: rawValue) ?? PhoneNumberType.sdkUnknown(rawValue)
    }
}

public enum PhoneType {
    case deskPhone
    case softPhone
    case sdkUnknown(String)
}

extension PhoneType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PhoneType] {
        return [
            .deskPhone,
            .softPhone,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deskPhone: return "DESK_PHONE"
        case .softPhone: return "SOFT_PHONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PhoneType(rawValue: rawValue) ?? PhoneType.sdkUnknown(rawValue)
    }
}

extension ProblemDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProblemDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProblemDetail(message: \(String(describing: message)))"}
}

/// <p>Information about a problem detail.</p>
public struct ProblemDetail: Equatable {
    /// <p>The problem detail's message.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

extension PromptSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension PromptSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PromptSummary(arn: \(String(describing: arn)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Contains information about the prompt.</p>
public struct PromptSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the prompt.</p>
    public let arn: String?
    /// <p>The identifier of the prompt.</p>
    public let id: String?
    /// <p>The name of the prompt.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
    }
}

extension Queue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case hoursOfOperationId = "HoursOfOperationId"
        case maxContacts = "MaxContacts"
        case name = "Name"
        case outboundCallerConfig = "OutboundCallerConfig"
        case queueArn = "QueueArn"
        case queueId = "QueueId"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hoursOfOperationId = hoursOfOperationId {
            try encodeContainer.encode(hoursOfOperationId, forKey: .hoursOfOperationId)
        }
        if maxContacts != 0 {
            try encodeContainer.encode(maxContacts, forKey: .maxContacts)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outboundCallerConfig = outboundCallerConfig {
            try encodeContainer.encode(outboundCallerConfig, forKey: .outboundCallerConfig)
        }
        if let queueArn = queueArn {
            try encodeContainer.encode(queueArn, forKey: .queueArn)
        }
        if let queueId = queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let queueArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queueArn)
        queueArn = queueArnDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let outboundCallerConfigDecoded = try containerValues.decodeIfPresent(OutboundCallerConfig.self, forKey: .outboundCallerConfig)
        outboundCallerConfig = outboundCallerConfigDecoded
        let hoursOfOperationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hoursOfOperationId)
        hoursOfOperationId = hoursOfOperationIdDecoded
        let maxContactsDecoded = try containerValues.decode(Int.self, forKey: .maxContacts)
        maxContacts = maxContactsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QueueStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Queue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Queue(description: \(String(describing: description)), hoursOfOperationId: \(String(describing: hoursOfOperationId)), maxContacts: \(String(describing: maxContacts)), name: \(String(describing: name)), outboundCallerConfig: \(String(describing: outboundCallerConfig)), queueArn: \(String(describing: queueArn)), queueId: \(String(describing: queueId)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

/// <p>Contains information about a queue.</p>
public struct Queue: Equatable {
    /// <p>The description of the queue.</p>
    public let description: String?
    /// <p>The identifier for the hours of operation.</p>
    public let hoursOfOperationId: String?
    /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
    public let maxContacts: Int
    /// <p>The name of the queue.</p>
    public let name: String?
    /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
    public let outboundCallerConfig: OutboundCallerConfig?
    /// <p>The Amazon Resource Name (ARN) for the queue.</p>
    public let queueArn: String?
    /// <p>The identifier for the queue.</p>
    public let queueId: String?
    /// <p>The status of the queue.</p>
    public let status: QueueStatus?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        hoursOfOperationId: String? = nil,
        maxContacts: Int = 0,
        name: String? = nil,
        outboundCallerConfig: OutboundCallerConfig? = nil,
        queueArn: String? = nil,
        queueId: String? = nil,
        status: QueueStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.hoursOfOperationId = hoursOfOperationId
        self.maxContacts = maxContacts
        self.name = name
        self.outboundCallerConfig = outboundCallerConfig
        self.queueArn = queueArn
        self.queueId = queueId
        self.status = status
        self.tags = tags
    }
}

extension QueueQuickConnectConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactFlowId = "ContactFlowId"
        case queueId = "QueueId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactFlowId = contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let queueId = queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
    }
}

extension QueueQuickConnectConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueueQuickConnectConfig(contactFlowId: \(String(describing: contactFlowId)), queueId: \(String(describing: queueId)))"}
}

/// <p>Contains information about a queue for a quick connect. The contact flow must be of type
///    Transfer to Queue.</p>
public struct QueueQuickConnectConfig: Equatable {
    /// <p>The identifier of the contact flow.</p>
    public let contactFlowId: String?
    /// <p>The identifier for the queue.</p>
    public let queueId: String?

    public init (
        contactFlowId: String? = nil,
        queueId: String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.queueId = queueId
    }
}

extension QueueReference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension QueueReference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueueReference(arn: \(String(describing: arn)), id: \(String(describing: id)))"}
}

/// <p>Contains information about a queue resource for which metrics are returned.</p>
public struct QueueReference: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the queue.</p>
    public let arn: String?
    /// <p>The identifier of the queue.</p>
    public let id: String?

    public init (
        arn: String? = nil,
        id: String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

public enum QueueStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension QueueStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [QueueStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = QueueStatus(rawValue: rawValue) ?? QueueStatus.sdkUnknown(rawValue)
    }
}

extension QueueSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
        case queueType = "QueueType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queueType = queueType {
            try encodeContainer.encode(queueType.rawValue, forKey: .queueType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let queueTypeDecoded = try containerValues.decodeIfPresent(QueueType.self, forKey: .queueType)
        queueType = queueTypeDecoded
    }
}

extension QueueSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueueSummary(arn: \(String(describing: arn)), id: \(String(describing: id)), name: \(String(describing: name)), queueType: \(String(describing: queueType)))"}
}

/// <p>Contains summary information about a queue.</p>
public struct QueueSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the queue.</p>
    public let arn: String?
    /// <p>The identifier of the queue.</p>
    public let id: String?
    /// <p>The name of the queue.</p>
    public let name: String?
    /// <p>The type of queue.</p>
    public let queueType: QueueType?

    public init (
        arn: String? = nil,
        id: String? = nil,
        name: String? = nil,
        queueType: QueueType? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.queueType = queueType
    }
}

public enum QueueType {
    case agent
    case standard
    case sdkUnknown(String)
}

extension QueueType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [QueueType] {
        return [
            .agent,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .agent: return "AGENT"
        case .standard: return "STANDARD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = QueueType(rawValue: rawValue) ?? QueueType.sdkUnknown(rawValue)
    }
}

extension QuickConnect: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case quickConnectARN = "QuickConnectARN"
        case quickConnectConfig = "QuickConnectConfig"
        case quickConnectId = "QuickConnectId"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quickConnectARN = quickConnectARN {
            try encodeContainer.encode(quickConnectARN, forKey: .quickConnectARN)
        }
        if let quickConnectConfig = quickConnectConfig {
            try encodeContainer.encode(quickConnectConfig, forKey: .quickConnectConfig)
        }
        if let quickConnectId = quickConnectId {
            try encodeContainer.encode(quickConnectId, forKey: .quickConnectId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quickConnectARN)
        quickConnectARN = quickConnectARNDecoded
        let quickConnectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quickConnectId)
        quickConnectId = quickConnectIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let quickConnectConfigDecoded = try containerValues.decodeIfPresent(QuickConnectConfig.self, forKey: .quickConnectConfig)
        quickConnectConfig = quickConnectConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension QuickConnect: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QuickConnect(description: \(String(describing: description)), name: \(String(describing: name)), quickConnectARN: \(String(describing: quickConnectARN)), quickConnectConfig: \(String(describing: quickConnectConfig)), quickConnectId: \(String(describing: quickConnectId)), tags: \(String(describing: tags)))"}
}

/// <p>Contains information about a quick connect.</p>
public struct QuickConnect: Equatable {
    /// <p>The description.</p>
    public let description: String?
    /// <p>The name of the quick connect.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
    public let quickConnectARN: String?
    /// <p>Contains information about the quick connect.</p>
    public let quickConnectConfig: QuickConnectConfig?
    /// <p>The identifier for the quick connect.</p>
    public let quickConnectId: String?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        name: String? = nil,
        quickConnectARN: String? = nil,
        quickConnectConfig: QuickConnectConfig? = nil,
        quickConnectId: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.quickConnectARN = quickConnectARN
        self.quickConnectConfig = quickConnectConfig
        self.quickConnectId = quickConnectId
        self.tags = tags
    }
}

extension QuickConnectConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case phoneConfig = "PhoneConfig"
        case queueConfig = "QueueConfig"
        case quickConnectType = "QuickConnectType"
        case userConfig = "UserConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneConfig = phoneConfig {
            try encodeContainer.encode(phoneConfig, forKey: .phoneConfig)
        }
        if let queueConfig = queueConfig {
            try encodeContainer.encode(queueConfig, forKey: .queueConfig)
        }
        if let quickConnectType = quickConnectType {
            try encodeContainer.encode(quickConnectType.rawValue, forKey: .quickConnectType)
        }
        if let userConfig = userConfig {
            try encodeContainer.encode(userConfig, forKey: .userConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectTypeDecoded = try containerValues.decodeIfPresent(QuickConnectType.self, forKey: .quickConnectType)
        quickConnectType = quickConnectTypeDecoded
        let userConfigDecoded = try containerValues.decodeIfPresent(UserQuickConnectConfig.self, forKey: .userConfig)
        userConfig = userConfigDecoded
        let queueConfigDecoded = try containerValues.decodeIfPresent(QueueQuickConnectConfig.self, forKey: .queueConfig)
        queueConfig = queueConfigDecoded
        let phoneConfigDecoded = try containerValues.decodeIfPresent(PhoneNumberQuickConnectConfig.self, forKey: .phoneConfig)
        phoneConfig = phoneConfigDecoded
    }
}

extension QuickConnectConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QuickConnectConfig(phoneConfig: \(String(describing: phoneConfig)), queueConfig: \(String(describing: queueConfig)), quickConnectType: \(String(describing: quickConnectType)), userConfig: \(String(describing: userConfig)))"}
}

/// <p>Contains configuration settings for a quick connect.</p>
public struct QuickConnectConfig: Equatable {
    /// <p>The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.</p>
    public let phoneConfig: PhoneNumberQuickConnectConfig?
    /// <p>The queue configuration. This is required only if QuickConnectType is QUEUE.</p>
    public let queueConfig: QueueQuickConnectConfig?
    /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are
    ///    prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE). </p>
    public let quickConnectType: QuickConnectType?
    /// <p>The user configuration. This is required only if QuickConnectType is USER.</p>
    public let userConfig: UserQuickConnectConfig?

    public init (
        phoneConfig: PhoneNumberQuickConnectConfig? = nil,
        queueConfig: QueueQuickConnectConfig? = nil,
        quickConnectType: QuickConnectType? = nil,
        userConfig: UserQuickConnectConfig? = nil
    )
    {
        self.phoneConfig = phoneConfig
        self.queueConfig = queueConfig
        self.quickConnectType = quickConnectType
        self.userConfig = userConfig
    }
}

extension QuickConnectSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
        case quickConnectType = "QuickConnectType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quickConnectType = quickConnectType {
            try encodeContainer.encode(quickConnectType.rawValue, forKey: .quickConnectType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let quickConnectTypeDecoded = try containerValues.decodeIfPresent(QuickConnectType.self, forKey: .quickConnectType)
        quickConnectType = quickConnectTypeDecoded
    }
}

extension QuickConnectSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QuickConnectSummary(arn: \(String(describing: arn)), id: \(String(describing: id)), name: \(String(describing: name)), quickConnectType: \(String(describing: quickConnectType)))"}
}

/// <p>Contains summary information about a quick connect.</p>
public struct QuickConnectSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the quick connect.</p>
    public let arn: String?
    /// <p>The identifier for the quick connect.</p>
    public let id: String?
    /// <p>The name of the quick connect.</p>
    public let name: String?
    /// <p>The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are
    ///    prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).</p>
    public let quickConnectType: QuickConnectType?

    public init (
        arn: String? = nil,
        id: String? = nil,
        name: String? = nil,
        quickConnectType: QuickConnectType? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.quickConnectType = quickConnectType
    }
}

public enum QuickConnectType {
    case phoneNumber
    case queue
    case user
    case sdkUnknown(String)
}

extension QuickConnectType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [QuickConnectType] {
        return [
            .phoneNumber,
            .queue,
            .user,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .phoneNumber: return "PHONE_NUMBER"
        case .queue: return "QUEUE"
        case .user: return "USER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = QuickConnectType(rawValue: rawValue) ?? QuickConnectType.sdkUnknown(rawValue)
    }
}

extension Reference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ReferenceType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Reference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Reference(type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>A link that an agent selects to complete a given task. You can have up to 4,096 UTF-8 bytes
///    across all references for a contact.</p>
public struct Reference: Equatable {
    /// <p>A valid
    ///    URL.</p>
    public let type: ReferenceType?
    /// <p>A formatted URL that displays to an agent in the Contact Control Panel (CCP)</p>
    public let value: String?

    public init (
        type: ReferenceType? = nil,
        value: String? = nil
    )
    {
        self.type = type
        self.value = value
    }
}

public enum ReferenceType {
    case url
    case sdkUnknown(String)
}

extension ReferenceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReferenceType] {
        return [
            .url,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .url: return "URL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReferenceType(rawValue: rawValue) ?? ReferenceType.sdkUnknown(rawValue)
    }
}

extension ResourceConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceConflictException(message: \(String(describing: message)))"}
}

extension ResourceConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource already has that name.</p>
public struct ResourceConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceConflictExceptionBody: Equatable {
    public let message: String?
}

extension ResourceConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>That resource is already in use. Please try another.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The identifier for the resource.</p>
    public var resourceId: String?
    /// <p>The type of resource.</p>
    public var resourceType: ResourceType?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
    public let resourceType: ResourceType?
    public let resourceId: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message about the resource.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ResourceType {
    case contact
    case contactFlow
    case hierarchyGroup
    case hierarchyLevel
    case instance
    case participant
    case user
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .contact,
            .contactFlow,
            .hierarchyGroup,
            .hierarchyLevel,
            .instance,
            .participant,
            .user,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contact: return "CONTACT"
        case .contactFlow: return "CONTACT_FLOW"
        case .hierarchyGroup: return "HIERARCHY_GROUP"
        case .hierarchyLevel: return "HIERARCHY_LEVEL"
        case .instance: return "INSTANCE"
        case .participant: return "PARTICIPANT"
        case .user: return "USER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

public struct ResumeContactRecordingInputBodyMiddleware: Middleware {
    public let id: String = "ResumeContactRecordingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResumeContactRecordingInput>,
                  next: H) -> Swift.Result<OperationOutput<ResumeContactRecordingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResumeContactRecordingInput>
    public typealias MOutput = OperationOutput<ResumeContactRecordingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResumeContactRecordingOutputError>
}

extension ResumeContactRecordingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResumeContactRecordingInput(contactId: \(String(describing: contactId)), initialContactId: \(String(describing: initialContactId)), instanceId: \(String(describing: instanceId)))"}
}

extension ResumeContactRecordingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let initialContactId = initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct ResumeContactRecordingInputHeadersMiddleware: Middleware {
    public let id: String = "ResumeContactRecordingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResumeContactRecordingInput>,
                  next: H) -> Swift.Result<OperationOutput<ResumeContactRecordingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResumeContactRecordingInput>
    public typealias MOutput = OperationOutput<ResumeContactRecordingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResumeContactRecordingOutputError>
}

public struct ResumeContactRecordingInputQueryItemMiddleware: Middleware {
    public let id: String = "ResumeContactRecordingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResumeContactRecordingInput>,
                  next: H) -> Swift.Result<OperationOutput<ResumeContactRecordingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResumeContactRecordingInput>
    public typealias MOutput = OperationOutput<ResumeContactRecordingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResumeContactRecordingOutputError>
}

public struct ResumeContactRecordingInput: Equatable {
    /// <p>The identifier of the contact.</p>
    public let contactId: String?
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the
    ///    first interaction with the contact center.</p>
    public let initialContactId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        contactId: String? = nil,
        initialContactId: String? = nil,
        instanceId: String? = nil
    )
    {
        self.contactId = contactId
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

struct ResumeContactRecordingInputBody: Equatable {
    public let instanceId: String?
    public let contactId: String?
    public let initialContactId: String?
}

extension ResumeContactRecordingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let initialContactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
    }
}

extension ResumeContactRecordingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResumeContactRecordingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResumeContactRecordingOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResumeContactRecordingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResumeContactRecordingOutputResponse()"}
}

extension ResumeContactRecordingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ResumeContactRecordingOutputResponse: Equatable {

    public init() {}
}

struct ResumeContactRecordingOutputResponseBody: Equatable {
}

extension ResumeContactRecordingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RoutingProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultOutboundQueueId = "DefaultOutboundQueueId"
        case description = "Description"
        case instanceId = "InstanceId"
        case mediaConcurrencies = "MediaConcurrencies"
        case name = "Name"
        case routingProfileArn = "RoutingProfileArn"
        case routingProfileId = "RoutingProfileId"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultOutboundQueueId = defaultOutboundQueueId {
            try encodeContainer.encode(defaultOutboundQueueId, forKey: .defaultOutboundQueueId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let mediaConcurrencies = mediaConcurrencies {
            var mediaConcurrenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaConcurrencies)
            for mediaconcurrencies0 in mediaConcurrencies {
                try mediaConcurrenciesContainer.encode(mediaconcurrencies0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let routingProfileArn = routingProfileArn {
            try encodeContainer.encode(routingProfileArn, forKey: .routingProfileArn)
        }
        if let routingProfileId = routingProfileId {
            try encodeContainer.encode(routingProfileId, forKey: .routingProfileId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let routingProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routingProfileArn)
        routingProfileArn = routingProfileArnDecoded
        let routingProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routingProfileId)
        routingProfileId = routingProfileIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let mediaConcurrenciesContainer = try containerValues.decodeIfPresent([MediaConcurrency?].self, forKey: .mediaConcurrencies)
        var mediaConcurrenciesDecoded0:[MediaConcurrency]? = nil
        if let mediaConcurrenciesContainer = mediaConcurrenciesContainer {
            mediaConcurrenciesDecoded0 = [MediaConcurrency]()
            for structure0 in mediaConcurrenciesContainer {
                if let structure0 = structure0 {
                    mediaConcurrenciesDecoded0?.append(structure0)
                }
            }
        }
        mediaConcurrencies = mediaConcurrenciesDecoded0
        let defaultOutboundQueueIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultOutboundQueueId)
        defaultOutboundQueueId = defaultOutboundQueueIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RoutingProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RoutingProfile(defaultOutboundQueueId: \(String(describing: defaultOutboundQueueId)), description: \(String(describing: description)), instanceId: \(String(describing: instanceId)), mediaConcurrencies: \(String(describing: mediaConcurrencies)), name: \(String(describing: name)), routingProfileArn: \(String(describing: routingProfileArn)), routingProfileId: \(String(describing: routingProfileId)), tags: \(String(describing: tags)))"}
}

/// <p>Contains information about a routing profile.</p>
public struct RoutingProfile: Equatable {
    /// <p>The identifier of the default outbound queue for this routing profile.</p>
    public let defaultOutboundQueueId: String?
    /// <p>The description of the routing profile.</p>
    public let description: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing
    ///    profile.</p>
    public let mediaConcurrencies: [MediaConcurrency]?
    /// <p>The name of the routing profile.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
    public let routingProfileArn: String?
    /// <p>The identifier of the routing profile.</p>
    public let routingProfileId: String?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?

    public init (
        defaultOutboundQueueId: String? = nil,
        description: String? = nil,
        instanceId: String? = nil,
        mediaConcurrencies: [MediaConcurrency]? = nil,
        name: String? = nil,
        routingProfileArn: String? = nil,
        routingProfileId: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.defaultOutboundQueueId = defaultOutboundQueueId
        self.description = description
        self.instanceId = instanceId
        self.mediaConcurrencies = mediaConcurrencies
        self.name = name
        self.routingProfileArn = routingProfileArn
        self.routingProfileId = routingProfileId
        self.tags = tags
    }
}

extension RoutingProfileQueueConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case delay = "Delay"
        case priority = "Priority"
        case queueReference = "QueueReference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if delay != 0 {
            try encodeContainer.encode(delay, forKey: .delay)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let queueReference = queueReference {
            try encodeContainer.encode(queueReference, forKey: .queueReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueReferenceDecoded = try containerValues.decodeIfPresent(RoutingProfileQueueReference.self, forKey: .queueReference)
        queueReference = queueReferenceDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let delayDecoded = try containerValues.decode(Int.self, forKey: .delay)
        delay = delayDecoded
    }
}

extension RoutingProfileQueueConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RoutingProfileQueueConfig(delay: \(String(describing: delay)), priority: \(String(describing: priority)), queueReference: \(String(describing: queueReference)))"}
}

/// <p>Contains information about the queue and channel for which priority and delay can be
///    set.</p>
public struct RoutingProfileQueueConfig: Equatable {
    /// <p>The delay, in seconds, a contact should be in the queue before they are routed to an
    ///    available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and
    ///     delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public let delay: Int
    /// <p>The order in which contacts are to be handled for the queue. For more information, see
    ///     <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and
    ///     delay</a>.</p>
    public let priority: Int
    /// <p>Contains information about a queue resource.</p>
    public let queueReference: RoutingProfileQueueReference?

    public init (
        delay: Int = 0,
        priority: Int = 0,
        queueReference: RoutingProfileQueueReference? = nil
    )
    {
        self.delay = delay
        self.priority = priority
        self.queueReference = queueReference
    }
}

extension RoutingProfileQueueConfigSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channel = "Channel"
        case delay = "Delay"
        case priority = "Priority"
        case queueArn = "QueueArn"
        case queueId = "QueueId"
        case queueName = "QueueName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if delay != 0 {
            try encodeContainer.encode(delay, forKey: .delay)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let queueArn = queueArn {
            try encodeContainer.encode(queueArn, forKey: .queueArn)
        }
        if let queueId = queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let queueName = queueName {
            try encodeContainer.encode(queueName, forKey: .queueName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let queueArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queueArn)
        queueArn = queueArnDecoded
        let queueNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queueName)
        queueName = queueNameDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let delayDecoded = try containerValues.decode(Int.self, forKey: .delay)
        delay = delayDecoded
        let channelDecoded = try containerValues.decodeIfPresent(Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension RoutingProfileQueueConfigSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RoutingProfileQueueConfigSummary(channel: \(String(describing: channel)), delay: \(String(describing: delay)), priority: \(String(describing: priority)), queueArn: \(String(describing: queueArn)), queueId: \(String(describing: queueId)), queueName: \(String(describing: queueName)))"}
}

/// <p>Contains summary information about a routing profile queue.</p>
public struct RoutingProfileQueueConfigSummary: Equatable {
    /// <p>The channels this queue supports.</p>
    public let channel: Channel?
    /// <p>The delay, in seconds, that a contact should be in the queue before they are routed to an
    ///    available agent. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and
    ///     delay</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public let delay: Int
    /// <p>The order in which contacts are to be handled for the queue. For more information, see
    ///     <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues: priority and
    ///     delay</a>.</p>
    public let priority: Int
    /// <p>The Amazon Resource Name (ARN) of the queue.</p>
    public let queueArn: String?
    /// <p>The identifier for the queue.</p>
    public let queueId: String?
    /// <p>The name of the queue.</p>
    public let queueName: String?

    public init (
        channel: Channel? = nil,
        delay: Int = 0,
        priority: Int = 0,
        queueArn: String? = nil,
        queueId: String? = nil,
        queueName: String? = nil
    )
    {
        self.channel = channel
        self.delay = delay
        self.priority = priority
        self.queueArn = queueArn
        self.queueId = queueId
        self.queueName = queueName
    }
}

extension RoutingProfileQueueReference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channel = "Channel"
        case queueId = "QueueId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if let queueId = queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let channelDecoded = try containerValues.decodeIfPresent(Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension RoutingProfileQueueReference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RoutingProfileQueueReference(channel: \(String(describing: channel)), queueId: \(String(describing: queueId)))"}
}

/// <p>Contains the channel and queue identifier for a routing profile.</p>
public struct RoutingProfileQueueReference: Equatable {
    /// <p>The channels agents can handle in the Contact Control Panel (CCP) for this routing
    ///    profile.</p>
    public let channel: Channel?
    /// <p>The identifier for the queue.</p>
    public let queueId: String?

    public init (
        channel: Channel? = nil,
        queueId: String? = nil
    )
    {
        self.channel = channel
        self.queueId = queueId
    }
}

extension RoutingProfileSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension RoutingProfileSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RoutingProfileSummary(arn: \(String(describing: arn)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Contains summary information about a routing profile.</p>
public struct RoutingProfileSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the routing profile.</p>
    public let arn: String?
    /// <p>The identifier of the routing profile.</p>
    public let id: String?
    /// <p>The name of the routing profile.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
    }
}

extension S3Config: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName = "BucketName"
        case bucketPrefix = "BucketPrefix"
        case encryptionConfig = "EncryptionConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let encryptionConfig = encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
    }
}

extension S3Config: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Config(bucketName: \(String(describing: bucketName)), bucketPrefix: \(String(describing: bucketPrefix)), encryptionConfig: \(String(describing: encryptionConfig)))"}
}

/// <p>Information about the Amazon Simple Storage Service (Amazon S3) storage type.</p>
public struct S3Config: Equatable {
    /// <p>The S3 bucket name.</p>
    public let bucketName: String?
    /// <p>The S3 bucket prefix.</p>
    public let bucketPrefix: String?
    /// <p>The Amazon S3 encryption configuration.</p>
    public let encryptionConfig: EncryptionConfig?

    public init (
        bucketName: String? = nil,
        bucketPrefix: String? = nil,
        encryptionConfig: EncryptionConfig? = nil
    )
    {
        self.bucketName = bucketName
        self.bucketPrefix = bucketPrefix
        self.encryptionConfig = encryptionConfig
    }
}

extension SecurityKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case creationTime = "CreationTime"
        case key = "Key"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension SecurityKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecurityKey(associationId: \(String(describing: associationId)), creationTime: \(String(describing: creationTime)), key: \(String(describing: key)))"}
}

/// <p>Configuration information of the security key.</p>
public struct SecurityKey: Equatable {
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    public let associationId: String?
    /// <p>When the security key was created.</p>
    public let creationTime: Date?
    /// <p>The key of the security key.</p>
    public let key: String?

    public init (
        associationId: String? = nil,
        creationTime: Date? = nil,
        key: String? = nil
    )
    {
        self.associationId = associationId
        self.creationTime = creationTime
        self.key = key
    }
}

extension SecurityProfileSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SecurityProfileSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecurityProfileSummary(arn: \(String(describing: arn)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Contains information about a security profile.</p>
public struct SecurityProfileSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the security profile.</p>
    public let arn: String?
    /// <p>The identifier of the security profile.</p>
    public let id: String?
    /// <p>The name of the security profile.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service quota has been exceeded.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum SourceType {
    case salesforce
    case zendesk
    case sdkUnknown(String)
}

extension SourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceType] {
        return [
            .salesforce,
            .zendesk,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .salesforce: return "SALESFORCE"
        case .zendesk: return "ZENDESK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
    }
}

public struct StartChatContactInputBodyMiddleware: Middleware {
    public let id: String = "StartChatContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartChatContactInput>,
                  next: H) -> Swift.Result<OperationOutput<StartChatContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartChatContactInput>
    public typealias MOutput = OperationOutput<StartChatContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartChatContactOutputError>
}

extension StartChatContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartChatContactInput(attributes: \(String(describing: attributes)), clientToken: \(String(describing: clientToken)), contactFlowId: \(String(describing: contactFlowId)), initialMessage: \(String(describing: initialMessage)), instanceId: \(String(describing: instanceId)), participantDetails: \(String(describing: participantDetails)))"}
}

extension StartChatContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case initialMessage = "InitialMessage"
        case instanceId = "InstanceId"
        case participantDetails = "ParticipantDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactFlowId = contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let initialMessage = initialMessage {
            try encodeContainer.encode(initialMessage, forKey: .initialMessage)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let participantDetails = participantDetails {
            try encodeContainer.encode(participantDetails, forKey: .participantDetails)
        }
    }
}

public struct StartChatContactInputHeadersMiddleware: Middleware {
    public let id: String = "StartChatContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartChatContactInput>,
                  next: H) -> Swift.Result<OperationOutput<StartChatContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartChatContactInput>
    public typealias MOutput = OperationOutput<StartChatContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartChatContactOutputError>
}

public struct StartChatContactInputQueryItemMiddleware: Middleware {
    public let id: String = "StartChatContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartChatContactInput>,
                  next: H) -> Swift.Result<OperationOutput<StartChatContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartChatContactInput>
    public typealias MOutput = OperationOutput<StartChatContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartChatContactOutputError>
}

public struct StartChatContactInput: Equatable {
    /// <p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect
    ///    attributes. They can be accessed in contact flows just like any other contact attributes. </p>
    ///          <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys
    ///    can include only alphanumeric, dash, and underscore characters.</p>
    public let attributes: [String:String]?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///    request.</p>
    public var clientToken: String?
    /// <p>The identifier of the contact flow for initiating the chat.
    ///    To
    ///    see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the
    ///    contact flow. On the contact flow page, under the name of the contact flow, choose <b>Show additional flow information</b>. The ContactFlowId is the last part of
    ///    the ARN, shown here in bold: </p>
    ///          <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b>
    ///          </p>
    public let contactFlowId: String?
    /// <p>The initial message to be sent to the newly created chat.</p>
    public let initialMessage: ChatMessage?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>Information identifying the participant.</p>
    public let participantDetails: ParticipantDetails?

    public init (
        attributes: [String:String]? = nil,
        clientToken: String? = nil,
        contactFlowId: String? = nil,
        initialMessage: ChatMessage? = nil,
        instanceId: String? = nil,
        participantDetails: ParticipantDetails? = nil
    )
    {
        self.attributes = attributes
        self.clientToken = clientToken
        self.contactFlowId = contactFlowId
        self.initialMessage = initialMessage
        self.instanceId = instanceId
        self.participantDetails = participantDetails
    }
}

struct StartChatContactInputBody: Equatable {
    public let instanceId: String?
    public let contactFlowId: String?
    public let attributes: [String:String]?
    public let participantDetails: ParticipantDetails?
    public let initialMessage: ChatMessage?
    public let clientToken: String?
}

extension StartChatContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case initialMessage = "InitialMessage"
        case instanceId = "InstanceId"
        case participantDetails = "ParticipantDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let participantDetailsDecoded = try containerValues.decodeIfPresent(ParticipantDetails.self, forKey: .participantDetails)
        participantDetails = participantDetailsDecoded
        let initialMessageDecoded = try containerValues.decodeIfPresent(ChatMessage.self, forKey: .initialMessage)
        initialMessage = initialMessageDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartChatContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartChatContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartChatContactOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartChatContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartChatContactOutputResponse(contactId: \(String(describing: contactId)), participantId: \(String(describing: participantId)), participantToken: \(String(describing: participantToken)))"}
}

extension StartChatContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartChatContactOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contactId = output.contactId
            self.participantId = output.participantId
            self.participantToken = output.participantToken
        } else {
            self.contactId = nil
            self.participantId = nil
            self.participantToken = nil
        }
    }
}

public struct StartChatContactOutputResponse: Equatable {
    /// <p>The identifier of this contact within the Amazon Connect instance. </p>
    public let contactId: String?
    /// <p>The identifier for a chat participant. The participantId for a chat participant is the same
    ///    throughout the chat lifecycle.</p>
    public let participantId: String?
    /// <p>The token used by the chat participant to call <a href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html">CreateParticipantConnection</a>. The participant token is valid for the lifetime of a chat
    ///    participant.</p>
    public let participantToken: String?

    public init (
        contactId: String? = nil,
        participantId: String? = nil,
        participantToken: String? = nil
    )
    {
        self.contactId = contactId
        self.participantId = participantId
        self.participantToken = participantToken
    }
}

struct StartChatContactOutputResponseBody: Equatable {
    public let contactId: String?
    public let participantId: String?
    public let participantToken: String?
}

extension StartChatContactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case participantId = "ParticipantId"
        case participantToken = "ParticipantToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let participantTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .participantToken)
        participantToken = participantTokenDecoded
    }
}

public struct StartContactRecordingInputBodyMiddleware: Middleware {
    public let id: String = "StartContactRecordingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartContactRecordingInput>,
                  next: H) -> Swift.Result<OperationOutput<StartContactRecordingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartContactRecordingInput>
    public typealias MOutput = OperationOutput<StartContactRecordingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartContactRecordingOutputError>
}

extension StartContactRecordingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartContactRecordingInput(contactId: \(String(describing: contactId)), initialContactId: \(String(describing: initialContactId)), instanceId: \(String(describing: instanceId)), voiceRecordingConfiguration: \(String(describing: voiceRecordingConfiguration)))"}
}

extension StartContactRecordingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
        case voiceRecordingConfiguration = "VoiceRecordingConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let initialContactId = initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let voiceRecordingConfiguration = voiceRecordingConfiguration {
            try encodeContainer.encode(voiceRecordingConfiguration, forKey: .voiceRecordingConfiguration)
        }
    }
}

public struct StartContactRecordingInputHeadersMiddleware: Middleware {
    public let id: String = "StartContactRecordingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartContactRecordingInput>,
                  next: H) -> Swift.Result<OperationOutput<StartContactRecordingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartContactRecordingInput>
    public typealias MOutput = OperationOutput<StartContactRecordingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartContactRecordingOutputError>
}

public struct StartContactRecordingInputQueryItemMiddleware: Middleware {
    public let id: String = "StartContactRecordingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartContactRecordingInput>,
                  next: H) -> Swift.Result<OperationOutput<StartContactRecordingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartContactRecordingInput>
    public typealias MOutput = OperationOutput<StartContactRecordingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartContactRecordingOutputError>
}

public struct StartContactRecordingInput: Equatable {
    /// <p>The identifier of the contact.</p>
    public let contactId: String?
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the
    ///    first interaction with the contact center.</p>
    public let initialContactId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The person being recorded.</p>
    public let voiceRecordingConfiguration: VoiceRecordingConfiguration?

    public init (
        contactId: String? = nil,
        initialContactId: String? = nil,
        instanceId: String? = nil,
        voiceRecordingConfiguration: VoiceRecordingConfiguration? = nil
    )
    {
        self.contactId = contactId
        self.initialContactId = initialContactId
        self.instanceId = instanceId
        self.voiceRecordingConfiguration = voiceRecordingConfiguration
    }
}

struct StartContactRecordingInputBody: Equatable {
    public let instanceId: String?
    public let contactId: String?
    public let initialContactId: String?
    public let voiceRecordingConfiguration: VoiceRecordingConfiguration?
}

extension StartContactRecordingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
        case voiceRecordingConfiguration = "VoiceRecordingConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let initialContactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
        let voiceRecordingConfigurationDecoded = try containerValues.decodeIfPresent(VoiceRecordingConfiguration.self, forKey: .voiceRecordingConfiguration)
        voiceRecordingConfiguration = voiceRecordingConfigurationDecoded
    }
}

extension StartContactRecordingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartContactRecordingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartContactRecordingOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartContactRecordingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartContactRecordingOutputResponse()"}
}

extension StartContactRecordingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartContactRecordingOutputResponse: Equatable {

    public init() {}
}

struct StartContactRecordingOutputResponseBody: Equatable {
}

extension StartContactRecordingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StartOutboundVoiceContactInputBodyMiddleware: Middleware {
    public let id: String = "StartOutboundVoiceContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartOutboundVoiceContactInput>,
                  next: H) -> Swift.Result<OperationOutput<StartOutboundVoiceContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartOutboundVoiceContactInput>
    public typealias MOutput = OperationOutput<StartOutboundVoiceContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartOutboundVoiceContactOutputError>
}

extension StartOutboundVoiceContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartOutboundVoiceContactInput(attributes: \(String(describing: attributes)), clientToken: \(String(describing: clientToken)), contactFlowId: \(String(describing: contactFlowId)), destinationPhoneNumber: \(String(describing: destinationPhoneNumber)), instanceId: \(String(describing: instanceId)), queueId: \(String(describing: queueId)), sourcePhoneNumber: \(String(describing: sourcePhoneNumber)))"}
}

extension StartOutboundVoiceContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case instanceId = "InstanceId"
        case queueId = "QueueId"
        case sourcePhoneNumber = "SourcePhoneNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactFlowId = contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let destinationPhoneNumber = destinationPhoneNumber {
            try encodeContainer.encode(destinationPhoneNumber, forKey: .destinationPhoneNumber)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let queueId = queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let sourcePhoneNumber = sourcePhoneNumber {
            try encodeContainer.encode(sourcePhoneNumber, forKey: .sourcePhoneNumber)
        }
    }
}

public struct StartOutboundVoiceContactInputHeadersMiddleware: Middleware {
    public let id: String = "StartOutboundVoiceContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartOutboundVoiceContactInput>,
                  next: H) -> Swift.Result<OperationOutput<StartOutboundVoiceContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartOutboundVoiceContactInput>
    public typealias MOutput = OperationOutput<StartOutboundVoiceContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartOutboundVoiceContactOutputError>
}

public struct StartOutboundVoiceContactInputQueryItemMiddleware: Middleware {
    public let id: String = "StartOutboundVoiceContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartOutboundVoiceContactInput>,
                  next: H) -> Swift.Result<OperationOutput<StartOutboundVoiceContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartOutboundVoiceContactInput>
    public typealias MOutput = OperationOutput<StartOutboundVoiceContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartOutboundVoiceContactOutputError>
}

public struct StartOutboundVoiceContactInput: Equatable {
    /// <p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect
    ///    attributes, and can be accessed in contact flows just like any other contact attributes.</p>
    ///          <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys
    ///    can include only alphanumeric, dash, and underscore characters.</p>
    public let attributes: [String:String]?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///    request. The token is valid for 7 days after creation. If a contact is already started, the
    ///    contact ID is returned. If the contact is disconnected, a new contact is started.</p>
    public var clientToken: String?
    /// <p>The
    ///    identifier of the contact flow for the outbound call. To see the ContactFlowId in the Amazon Connect
    ///    console user interface, on the navigation menu go to <b>Routing</b>,
    ///     <b>Contact Flows</b>. Choose the contact flow. On the contact flow
    ///    page, under the name of the contact flow, choose <b>Show additional flow
    ///     information</b>. The ContactFlowId is the last part of the ARN, shown here in bold: </p>
    ///          <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b>
    ///          </p>
    public let contactFlowId: String?
    /// <p>The phone number of the customer, in E.164 format.</p>
    public let destinationPhoneNumber: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The queue for the call. If you specify a queue, the phone displayed for caller ID is the
    ///    phone number specified in the queue. If you do not specify a queue, the queue defined in the
    ///    contact flow is used. If you do not specify a queue, you must specify a source phone
    ///    number.</p>
    public let queueId: String?
    /// <p>The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify
    ///    a source phone number, you must specify a queue.</p>
    public let sourcePhoneNumber: String?

    public init (
        attributes: [String:String]? = nil,
        clientToken: String? = nil,
        contactFlowId: String? = nil,
        destinationPhoneNumber: String? = nil,
        instanceId: String? = nil,
        queueId: String? = nil,
        sourcePhoneNumber: String? = nil
    )
    {
        self.attributes = attributes
        self.clientToken = clientToken
        self.contactFlowId = contactFlowId
        self.destinationPhoneNumber = destinationPhoneNumber
        self.instanceId = instanceId
        self.queueId = queueId
        self.sourcePhoneNumber = sourcePhoneNumber
    }
}

struct StartOutboundVoiceContactInputBody: Equatable {
    public let destinationPhoneNumber: String?
    public let contactFlowId: String?
    public let instanceId: String?
    public let clientToken: String?
    public let sourcePhoneNumber: String?
    public let queueId: String?
    public let attributes: [String:String]?
}

extension StartOutboundVoiceContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case instanceId = "InstanceId"
        case queueId = "QueueId"
        case sourcePhoneNumber = "SourcePhoneNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationPhoneNumber)
        destinationPhoneNumber = destinationPhoneNumberDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourcePhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourcePhoneNumber)
        sourcePhoneNumber = sourcePhoneNumberDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension StartOutboundVoiceContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartOutboundVoiceContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DestinationNotAllowedException" : self = .destinationNotAllowedException(try DestinationNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OutboundContactNotPermittedException" : self = .outboundContactNotPermittedException(try OutboundContactNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartOutboundVoiceContactOutputError: Equatable {
    case destinationNotAllowedException(DestinationNotAllowedException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case outboundContactNotPermittedException(OutboundContactNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartOutboundVoiceContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartOutboundVoiceContactOutputResponse(contactId: \(String(describing: contactId)))"}
}

extension StartOutboundVoiceContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartOutboundVoiceContactOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contactId = output.contactId
        } else {
            self.contactId = nil
        }
    }
}

public struct StartOutboundVoiceContactOutputResponse: Equatable {
    /// <p>The identifier of this contact within the Amazon Connect instance.</p>
    public let contactId: String?

    public init (
        contactId: String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct StartOutboundVoiceContactOutputResponseBody: Equatable {
    public let contactId: String?
}

extension StartOutboundVoiceContactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

public struct StartTaskContactInputBodyMiddleware: Middleware {
    public let id: String = "StartTaskContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTaskContactInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTaskContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTaskContactInput>
    public typealias MOutput = OperationOutput<StartTaskContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTaskContactOutputError>
}

extension StartTaskContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTaskContactInput(attributes: \(String(describing: attributes)), clientToken: \(String(describing: clientToken)), contactFlowId: \(String(describing: contactFlowId)), description: \(String(describing: description)), instanceId: \(String(describing: instanceId)), name: \(String(describing: name)), previousContactId: \(String(describing: previousContactId)), references: \(String(describing: references)))"}
}

extension StartTaskContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case description = "Description"
        case instanceId = "InstanceId"
        case name = "Name"
        case previousContactId = "PreviousContactId"
        case references = "References"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactFlowId = contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let previousContactId = previousContactId {
            try encodeContainer.encode(previousContactId, forKey: .previousContactId)
        }
        if let references = references {
            var referencesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .references)
            for (dictKey0, contactreferences0) in references {
                try referencesContainer.encode(contactreferences0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct StartTaskContactInputHeadersMiddleware: Middleware {
    public let id: String = "StartTaskContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTaskContactInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTaskContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTaskContactInput>
    public typealias MOutput = OperationOutput<StartTaskContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTaskContactOutputError>
}

public struct StartTaskContactInputQueryItemMiddleware: Middleware {
    public let id: String = "StartTaskContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTaskContactInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTaskContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTaskContactInput>
    public typealias MOutput = OperationOutput<StartTaskContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTaskContactOutputError>
}

public struct StartTaskContactInput: Equatable {
    /// <p>A custom key-value pair using an attribute map. The attributes are standard Amazon Connect
    ///    attributes, and can be accessed in contact flows just like any other contact attributes.</p>
    ///          <p>There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys
    ///    can include only alphanumeric, dash, and underscore characters.</p>
    public let attributes: [String:String]?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///    request.</p>
    public var clientToken: String?
    /// <p>The identifier of the contact flow for initiating the tasks. To see the ContactFlowId in the
    ///    Amazon Connect console user interface, on the navigation menu go to <b>Routing</b>, <b>Contact Flows</b>. Choose the contact flow. On
    ///    the contact flow page, under the name of the contact flow, choose <b>Show
    ///     additional flow information</b>. The ContactFlowId is the last part of the ARN, shown
    ///    here in bold: </p>
    ///          <p>arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b>
    ///          </p>
    public let contactFlowId: String?
    /// <p>A description of the task that is shown to an agent in the Contact Control Panel
    ///    (CCP).</p>
    public let description: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The name of a task that is shown to an agent in the Contact Control Panel (CCP).</p>
    public let name: String?
    /// <p>The identifier of the previous chat, voice, or task contact. </p>
    public let previousContactId: String?
    /// <p>A formatted URL that is shown to an agent in the Contact Control Panel (CCP).</p>
    public let references: [String:Reference]?

    public init (
        attributes: [String:String]? = nil,
        clientToken: String? = nil,
        contactFlowId: String? = nil,
        description: String? = nil,
        instanceId: String? = nil,
        name: String? = nil,
        previousContactId: String? = nil,
        references: [String:Reference]? = nil
    )
    {
        self.attributes = attributes
        self.clientToken = clientToken
        self.contactFlowId = contactFlowId
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.previousContactId = previousContactId
        self.references = references
    }
}

struct StartTaskContactInputBody: Equatable {
    public let instanceId: String?
    public let previousContactId: String?
    public let contactFlowId: String?
    public let attributes: [String:String]?
    public let name: String?
    public let references: [String:Reference]?
    public let description: String?
    public let clientToken: String?
}

extension StartTaskContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case description = "Description"
        case instanceId = "InstanceId"
        case name = "Name"
        case previousContactId = "PreviousContactId"
        case references = "References"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let previousContactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .previousContactId)
        previousContactId = previousContactIdDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let referencesContainer = try containerValues.decodeIfPresent([String: Reference?].self, forKey: .references)
        var referencesDecoded0: [String:Reference]? = nil
        if let referencesContainer = referencesContainer {
            referencesDecoded0 = [String:Reference]()
            for (key0, reference0) in referencesContainer {
                if let reference0 = reference0 {
                    referencesDecoded0?[key0] = reference0
                }
            }
        }
        references = referencesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartTaskContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartTaskContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartTaskContactOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartTaskContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTaskContactOutputResponse(contactId: \(String(describing: contactId)))"}
}

extension StartTaskContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartTaskContactOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contactId = output.contactId
        } else {
            self.contactId = nil
        }
    }
}

public struct StartTaskContactOutputResponse: Equatable {
    /// <p>The identifier of this contact within the Amazon Connect instance.</p>
    public let contactId: String?

    public init (
        contactId: String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct StartTaskContactOutputResponseBody: Equatable {
    public let contactId: String?
}

extension StartTaskContactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

public enum Statistic {
    case avg
    case max
    case sum
    case sdkUnknown(String)
}

extension Statistic : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Statistic] {
        return [
            .avg,
            .max,
            .sum,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .avg: return "AVG"
        case .max: return "MAX"
        case .sum: return "SUM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Statistic(rawValue: rawValue) ?? Statistic.sdkUnknown(rawValue)
    }
}

public struct StopContactInputBodyMiddleware: Middleware {
    public let id: String = "StopContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopContactInput>,
                  next: H) -> Swift.Result<OperationOutput<StopContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopContactInput>
    public typealias MOutput = OperationOutput<StopContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopContactOutputError>
}

extension StopContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopContactInput(contactId: \(String(describing: contactId)), instanceId: \(String(describing: instanceId)))"}
}

extension StopContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct StopContactInputHeadersMiddleware: Middleware {
    public let id: String = "StopContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopContactInput>,
                  next: H) -> Swift.Result<OperationOutput<StopContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopContactInput>
    public typealias MOutput = OperationOutput<StopContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopContactOutputError>
}

public struct StopContactInputQueryItemMiddleware: Middleware {
    public let id: String = "StopContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopContactInput>,
                  next: H) -> Swift.Result<OperationOutput<StopContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopContactInput>
    public typealias MOutput = OperationOutput<StopContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopContactOutputError>
}

public struct StopContactInput: Equatable {
    /// <p>The ID of the contact.</p>
    public let contactId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        contactId: String? = nil,
        instanceId: String? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
    }
}

struct StopContactInputBody: Equatable {
    public let contactId: String?
    public let instanceId: String?
}

extension StopContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension StopContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContactNotFoundException" : self = .contactNotFoundException(try ContactNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopContactOutputError: Equatable {
    case contactNotFoundException(ContactNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopContactOutputResponse()"}
}

extension StopContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopContactOutputResponse: Equatable {

    public init() {}
}

struct StopContactOutputResponseBody: Equatable {
}

extension StopContactOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StopContactRecordingInputBodyMiddleware: Middleware {
    public let id: String = "StopContactRecordingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopContactRecordingInput>,
                  next: H) -> Swift.Result<OperationOutput<StopContactRecordingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopContactRecordingInput>
    public typealias MOutput = OperationOutput<StopContactRecordingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopContactRecordingOutputError>
}

extension StopContactRecordingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopContactRecordingInput(contactId: \(String(describing: contactId)), initialContactId: \(String(describing: initialContactId)), instanceId: \(String(describing: instanceId)))"}
}

extension StopContactRecordingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let initialContactId = initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct StopContactRecordingInputHeadersMiddleware: Middleware {
    public let id: String = "StopContactRecordingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopContactRecordingInput>,
                  next: H) -> Swift.Result<OperationOutput<StopContactRecordingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopContactRecordingInput>
    public typealias MOutput = OperationOutput<StopContactRecordingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopContactRecordingOutputError>
}

public struct StopContactRecordingInputQueryItemMiddleware: Middleware {
    public let id: String = "StopContactRecordingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopContactRecordingInput>,
                  next: H) -> Swift.Result<OperationOutput<StopContactRecordingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopContactRecordingInput>
    public typealias MOutput = OperationOutput<StopContactRecordingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopContactRecordingOutputError>
}

public struct StopContactRecordingInput: Equatable {
    /// <p>The identifier of the contact.</p>
    public let contactId: String?
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the
    ///    first interaction with the contact center.</p>
    public let initialContactId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        contactId: String? = nil,
        initialContactId: String? = nil,
        instanceId: String? = nil
    )
    {
        self.contactId = contactId
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

struct StopContactRecordingInputBody: Equatable {
    public let instanceId: String?
    public let contactId: String?
    public let initialContactId: String?
}

extension StopContactRecordingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let initialContactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
    }
}

extension StopContactRecordingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopContactRecordingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopContactRecordingOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopContactRecordingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopContactRecordingOutputResponse()"}
}

extension StopContactRecordingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopContactRecordingOutputResponse: Equatable {

    public init() {}
}

struct StopContactRecordingOutputResponseBody: Equatable {
}

extension StopContactRecordingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum StorageType {
    case kinesisFirehose
    case kinesisStream
    case kinesisVideoStream
    case s3
    case sdkUnknown(String)
}

extension StorageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StorageType] {
        return [
            .kinesisFirehose,
            .kinesisStream,
            .kinesisVideoStream,
            .s3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .kinesisFirehose: return "KINESIS_FIREHOSE"
        case .kinesisStream: return "KINESIS_STREAM"
        case .kinesisVideoStream: return "KINESIS_VIDEO_STREAM"
        case .s3: return "S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StorageType(rawValue: rawValue) ?? StorageType.sdkUnknown(rawValue)
    }
}

public struct SuspendContactRecordingInputBodyMiddleware: Middleware {
    public let id: String = "SuspendContactRecordingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SuspendContactRecordingInput>,
                  next: H) -> Swift.Result<OperationOutput<SuspendContactRecordingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SuspendContactRecordingInput>
    public typealias MOutput = OperationOutput<SuspendContactRecordingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SuspendContactRecordingOutputError>
}

extension SuspendContactRecordingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuspendContactRecordingInput(contactId: \(String(describing: contactId)), initialContactId: \(String(describing: initialContactId)), instanceId: \(String(describing: instanceId)))"}
}

extension SuspendContactRecordingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let initialContactId = initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct SuspendContactRecordingInputHeadersMiddleware: Middleware {
    public let id: String = "SuspendContactRecordingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SuspendContactRecordingInput>,
                  next: H) -> Swift.Result<OperationOutput<SuspendContactRecordingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SuspendContactRecordingInput>
    public typealias MOutput = OperationOutput<SuspendContactRecordingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SuspendContactRecordingOutputError>
}

public struct SuspendContactRecordingInputQueryItemMiddleware: Middleware {
    public let id: String = "SuspendContactRecordingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SuspendContactRecordingInput>,
                  next: H) -> Swift.Result<OperationOutput<SuspendContactRecordingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SuspendContactRecordingInput>
    public typealias MOutput = OperationOutput<SuspendContactRecordingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SuspendContactRecordingOutputError>
}

public struct SuspendContactRecordingInput: Equatable {
    /// <p>The identifier of the contact.</p>
    public let contactId: String?
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the
    ///    first interaction with the contact center.</p>
    public let initialContactId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        contactId: String? = nil,
        initialContactId: String? = nil,
        instanceId: String? = nil
    )
    {
        self.contactId = contactId
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

struct SuspendContactRecordingInputBody: Equatable {
    public let instanceId: String?
    public let contactId: String?
    public let initialContactId: String?
}

extension SuspendContactRecordingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let initialContactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
    }
}

extension SuspendContactRecordingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SuspendContactRecordingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SuspendContactRecordingOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SuspendContactRecordingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuspendContactRecordingOutputResponse()"}
}

extension SuspendContactRecordingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SuspendContactRecordingOutputResponse: Equatable {

    public init() {}
}

struct SuspendContactRecordingOutputResponseBody: Equatable {
}

extension SuspendContactRecordingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>One or more tags. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Threshold: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparison = "Comparison"
        case thresholdValue = "ThresholdValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let thresholdValue = thresholdValue {
            try encodeContainer.encode(thresholdValue, forKey: .thresholdValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonDecoded = try containerValues.decodeIfPresent(Comparison.self, forKey: .comparison)
        comparison = comparisonDecoded
        let thresholdValueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .thresholdValue)
        thresholdValue = thresholdValueDecoded
    }
}

extension Threshold: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Threshold(comparison: \(String(describing: comparison)), thresholdValue: \(String(describing: thresholdValue)))"}
}

/// <p>Contains information about the threshold for service level metrics.</p>
public struct Threshold: Equatable {
    /// <p>The type of comparison. Only "less than" (LT) comparisons are supported.</p>
    public let comparison: Comparison?
    /// <p>The threshold value to compare.</p>
    public let thresholdValue: Double?

    public init (
        comparison: Comparison? = nil,
        thresholdValue: Double? = nil
    )
    {
        self.comparison = comparison
        self.thresholdValue = thresholdValue
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The throttling limit has been exceeded.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Unit {
    case count
    case percent
    case seconds
    case sdkUnknown(String)
}

extension Unit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Unit] {
        return [
            .count,
            .percent,
            .seconds,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .count: return "COUNT"
        case .percent: return "PERCENT"
        case .seconds: return "SECONDS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Unit(rawValue: rawValue) ?? Unit.sdkUnknown(rawValue)
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>The tag keys.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateContactAttributesInputBodyMiddleware: Middleware {
    public let id: String = "UpdateContactAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactAttributesInput>
    public typealias MOutput = OperationOutput<UpdateContactAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactAttributesOutputError>
}

extension UpdateContactAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateContactAttributesInput(attributes: \(String(describing: attributes)), initialContactId: \(String(describing: initialContactId)), instanceId: \(String(describing: instanceId)))"}
}

extension UpdateContactAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let initialContactId = initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct UpdateContactAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateContactAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactAttributesInput>
    public typealias MOutput = OperationOutput<UpdateContactAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactAttributesOutputError>
}

public struct UpdateContactAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateContactAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactAttributesInput>
    public typealias MOutput = OperationOutput<UpdateContactAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactAttributesOutputError>
}

public struct UpdateContactAttributesInput: Equatable {
    /// <p>The Amazon Connect attributes. These attributes can be accessed in contact flows just like any other
    ///    contact attributes.</p>
    ///          <p>You can have up to 32,768 UTF-8 bytes across all attributes for a contact. Attribute keys
    ///    can include only alphanumeric, dash, and underscore characters.</p>
    public let attributes: [String:String]?
    /// <p>The identifier of the contact. This is the identifier of the contact associated with the
    ///    first interaction with the contact center.</p>
    public let initialContactId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        attributes: [String:String]? = nil,
        initialContactId: String? = nil,
        instanceId: String? = nil
    )
    {
        self.attributes = attributes
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

struct UpdateContactAttributesInputBody: Equatable {
    public let initialContactId: String?
    public let instanceId: String?
    public let attributes: [String:String]?
}

extension UpdateContactAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialContactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension UpdateContactAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactAttributesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateContactAttributesOutputResponse()"}
}

extension UpdateContactAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactAttributesOutputResponse: Equatable {

    public init() {}
}

struct UpdateContactAttributesOutputResponseBody: Equatable {
}

extension UpdateContactAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateContactFlowContentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateContactFlowContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactFlowContentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactFlowContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactFlowContentInput>
    public typealias MOutput = OperationOutput<UpdateContactFlowContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactFlowContentOutputError>
}

extension UpdateContactFlowContentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateContactFlowContentInput(contactFlowId: \(String(describing: contactFlowId)), content: \(String(describing: content)), instanceId: \(String(describing: instanceId)))"}
}

extension UpdateContactFlowContentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
    }
}

public struct UpdateContactFlowContentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateContactFlowContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactFlowContentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactFlowContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactFlowContentInput>
    public typealias MOutput = OperationOutput<UpdateContactFlowContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactFlowContentOutputError>
}

public struct UpdateContactFlowContentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateContactFlowContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactFlowContentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactFlowContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactFlowContentInput>
    public typealias MOutput = OperationOutput<UpdateContactFlowContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactFlowContentOutputError>
}

public struct UpdateContactFlowContentInput: Equatable {
    /// <p>The identifier of the contact flow.</p>
    public let contactFlowId: String?
    /// <p>The JSON string that represents contact flows content. For an example, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/flow-language-example.html">Example contact
    ///     flow in Amazon Connect Flow language</a> in the <i>Amazon Connect Administrator Guide</i>.
    ///   </p>
    public let content: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        contactFlowId: String? = nil,
        content: String? = nil,
        instanceId: String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.content = content
        self.instanceId = instanceId
    }
}

struct UpdateContactFlowContentInputBody: Equatable {
    public let content: String?
}

extension UpdateContactFlowContentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
    }
}

extension UpdateContactFlowContentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactFlowContentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContactFlowException" : self = .invalidContactFlowException(try InvalidContactFlowException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactFlowContentOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidContactFlowException(InvalidContactFlowException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactFlowContentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateContactFlowContentOutputResponse()"}
}

extension UpdateContactFlowContentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactFlowContentOutputResponse: Equatable {

    public init() {}
}

struct UpdateContactFlowContentOutputResponseBody: Equatable {
}

extension UpdateContactFlowContentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateContactFlowNameInputBodyMiddleware: Middleware {
    public let id: String = "UpdateContactFlowNameInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactFlowNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactFlowNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactFlowNameInput>
    public typealias MOutput = OperationOutput<UpdateContactFlowNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactFlowNameOutputError>
}

extension UpdateContactFlowNameInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateContactFlowNameInput(contactFlowId: \(String(describing: contactFlowId)), description: \(String(describing: description)), instanceId: \(String(describing: instanceId)), name: \(String(describing: name)))"}
}

extension UpdateContactFlowNameInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateContactFlowNameInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateContactFlowNameInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactFlowNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactFlowNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactFlowNameInput>
    public typealias MOutput = OperationOutput<UpdateContactFlowNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactFlowNameOutputError>
}

public struct UpdateContactFlowNameInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateContactFlowNameInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateContactFlowNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateContactFlowNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateContactFlowNameInput>
    public typealias MOutput = OperationOutput<UpdateContactFlowNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateContactFlowNameOutputError>
}

public struct UpdateContactFlowNameInput: Equatable {
    /// <p>The identifier of the contact flow.</p>
    public let contactFlowId: String?
    /// <p>The description of the contact flow.</p>
    public let description: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The name of the contact flow.</p>
    public let name: String?

    public init (
        contactFlowId: String? = nil,
        description: String? = nil,
        instanceId: String? = nil,
        name: String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.description = description
        self.instanceId = instanceId
        self.name = name
    }
}

struct UpdateContactFlowNameInputBody: Equatable {
    public let name: String?
    public let description: String?
}

extension UpdateContactFlowNameInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateContactFlowNameOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactFlowNameOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactFlowNameOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactFlowNameOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateContactFlowNameOutputResponse()"}
}

extension UpdateContactFlowNameOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactFlowNameOutputResponse: Equatable {

    public init() {}
}

struct UpdateContactFlowNameOutputResponseBody: Equatable {
}

extension UpdateContactFlowNameOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateInstanceAttributeInputBodyMiddleware: Middleware {
    public let id: String = "UpdateInstanceAttributeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceAttributeInput>
    public typealias MOutput = OperationOutput<UpdateInstanceAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceAttributeOutputError>
}

extension UpdateInstanceAttributeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInstanceAttributeInput(attributeType: \(String(describing: attributeType)), instanceId: \(String(describing: instanceId)), value: \(String(describing: value)))"}
}

extension UpdateInstanceAttributeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }
}

public struct UpdateInstanceAttributeInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateInstanceAttributeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceAttributeInput>
    public typealias MOutput = OperationOutput<UpdateInstanceAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceAttributeOutputError>
}

public struct UpdateInstanceAttributeInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateInstanceAttributeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceAttributeInput>
    public typealias MOutput = OperationOutput<UpdateInstanceAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceAttributeOutputError>
}

public struct UpdateInstanceAttributeInput: Equatable {
    /// <p>The type of attribute.</p>
    public let attributeType: InstanceAttributeType?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The value for the attribute. Maximum character limit is 100. </p>
    public let value: String?

    public init (
        attributeType: InstanceAttributeType? = nil,
        instanceId: String? = nil,
        value: String? = nil
    )
    {
        self.attributeType = attributeType
        self.instanceId = instanceId
        self.value = value
    }
}

struct UpdateInstanceAttributeInputBody: Equatable {
    public let value: String?
}

extension UpdateInstanceAttributeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension UpdateInstanceAttributeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInstanceAttributeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInstanceAttributeOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInstanceAttributeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInstanceAttributeOutputResponse()"}
}

extension UpdateInstanceAttributeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateInstanceAttributeOutputResponse: Equatable {

    public init() {}
}

struct UpdateInstanceAttributeOutputResponseBody: Equatable {
}

extension UpdateInstanceAttributeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateInstanceStorageConfigInputBodyMiddleware: Middleware {
    public let id: String = "UpdateInstanceStorageConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceStorageConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceStorageConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceStorageConfigInput>
    public typealias MOutput = OperationOutput<UpdateInstanceStorageConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceStorageConfigOutputError>
}

extension UpdateInstanceStorageConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInstanceStorageConfigInput(associationId: \(String(describing: associationId)), instanceId: \(String(describing: instanceId)), resourceType: \(String(describing: resourceType)), storageConfig: \(String(describing: storageConfig)))"}
}

extension UpdateInstanceStorageConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case storageConfig = "StorageConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let storageConfig = storageConfig {
            try encodeContainer.encode(storageConfig, forKey: .storageConfig)
        }
    }
}

public struct UpdateInstanceStorageConfigInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateInstanceStorageConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceStorageConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceStorageConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceStorageConfigInput>
    public typealias MOutput = OperationOutput<UpdateInstanceStorageConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceStorageConfigOutputError>
}

public struct UpdateInstanceStorageConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateInstanceStorageConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceStorageConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceStorageConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = URLQueryItem(name: "resourceType".urlPercentEncoding(), value: String(resourceType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceStorageConfigInput>
    public typealias MOutput = OperationOutput<UpdateInstanceStorageConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceStorageConfigOutputError>
}

public struct UpdateInstanceStorageConfigInput: Equatable {
    /// <p>The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.</p>
    public let associationId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>A valid resource type.</p>
    public let resourceType: InstanceStorageResourceType?
    /// <p>The storage configuration for the instance.</p>
    public let storageConfig: InstanceStorageConfig?

    public init (
        associationId: String? = nil,
        instanceId: String? = nil,
        resourceType: InstanceStorageResourceType? = nil,
        storageConfig: InstanceStorageConfig? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
        self.resourceType = resourceType
        self.storageConfig = storageConfig
    }
}

struct UpdateInstanceStorageConfigInputBody: Equatable {
    public let storageConfig: InstanceStorageConfig?
}

extension UpdateInstanceStorageConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case storageConfig = "StorageConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageConfigDecoded = try containerValues.decodeIfPresent(InstanceStorageConfig.self, forKey: .storageConfig)
        storageConfig = storageConfigDecoded
    }
}

extension UpdateInstanceStorageConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInstanceStorageConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInstanceStorageConfigOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInstanceStorageConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInstanceStorageConfigOutputResponse()"}
}

extension UpdateInstanceStorageConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateInstanceStorageConfigOutputResponse: Equatable {

    public init() {}
}

struct UpdateInstanceStorageConfigOutputResponseBody: Equatable {
}

extension UpdateInstanceStorageConfigOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateQueueHoursOfOperationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateQueueHoursOfOperationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQueueHoursOfOperationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQueueHoursOfOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQueueHoursOfOperationInput>
    public typealias MOutput = OperationOutput<UpdateQueueHoursOfOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQueueHoursOfOperationOutputError>
}

extension UpdateQueueHoursOfOperationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQueueHoursOfOperationInput(hoursOfOperationId: \(String(describing: hoursOfOperationId)), instanceId: \(String(describing: instanceId)), queueId: \(String(describing: queueId)))"}
}

extension UpdateQueueHoursOfOperationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hoursOfOperationId = "HoursOfOperationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hoursOfOperationId = hoursOfOperationId {
            try encodeContainer.encode(hoursOfOperationId, forKey: .hoursOfOperationId)
        }
    }
}

public struct UpdateQueueHoursOfOperationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateQueueHoursOfOperationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQueueHoursOfOperationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQueueHoursOfOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQueueHoursOfOperationInput>
    public typealias MOutput = OperationOutput<UpdateQueueHoursOfOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQueueHoursOfOperationOutputError>
}

public struct UpdateQueueHoursOfOperationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateQueueHoursOfOperationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQueueHoursOfOperationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQueueHoursOfOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQueueHoursOfOperationInput>
    public typealias MOutput = OperationOutput<UpdateQueueHoursOfOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQueueHoursOfOperationOutputError>
}

public struct UpdateQueueHoursOfOperationInput: Equatable {
    /// <p>The identifier for the hours of operation.</p>
    public let hoursOfOperationId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier for the queue.</p>
    public let queueId: String?

    public init (
        hoursOfOperationId: String? = nil,
        instanceId: String? = nil,
        queueId: String? = nil
    )
    {
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
        self.queueId = queueId
    }
}

struct UpdateQueueHoursOfOperationInputBody: Equatable {
    public let hoursOfOperationId: String?
}

extension UpdateQueueHoursOfOperationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hoursOfOperationId = "HoursOfOperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursOfOperationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hoursOfOperationId)
        hoursOfOperationId = hoursOfOperationIdDecoded
    }
}

extension UpdateQueueHoursOfOperationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQueueHoursOfOperationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQueueHoursOfOperationOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQueueHoursOfOperationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQueueHoursOfOperationOutputResponse()"}
}

extension UpdateQueueHoursOfOperationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQueueHoursOfOperationOutputResponse: Equatable {

    public init() {}
}

struct UpdateQueueHoursOfOperationOutputResponseBody: Equatable {
}

extension UpdateQueueHoursOfOperationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateQueueMaxContactsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateQueueMaxContactsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQueueMaxContactsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQueueMaxContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQueueMaxContactsInput>
    public typealias MOutput = OperationOutput<UpdateQueueMaxContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQueueMaxContactsOutputError>
}

extension UpdateQueueMaxContactsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQueueMaxContactsInput(instanceId: \(String(describing: instanceId)), maxContacts: \(String(describing: maxContacts)), queueId: \(String(describing: queueId)))"}
}

extension UpdateQueueMaxContactsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxContacts = "MaxContacts"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxContacts != 0 {
            try encodeContainer.encode(maxContacts, forKey: .maxContacts)
        }
    }
}

public struct UpdateQueueMaxContactsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateQueueMaxContactsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQueueMaxContactsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQueueMaxContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQueueMaxContactsInput>
    public typealias MOutput = OperationOutput<UpdateQueueMaxContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQueueMaxContactsOutputError>
}

public struct UpdateQueueMaxContactsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateQueueMaxContactsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQueueMaxContactsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQueueMaxContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQueueMaxContactsInput>
    public typealias MOutput = OperationOutput<UpdateQueueMaxContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQueueMaxContactsOutputError>
}

public struct UpdateQueueMaxContactsInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximum number of contacts that can be in the queue before it is considered full.</p>
    public let maxContacts: Int
    /// <p>The identifier for the queue.</p>
    public let queueId: String?

    public init (
        instanceId: String? = nil,
        maxContacts: Int = 0,
        queueId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxContacts = maxContacts
        self.queueId = queueId
    }
}

struct UpdateQueueMaxContactsInputBody: Equatable {
    public let maxContacts: Int
}

extension UpdateQueueMaxContactsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxContacts = "MaxContacts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxContactsDecoded = try containerValues.decode(Int.self, forKey: .maxContacts)
        maxContacts = maxContactsDecoded
    }
}

extension UpdateQueueMaxContactsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQueueMaxContactsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQueueMaxContactsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQueueMaxContactsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQueueMaxContactsOutputResponse()"}
}

extension UpdateQueueMaxContactsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQueueMaxContactsOutputResponse: Equatable {

    public init() {}
}

struct UpdateQueueMaxContactsOutputResponseBody: Equatable {
}

extension UpdateQueueMaxContactsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateQueueNameInputBodyMiddleware: Middleware {
    public let id: String = "UpdateQueueNameInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQueueNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQueueNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQueueNameInput>
    public typealias MOutput = OperationOutput<UpdateQueueNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQueueNameOutputError>
}

extension UpdateQueueNameInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQueueNameInput(description: \(String(describing: description)), instanceId: \(String(describing: instanceId)), name: \(String(describing: name)), queueId: \(String(describing: queueId)))"}
}

extension UpdateQueueNameInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateQueueNameInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateQueueNameInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQueueNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQueueNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQueueNameInput>
    public typealias MOutput = OperationOutput<UpdateQueueNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQueueNameOutputError>
}

public struct UpdateQueueNameInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateQueueNameInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQueueNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQueueNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQueueNameInput>
    public typealias MOutput = OperationOutput<UpdateQueueNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQueueNameOutputError>
}

public struct UpdateQueueNameInput: Equatable {
    /// <p>The description of the queue.</p>
    public let description: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The name of the queue.</p>
    public let name: String?
    /// <p>The identifier for the queue.</p>
    public let queueId: String?

    public init (
        description: String? = nil,
        instanceId: String? = nil,
        name: String? = nil,
        queueId: String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.queueId = queueId
    }
}

struct UpdateQueueNameInputBody: Equatable {
    public let name: String?
    public let description: String?
}

extension UpdateQueueNameInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateQueueNameOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQueueNameOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQueueNameOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQueueNameOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQueueNameOutputResponse()"}
}

extension UpdateQueueNameOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQueueNameOutputResponse: Equatable {

    public init() {}
}

struct UpdateQueueNameOutputResponseBody: Equatable {
}

extension UpdateQueueNameOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateQueueOutboundCallerConfigInputBodyMiddleware: Middleware {
    public let id: String = "UpdateQueueOutboundCallerConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQueueOutboundCallerConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQueueOutboundCallerConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQueueOutboundCallerConfigInput>
    public typealias MOutput = OperationOutput<UpdateQueueOutboundCallerConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQueueOutboundCallerConfigOutputError>
}

extension UpdateQueueOutboundCallerConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQueueOutboundCallerConfigInput(instanceId: \(String(describing: instanceId)), outboundCallerConfig: \(String(describing: outboundCallerConfig)), queueId: \(String(describing: queueId)))"}
}

extension UpdateQueueOutboundCallerConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case outboundCallerConfig = "OutboundCallerConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outboundCallerConfig = outboundCallerConfig {
            try encodeContainer.encode(outboundCallerConfig, forKey: .outboundCallerConfig)
        }
    }
}

public struct UpdateQueueOutboundCallerConfigInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateQueueOutboundCallerConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQueueOutboundCallerConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQueueOutboundCallerConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQueueOutboundCallerConfigInput>
    public typealias MOutput = OperationOutput<UpdateQueueOutboundCallerConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQueueOutboundCallerConfigOutputError>
}

public struct UpdateQueueOutboundCallerConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateQueueOutboundCallerConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQueueOutboundCallerConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQueueOutboundCallerConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQueueOutboundCallerConfigInput>
    public typealias MOutput = OperationOutput<UpdateQueueOutboundCallerConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQueueOutboundCallerConfigOutputError>
}

public struct UpdateQueueOutboundCallerConfigInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The outbound caller ID name, number, and outbound whisper flow.</p>
    public let outboundCallerConfig: OutboundCallerConfig?
    /// <p>The identifier for the queue.</p>
    public let queueId: String?

    public init (
        instanceId: String? = nil,
        outboundCallerConfig: OutboundCallerConfig? = nil,
        queueId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.outboundCallerConfig = outboundCallerConfig
        self.queueId = queueId
    }
}

struct UpdateQueueOutboundCallerConfigInputBody: Equatable {
    public let outboundCallerConfig: OutboundCallerConfig?
}

extension UpdateQueueOutboundCallerConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case outboundCallerConfig = "OutboundCallerConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outboundCallerConfigDecoded = try containerValues.decodeIfPresent(OutboundCallerConfig.self, forKey: .outboundCallerConfig)
        outboundCallerConfig = outboundCallerConfigDecoded
    }
}

extension UpdateQueueOutboundCallerConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQueueOutboundCallerConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQueueOutboundCallerConfigOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQueueOutboundCallerConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQueueOutboundCallerConfigOutputResponse()"}
}

extension UpdateQueueOutboundCallerConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQueueOutboundCallerConfigOutputResponse: Equatable {

    public init() {}
}

struct UpdateQueueOutboundCallerConfigOutputResponseBody: Equatable {
}

extension UpdateQueueOutboundCallerConfigOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateQueueStatusInputBodyMiddleware: Middleware {
    public let id: String = "UpdateQueueStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQueueStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQueueStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQueueStatusInput>
    public typealias MOutput = OperationOutput<UpdateQueueStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQueueStatusOutputError>
}

extension UpdateQueueStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQueueStatusInput(instanceId: \(String(describing: instanceId)), queueId: \(String(describing: queueId)), status: \(String(describing: status)))"}
}

extension UpdateQueueStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateQueueStatusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateQueueStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQueueStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQueueStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQueueStatusInput>
    public typealias MOutput = OperationOutput<UpdateQueueStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQueueStatusOutputError>
}

public struct UpdateQueueStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateQueueStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQueueStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQueueStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQueueStatusInput>
    public typealias MOutput = OperationOutput<UpdateQueueStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQueueStatusOutputError>
}

public struct UpdateQueueStatusInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier for the queue.</p>
    public let queueId: String?
    /// <p>The status of the queue.</p>
    public let status: QueueStatus?

    public init (
        instanceId: String? = nil,
        queueId: String? = nil,
        status: QueueStatus? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
        self.status = status
    }
}

struct UpdateQueueStatusInputBody: Equatable {
    public let status: QueueStatus?
}

extension UpdateQueueStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(QueueStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateQueueStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQueueStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQueueStatusOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQueueStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQueueStatusOutputResponse()"}
}

extension UpdateQueueStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQueueStatusOutputResponse: Equatable {

    public init() {}
}

struct UpdateQueueStatusOutputResponseBody: Equatable {
}

extension UpdateQueueStatusOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateQuickConnectConfigInputBodyMiddleware: Middleware {
    public let id: String = "UpdateQuickConnectConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQuickConnectConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQuickConnectConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQuickConnectConfigInput>
    public typealias MOutput = OperationOutput<UpdateQuickConnectConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQuickConnectConfigOutputError>
}

extension UpdateQuickConnectConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQuickConnectConfigInput(instanceId: \(String(describing: instanceId)), quickConnectConfig: \(String(describing: quickConnectConfig)), quickConnectId: \(String(describing: quickConnectId)))"}
}

extension UpdateQuickConnectConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case quickConnectConfig = "QuickConnectConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quickConnectConfig = quickConnectConfig {
            try encodeContainer.encode(quickConnectConfig, forKey: .quickConnectConfig)
        }
    }
}

public struct UpdateQuickConnectConfigInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateQuickConnectConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQuickConnectConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQuickConnectConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQuickConnectConfigInput>
    public typealias MOutput = OperationOutput<UpdateQuickConnectConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQuickConnectConfigOutputError>
}

public struct UpdateQuickConnectConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateQuickConnectConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQuickConnectConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQuickConnectConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQuickConnectConfigInput>
    public typealias MOutput = OperationOutput<UpdateQuickConnectConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQuickConnectConfigOutputError>
}

public struct UpdateQuickConnectConfigInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>Information about the configuration settings for the quick connect.</p>
    public let quickConnectConfig: QuickConnectConfig?
    /// <p>The identifier for the quick connect.</p>
    public let quickConnectId: String?

    public init (
        instanceId: String? = nil,
        quickConnectConfig: QuickConnectConfig? = nil,
        quickConnectId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.quickConnectConfig = quickConnectConfig
        self.quickConnectId = quickConnectId
    }
}

struct UpdateQuickConnectConfigInputBody: Equatable {
    public let quickConnectConfig: QuickConnectConfig?
}

extension UpdateQuickConnectConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case quickConnectConfig = "QuickConnectConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectConfigDecoded = try containerValues.decodeIfPresent(QuickConnectConfig.self, forKey: .quickConnectConfig)
        quickConnectConfig = quickConnectConfigDecoded
    }
}

extension UpdateQuickConnectConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQuickConnectConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQuickConnectConfigOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQuickConnectConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQuickConnectConfigOutputResponse()"}
}

extension UpdateQuickConnectConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQuickConnectConfigOutputResponse: Equatable {

    public init() {}
}

struct UpdateQuickConnectConfigOutputResponseBody: Equatable {
}

extension UpdateQuickConnectConfigOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateQuickConnectNameInputBodyMiddleware: Middleware {
    public let id: String = "UpdateQuickConnectNameInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQuickConnectNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQuickConnectNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQuickConnectNameInput>
    public typealias MOutput = OperationOutput<UpdateQuickConnectNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQuickConnectNameOutputError>
}

extension UpdateQuickConnectNameInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQuickConnectNameInput(description: \(String(describing: description)), instanceId: \(String(describing: instanceId)), name: \(String(describing: name)), quickConnectId: \(String(describing: quickConnectId)))"}
}

extension UpdateQuickConnectNameInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateQuickConnectNameInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateQuickConnectNameInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQuickConnectNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQuickConnectNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQuickConnectNameInput>
    public typealias MOutput = OperationOutput<UpdateQuickConnectNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQuickConnectNameOutputError>
}

public struct UpdateQuickConnectNameInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateQuickConnectNameInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateQuickConnectNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateQuickConnectNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateQuickConnectNameInput>
    public typealias MOutput = OperationOutput<UpdateQuickConnectNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateQuickConnectNameOutputError>
}

public struct UpdateQuickConnectNameInput: Equatable {
    /// <p>The description of the quick connect.</p>
    public let description: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The name of the quick connect.</p>
    public let name: String?
    /// <p>The identifier for the quick connect.</p>
    public let quickConnectId: String?

    public init (
        description: String? = nil,
        instanceId: String? = nil,
        name: String? = nil,
        quickConnectId: String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.quickConnectId = quickConnectId
    }
}

struct UpdateQuickConnectNameInputBody: Equatable {
    public let name: String?
    public let description: String?
}

extension UpdateQuickConnectNameInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateQuickConnectNameOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQuickConnectNameOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQuickConnectNameOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQuickConnectNameOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateQuickConnectNameOutputResponse()"}
}

extension UpdateQuickConnectNameOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQuickConnectNameOutputResponse: Equatable {

    public init() {}
}

struct UpdateQuickConnectNameOutputResponseBody: Equatable {
}

extension UpdateQuickConnectNameOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRoutingProfileConcurrencyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRoutingProfileConcurrencyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoutingProfileConcurrencyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoutingProfileConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoutingProfileConcurrencyInput>
    public typealias MOutput = OperationOutput<UpdateRoutingProfileConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoutingProfileConcurrencyOutputError>
}

extension UpdateRoutingProfileConcurrencyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRoutingProfileConcurrencyInput(instanceId: \(String(describing: instanceId)), mediaConcurrencies: \(String(describing: mediaConcurrencies)), routingProfileId: \(String(describing: routingProfileId)))"}
}

extension UpdateRoutingProfileConcurrencyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mediaConcurrencies = "MediaConcurrencies"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaConcurrencies = mediaConcurrencies {
            var mediaConcurrenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaConcurrencies)
            for mediaconcurrencies0 in mediaConcurrencies {
                try mediaConcurrenciesContainer.encode(mediaconcurrencies0)
            }
        }
    }
}

public struct UpdateRoutingProfileConcurrencyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRoutingProfileConcurrencyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoutingProfileConcurrencyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoutingProfileConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoutingProfileConcurrencyInput>
    public typealias MOutput = OperationOutput<UpdateRoutingProfileConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoutingProfileConcurrencyOutputError>
}

public struct UpdateRoutingProfileConcurrencyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRoutingProfileConcurrencyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoutingProfileConcurrencyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoutingProfileConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoutingProfileConcurrencyInput>
    public typealias MOutput = OperationOutput<UpdateRoutingProfileConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoutingProfileConcurrencyOutputError>
}

public struct UpdateRoutingProfileConcurrencyInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The channels that agents can handle in the Contact Control Panel (CCP).</p>
    public let mediaConcurrencies: [MediaConcurrency]?
    /// <p>The identifier of the routing profile.</p>
    public let routingProfileId: String?

    public init (
        instanceId: String? = nil,
        mediaConcurrencies: [MediaConcurrency]? = nil,
        routingProfileId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.mediaConcurrencies = mediaConcurrencies
        self.routingProfileId = routingProfileId
    }
}

struct UpdateRoutingProfileConcurrencyInputBody: Equatable {
    public let mediaConcurrencies: [MediaConcurrency]?
}

extension UpdateRoutingProfileConcurrencyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mediaConcurrencies = "MediaConcurrencies"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaConcurrenciesContainer = try containerValues.decodeIfPresent([MediaConcurrency?].self, forKey: .mediaConcurrencies)
        var mediaConcurrenciesDecoded0:[MediaConcurrency]? = nil
        if let mediaConcurrenciesContainer = mediaConcurrenciesContainer {
            mediaConcurrenciesDecoded0 = [MediaConcurrency]()
            for structure0 in mediaConcurrenciesContainer {
                if let structure0 = structure0 {
                    mediaConcurrenciesDecoded0?.append(structure0)
                }
            }
        }
        mediaConcurrencies = mediaConcurrenciesDecoded0
    }
}

extension UpdateRoutingProfileConcurrencyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoutingProfileConcurrencyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoutingProfileConcurrencyOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoutingProfileConcurrencyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRoutingProfileConcurrencyOutputResponse()"}
}

extension UpdateRoutingProfileConcurrencyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRoutingProfileConcurrencyOutputResponse: Equatable {

    public init() {}
}

struct UpdateRoutingProfileConcurrencyOutputResponseBody: Equatable {
}

extension UpdateRoutingProfileConcurrencyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRoutingProfileDefaultOutboundQueueInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRoutingProfileDefaultOutboundQueueInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoutingProfileDefaultOutboundQueueInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoutingProfileDefaultOutboundQueueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoutingProfileDefaultOutboundQueueInput>
    public typealias MOutput = OperationOutput<UpdateRoutingProfileDefaultOutboundQueueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoutingProfileDefaultOutboundQueueOutputError>
}

extension UpdateRoutingProfileDefaultOutboundQueueInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRoutingProfileDefaultOutboundQueueInput(defaultOutboundQueueId: \(String(describing: defaultOutboundQueueId)), instanceId: \(String(describing: instanceId)), routingProfileId: \(String(describing: routingProfileId)))"}
}

extension UpdateRoutingProfileDefaultOutboundQueueInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultOutboundQueueId = "DefaultOutboundQueueId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultOutboundQueueId = defaultOutboundQueueId {
            try encodeContainer.encode(defaultOutboundQueueId, forKey: .defaultOutboundQueueId)
        }
    }
}

public struct UpdateRoutingProfileDefaultOutboundQueueInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRoutingProfileDefaultOutboundQueueInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoutingProfileDefaultOutboundQueueInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoutingProfileDefaultOutboundQueueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoutingProfileDefaultOutboundQueueInput>
    public typealias MOutput = OperationOutput<UpdateRoutingProfileDefaultOutboundQueueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoutingProfileDefaultOutboundQueueOutputError>
}

public struct UpdateRoutingProfileDefaultOutboundQueueInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRoutingProfileDefaultOutboundQueueInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoutingProfileDefaultOutboundQueueInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoutingProfileDefaultOutboundQueueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoutingProfileDefaultOutboundQueueInput>
    public typealias MOutput = OperationOutput<UpdateRoutingProfileDefaultOutboundQueueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoutingProfileDefaultOutboundQueueOutputError>
}

public struct UpdateRoutingProfileDefaultOutboundQueueInput: Equatable {
    /// <p>The identifier for the default outbound queue.</p>
    public let defaultOutboundQueueId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier of the routing profile.</p>
    public let routingProfileId: String?

    public init (
        defaultOutboundQueueId: String? = nil,
        instanceId: String? = nil,
        routingProfileId: String? = nil
    )
    {
        self.defaultOutboundQueueId = defaultOutboundQueueId
        self.instanceId = instanceId
        self.routingProfileId = routingProfileId
    }
}

struct UpdateRoutingProfileDefaultOutboundQueueInputBody: Equatable {
    public let defaultOutboundQueueId: String?
}

extension UpdateRoutingProfileDefaultOutboundQueueInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultOutboundQueueId = "DefaultOutboundQueueId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultOutboundQueueIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultOutboundQueueId)
        defaultOutboundQueueId = defaultOutboundQueueIdDecoded
    }
}

extension UpdateRoutingProfileDefaultOutboundQueueOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoutingProfileDefaultOutboundQueueOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoutingProfileDefaultOutboundQueueOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoutingProfileDefaultOutboundQueueOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRoutingProfileDefaultOutboundQueueOutputResponse()"}
}

extension UpdateRoutingProfileDefaultOutboundQueueOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRoutingProfileDefaultOutboundQueueOutputResponse: Equatable {

    public init() {}
}

struct UpdateRoutingProfileDefaultOutboundQueueOutputResponseBody: Equatable {
}

extension UpdateRoutingProfileDefaultOutboundQueueOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRoutingProfileNameInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRoutingProfileNameInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoutingProfileNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoutingProfileNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoutingProfileNameInput>
    public typealias MOutput = OperationOutput<UpdateRoutingProfileNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoutingProfileNameOutputError>
}

extension UpdateRoutingProfileNameInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRoutingProfileNameInput(description: \(String(describing: description)), instanceId: \(String(describing: instanceId)), name: \(String(describing: name)), routingProfileId: \(String(describing: routingProfileId)))"}
}

extension UpdateRoutingProfileNameInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateRoutingProfileNameInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRoutingProfileNameInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoutingProfileNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoutingProfileNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoutingProfileNameInput>
    public typealias MOutput = OperationOutput<UpdateRoutingProfileNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoutingProfileNameOutputError>
}

public struct UpdateRoutingProfileNameInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRoutingProfileNameInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoutingProfileNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoutingProfileNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoutingProfileNameInput>
    public typealias MOutput = OperationOutput<UpdateRoutingProfileNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoutingProfileNameOutputError>
}

public struct UpdateRoutingProfileNameInput: Equatable {
    /// <p>The description of the routing profile. Must not be more than 250 characters.</p>
    public let description: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The name of the routing profile. Must not be more than 127 characters.</p>
    public let name: String?
    /// <p>The identifier of the routing profile.</p>
    public let routingProfileId: String?

    public init (
        description: String? = nil,
        instanceId: String? = nil,
        name: String? = nil,
        routingProfileId: String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.routingProfileId = routingProfileId
    }
}

struct UpdateRoutingProfileNameInputBody: Equatable {
    public let name: String?
    public let description: String?
}

extension UpdateRoutingProfileNameInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateRoutingProfileNameOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoutingProfileNameOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoutingProfileNameOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoutingProfileNameOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRoutingProfileNameOutputResponse()"}
}

extension UpdateRoutingProfileNameOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRoutingProfileNameOutputResponse: Equatable {

    public init() {}
}

struct UpdateRoutingProfileNameOutputResponseBody: Equatable {
}

extension UpdateRoutingProfileNameOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRoutingProfileQueuesInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRoutingProfileQueuesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoutingProfileQueuesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoutingProfileQueuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoutingProfileQueuesInput>
    public typealias MOutput = OperationOutput<UpdateRoutingProfileQueuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoutingProfileQueuesOutputError>
}

extension UpdateRoutingProfileQueuesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRoutingProfileQueuesInput(instanceId: \(String(describing: instanceId)), queueConfigs: \(String(describing: queueConfigs)), routingProfileId: \(String(describing: routingProfileId)))"}
}

extension UpdateRoutingProfileQueuesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case queueConfigs = "QueueConfigs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queueConfigs = queueConfigs {
            var queueConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queueConfigs)
            for routingprofilequeueconfiglist0 in queueConfigs {
                try queueConfigsContainer.encode(routingprofilequeueconfiglist0)
            }
        }
    }
}

public struct UpdateRoutingProfileQueuesInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRoutingProfileQueuesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoutingProfileQueuesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoutingProfileQueuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoutingProfileQueuesInput>
    public typealias MOutput = OperationOutput<UpdateRoutingProfileQueuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoutingProfileQueuesOutputError>
}

public struct UpdateRoutingProfileQueuesInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRoutingProfileQueuesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRoutingProfileQueuesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRoutingProfileQueuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRoutingProfileQueuesInput>
    public typealias MOutput = OperationOutput<UpdateRoutingProfileQueuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRoutingProfileQueuesOutputError>
}

public struct UpdateRoutingProfileQueuesInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The queues to be updated for this routing profile.
    ///    Queues must first be associated to the routing
    ///    profile. You can do this using AssociateRoutingProfileQueues.</p>
    public let queueConfigs: [RoutingProfileQueueConfig]?
    /// <p>The identifier of the routing profile.</p>
    public let routingProfileId: String?

    public init (
        instanceId: String? = nil,
        queueConfigs: [RoutingProfileQueueConfig]? = nil,
        routingProfileId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueConfigs = queueConfigs
        self.routingProfileId = routingProfileId
    }
}

struct UpdateRoutingProfileQueuesInputBody: Equatable {
    public let queueConfigs: [RoutingProfileQueueConfig]?
}

extension UpdateRoutingProfileQueuesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case queueConfigs = "QueueConfigs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueConfigsContainer = try containerValues.decodeIfPresent([RoutingProfileQueueConfig?].self, forKey: .queueConfigs)
        var queueConfigsDecoded0:[RoutingProfileQueueConfig]? = nil
        if let queueConfigsContainer = queueConfigsContainer {
            queueConfigsDecoded0 = [RoutingProfileQueueConfig]()
            for structure0 in queueConfigsContainer {
                if let structure0 = structure0 {
                    queueConfigsDecoded0?.append(structure0)
                }
            }
        }
        queueConfigs = queueConfigsDecoded0
    }
}

extension UpdateRoutingProfileQueuesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoutingProfileQueuesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoutingProfileQueuesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoutingProfileQueuesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRoutingProfileQueuesOutputResponse()"}
}

extension UpdateRoutingProfileQueuesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRoutingProfileQueuesOutputResponse: Equatable {

    public init() {}
}

struct UpdateRoutingProfileQueuesOutputResponseBody: Equatable {
}

extension UpdateRoutingProfileQueuesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateUserHierarchyGroupNameInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserHierarchyGroupNameInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserHierarchyGroupNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserHierarchyGroupNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserHierarchyGroupNameInput>
    public typealias MOutput = OperationOutput<UpdateUserHierarchyGroupNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserHierarchyGroupNameOutputError>
}

extension UpdateUserHierarchyGroupNameInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserHierarchyGroupNameInput(hierarchyGroupId: \(String(describing: hierarchyGroupId)), instanceId: \(String(describing: instanceId)), name: \(String(describing: name)))"}
}

extension UpdateUserHierarchyGroupNameInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateUserHierarchyGroupNameInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserHierarchyGroupNameInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserHierarchyGroupNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserHierarchyGroupNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserHierarchyGroupNameInput>
    public typealias MOutput = OperationOutput<UpdateUserHierarchyGroupNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserHierarchyGroupNameOutputError>
}

public struct UpdateUserHierarchyGroupNameInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserHierarchyGroupNameInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserHierarchyGroupNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserHierarchyGroupNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserHierarchyGroupNameInput>
    public typealias MOutput = OperationOutput<UpdateUserHierarchyGroupNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserHierarchyGroupNameOutputError>
}

public struct UpdateUserHierarchyGroupNameInput: Equatable {
    /// <p>The identifier of the hierarchy group.</p>
    public let hierarchyGroupId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The name of the hierarchy group. Must not be more than 100 characters.</p>
    public let name: String?

    public init (
        hierarchyGroupId: String? = nil,
        instanceId: String? = nil,
        name: String? = nil
    )
    {
        self.hierarchyGroupId = hierarchyGroupId
        self.instanceId = instanceId
        self.name = name
    }
}

struct UpdateUserHierarchyGroupNameInputBody: Equatable {
    public let name: String?
}

extension UpdateUserHierarchyGroupNameInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateUserHierarchyGroupNameOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserHierarchyGroupNameOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserHierarchyGroupNameOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserHierarchyGroupNameOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserHierarchyGroupNameOutputResponse()"}
}

extension UpdateUserHierarchyGroupNameOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserHierarchyGroupNameOutputResponse: Equatable {

    public init() {}
}

struct UpdateUserHierarchyGroupNameOutputResponseBody: Equatable {
}

extension UpdateUserHierarchyGroupNameOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateUserHierarchyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserHierarchyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserHierarchyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserHierarchyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserHierarchyInput>
    public typealias MOutput = OperationOutput<UpdateUserHierarchyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserHierarchyOutputError>
}

extension UpdateUserHierarchyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserHierarchyInput(hierarchyGroupId: \(String(describing: hierarchyGroupId)), instanceId: \(String(describing: instanceId)), userId: \(String(describing: userId)))"}
}

extension UpdateUserHierarchyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hierarchyGroupId = "HierarchyGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hierarchyGroupId = hierarchyGroupId {
            try encodeContainer.encode(hierarchyGroupId, forKey: .hierarchyGroupId)
        }
    }
}

public struct UpdateUserHierarchyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserHierarchyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserHierarchyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserHierarchyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserHierarchyInput>
    public typealias MOutput = OperationOutput<UpdateUserHierarchyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserHierarchyOutputError>
}

public struct UpdateUserHierarchyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserHierarchyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserHierarchyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserHierarchyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserHierarchyInput>
    public typealias MOutput = OperationOutput<UpdateUserHierarchyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserHierarchyOutputError>
}

public struct UpdateUserHierarchyInput: Equatable {
    /// <p>The identifier of the hierarchy group.</p>
    public let hierarchyGroupId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier of the user account.</p>
    public let userId: String?

    public init (
        hierarchyGroupId: String? = nil,
        instanceId: String? = nil,
        userId: String? = nil
    )
    {
        self.hierarchyGroupId = hierarchyGroupId
        self.instanceId = instanceId
        self.userId = userId
    }
}

struct UpdateUserHierarchyInputBody: Equatable {
    public let hierarchyGroupId: String?
}

extension UpdateUserHierarchyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hierarchyGroupId = "HierarchyGroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hierarchyGroupId)
        hierarchyGroupId = hierarchyGroupIdDecoded
    }
}

extension UpdateUserHierarchyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserHierarchyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserHierarchyOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserHierarchyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserHierarchyOutputResponse()"}
}

extension UpdateUserHierarchyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserHierarchyOutputResponse: Equatable {

    public init() {}
}

struct UpdateUserHierarchyOutputResponseBody: Equatable {
}

extension UpdateUserHierarchyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateUserHierarchyStructureInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserHierarchyStructureInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserHierarchyStructureInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserHierarchyStructureOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserHierarchyStructureInput>
    public typealias MOutput = OperationOutput<UpdateUserHierarchyStructureOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserHierarchyStructureOutputError>
}

extension UpdateUserHierarchyStructureInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserHierarchyStructureInput(hierarchyStructure: \(String(describing: hierarchyStructure)), instanceId: \(String(describing: instanceId)))"}
}

extension UpdateUserHierarchyStructureInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hierarchyStructure = "HierarchyStructure"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hierarchyStructure = hierarchyStructure {
            try encodeContainer.encode(hierarchyStructure, forKey: .hierarchyStructure)
        }
    }
}

public struct UpdateUserHierarchyStructureInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserHierarchyStructureInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserHierarchyStructureInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserHierarchyStructureOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserHierarchyStructureInput>
    public typealias MOutput = OperationOutput<UpdateUserHierarchyStructureOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserHierarchyStructureOutputError>
}

public struct UpdateUserHierarchyStructureInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserHierarchyStructureInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserHierarchyStructureInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserHierarchyStructureOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserHierarchyStructureInput>
    public typealias MOutput = OperationOutput<UpdateUserHierarchyStructureOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserHierarchyStructureOutputError>
}

public struct UpdateUserHierarchyStructureInput: Equatable {
    /// <p>The hierarchy levels to update.</p>
    public let hierarchyStructure: HierarchyStructureUpdate?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?

    public init (
        hierarchyStructure: HierarchyStructureUpdate? = nil,
        instanceId: String? = nil
    )
    {
        self.hierarchyStructure = hierarchyStructure
        self.instanceId = instanceId
    }
}

struct UpdateUserHierarchyStructureInputBody: Equatable {
    public let hierarchyStructure: HierarchyStructureUpdate?
}

extension UpdateUserHierarchyStructureInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hierarchyStructure = "HierarchyStructure"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyStructureDecoded = try containerValues.decodeIfPresent(HierarchyStructureUpdate.self, forKey: .hierarchyStructure)
        hierarchyStructure = hierarchyStructureDecoded
    }
}

extension UpdateUserHierarchyStructureOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserHierarchyStructureOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserHierarchyStructureOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserHierarchyStructureOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserHierarchyStructureOutputResponse()"}
}

extension UpdateUserHierarchyStructureOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserHierarchyStructureOutputResponse: Equatable {

    public init() {}
}

struct UpdateUserHierarchyStructureOutputResponseBody: Equatable {
}

extension UpdateUserHierarchyStructureOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateUserIdentityInfoInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserIdentityInfoInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserIdentityInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserIdentityInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserIdentityInfoInput>
    public typealias MOutput = OperationOutput<UpdateUserIdentityInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserIdentityInfoOutputError>
}

extension UpdateUserIdentityInfoInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserIdentityInfoInput(identityInfo: \(String(describing: identityInfo)), instanceId: \(String(describing: instanceId)), userId: \(String(describing: userId)))"}
}

extension UpdateUserIdentityInfoInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityInfo = "IdentityInfo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityInfo = identityInfo {
            try encodeContainer.encode(identityInfo, forKey: .identityInfo)
        }
    }
}

public struct UpdateUserIdentityInfoInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserIdentityInfoInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserIdentityInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserIdentityInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserIdentityInfoInput>
    public typealias MOutput = OperationOutput<UpdateUserIdentityInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserIdentityInfoOutputError>
}

public struct UpdateUserIdentityInfoInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserIdentityInfoInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserIdentityInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserIdentityInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserIdentityInfoInput>
    public typealias MOutput = OperationOutput<UpdateUserIdentityInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserIdentityInfoOutputError>
}

public struct UpdateUserIdentityInfoInput: Equatable {
    /// <p>The identity information for the user.</p>
    public let identityInfo: UserIdentityInfo?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier of the user account.</p>
    public let userId: String?

    public init (
        identityInfo: UserIdentityInfo? = nil,
        instanceId: String? = nil,
        userId: String? = nil
    )
    {
        self.identityInfo = identityInfo
        self.instanceId = instanceId
        self.userId = userId
    }
}

struct UpdateUserIdentityInfoInputBody: Equatable {
    public let identityInfo: UserIdentityInfo?
}

extension UpdateUserIdentityInfoInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityInfo = "IdentityInfo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityInfoDecoded = try containerValues.decodeIfPresent(UserIdentityInfo.self, forKey: .identityInfo)
        identityInfo = identityInfoDecoded
    }
}

extension UpdateUserIdentityInfoOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserIdentityInfoOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserIdentityInfoOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserIdentityInfoOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserIdentityInfoOutputResponse()"}
}

extension UpdateUserIdentityInfoOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserIdentityInfoOutputResponse: Equatable {

    public init() {}
}

struct UpdateUserIdentityInfoOutputResponseBody: Equatable {
}

extension UpdateUserIdentityInfoOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateUserPhoneConfigInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserPhoneConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserPhoneConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserPhoneConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserPhoneConfigInput>
    public typealias MOutput = OperationOutput<UpdateUserPhoneConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserPhoneConfigOutputError>
}

extension UpdateUserPhoneConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserPhoneConfigInput(instanceId: \(String(describing: instanceId)), phoneConfig: \(String(describing: phoneConfig)), userId: \(String(describing: userId)))"}
}

extension UpdateUserPhoneConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case phoneConfig = "PhoneConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneConfig = phoneConfig {
            try encodeContainer.encode(phoneConfig, forKey: .phoneConfig)
        }
    }
}

public struct UpdateUserPhoneConfigInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserPhoneConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserPhoneConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserPhoneConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserPhoneConfigInput>
    public typealias MOutput = OperationOutput<UpdateUserPhoneConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserPhoneConfigOutputError>
}

public struct UpdateUserPhoneConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserPhoneConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserPhoneConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserPhoneConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserPhoneConfigInput>
    public typealias MOutput = OperationOutput<UpdateUserPhoneConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserPhoneConfigOutputError>
}

public struct UpdateUserPhoneConfigInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>Information about phone configuration settings for the user.</p>
    public let phoneConfig: UserPhoneConfig?
    /// <p>The identifier of the user account.</p>
    public let userId: String?

    public init (
        instanceId: String? = nil,
        phoneConfig: UserPhoneConfig? = nil,
        userId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.phoneConfig = phoneConfig
        self.userId = userId
    }
}

struct UpdateUserPhoneConfigInputBody: Equatable {
    public let phoneConfig: UserPhoneConfig?
}

extension UpdateUserPhoneConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case phoneConfig = "PhoneConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneConfigDecoded = try containerValues.decodeIfPresent(UserPhoneConfig.self, forKey: .phoneConfig)
        phoneConfig = phoneConfigDecoded
    }
}

extension UpdateUserPhoneConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserPhoneConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserPhoneConfigOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserPhoneConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserPhoneConfigOutputResponse()"}
}

extension UpdateUserPhoneConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserPhoneConfigOutputResponse: Equatable {

    public init() {}
}

struct UpdateUserPhoneConfigOutputResponseBody: Equatable {
}

extension UpdateUserPhoneConfigOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateUserRoutingProfileInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserRoutingProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserRoutingProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserRoutingProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserRoutingProfileInput>
    public typealias MOutput = OperationOutput<UpdateUserRoutingProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserRoutingProfileOutputError>
}

extension UpdateUserRoutingProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserRoutingProfileInput(instanceId: \(String(describing: instanceId)), routingProfileId: \(String(describing: routingProfileId)), userId: \(String(describing: userId)))"}
}

extension UpdateUserRoutingProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case routingProfileId = "RoutingProfileId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let routingProfileId = routingProfileId {
            try encodeContainer.encode(routingProfileId, forKey: .routingProfileId)
        }
    }
}

public struct UpdateUserRoutingProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserRoutingProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserRoutingProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserRoutingProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserRoutingProfileInput>
    public typealias MOutput = OperationOutput<UpdateUserRoutingProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserRoutingProfileOutputError>
}

public struct UpdateUserRoutingProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserRoutingProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserRoutingProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserRoutingProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserRoutingProfileInput>
    public typealias MOutput = OperationOutput<UpdateUserRoutingProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserRoutingProfileOutputError>
}

public struct UpdateUserRoutingProfileInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifier of the routing profile for the user.</p>
    public let routingProfileId: String?
    /// <p>The identifier of the user account.</p>
    public let userId: String?

    public init (
        instanceId: String? = nil,
        routingProfileId: String? = nil,
        userId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.routingProfileId = routingProfileId
        self.userId = userId
    }
}

struct UpdateUserRoutingProfileInputBody: Equatable {
    public let routingProfileId: String?
}

extension UpdateUserRoutingProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case routingProfileId = "RoutingProfileId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routingProfileId)
        routingProfileId = routingProfileIdDecoded
    }
}

extension UpdateUserRoutingProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserRoutingProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserRoutingProfileOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserRoutingProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserRoutingProfileOutputResponse()"}
}

extension UpdateUserRoutingProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserRoutingProfileOutputResponse: Equatable {

    public init() {}
}

struct UpdateUserRoutingProfileOutputResponseBody: Equatable {
}

extension UpdateUserRoutingProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateUserSecurityProfilesInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserSecurityProfilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserSecurityProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserSecurityProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserSecurityProfilesInput>
    public typealias MOutput = OperationOutput<UpdateUserSecurityProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserSecurityProfilesOutputError>
}

extension UpdateUserSecurityProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserSecurityProfilesInput(instanceId: \(String(describing: instanceId)), securityProfileIds: \(String(describing: securityProfileIds)), userId: \(String(describing: userId)))"}
}

extension UpdateUserSecurityProfilesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityProfileIds = "SecurityProfileIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityProfileIds = securityProfileIds {
            var securityProfileIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityProfileIds)
            for securityprofileids0 in securityProfileIds {
                try securityProfileIdsContainer.encode(securityprofileids0)
            }
        }
    }
}

public struct UpdateUserSecurityProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserSecurityProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserSecurityProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserSecurityProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserSecurityProfilesInput>
    public typealias MOutput = OperationOutput<UpdateUserSecurityProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserSecurityProfilesOutputError>
}

public struct UpdateUserSecurityProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserSecurityProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserSecurityProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserSecurityProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserSecurityProfilesInput>
    public typealias MOutput = OperationOutput<UpdateUserSecurityProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserSecurityProfilesOutputError>
}

public struct UpdateUserSecurityProfilesInput: Equatable {
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The identifiers of the security profiles for the user.</p>
    public let securityProfileIds: [String]?
    /// <p>The identifier of the user account.</p>
    public let userId: String?

    public init (
        instanceId: String? = nil,
        securityProfileIds: [String]? = nil,
        userId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.securityProfileIds = securityProfileIds
        self.userId = userId
    }
}

struct UpdateUserSecurityProfilesInputBody: Equatable {
    public let securityProfileIds: [String]?
}

extension UpdateUserSecurityProfilesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case securityProfileIds = "SecurityProfileIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityProfileIds)
        var securityProfileIdsDecoded0:[String]? = nil
        if let securityProfileIdsContainer = securityProfileIdsContainer {
            securityProfileIdsDecoded0 = [String]()
            for string0 in securityProfileIdsContainer {
                if let string0 = string0 {
                    securityProfileIdsDecoded0?.append(string0)
                }
            }
        }
        securityProfileIds = securityProfileIdsDecoded0
    }
}

extension UpdateUserSecurityProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserSecurityProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserSecurityProfilesOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserSecurityProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserSecurityProfilesOutputResponse()"}
}

extension UpdateUserSecurityProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserSecurityProfilesOutputResponse: Equatable {

    public init() {}
}

struct UpdateUserSecurityProfilesOutputResponseBody: Equatable {
}

extension UpdateUserSecurityProfilesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UseCase: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case useCaseArn = "UseCaseArn"
        case useCaseId = "UseCaseId"
        case useCaseType = "UseCaseType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let useCaseArn = useCaseArn {
            try encodeContainer.encode(useCaseArn, forKey: .useCaseArn)
        }
        if let useCaseId = useCaseId {
            try encodeContainer.encode(useCaseId, forKey: .useCaseId)
        }
        if let useCaseType = useCaseType {
            try encodeContainer.encode(useCaseType.rawValue, forKey: .useCaseType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let useCaseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .useCaseId)
        useCaseId = useCaseIdDecoded
        let useCaseArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .useCaseArn)
        useCaseArn = useCaseArnDecoded
        let useCaseTypeDecoded = try containerValues.decodeIfPresent(UseCaseType.self, forKey: .useCaseType)
        useCaseType = useCaseTypeDecoded
    }
}

extension UseCase: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UseCase(useCaseArn: \(String(describing: useCaseArn)), useCaseId: \(String(describing: useCaseId)), useCaseType: \(String(describing: useCaseType)))"}
}

/// <p>Contains the
///    use
///    case.</p>
public struct UseCase: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the use case.</p>
    public let useCaseArn: String?
    /// <p>The identifier for the use case.</p>
    public let useCaseId: String?
    /// <p>The type of use case to associate to the AppIntegration association. Each AppIntegration
    ///    association can have only one of each use case type.</p>
    public let useCaseType: UseCaseType?

    public init (
        useCaseArn: String? = nil,
        useCaseId: String? = nil,
        useCaseType: UseCaseType? = nil
    )
    {
        self.useCaseArn = useCaseArn
        self.useCaseId = useCaseId
        self.useCaseType = useCaseType
    }
}

public enum UseCaseType {
    case rulesEvaluation
    case sdkUnknown(String)
}

extension UseCaseType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UseCaseType] {
        return [
            .rulesEvaluation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .rulesEvaluation: return "RULES_EVALUATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UseCaseType(rawValue: rawValue) ?? UseCaseType.sdkUnknown(rawValue)
    }
}

extension User: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case directoryUserId = "DirectoryUserId"
        case hierarchyGroupId = "HierarchyGroupId"
        case id = "Id"
        case identityInfo = "IdentityInfo"
        case phoneConfig = "PhoneConfig"
        case routingProfileId = "RoutingProfileId"
        case securityProfileIds = "SecurityProfileIds"
        case tags = "Tags"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let directoryUserId = directoryUserId {
            try encodeContainer.encode(directoryUserId, forKey: .directoryUserId)
        }
        if let hierarchyGroupId = hierarchyGroupId {
            try encodeContainer.encode(hierarchyGroupId, forKey: .hierarchyGroupId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identityInfo = identityInfo {
            try encodeContainer.encode(identityInfo, forKey: .identityInfo)
        }
        if let phoneConfig = phoneConfig {
            try encodeContainer.encode(phoneConfig, forKey: .phoneConfig)
        }
        if let routingProfileId = routingProfileId {
            try encodeContainer.encode(routingProfileId, forKey: .routingProfileId)
        }
        if let securityProfileIds = securityProfileIds {
            var securityProfileIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityProfileIds)
            for securityprofileids0 in securityProfileIds {
                try securityProfileIdsContainer.encode(securityprofileids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let identityInfoDecoded = try containerValues.decodeIfPresent(UserIdentityInfo.self, forKey: .identityInfo)
        identityInfo = identityInfoDecoded
        let phoneConfigDecoded = try containerValues.decodeIfPresent(UserPhoneConfig.self, forKey: .phoneConfig)
        phoneConfig = phoneConfigDecoded
        let directoryUserIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryUserId)
        directoryUserId = directoryUserIdDecoded
        let securityProfileIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityProfileIds)
        var securityProfileIdsDecoded0:[String]? = nil
        if let securityProfileIdsContainer = securityProfileIdsContainer {
            securityProfileIdsDecoded0 = [String]()
            for string0 in securityProfileIdsContainer {
                if let string0 = string0 {
                    securityProfileIdsDecoded0?.append(string0)
                }
            }
        }
        securityProfileIds = securityProfileIdsDecoded0
        let routingProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routingProfileId)
        routingProfileId = routingProfileIdDecoded
        let hierarchyGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hierarchyGroupId)
        hierarchyGroupId = hierarchyGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension User: CustomDebugStringConvertible {
    public var debugDescription: String {
        "User(arn: \(String(describing: arn)), directoryUserId: \(String(describing: directoryUserId)), hierarchyGroupId: \(String(describing: hierarchyGroupId)), id: \(String(describing: id)), identityInfo: \(String(describing: identityInfo)), phoneConfig: \(String(describing: phoneConfig)), routingProfileId: \(String(describing: routingProfileId)), securityProfileIds: \(String(describing: securityProfileIds)), tags: \(String(describing: tags)), username: \(String(describing: username)))"}
}

/// <p>Contains information about a user account for a Amazon Connect instance.</p>
public struct User: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the user account.</p>
    public let arn: String?
    /// <p>The identifier of the user account in the directory used for identity management.</p>
    public let directoryUserId: String?
    /// <p>The identifier of the hierarchy group for the user.</p>
    public let hierarchyGroupId: String?
    /// <p>The identifier of the user account.</p>
    public let id: String?
    /// <p>Information about the user identity.</p>
    public let identityInfo: UserIdentityInfo?
    /// <p>Information about the phone configuration for the user.</p>
    public let phoneConfig: UserPhoneConfig?
    /// <p>The identifier of the routing profile for the user.</p>
    public let routingProfileId: String?
    /// <p>The identifiers of the security profiles for the user.</p>
    public let securityProfileIds: [String]?
    /// <p>The
    ///    tags.</p>
    public let tags: [String:String]?
    /// <p>The user name assigned to the user account.</p>
    public let username: String?

    public init (
        arn: String? = nil,
        directoryUserId: String? = nil,
        hierarchyGroupId: String? = nil,
        id: String? = nil,
        identityInfo: UserIdentityInfo? = nil,
        phoneConfig: UserPhoneConfig? = nil,
        routingProfileId: String? = nil,
        securityProfileIds: [String]? = nil,
        tags: [String:String]? = nil,
        username: String? = nil
    )
    {
        self.arn = arn
        self.directoryUserId = directoryUserId
        self.hierarchyGroupId = hierarchyGroupId
        self.id = id
        self.identityInfo = identityInfo
        self.phoneConfig = phoneConfig
        self.routingProfileId = routingProfileId
        self.securityProfileIds = securityProfileIds
        self.tags = tags
        self.username = username
    }
}

extension UserIdentityInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case email = "Email"
        case firstName = "FirstName"
        case lastName = "LastName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firstNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
    }
}

extension UserIdentityInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserIdentityInfo(email: \(String(describing: email)), firstName: \(String(describing: firstName)), lastName: \(String(describing: lastName)))"}
}

/// <p>Contains information about the identity of a user.</p>
public struct UserIdentityInfo: Equatable {
    /// <p>The email address. If you are using SAML for identity management and include this parameter,
    ///    an error is returned.</p>
    public let email: String?
    /// <p>The first name. This is required if you are using Amazon Connect or SAML for identity
    ///    management.</p>
    public let firstName: String?
    /// <p>The last name. This is required if you are using Amazon Connect or SAML for identity
    ///    management.</p>
    public let lastName: String?

    public init (
        email: String? = nil,
        firstName: String? = nil,
        lastName: String? = nil
    )
    {
        self.email = email
        self.firstName = firstName
        self.lastName = lastName
    }
}

extension UserNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserNotFoundException(message: \(String(describing: message)))"}
}

extension UserNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UserNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No user with the specified credentials was found in the Amazon Connect instance.</p>
public struct UserNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UserNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension UserNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UserPhoneConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case afterContactWorkTimeLimit = "AfterContactWorkTimeLimit"
        case autoAccept = "AutoAccept"
        case deskPhoneNumber = "DeskPhoneNumber"
        case phoneType = "PhoneType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if afterContactWorkTimeLimit != 0 {
            try encodeContainer.encode(afterContactWorkTimeLimit, forKey: .afterContactWorkTimeLimit)
        }
        if autoAccept != false {
            try encodeContainer.encode(autoAccept, forKey: .autoAccept)
        }
        if let deskPhoneNumber = deskPhoneNumber {
            try encodeContainer.encode(deskPhoneNumber, forKey: .deskPhoneNumber)
        }
        if let phoneType = phoneType {
            try encodeContainer.encode(phoneType.rawValue, forKey: .phoneType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneTypeDecoded = try containerValues.decodeIfPresent(PhoneType.self, forKey: .phoneType)
        phoneType = phoneTypeDecoded
        let autoAcceptDecoded = try containerValues.decode(Bool.self, forKey: .autoAccept)
        autoAccept = autoAcceptDecoded
        let afterContactWorkTimeLimitDecoded = try containerValues.decode(Int.self, forKey: .afterContactWorkTimeLimit)
        afterContactWorkTimeLimit = afterContactWorkTimeLimitDecoded
        let deskPhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deskPhoneNumber)
        deskPhoneNumber = deskPhoneNumberDecoded
    }
}

extension UserPhoneConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserPhoneConfig(afterContactWorkTimeLimit: \(String(describing: afterContactWorkTimeLimit)), autoAccept: \(String(describing: autoAccept)), deskPhoneNumber: \(String(describing: deskPhoneNumber)), phoneType: \(String(describing: phoneType)))"}
}

/// <p>Contains information about the phone configuration settings for a user.</p>
public struct UserPhoneConfig: Equatable {
    /// <p>The After Call Work (ACW) timeout setting, in seconds.</p>
    public let afterContactWorkTimeLimit: Int
    /// <p>The Auto accept setting.</p>
    public let autoAccept: Bool
    /// <p>The phone number for the user's desk phone.</p>
    public let deskPhoneNumber: String?
    /// <p>The phone type.</p>
    public let phoneType: PhoneType?

    public init (
        afterContactWorkTimeLimit: Int = 0,
        autoAccept: Bool = false,
        deskPhoneNumber: String? = nil,
        phoneType: PhoneType? = nil
    )
    {
        self.afterContactWorkTimeLimit = afterContactWorkTimeLimit
        self.autoAccept = autoAccept
        self.deskPhoneNumber = deskPhoneNumber
        self.phoneType = phoneType
    }
}

extension UserQuickConnectConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactFlowId = "ContactFlowId"
        case userId = "UserId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactFlowId = contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
    }
}

extension UserQuickConnectConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserQuickConnectConfig(contactFlowId: \(String(describing: contactFlowId)), userId: \(String(describing: userId)))"}
}

/// <p>Contains information about the quick connect configuration settings for a user. The contact
///    flow must be of type Transfer to Agent.</p>
public struct UserQuickConnectConfig: Equatable {
    /// <p>The identifier of the contact flow.</p>
    public let contactFlowId: String?
    /// <p>The identifier of the user.</p>
    public let userId: String?

    public init (
        contactFlowId: String? = nil,
        userId: String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.userId = userId
    }
}

extension UserSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension UserSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserSummary(arn: \(String(describing: arn)), id: \(String(describing: id)), username: \(String(describing: username)))"}
}

/// <p>Contains summary information about a user.</p>
public struct UserSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the user account.</p>
    public let arn: String?
    /// <p>The identifier of the user account.</p>
    public let id: String?
    /// <p>The Amazon Connect user name of the user account.</p>
    public let username: String?

    public init (
        arn: String? = nil,
        id: String? = nil,
        username: String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.username = username
    }
}

extension VoiceRecordingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case voiceRecordingTrack = "VoiceRecordingTrack"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let voiceRecordingTrack = voiceRecordingTrack {
            try encodeContainer.encode(voiceRecordingTrack.rawValue, forKey: .voiceRecordingTrack)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceRecordingTrackDecoded = try containerValues.decodeIfPresent(VoiceRecordingTrack.self, forKey: .voiceRecordingTrack)
        voiceRecordingTrack = voiceRecordingTrackDecoded
    }
}

extension VoiceRecordingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VoiceRecordingConfiguration(voiceRecordingTrack: \(String(describing: voiceRecordingTrack)))"}
}

/// <p>Contains information about the recording configuration settings.</p>
public struct VoiceRecordingConfiguration: Equatable {
    /// <p>Identifies which track is being recorded.</p>
    public let voiceRecordingTrack: VoiceRecordingTrack?

    public init (
        voiceRecordingTrack: VoiceRecordingTrack? = nil
    )
    {
        self.voiceRecordingTrack = voiceRecordingTrack
    }
}

public enum VoiceRecordingTrack {
    case all
    case fromAgent
    case toAgent
    case sdkUnknown(String)
}

extension VoiceRecordingTrack : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VoiceRecordingTrack] {
        return [
            .all,
            .fromAgent,
            .toAgent,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .fromAgent: return "FROM_AGENT"
        case .toAgent: return "TO_AGENT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VoiceRecordingTrack(rawValue: rawValue) ?? VoiceRecordingTrack.sdkUnknown(rawValue)
    }
}
