// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class ConnectClient {
    let client: SdkHttpClient
    let config: ConnectClientConfiguration
    let serviceName = "Connect"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: ConnectClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class ConnectClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> ConnectClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try ConnectClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension ConnectClient: ConnectClientProtocol {
    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Associates an approved origin to an Amazon Connect instance.</p>
    public func associateApprovedOrigin(input: AssociateApprovedOriginInput, completion: @escaping (SdkResult<AssociateApprovedOriginOutput, AssociateApprovedOriginOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/approved-origin"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateApprovedOrigin")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateApprovedOriginInput, AssociateApprovedOriginOutput, AssociateApprovedOriginOutputError>(id: "associateApprovedOrigin")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateApprovedOriginInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateApprovedOriginInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateApprovedOriginInput, AssociateApprovedOriginOutput, AssociateApprovedOriginOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateApprovedOriginInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Associates a storage resource type for the first time. You can only associate one type of
    ///    storage configuration in a single call. This means, for example, that you can't define an
    ///    instance with multiple S3 buckets for storing chat transcripts.</p>
    ///          <p>This API does not create a resource that doesn't exist. It only associates it to the
    ///    instance. Ensure that the resource being specified in the storage configuration, like an S3
    ///    bucket, exists when being used for association.</p>
    public func associateInstanceStorageConfig(input: AssociateInstanceStorageConfigInput, completion: @escaping (SdkResult<AssociateInstanceStorageConfigOutput, AssociateInstanceStorageConfigOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/storage-config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateInstanceStorageConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateInstanceStorageConfigInput, AssociateInstanceStorageConfigOutput, AssociateInstanceStorageConfigOutputError>(id: "associateInstanceStorageConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateInstanceStorageConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateInstanceStorageConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateInstanceStorageConfigInput, AssociateInstanceStorageConfigOutput, AssociateInstanceStorageConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateInstanceStorageConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Allows the specified Amazon Connect instance to access the specified Lambda function.</p>
    public func associateLambdaFunction(input: AssociateLambdaFunctionInput, completion: @escaping (SdkResult<AssociateLambdaFunctionOutput, AssociateLambdaFunctionOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/lambda-function"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateLambdaFunction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateLambdaFunctionInput, AssociateLambdaFunctionOutput, AssociateLambdaFunctionOutputError>(id: "associateLambdaFunction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateLambdaFunctionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateLambdaFunctionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateLambdaFunctionInput, AssociateLambdaFunctionOutput, AssociateLambdaFunctionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateLambdaFunctionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Allows the specified Amazon Connect instance to access the specified Amazon Lex bot.</p>
    public func associateLexBot(input: AssociateLexBotInput, completion: @escaping (SdkResult<AssociateLexBotOutput, AssociateLexBotOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/lex-bot"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateLexBot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateLexBotInput, AssociateLexBotOutput, AssociateLexBotOutputError>(id: "associateLexBot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateLexBotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateLexBotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateLexBotInput, AssociateLexBotOutput, AssociateLexBotOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateLexBotInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Associates a set of quick connects with a queue.</p>
    public func associateQueueQuickConnects(input: AssociateQueueQuickConnectsInput, completion: @escaping (SdkResult<AssociateQueueQuickConnectsOutput, AssociateQueueQuickConnectsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)/associate-quick-connects"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateQueueQuickConnects")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateQueueQuickConnectsInput, AssociateQueueQuickConnectsOutput, AssociateQueueQuickConnectsOutputError>(id: "associateQueueQuickConnects")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateQueueQuickConnectsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateQueueQuickConnectsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateQueueQuickConnectsInput, AssociateQueueQuickConnectsOutput, AssociateQueueQuickConnectsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateQueueQuickConnectsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Associates a set of queues with a routing profile.</p>
    public func associateRoutingProfileQueues(input: AssociateRoutingProfileQueuesInput, completion: @escaping (SdkResult<AssociateRoutingProfileQueuesOutput, AssociateRoutingProfileQueuesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let routingProfileId = input.routingProfileId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routingProfileId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)/\(routingProfileId)/associate-queues"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateRoutingProfileQueues")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateRoutingProfileQueuesInput, AssociateRoutingProfileQueuesOutput, AssociateRoutingProfileQueuesOutputError>(id: "associateRoutingProfileQueues")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateRoutingProfileQueuesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateRoutingProfileQueuesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateRoutingProfileQueuesInput, AssociateRoutingProfileQueuesOutput, AssociateRoutingProfileQueuesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateRoutingProfileQueuesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Associates a security key to the instance.</p>
    public func associateSecurityKey(input: AssociateSecurityKeyInput, completion: @escaping (SdkResult<AssociateSecurityKeyOutput, AssociateSecurityKeyOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/security-key"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateSecurityKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateSecurityKeyInput, AssociateSecurityKeyOutput, AssociateSecurityKeyOutputError>(id: "associateSecurityKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateSecurityKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateSecurityKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateSecurityKeyInput, AssociateSecurityKeyOutput, AssociateSecurityKeyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateSecurityKeyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a contact flow for the specified Amazon Connect instance.</p>
    ///          <p>You can also create and update contact flows using the <a href="https://docs.aws.amazon.com/connect/latest/adminguide/flow-language.html">Amazon Connect
    ///    Flow language</a>.</p>
    public func createContactFlow(input: CreateContactFlowInput, completion: @escaping (SdkResult<CreateContactFlowOutput, CreateContactFlowOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/contact-flows/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createContactFlow")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateContactFlowInput, CreateContactFlowOutput, CreateContactFlowOutputError>(id: "createContactFlow")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateContactFlowInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateContactFlowInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateContactFlowInput, CreateContactFlowOutput, CreateContactFlowOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateContactFlowInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Initiates an Amazon Connect instance with all the supported channels enabled. It does not attach any
    ///    storage, such as Amazon Simple Storage Service (Amazon S3) or Amazon Kinesis. It also does not
    ///    allow for any configurations on features, such as Contact Lens for Amazon Connect. </p>
    ///          <p>Amazon Connect enforces a limit on the total number of instances that you can create or delete in 30 days.
    /// If you exceed this limit, you will get an error message indicating there has been an excessive number of attempts at creating or deleting instances.
    /// You must wait 30 days before you can restart creating and deleting instances in your account.</p>
    public func createInstance(input: CreateInstanceInput, completion: @escaping (SdkResult<CreateInstanceOutput, CreateInstanceOutputError>) -> Void)
    {
        let urlPath = "/instance"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createInstance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateInstanceInput, CreateInstanceOutput, CreateInstanceOutputError>(id: "createInstance")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateInstanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateInstanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateInstanceInput, CreateInstanceOutput, CreateInstanceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateInstanceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create an AppIntegration association with an Amazon Connect instance.</p>
    public func createIntegrationAssociation(input: CreateIntegrationAssociationInput, completion: @escaping (SdkResult<CreateIntegrationAssociationOutput, CreateIntegrationAssociationOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/integration-associations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createIntegrationAssociation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateIntegrationAssociationInput, CreateIntegrationAssociationOutput, CreateIntegrationAssociationOutputError>(id: "createIntegrationAssociation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateIntegrationAssociationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateIntegrationAssociationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateIntegrationAssociationInput, CreateIntegrationAssociationOutput, CreateIntegrationAssociationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateIntegrationAssociationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Creates a new queue for the specified Amazon Connect instance.</p>
    public func createQueue(input: CreateQueueInput, completion: @escaping (SdkResult<CreateQueueOutput, CreateQueueOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createQueue")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateQueueInput, CreateQueueOutput, CreateQueueOutputError>(id: "createQueue")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateQueueInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateQueueInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateQueueInput, CreateQueueOutput, CreateQueueOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateQueueInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Creates a quick connect for the specified Amazon Connect instance.</p>
    public func createQuickConnect(input: CreateQuickConnectInput, completion: @escaping (SdkResult<CreateQuickConnectOutput, CreateQuickConnectOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/quick-connects/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createQuickConnect")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateQuickConnectInput, CreateQuickConnectOutput, CreateQuickConnectOutputError>(id: "createQuickConnect")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateQuickConnectInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateQuickConnectInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateQuickConnectInput, CreateQuickConnectOutput, CreateQuickConnectOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateQuickConnectInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new routing profile.</p>
    public func createRoutingProfile(input: CreateRoutingProfileInput, completion: @escaping (SdkResult<CreateRoutingProfileOutput, CreateRoutingProfileOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createRoutingProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateRoutingProfileInput, CreateRoutingProfileOutput, CreateRoutingProfileOutputError>(id: "createRoutingProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateRoutingProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateRoutingProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateRoutingProfileInput, CreateRoutingProfileOutput, CreateRoutingProfileOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateRoutingProfileInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a use case for an AppIntegration association.</p>
    public func createUseCase(input: CreateUseCaseInput, completion: @escaping (SdkResult<CreateUseCaseOutput, CreateUseCaseOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let integrationAssociationId = input.integrationAssociationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component integrationAssociationId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/integration-associations/\(integrationAssociationId)/use-cases"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createUseCase")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateUseCaseInput, CreateUseCaseOutput, CreateUseCaseOutputError>(id: "createUseCase")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateUseCaseInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateUseCaseInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateUseCaseInput, CreateUseCaseOutput, CreateUseCaseOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateUseCaseInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a user account for the specified Amazon Connect instance.</p>
    ///          <p>For information about how to create user accounts using the Amazon Connect console, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/user-management.html">Add Users</a> in
    ///    the <i>Amazon Connect Administrator Guide</i>.</p>
    public func createUser(input: CreateUserInput, completion: @escaping (SdkResult<CreateUserOutput, CreateUserOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/users/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createUser")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateUserInput, CreateUserOutput, CreateUserOutputError>(id: "createUser")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateUserInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateUserInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateUserInput, CreateUserOutput, CreateUserOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateUserInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new user hierarchy group.</p>
    public func createUserHierarchyGroup(input: CreateUserHierarchyGroupInput, completion: @escaping (SdkResult<CreateUserHierarchyGroupOutput, CreateUserHierarchyGroupOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/user-hierarchy-groups/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createUserHierarchyGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateUserHierarchyGroupInput, CreateUserHierarchyGroupOutput, CreateUserHierarchyGroupOutputError>(id: "createUserHierarchyGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateUserHierarchyGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateUserHierarchyGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateUserHierarchyGroupInput, CreateUserHierarchyGroupOutput, CreateUserHierarchyGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateUserHierarchyGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Deletes the Amazon Connect instance.</p>
    ///          <p>Amazon Connect enforces a limit on the total number of instances that you can create or delete in 30 days.
    /// If you exceed this limit, you will get an error message indicating there has been an excessive number of attempts at creating or deleting instances.
    /// You must wait 30 days before you can restart creating and deleting instances in your account.</p>
    public func deleteInstance(input: DeleteInstanceInput, completion: @escaping (SdkResult<DeleteInstanceOutput, DeleteInstanceOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteInstance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteInstanceInput, DeleteInstanceOutput, DeleteInstanceOutputError>(id: "deleteInstance")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteInstanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteInstanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteInstanceInput, DeleteInstanceOutput, DeleteInstanceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an AppIntegration association from an Amazon Connect instance. The association must not have
    ///    any use cases associated with it.</p>
    public func deleteIntegrationAssociation(input: DeleteIntegrationAssociationInput, completion: @escaping (SdkResult<DeleteIntegrationAssociationOutput, DeleteIntegrationAssociationOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let integrationAssociationId = input.integrationAssociationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component integrationAssociationId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/integration-associations/\(integrationAssociationId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteIntegrationAssociation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteIntegrationAssociationInput, DeleteIntegrationAssociationOutput, DeleteIntegrationAssociationOutputError>(id: "deleteIntegrationAssociation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntegrationAssociationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntegrationAssociationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteIntegrationAssociationInput, DeleteIntegrationAssociationOutput, DeleteIntegrationAssociationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Deletes a quick connect.</p>
    public func deleteQuickConnect(input: DeleteQuickConnectInput, completion: @escaping (SdkResult<DeleteQuickConnectOutput, DeleteQuickConnectOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let quickConnectId = input.quickConnectId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component quickConnectId unexpectedly nil"))))
            return
        }
        let urlPath = "/quick-connects/\(instanceId)/\(quickConnectId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteQuickConnect")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteQuickConnectInput, DeleteQuickConnectOutput, DeleteQuickConnectOutputError>(id: "deleteQuickConnect")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteQuickConnectInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteQuickConnectInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteQuickConnectInput, DeleteQuickConnectOutput, DeleteQuickConnectOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a use case from an AppIntegration association.</p>
    public func deleteUseCase(input: DeleteUseCaseInput, completion: @escaping (SdkResult<DeleteUseCaseOutput, DeleteUseCaseOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let integrationAssociationId = input.integrationAssociationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component integrationAssociationId unexpectedly nil"))))
            return
        }
        guard let useCaseId = input.useCaseId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component useCaseId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/integration-associations/\(integrationAssociationId)/use-cases/\(useCaseId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteUseCase")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteUseCaseInput, DeleteUseCaseOutput, DeleteUseCaseOutputError>(id: "deleteUseCase")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteUseCaseInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteUseCaseInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteUseCaseInput, DeleteUseCaseOutput, DeleteUseCaseOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a user account from the specified Amazon Connect instance.</p>
    ///          <p>For information about what happens to a user's data when their account is deleted, see
    ///     <a href="https://docs.aws.amazon.com/connect/latest/adminguide/delete-users.html">Delete Users from
    ///     Your Amazon Connect Instance</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func deleteUser(input: DeleteUserInput, completion: @escaping (SdkResult<DeleteUserOutput, DeleteUserOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/users/\(instanceId)/\(userId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteUser")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteUserInput, DeleteUserOutput, DeleteUserOutputError>(id: "deleteUser")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteUserInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteUserInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteUserInput, DeleteUserOutput, DeleteUserOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an existing user hierarchy group. It must not be associated with any agents or have
    ///    any active child groups.</p>
    public func deleteUserHierarchyGroup(input: DeleteUserHierarchyGroupInput, completion: @escaping (SdkResult<DeleteUserHierarchyGroupOutput, DeleteUserHierarchyGroupOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let hierarchyGroupId = input.hierarchyGroupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hierarchyGroupId unexpectedly nil"))))
            return
        }
        let urlPath = "/user-hierarchy-groups/\(instanceId)/\(hierarchyGroupId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteUserHierarchyGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteUserHierarchyGroupInput, DeleteUserHierarchyGroupOutput, DeleteUserHierarchyGroupOutputError>(id: "deleteUserHierarchyGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteUserHierarchyGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteUserHierarchyGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteUserHierarchyGroupInput, DeleteUserHierarchyGroupOutput, DeleteUserHierarchyGroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the specified contact flow.</p>
    ///          <p>You can also create and update contact flows using the <a href="https://docs.aws.amazon.com/connect/latest/adminguide/flow-language.html">Amazon Connect
    ///    Flow language</a>.</p>
    public func describeContactFlow(input: DescribeContactFlowInput, completion: @escaping (SdkResult<DescribeContactFlowOutput, DescribeContactFlowOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let contactFlowId = input.contactFlowId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component contactFlowId unexpectedly nil"))))
            return
        }
        let urlPath = "/contact-flows/\(instanceId)/\(contactFlowId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeContactFlow")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeContactFlowInput, DescribeContactFlowOutput, DescribeContactFlowOutputError>(id: "describeContactFlow")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeContactFlowInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeContactFlowInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeContactFlowInput, DescribeContactFlowOutput, DescribeContactFlowOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Describes the hours of operation.</p>
    public func describeHoursOfOperation(input: DescribeHoursOfOperationInput, completion: @escaping (SdkResult<DescribeHoursOfOperationOutput, DescribeHoursOfOperationOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let hoursOfOperationId = input.hoursOfOperationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hoursOfOperationId unexpectedly nil"))))
            return
        }
        let urlPath = "/hours-of-operations/\(instanceId)/\(hoursOfOperationId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeHoursOfOperation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeHoursOfOperationInput, DescribeHoursOfOperationOutput, DescribeHoursOfOperationOutputError>(id: "describeHoursOfOperation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeHoursOfOperationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeHoursOfOperationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeHoursOfOperationInput, DescribeHoursOfOperationOutput, DescribeHoursOfOperationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Returns the current state of the specified instance identifier. It tracks the instance while
    ///    it is being created and returns an error status, if applicable. </p>
    ///          <p>If an instance is not created successfully, the instance status reason field returns details
    ///    relevant to the reason. The instance in a failed state is returned only for 24 hours after the
    ///    CreateInstance API was invoked.</p>
    public func describeInstance(input: DescribeInstanceInput, completion: @escaping (SdkResult<DescribeInstanceOutput, DescribeInstanceOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeInstance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeInstanceInput, DescribeInstanceOutput, DescribeInstanceOutputError>(id: "describeInstance")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeInstanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeInstanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeInstanceInput, DescribeInstanceOutput, DescribeInstanceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Describes the specified instance attribute.</p>
    public func describeInstanceAttribute(input: DescribeInstanceAttributeInput, completion: @escaping (SdkResult<DescribeInstanceAttributeOutput, DescribeInstanceAttributeOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let attributeType = input.attributeType else {
            completion(.failure(.client(ClientError.serializationFailed("uri component attributeType unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/attribute/\(attributeType.rawValue)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeInstanceAttribute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeInstanceAttributeInput, DescribeInstanceAttributeOutput, DescribeInstanceAttributeOutputError>(id: "describeInstanceAttribute")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeInstanceAttributeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeInstanceAttributeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeInstanceAttributeInput, DescribeInstanceAttributeOutput, DescribeInstanceAttributeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Retrieves the current storage configurations for the specified resource type, association
    ///    ID, and instance ID.</p>
    public func describeInstanceStorageConfig(input: DescribeInstanceStorageConfigInput, completion: @escaping (SdkResult<DescribeInstanceStorageConfigOutput, DescribeInstanceStorageConfigOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let associationId = input.associationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component associationId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/storage-config/\(associationId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeInstanceStorageConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeInstanceStorageConfigInput, DescribeInstanceStorageConfigOutput, DescribeInstanceStorageConfigOutputError>(id: "describeInstanceStorageConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeInstanceStorageConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeInstanceStorageConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeInstanceStorageConfigInput, DescribeInstanceStorageConfigOutput, DescribeInstanceStorageConfigOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Describes the specified queue.</p>
    public func describeQueue(input: DescribeQueueInput, completion: @escaping (SdkResult<DescribeQueueOutput, DescribeQueueOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeQueue")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeQueueInput, DescribeQueueOutput, DescribeQueueOutputError>(id: "describeQueue")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeQueueInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeQueueInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeQueueInput, DescribeQueueOutput, DescribeQueueOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Describes the quick connect.</p>
    public func describeQuickConnect(input: DescribeQuickConnectInput, completion: @escaping (SdkResult<DescribeQuickConnectOutput, DescribeQuickConnectOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let quickConnectId = input.quickConnectId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component quickConnectId unexpectedly nil"))))
            return
        }
        let urlPath = "/quick-connects/\(instanceId)/\(quickConnectId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeQuickConnect")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeQuickConnectInput, DescribeQuickConnectOutput, DescribeQuickConnectOutputError>(id: "describeQuickConnect")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeQuickConnectInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeQuickConnectInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeQuickConnectInput, DescribeQuickConnectOutput, DescribeQuickConnectOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the specified routing profile.</p>
    public func describeRoutingProfile(input: DescribeRoutingProfileInput, completion: @escaping (SdkResult<DescribeRoutingProfileOutput, DescribeRoutingProfileOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let routingProfileId = input.routingProfileId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routingProfileId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)/\(routingProfileId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeRoutingProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeRoutingProfileInput, DescribeRoutingProfileOutput, DescribeRoutingProfileOutputError>(id: "describeRoutingProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeRoutingProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeRoutingProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeRoutingProfileInput, DescribeRoutingProfileOutput, DescribeRoutingProfileOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the specified user account. You can find the instance ID in the console (it’s the
    ///    final part of the ARN). The console does not display the user IDs. Instead, list the users and
    ///    note the IDs provided in the output.</p>
    public func describeUser(input: DescribeUserInput, completion: @escaping (SdkResult<DescribeUserOutput, DescribeUserOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/users/\(instanceId)/\(userId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeUser")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeUserInput, DescribeUserOutput, DescribeUserOutputError>(id: "describeUser")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeUserInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeUserInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeUserInput, DescribeUserOutput, DescribeUserOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the specified hierarchy group.</p>
    public func describeUserHierarchyGroup(input: DescribeUserHierarchyGroupInput, completion: @escaping (SdkResult<DescribeUserHierarchyGroupOutput, DescribeUserHierarchyGroupOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let hierarchyGroupId = input.hierarchyGroupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hierarchyGroupId unexpectedly nil"))))
            return
        }
        let urlPath = "/user-hierarchy-groups/\(instanceId)/\(hierarchyGroupId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeUserHierarchyGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeUserHierarchyGroupInput, DescribeUserHierarchyGroupOutput, DescribeUserHierarchyGroupOutputError>(id: "describeUserHierarchyGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeUserHierarchyGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeUserHierarchyGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeUserHierarchyGroupInput, DescribeUserHierarchyGroupOutput, DescribeUserHierarchyGroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the hierarchy structure of the specified Amazon Connect instance.</p>
    public func describeUserHierarchyStructure(input: DescribeUserHierarchyStructureInput, completion: @escaping (SdkResult<DescribeUserHierarchyStructureOutput, DescribeUserHierarchyStructureOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/user-hierarchy-structure/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeUserHierarchyStructure")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeUserHierarchyStructureInput, DescribeUserHierarchyStructureOutput, DescribeUserHierarchyStructureOutputError>(id: "describeUserHierarchyStructure")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeUserHierarchyStructureInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeUserHierarchyStructureInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeUserHierarchyStructureInput, DescribeUserHierarchyStructureOutput, DescribeUserHierarchyStructureOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Revokes access to integrated applications from Amazon Connect.</p>
    public func disassociateApprovedOrigin(input: DisassociateApprovedOriginInput, completion: @escaping (SdkResult<DisassociateApprovedOriginOutput, DisassociateApprovedOriginOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/approved-origin"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateApprovedOrigin")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateApprovedOriginInput, DisassociateApprovedOriginOutput, DisassociateApprovedOriginOutputError>(id: "disassociateApprovedOrigin")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateApprovedOriginInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateApprovedOriginInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateApprovedOriginInput, DisassociateApprovedOriginOutput, DisassociateApprovedOriginOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Removes the storage type configurations for the specified resource type and association
    ///    ID.</p>
    public func disassociateInstanceStorageConfig(input: DisassociateInstanceStorageConfigInput, completion: @escaping (SdkResult<DisassociateInstanceStorageConfigOutput, DisassociateInstanceStorageConfigOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let associationId = input.associationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component associationId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/storage-config/\(associationId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateInstanceStorageConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateInstanceStorageConfigInput, DisassociateInstanceStorageConfigOutput, DisassociateInstanceStorageConfigOutputError>(id: "disassociateInstanceStorageConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateInstanceStorageConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateInstanceStorageConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateInstanceStorageConfigInput, DisassociateInstanceStorageConfigOutput, DisassociateInstanceStorageConfigOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Remove the Lambda function from the dropdown options available in the relevant contact flow
    ///    blocks.</p>
    public func disassociateLambdaFunction(input: DisassociateLambdaFunctionInput, completion: @escaping (SdkResult<DisassociateLambdaFunctionOutput, DisassociateLambdaFunctionOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/lambda-function"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateLambdaFunction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateLambdaFunctionInput, DisassociateLambdaFunctionOutput, DisassociateLambdaFunctionOutputError>(id: "disassociateLambdaFunction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateLambdaFunctionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateLambdaFunctionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateLambdaFunctionInput, DisassociateLambdaFunctionOutput, DisassociateLambdaFunctionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Revokes authorization from the specified instance to access the specified Amazon Lex bot.</p>
    public func disassociateLexBot(input: DisassociateLexBotInput, completion: @escaping (SdkResult<DisassociateLexBotOutput, DisassociateLexBotOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/lex-bot"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateLexBot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateLexBotInput, DisassociateLexBotOutput, DisassociateLexBotOutputError>(id: "disassociateLexBot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateLexBotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateLexBotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateLexBotInput, DisassociateLexBotOutput, DisassociateLexBotOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Disassociates a set of quick connects from a queue.</p>
    public func disassociateQueueQuickConnects(input: DisassociateQueueQuickConnectsInput, completion: @escaping (SdkResult<DisassociateQueueQuickConnectsOutput, DisassociateQueueQuickConnectsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)/disassociate-quick-connects"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateQueueQuickConnects")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateQueueQuickConnectsInput, DisassociateQueueQuickConnectsOutput, DisassociateQueueQuickConnectsOutputError>(id: "disassociateQueueQuickConnects")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateQueueQuickConnectsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateQueueQuickConnectsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateQueueQuickConnectsInput, DisassociateQueueQuickConnectsOutput, DisassociateQueueQuickConnectsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DisassociateQueueQuickConnectsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Disassociates a set of queues from a routing profile.</p>
    public func disassociateRoutingProfileQueues(input: DisassociateRoutingProfileQueuesInput, completion: @escaping (SdkResult<DisassociateRoutingProfileQueuesOutput, DisassociateRoutingProfileQueuesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let routingProfileId = input.routingProfileId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routingProfileId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)/\(routingProfileId)/disassociate-queues"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateRoutingProfileQueues")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateRoutingProfileQueuesInput, DisassociateRoutingProfileQueuesOutput, DisassociateRoutingProfileQueuesOutputError>(id: "disassociateRoutingProfileQueues")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateRoutingProfileQueuesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateRoutingProfileQueuesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateRoutingProfileQueuesInput, DisassociateRoutingProfileQueuesOutput, DisassociateRoutingProfileQueuesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DisassociateRoutingProfileQueuesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Deletes the specified security key.</p>
    public func disassociateSecurityKey(input: DisassociateSecurityKeyInput, completion: @escaping (SdkResult<DisassociateSecurityKeyOutput, DisassociateSecurityKeyOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let associationId = input.associationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component associationId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/security-key/\(associationId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateSecurityKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateSecurityKeyInput, DisassociateSecurityKeyOutput, DisassociateSecurityKeyOutputError>(id: "disassociateSecurityKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateSecurityKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateSecurityKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateSecurityKeyInput, DisassociateSecurityKeyOutput, DisassociateSecurityKeyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the contact attributes for the specified contact.</p>
    public func getContactAttributes(input: GetContactAttributesInput, completion: @escaping (SdkResult<GetContactAttributesOutput, GetContactAttributesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let initialContactId = input.initialContactId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component initialContactId unexpectedly nil"))))
            return
        }
        let urlPath = "/contact/attributes/\(instanceId)/\(initialContactId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getContactAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetContactAttributesInput, GetContactAttributesOutput, GetContactAttributesOutputError>(id: "getContactAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetContactAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetContactAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetContactAttributesInput, GetContactAttributesOutput, GetContactAttributesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the real-time metric data from the specified Amazon Connect instance.</p>
    ///          <p>For a description of each metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html">Real-time Metrics
    ///     Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func getCurrentMetricData(input: GetCurrentMetricDataInput, completion: @escaping (SdkResult<GetCurrentMetricDataOutput, GetCurrentMetricDataOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/metrics/current/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getCurrentMetricData")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetCurrentMetricDataInput, GetCurrentMetricDataOutput, GetCurrentMetricDataOutputError>(id: "getCurrentMetricData")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetCurrentMetricDataInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetCurrentMetricDataInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetCurrentMetricDataInput, GetCurrentMetricDataOutput, GetCurrentMetricDataOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: GetCurrentMetricDataInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a token for federation.</p>
    ///          <note>
    ///             <p>This API doesn't support root users. If you try to invoke GetFederationToken with root
    ///     credentials, an error message similar to the following one appears: </p>
    ///             <p>
    ///                <code>Provided identity: Principal: .... User: .... cannot be used for federation with
    ///      Amazon Connect</code>
    ///             </p>
    ///          </note>
    public func getFederationToken(input: GetFederationTokenInput, completion: @escaping (SdkResult<GetFederationTokenOutput, GetFederationTokenOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/user/federate/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getFederationToken")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetFederationTokenInput, GetFederationTokenOutput, GetFederationTokenOutputError>(id: "getFederationToken")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetFederationTokenInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetFederationTokenInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetFederationTokenInput, GetFederationTokenOutput, GetFederationTokenOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets historical metric data from the specified Amazon Connect instance.</p>
    ///
    ///          <p>For a description of each historical metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical Metrics
    ///     Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func getMetricData(input: GetMetricDataInput, completion: @escaping (SdkResult<GetMetricDataOutput, GetMetricDataOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/metrics/historical/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getMetricData")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetMetricDataInput, GetMetricDataOutput, GetMetricDataOutputError>(id: "getMetricData")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetMetricDataInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetMetricDataInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetMetricDataInput, GetMetricDataOutput, GetMetricDataOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: GetMetricDataInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Returns a paginated list of all approved origins associated with the instance.</p>
    public func listApprovedOrigins(input: ListApprovedOriginsInput, completion: @escaping (SdkResult<ListApprovedOriginsOutput, ListApprovedOriginsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/approved-origins"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listApprovedOrigins")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListApprovedOriginsInput, ListApprovedOriginsOutput, ListApprovedOriginsOutputError>(id: "listApprovedOrigins")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListApprovedOriginsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListApprovedOriginsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListApprovedOriginsInput, ListApprovedOriginsOutput, ListApprovedOriginsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides information about the contact flows for the specified Amazon Connect instance.</p>
    ///          <p>You can also create and update contact flows using the <a href="https://docs.aws.amazon.com/connect/latest/adminguide/flow-language.html">Amazon Connect
    ///    Flow language</a>.</p>
    ///          <p>For more information about contact flows, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-contact-flows.html">Contact Flows</a> in the
    ///     <i>Amazon Connect Administrator Guide</i>.</p>
    public func listContactFlows(input: ListContactFlowsInput, completion: @escaping (SdkResult<ListContactFlowsOutput, ListContactFlowsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/contact-flows-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listContactFlows")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListContactFlowsInput, ListContactFlowsOutput, ListContactFlowsOutputError>(id: "listContactFlows")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListContactFlowsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListContactFlowsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListContactFlowsInput, ListContactFlowsOutput, ListContactFlowsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides information about the hours of operation for the specified Amazon Connect instance.</p>
    ///          <p>For more information about hours of operation, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/set-hours-operation.html">Set the Hours of Operation for a
    ///     Queue</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func listHoursOfOperations(input: ListHoursOfOperationsInput, completion: @escaping (SdkResult<ListHoursOfOperationsOutput, ListHoursOfOperationsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/hours-of-operations-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listHoursOfOperations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListHoursOfOperationsInput, ListHoursOfOperationsOutput, ListHoursOfOperationsOutputError>(id: "listHoursOfOperations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListHoursOfOperationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListHoursOfOperationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListHoursOfOperationsInput, ListHoursOfOperationsOutput, ListHoursOfOperationsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Returns a paginated list of all attribute types for the given instance.</p>
    public func listInstanceAttributes(input: ListInstanceAttributesInput, completion: @escaping (SdkResult<ListInstanceAttributesOutput, ListInstanceAttributesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/attributes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listInstanceAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListInstanceAttributesInput, ListInstanceAttributesOutput, ListInstanceAttributesOutputError>(id: "listInstanceAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListInstanceAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListInstanceAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListInstanceAttributesInput, ListInstanceAttributesOutput, ListInstanceAttributesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///
    ///          <p>Returns a paginated list of storage configs for the identified instance and resource
    ///    type.</p>
    public func listInstanceStorageConfigs(input: ListInstanceStorageConfigsInput, completion: @escaping (SdkResult<ListInstanceStorageConfigsOutput, ListInstanceStorageConfigsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/storage-configs"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listInstanceStorageConfigs")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListInstanceStorageConfigsInput, ListInstanceStorageConfigsOutput, ListInstanceStorageConfigsOutputError>(id: "listInstanceStorageConfigs")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListInstanceStorageConfigsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListInstanceStorageConfigsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListInstanceStorageConfigsInput, ListInstanceStorageConfigsOutput, ListInstanceStorageConfigsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Return a list of instances which are in active state, creation-in-progress state, and failed
    ///    state. Instances that aren't successfully created (they are in a failed state) are returned only
    ///    for 24 hours after the CreateInstance API was invoked.</p>
    public func listInstances(input: ListInstancesInput, completion: @escaping (SdkResult<ListInstancesOutput, ListInstancesOutputError>) -> Void)
    {
        let urlPath = "/instance"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listInstances")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListInstancesInput, ListInstancesOutput, ListInstancesOutputError>(id: "listInstances")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListInstancesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListInstancesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListInstancesInput, ListInstancesOutput, ListInstancesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides summary information about the AppIntegration associations for the specified Amazon Connect
    ///    instance.</p>
    public func listIntegrationAssociations(input: ListIntegrationAssociationsInput, completion: @escaping (SdkResult<ListIntegrationAssociationsOutput, ListIntegrationAssociationsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/integration-associations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listIntegrationAssociations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListIntegrationAssociationsInput, ListIntegrationAssociationsOutput, ListIntegrationAssociationsOutputError>(id: "listIntegrationAssociations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListIntegrationAssociationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListIntegrationAssociationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListIntegrationAssociationsInput, ListIntegrationAssociationsOutput, ListIntegrationAssociationsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Returns a paginated list of all Lambda functions that display in the dropdown options in the
    ///    relevant contact flow blocks.</p>
    public func listLambdaFunctions(input: ListLambdaFunctionsInput, completion: @escaping (SdkResult<ListLambdaFunctionsOutput, ListLambdaFunctionsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/lambda-functions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listLambdaFunctions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListLambdaFunctionsInput, ListLambdaFunctionsOutput, ListLambdaFunctionsOutputError>(id: "listLambdaFunctions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListLambdaFunctionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListLambdaFunctionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListLambdaFunctionsInput, ListLambdaFunctionsOutput, ListLambdaFunctionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Returns a paginated list of all the Amazon Lex bots currently associated with the
    ///    instance.</p>
    public func listLexBots(input: ListLexBotsInput, completion: @escaping (SdkResult<ListLexBotsOutput, ListLexBotsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/lex-bots"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listLexBots")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListLexBotsInput, ListLexBotsOutput, ListLexBotsOutputError>(id: "listLexBots")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListLexBotsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListLexBotsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListLexBotsInput, ListLexBotsOutput, ListLexBotsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides information about the phone numbers for the specified Amazon Connect instance. </p>
    ///          <p>For more information about phone numbers, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-center-phone-number.html">Set Up Phone Numbers for Your
    ///     Contact Center</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func listPhoneNumbers(input: ListPhoneNumbersInput, completion: @escaping (SdkResult<ListPhoneNumbersOutput, ListPhoneNumbersOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/phone-numbers-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPhoneNumbers")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPhoneNumbersInput, ListPhoneNumbersOutput, ListPhoneNumbersOutputError>(id: "listPhoneNumbers")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPhoneNumbersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPhoneNumbersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPhoneNumbersInput, ListPhoneNumbersOutput, ListPhoneNumbersOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides information about the prompts for the specified Amazon Connect instance.</p>
    public func listPrompts(input: ListPromptsInput, completion: @escaping (SdkResult<ListPromptsOutput, ListPromptsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/prompts-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPrompts")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPromptsInput, ListPromptsOutput, ListPromptsOutputError>(id: "listPrompts")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPromptsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPromptsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPromptsInput, ListPromptsOutput, ListPromptsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Lists the quick connects associated with a queue.</p>
    public func listQueueQuickConnects(input: ListQueueQuickConnectsInput, completion: @escaping (SdkResult<ListQueueQuickConnectsOutput, ListQueueQuickConnectsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)/quick-connects"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listQueueQuickConnects")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListQueueQuickConnectsInput, ListQueueQuickConnectsOutput, ListQueueQuickConnectsOutputError>(id: "listQueueQuickConnects")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListQueueQuickConnectsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListQueueQuickConnectsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListQueueQuickConnectsInput, ListQueueQuickConnectsOutput, ListQueueQuickConnectsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides information about the queues for the specified Amazon Connect instance.</p>
    ///          <p>If you do not specify a <code>QueueTypes</code>
    ///    parameter, both standard and agent queues are returned. This might cause an unexpected truncation
    ///    of results if you have more than 1000 agents and you limit the number of results of the API call
    ///    in code.</p>
    ///          <p>For more information about queues, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-queues-standard-and-agent.html">Queues: Standard and
    ///     Agent</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func listQueues(input: ListQueuesInput, completion: @escaping (SdkResult<ListQueuesOutput, ListQueuesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listQueues")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListQueuesInput, ListQueuesOutput, ListQueuesOutputError>(id: "listQueues")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListQueuesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListQueuesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListQueuesInput, ListQueuesOutput, ListQueuesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Provides information about the quick connects for the specified Amazon Connect instance. </p>
    public func listQuickConnects(input: ListQuickConnectsInput, completion: @escaping (SdkResult<ListQuickConnectsOutput, ListQuickConnectsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/quick-connects/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listQuickConnects")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListQuickConnectsInput, ListQuickConnectsOutput, ListQuickConnectsOutputError>(id: "listQuickConnects")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListQuickConnectsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListQuickConnectsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListQuickConnectsInput, ListQuickConnectsOutput, ListQuickConnectsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the queues associated with a routing profile.</p>
    public func listRoutingProfileQueues(input: ListRoutingProfileQueuesInput, completion: @escaping (SdkResult<ListRoutingProfileQueuesOutput, ListRoutingProfileQueuesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let routingProfileId = input.routingProfileId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routingProfileId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)/\(routingProfileId)/queues"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listRoutingProfileQueues")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListRoutingProfileQueuesInput, ListRoutingProfileQueuesOutput, ListRoutingProfileQueuesOutputError>(id: "listRoutingProfileQueues")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListRoutingProfileQueuesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListRoutingProfileQueuesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListRoutingProfileQueuesInput, ListRoutingProfileQueuesOutput, ListRoutingProfileQueuesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides summary information about the routing profiles for the specified Amazon Connect
    ///    instance.</p>
    ///          <p>For more information about routing profiles, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing.html">Routing Profiles</a> and <a href="https://docs.aws.amazon.com/connect/latest/adminguide/routing-profiles.html">Create a Routing
    ///     Profile</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func listRoutingProfiles(input: ListRoutingProfilesInput, completion: @escaping (SdkResult<ListRoutingProfilesOutput, ListRoutingProfilesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listRoutingProfiles")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListRoutingProfilesInput, ListRoutingProfilesOutput, ListRoutingProfilesOutputError>(id: "listRoutingProfiles")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListRoutingProfilesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListRoutingProfilesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListRoutingProfilesInput, ListRoutingProfilesOutput, ListRoutingProfilesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Returns a paginated list of all security keys associated with the instance.</p>
    public func listSecurityKeys(input: ListSecurityKeysInput, completion: @escaping (SdkResult<ListSecurityKeysOutput, ListSecurityKeysOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/security-keys"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listSecurityKeys")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListSecurityKeysInput, ListSecurityKeysOutput, ListSecurityKeysOutputError>(id: "listSecurityKeys")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListSecurityKeysInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListSecurityKeysInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListSecurityKeysInput, ListSecurityKeysOutput, ListSecurityKeysOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides summary information about the security profiles for the specified Amazon Connect
    ///    instance.</p>
    ///          <p>For more information about security profiles, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/connect-security-profiles.html">Security Profiles</a> in the
    ///     <i>Amazon Connect Administrator Guide</i>.</p>
    public func listSecurityProfiles(input: ListSecurityProfilesInput, completion: @escaping (SdkResult<ListSecurityProfilesOutput, ListSecurityProfilesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/security-profiles-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listSecurityProfiles")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListSecurityProfilesInput, ListSecurityProfilesOutput, ListSecurityProfilesOutputError>(id: "listSecurityProfiles")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListSecurityProfilesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListSecurityProfilesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListSecurityProfilesInput, ListSecurityProfilesOutput, ListSecurityProfilesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the tags for the specified resource.</p>
    ///          <p>For sample policies that use tags, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/security_iam_id-based-policy-examples.html">Amazon Connect Identity-Based
    ///     Policy Examples</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutput, ListTagsForResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the use cases. </p>
    public func listUseCases(input: ListUseCasesInput, completion: @escaping (SdkResult<ListUseCasesOutput, ListUseCasesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let integrationAssociationId = input.integrationAssociationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component integrationAssociationId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/integration-associations/\(integrationAssociationId)/use-cases"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listUseCases")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListUseCasesInput, ListUseCasesOutput, ListUseCasesOutputError>(id: "listUseCases")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListUseCasesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListUseCasesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListUseCasesInput, ListUseCasesOutput, ListUseCasesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides summary information about the hierarchy groups for the specified Amazon Connect
    ///    instance.</p>
    ///          <p>For more information about agent hierarchies, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/agent-hierarchy.html">Set Up Agent Hierarchies</a> in the
    ///     <i>Amazon Connect Administrator Guide</i>.</p>
    public func listUserHierarchyGroups(input: ListUserHierarchyGroupsInput, completion: @escaping (SdkResult<ListUserHierarchyGroupsOutput, ListUserHierarchyGroupsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/user-hierarchy-groups-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listUserHierarchyGroups")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListUserHierarchyGroupsInput, ListUserHierarchyGroupsOutput, ListUserHierarchyGroupsOutputError>(id: "listUserHierarchyGroups")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListUserHierarchyGroupsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListUserHierarchyGroupsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListUserHierarchyGroupsInput, ListUserHierarchyGroupsOutput, ListUserHierarchyGroupsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides summary information about the users for the specified Amazon Connect instance.</p>
    public func listUsers(input: ListUsersInput, completion: @escaping (SdkResult<ListUsersOutput, ListUsersOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/users-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listUsers")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListUsersInput, ListUsersOutput, ListUsersOutputError>(id: "listUsers")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListUsersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListUsersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListUsersInput, ListUsersOutput, ListUsersOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>When a contact is being recorded, and the recording has been suspended using
    ///    SuspendContactRecording, this API resumes recording the call.</p>
    ///
    ///          <p>Only voice recordings are supported at this time.</p>
    public func resumeContactRecording(input: ResumeContactRecordingInput, completion: @escaping (SdkResult<ResumeContactRecordingOutput, ResumeContactRecordingOutputError>) -> Void)
    {
        let urlPath = "/contact/resume-recording"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "resumeContactRecording")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ResumeContactRecordingInput, ResumeContactRecordingOutput, ResumeContactRecordingOutputError>(id: "resumeContactRecording")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ResumeContactRecordingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ResumeContactRecordingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ResumeContactRecordingInput, ResumeContactRecordingOutput, ResumeContactRecordingOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ResumeContactRecordingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Initiates a contact flow to start a new chat for the customer. Response of this API provides
    ///    a token required to obtain credentials from the <a href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html">CreateParticipantConnection</a> API in the Amazon Connect Participant Service.</p>
    ///
    ///          <p>When a new chat contact is successfully created, clients must subscribe to the participant’s
    ///    connection for the created chat within 5 minutes. This is achieved by invoking <a href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html">CreateParticipantConnection</a> with WEBSOCKET and CONNECTION_CREDENTIALS. </p>
    ///
    ///          <p>A 429 error occurs in two situations:</p>
    ///          <ul>
    ///             <li>
    ///                <p>API rate limit is exceeded. API TPS throttling returns a <code>TooManyRequests</code>
    ///      exception.</p>
    ///             </li>
    ///             <li>
    ///                <p>The <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">quota for concurrent active
    ///       chats</a> is exceeded. Active chat throttling returns a
    ///       <code>LimitExceededException</code>.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>For more information about chat, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat.html">Chat</a> in the <i>Amazon Connect Administrator
    ///     Guide</i>.</p>
    public func startChatContact(input: StartChatContactInput, completion: @escaping (SdkResult<StartChatContactOutput, StartChatContactOutputError>) -> Void)
    {
        let urlPath = "/contact/chat"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startChatContact")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartChatContactInput, StartChatContactOutput, StartChatContactOutputError>(id: "startChatContact")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<StartChatContactOutput>, SdkError<StartChatContactOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: StartChatContactInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartChatContactInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartChatContactInput, StartChatContactOutput, StartChatContactOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartChatContactInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Starts recording the contact when the agent joins the call. StartContactRecording is a
    ///    one-time action. For example, if you use StopContactRecording to stop recording an ongoing call,
    ///    you can't use StartContactRecording to restart it. For scenarios where the recording has started
    ///    and you want to suspend and resume it, such as when collecting sensitive information (for
    ///    example, a credit card number), use SuspendContactRecording and ResumeContactRecording.</p>
    ///          <p>You can use this API to override the recording behavior configured in the <a href="https://docs.aws.amazon.com/connect/latest/adminguide/set-recording-behavior.html">Set recording
    ///     behavior</a> block.</p>
    ///          <p>Only voice recordings are supported at this time.</p>
    public func startContactRecording(input: StartContactRecordingInput, completion: @escaping (SdkResult<StartContactRecordingOutput, StartContactRecordingOutputError>) -> Void)
    {
        let urlPath = "/contact/start-recording"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startContactRecording")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartContactRecordingInput, StartContactRecordingOutput, StartContactRecordingOutputError>(id: "startContactRecording")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartContactRecordingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartContactRecordingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartContactRecordingInput, StartContactRecordingOutput, StartContactRecordingOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartContactRecordingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Places an outbound call to a contact, and then initiates the contact flow. It performs the
    ///    actions in the contact flow that's specified (in <code>ContactFlowId</code>).</p>
    ///
    ///          <p>Agents do not initiate the outbound API, which means that they do not dial the contact. If
    ///    the contact flow places an outbound call to a contact, and then puts the contact in queue, the
    ///    call is then routed to the agent, like any other inbound case.</p>
    ///
    ///          <p>There is a 60-second dialing timeout for this operation. If the call is not connected after
    ///    60 seconds, it fails.</p>
    ///          <note>
    ///             <p>UK numbers with a 447 prefix are not allowed by default. Before you can dial these UK
    ///     mobile numbers, you must submit a service quota increase request. For more information, see
    ///      <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">Amazon Connect Service Quotas</a> in the <i>Amazon Connect Administrator Guide</i>. </p>
    ///          </note>
    public func startOutboundVoiceContact(input: StartOutboundVoiceContactInput, completion: @escaping (SdkResult<StartOutboundVoiceContactOutput, StartOutboundVoiceContactOutputError>) -> Void)
    {
        let urlPath = "/contact/outbound-voice"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startOutboundVoiceContact")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartOutboundVoiceContactInput, StartOutboundVoiceContactOutput, StartOutboundVoiceContactOutputError>(id: "startOutboundVoiceContact")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<StartOutboundVoiceContactOutput>, SdkError<StartOutboundVoiceContactOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: StartOutboundVoiceContactInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartOutboundVoiceContactInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartOutboundVoiceContactInput, StartOutboundVoiceContactOutput, StartOutboundVoiceContactOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartOutboundVoiceContactInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Initiates a contact flow to start a new task.</p>
    public func startTaskContact(input: StartTaskContactInput, completion: @escaping (SdkResult<StartTaskContactOutput, StartTaskContactOutputError>) -> Void)
    {
        let urlPath = "/contact/task"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startTaskContact")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartTaskContactInput, StartTaskContactOutput, StartTaskContactOutputError>(id: "startTaskContact")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<StartTaskContactOutput>, SdkError<StartTaskContactOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: StartTaskContactInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartTaskContactInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartTaskContactInput, StartTaskContactOutput, StartTaskContactOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartTaskContactInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Ends the specified contact.</p>
    public func stopContact(input: StopContactInput, completion: @escaping (SdkResult<StopContactOutput, StopContactOutputError>) -> Void)
    {
        let urlPath = "/contact/stop"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "stopContact")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StopContactInput, StopContactOutput, StopContactOutputError>(id: "stopContact")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StopContactInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StopContactInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StopContactInput, StopContactOutput, StopContactOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StopContactInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Stops recording a call when a contact is being recorded. StopContactRecording is a one-time
    ///    action. If you use StopContactRecording to stop recording an ongoing call, you can't use
    ///    StartContactRecording to restart it. For scenarios where the recording has started and you want
    ///    to suspend it for sensitive information (for example, to collect a credit card number), and then
    ///    restart it, use SuspendContactRecording and ResumeContactRecording.</p>
    ///
    ///          <p>Only voice recordings are supported at this time.</p>
    public func stopContactRecording(input: StopContactRecordingInput, completion: @escaping (SdkResult<StopContactRecordingOutput, StopContactRecordingOutputError>) -> Void)
    {
        let urlPath = "/contact/stop-recording"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "stopContactRecording")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StopContactRecordingInput, StopContactRecordingOutput, StopContactRecordingOutputError>(id: "stopContactRecording")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StopContactRecordingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StopContactRecordingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StopContactRecordingInput, StopContactRecordingOutput, StopContactRecordingOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StopContactRecordingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>When a contact is being recorded, this API suspends recording the call. For example, you
    ///    might suspend the call recording while collecting sensitive information, such as a credit card
    ///    number. Then use ResumeContactRecording to restart recording. </p>
    ///          <p>The period of time that the recording is suspended is filled with silence in the final
    ///    recording. </p>
    ///          <p>Only voice recordings are supported at this time.</p>
    public func suspendContactRecording(input: SuspendContactRecordingInput, completion: @escaping (SdkResult<SuspendContactRecordingOutput, SuspendContactRecordingOutputError>) -> Void)
    {
        let urlPath = "/contact/suspend-recording"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "suspendContactRecording")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SuspendContactRecordingInput, SuspendContactRecordingOutput, SuspendContactRecordingOutputError>(id: "suspendContactRecording")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SuspendContactRecordingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SuspendContactRecordingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SuspendContactRecordingInput, SuspendContactRecordingOutput, SuspendContactRecordingOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: SuspendContactRecordingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds the specified tags to the specified resource.</p>
    ///          <p>The supported resource types are users, routing profiles, queues, quick connects, and
    ///    contact flows.</p>
    ///          <p>For sample policies that use tags, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/security_iam_id-based-policy-examples.html">Amazon Connect Identity-Based
    ///     Policy Examples</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutput, TagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutput, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutput, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes the specified tags from the specified resource.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutput, UntagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutput, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutput, UntagResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates or updates
    ///    user-defined contact attributes
    ///    associated with the specified contact.</p>
    ///          <p>You can create or update user-defined attributes for both ongoing and completed contacts.
    ///    For example, while the call is active, you can update the customer's name or the reason the
    ///    customer called. You can add notes about steps that the agent took during the call that display
    ///    to the next agent that takes the call. You can also update attributes for a contact using data
    ///    from your CRM application and save the data with the contact in Amazon Connect. You could also flag calls
    ///    for additional analysis, such as legal review or to identify abusive callers.</p>
    ///          <p>Contact attributes are available in Amazon Connect for 24 months, and are then deleted. For
    ///    information about CTR retention and the maximum size of the CTR attributes section, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html#feature-limits">Feature
    ///     specifications</a> in the <i>Amazon Connect Administrator Guide</i>. </p>
    ///
    ///          <p>
    ///             <b>Important:</b> You cannot use the operation to update
    ///    attributes for contacts that occurred prior to the release of the API, which was September 12,
    ///    2018. You can update attributes only for contacts that started after the release of the API. If
    ///    you attempt to update attributes for a contact that occurred prior to the release of the API, a
    ///    400 error is returned. This applies also to queued callbacks that were initiated prior to the
    ///    release of the API but are still active in your instance.</p>
    public func updateContactAttributes(input: UpdateContactAttributesInput, completion: @escaping (SdkResult<UpdateContactAttributesOutput, UpdateContactAttributesOutputError>) -> Void)
    {
        let urlPath = "/contact/attributes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateContactAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateContactAttributesInput, UpdateContactAttributesOutput, UpdateContactAttributesOutputError>(id: "updateContactAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateContactAttributesInput, UpdateContactAttributesOutput, UpdateContactAttributesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactAttributesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the specified contact flow.</p>
    ///          <p>You can also create and update contact flows using the <a href="https://docs.aws.amazon.com/connect/latest/adminguide/flow-language.html">Amazon Connect
    ///    Flow language</a>.</p>
    public func updateContactFlowContent(input: UpdateContactFlowContentInput, completion: @escaping (SdkResult<UpdateContactFlowContentOutput, UpdateContactFlowContentOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let contactFlowId = input.contactFlowId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component contactFlowId unexpectedly nil"))))
            return
        }
        let urlPath = "/contact-flows/\(instanceId)/\(contactFlowId)/content"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateContactFlowContent")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateContactFlowContentInput, UpdateContactFlowContentOutput, UpdateContactFlowContentOutputError>(id: "updateContactFlowContent")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactFlowContentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactFlowContentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateContactFlowContentInput, UpdateContactFlowContentOutput, UpdateContactFlowContentOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactFlowContentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>The name of the contact flow.</p>
    ///          <p>You can also create and update contact flows using the <a href="https://docs.aws.amazon.com/connect/latest/adminguide/flow-language.html">Amazon Connect
    ///    Flow language</a>.</p>
    public func updateContactFlowName(input: UpdateContactFlowNameInput, completion: @escaping (SdkResult<UpdateContactFlowNameOutput, UpdateContactFlowNameOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let contactFlowId = input.contactFlowId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component contactFlowId unexpectedly nil"))))
            return
        }
        let urlPath = "/contact-flows/\(instanceId)/\(contactFlowId)/name"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateContactFlowName")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateContactFlowNameInput, UpdateContactFlowNameOutput, UpdateContactFlowNameOutputError>(id: "updateContactFlowName")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactFlowNameInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactFlowNameInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateContactFlowNameInput, UpdateContactFlowNameOutput, UpdateContactFlowNameOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactFlowNameInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates the value for the specified attribute type.</p>
    public func updateInstanceAttribute(input: UpdateInstanceAttributeInput, completion: @escaping (SdkResult<UpdateInstanceAttributeOutput, UpdateInstanceAttributeOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let attributeType = input.attributeType else {
            completion(.failure(.client(ClientError.serializationFailed("uri component attributeType unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/attribute/\(attributeType.rawValue)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateInstanceAttribute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateInstanceAttributeInput, UpdateInstanceAttributeOutput, UpdateInstanceAttributeOutputError>(id: "updateInstanceAttribute")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateInstanceAttributeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateInstanceAttributeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateInstanceAttributeInput, UpdateInstanceAttributeOutput, UpdateInstanceAttributeOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateInstanceAttributeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates an existing configuration for a resource type. This API is idempotent.</p>
    public func updateInstanceStorageConfig(input: UpdateInstanceStorageConfigInput, completion: @escaping (SdkResult<UpdateInstanceStorageConfigOutput, UpdateInstanceStorageConfigOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let associationId = input.associationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component associationId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/storage-config/\(associationId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateInstanceStorageConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateInstanceStorageConfigInput, UpdateInstanceStorageConfigOutput, UpdateInstanceStorageConfigOutputError>(id: "updateInstanceStorageConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateInstanceStorageConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateInstanceStorageConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateInstanceStorageConfigInput, UpdateInstanceStorageConfigOutput, UpdateInstanceStorageConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateInstanceStorageConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates the hours of operation for the specified queue.</p>
    public func updateQueueHoursOfOperation(input: UpdateQueueHoursOfOperationInput, completion: @escaping (SdkResult<UpdateQueueHoursOfOperationOutput, UpdateQueueHoursOfOperationOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)/hours-of-operation"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateQueueHoursOfOperation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateQueueHoursOfOperationInput, UpdateQueueHoursOfOperationOutput, UpdateQueueHoursOfOperationOutputError>(id: "updateQueueHoursOfOperation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueHoursOfOperationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueHoursOfOperationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateQueueHoursOfOperationInput, UpdateQueueHoursOfOperationOutput, UpdateQueueHoursOfOperationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueHoursOfOperationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates the maximum number of contacts allowed in a queue before it is considered
    ///    full.</p>
    public func updateQueueMaxContacts(input: UpdateQueueMaxContactsInput, completion: @escaping (SdkResult<UpdateQueueMaxContactsOutput, UpdateQueueMaxContactsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)/max-contacts"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateQueueMaxContacts")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateQueueMaxContactsInput, UpdateQueueMaxContactsOutput, UpdateQueueMaxContactsOutputError>(id: "updateQueueMaxContacts")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueMaxContactsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueMaxContactsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateQueueMaxContactsInput, UpdateQueueMaxContactsOutput, UpdateQueueMaxContactsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueMaxContactsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates the name and description of a queue. At least <code>Name</code> or <code>Description</code> must be provided.</p>
    public func updateQueueName(input: UpdateQueueNameInput, completion: @escaping (SdkResult<UpdateQueueNameOutput, UpdateQueueNameOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)/name"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateQueueName")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateQueueNameInput, UpdateQueueNameOutput, UpdateQueueNameOutputError>(id: "updateQueueName")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueNameInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueNameInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateQueueNameInput, UpdateQueueNameOutput, UpdateQueueNameOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueNameInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates the outbound caller ID name, number, and outbound whisper flow for a specified
    ///    queue.</p>
    public func updateQueueOutboundCallerConfig(input: UpdateQueueOutboundCallerConfigInput, completion: @escaping (SdkResult<UpdateQueueOutboundCallerConfigOutput, UpdateQueueOutboundCallerConfigOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)/outbound-caller-config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateQueueOutboundCallerConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateQueueOutboundCallerConfigInput, UpdateQueueOutboundCallerConfigOutput, UpdateQueueOutboundCallerConfigOutputError>(id: "updateQueueOutboundCallerConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueOutboundCallerConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueOutboundCallerConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateQueueOutboundCallerConfigInput, UpdateQueueOutboundCallerConfigOutput, UpdateQueueOutboundCallerConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueOutboundCallerConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates the status of the queue.</p>
    public func updateQueueStatus(input: UpdateQueueStatusInput, completion: @escaping (SdkResult<UpdateQueueStatusOutput, UpdateQueueStatusOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)/status"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateQueueStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateQueueStatusInput, UpdateQueueStatusOutput, UpdateQueueStatusOutputError>(id: "updateQueueStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateQueueStatusInput, UpdateQueueStatusOutput, UpdateQueueStatusOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueStatusInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates the configuration settings for the specified quick connect.</p>
    public func updateQuickConnectConfig(input: UpdateQuickConnectConfigInput, completion: @escaping (SdkResult<UpdateQuickConnectConfigOutput, UpdateQuickConnectConfigOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let quickConnectId = input.quickConnectId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component quickConnectId unexpectedly nil"))))
            return
        }
        let urlPath = "/quick-connects/\(instanceId)/\(quickConnectId)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateQuickConnectConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateQuickConnectConfigInput, UpdateQuickConnectConfigOutput, UpdateQuickConnectConfigOutputError>(id: "updateQuickConnectConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateQuickConnectConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateQuickConnectConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateQuickConnectConfigInput, UpdateQuickConnectConfigOutput, UpdateQuickConnectConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateQuickConnectConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates the name and description of a quick connect. The request accepts the following data in JSON format. At least <code>Name</code> or <code>Description</code> must be provided.</p>
    public func updateQuickConnectName(input: UpdateQuickConnectNameInput, completion: @escaping (SdkResult<UpdateQuickConnectNameOutput, UpdateQuickConnectNameOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let quickConnectId = input.quickConnectId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component quickConnectId unexpectedly nil"))))
            return
        }
        let urlPath = "/quick-connects/\(instanceId)/\(quickConnectId)/name"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateQuickConnectName")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateQuickConnectNameInput, UpdateQuickConnectNameOutput, UpdateQuickConnectNameOutputError>(id: "updateQuickConnectName")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateQuickConnectNameInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateQuickConnectNameInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateQuickConnectNameInput, UpdateQuickConnectNameOutput, UpdateQuickConnectNameOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateQuickConnectNameInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the channels that agents can handle in the Contact Control Panel (CCP) for a routing
    ///    profile.</p>
    public func updateRoutingProfileConcurrency(input: UpdateRoutingProfileConcurrencyInput, completion: @escaping (SdkResult<UpdateRoutingProfileConcurrencyOutput, UpdateRoutingProfileConcurrencyOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let routingProfileId = input.routingProfileId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routingProfileId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)/\(routingProfileId)/concurrency"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateRoutingProfileConcurrency")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateRoutingProfileConcurrencyInput, UpdateRoutingProfileConcurrencyOutput, UpdateRoutingProfileConcurrencyOutputError>(id: "updateRoutingProfileConcurrency")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileConcurrencyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileConcurrencyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateRoutingProfileConcurrencyInput, UpdateRoutingProfileConcurrencyOutput, UpdateRoutingProfileConcurrencyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileConcurrencyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the default outbound queue of a routing profile.</p>
    public func updateRoutingProfileDefaultOutboundQueue(input: UpdateRoutingProfileDefaultOutboundQueueInput, completion: @escaping (SdkResult<UpdateRoutingProfileDefaultOutboundQueueOutput, UpdateRoutingProfileDefaultOutboundQueueOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let routingProfileId = input.routingProfileId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routingProfileId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)/\(routingProfileId)/default-outbound-queue"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateRoutingProfileDefaultOutboundQueue")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateRoutingProfileDefaultOutboundQueueInput, UpdateRoutingProfileDefaultOutboundQueueOutput, UpdateRoutingProfileDefaultOutboundQueueOutputError>(id: "updateRoutingProfileDefaultOutboundQueue")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileDefaultOutboundQueueInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileDefaultOutboundQueueInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateRoutingProfileDefaultOutboundQueueInput, UpdateRoutingProfileDefaultOutboundQueueOutput, UpdateRoutingProfileDefaultOutboundQueueOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileDefaultOutboundQueueInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the name and description of a routing profile. The request accepts the following data in JSON format.
    ///    At least <code>Name</code> or <code>Description</code> must be provided.</p>
    public func updateRoutingProfileName(input: UpdateRoutingProfileNameInput, completion: @escaping (SdkResult<UpdateRoutingProfileNameOutput, UpdateRoutingProfileNameOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let routingProfileId = input.routingProfileId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routingProfileId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)/\(routingProfileId)/name"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateRoutingProfileName")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateRoutingProfileNameInput, UpdateRoutingProfileNameOutput, UpdateRoutingProfileNameOutputError>(id: "updateRoutingProfileName")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileNameInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileNameInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateRoutingProfileNameInput, UpdateRoutingProfileNameOutput, UpdateRoutingProfileNameOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileNameInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the properties associated with a set of queues for a routing profile.</p>
    public func updateRoutingProfileQueues(input: UpdateRoutingProfileQueuesInput, completion: @escaping (SdkResult<UpdateRoutingProfileQueuesOutput, UpdateRoutingProfileQueuesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let routingProfileId = input.routingProfileId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routingProfileId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)/\(routingProfileId)/queues"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateRoutingProfileQueues")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateRoutingProfileQueuesInput, UpdateRoutingProfileQueuesOutput, UpdateRoutingProfileQueuesOutputError>(id: "updateRoutingProfileQueues")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileQueuesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileQueuesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateRoutingProfileQueuesInput, UpdateRoutingProfileQueuesOutput, UpdateRoutingProfileQueuesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileQueuesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Assigns the specified hierarchy group to the specified user.</p>
    public func updateUserHierarchy(input: UpdateUserHierarchyInput, completion: @escaping (SdkResult<UpdateUserHierarchyOutput, UpdateUserHierarchyOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/users/\(instanceId)/\(userId)/hierarchy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUserHierarchy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUserHierarchyInput, UpdateUserHierarchyOutput, UpdateUserHierarchyOutputError>(id: "updateUserHierarchy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateUserHierarchyInput, UpdateUserHierarchyOutput, UpdateUserHierarchyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the name of the user hierarchy group. </p>
    public func updateUserHierarchyGroupName(input: UpdateUserHierarchyGroupNameInput, completion: @escaping (SdkResult<UpdateUserHierarchyGroupNameOutput, UpdateUserHierarchyGroupNameOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let hierarchyGroupId = input.hierarchyGroupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hierarchyGroupId unexpectedly nil"))))
            return
        }
        let urlPath = "/user-hierarchy-groups/\(instanceId)/\(hierarchyGroupId)/name"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUserHierarchyGroupName")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUserHierarchyGroupNameInput, UpdateUserHierarchyGroupNameOutput, UpdateUserHierarchyGroupNameOutputError>(id: "updateUserHierarchyGroupName")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyGroupNameInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyGroupNameInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateUserHierarchyGroupNameInput, UpdateUserHierarchyGroupNameOutput, UpdateUserHierarchyGroupNameOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyGroupNameInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the user hierarchy structure: add, remove, and rename user hierarchy levels.</p>
    public func updateUserHierarchyStructure(input: UpdateUserHierarchyStructureInput, completion: @escaping (SdkResult<UpdateUserHierarchyStructureOutput, UpdateUserHierarchyStructureOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/user-hierarchy-structure/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUserHierarchyStructure")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUserHierarchyStructureInput, UpdateUserHierarchyStructureOutput, UpdateUserHierarchyStructureOutputError>(id: "updateUserHierarchyStructure")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyStructureInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyStructureInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateUserHierarchyStructureInput, UpdateUserHierarchyStructureOutput, UpdateUserHierarchyStructureOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyStructureInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the identity information for the specified user.</p>
    ///          <important>
    ///             <p>We strongly recommend limiting who has the ability to invoke
    ///      <code>UpdateUserIdentityInfo</code>. Someone with that ability can change the login credentials
    ///     of other users by changing their email address. This poses a security risk to your organization.
    ///     They can change the email address of a user to the attacker's email address, and then reset the
    ///     password through email. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-best-practices.html">Best Practices for
    ///      Security Profiles</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    ///          </important>
    public func updateUserIdentityInfo(input: UpdateUserIdentityInfoInput, completion: @escaping (SdkResult<UpdateUserIdentityInfoOutput, UpdateUserIdentityInfoOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/users/\(instanceId)/\(userId)/identity-info"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUserIdentityInfo")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUserIdentityInfoInput, UpdateUserIdentityInfoOutput, UpdateUserIdentityInfoOutputError>(id: "updateUserIdentityInfo")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserIdentityInfoInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserIdentityInfoInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateUserIdentityInfoInput, UpdateUserIdentityInfoOutput, UpdateUserIdentityInfoOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserIdentityInfoInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the phone configuration settings for the specified user.</p>
    public func updateUserPhoneConfig(input: UpdateUserPhoneConfigInput, completion: @escaping (SdkResult<UpdateUserPhoneConfigOutput, UpdateUserPhoneConfigOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/users/\(instanceId)/\(userId)/phone-config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUserPhoneConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUserPhoneConfigInput, UpdateUserPhoneConfigOutput, UpdateUserPhoneConfigOutputError>(id: "updateUserPhoneConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserPhoneConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserPhoneConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateUserPhoneConfigInput, UpdateUserPhoneConfigOutput, UpdateUserPhoneConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserPhoneConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Assigns the specified routing profile to the specified user.</p>
    public func updateUserRoutingProfile(input: UpdateUserRoutingProfileInput, completion: @escaping (SdkResult<UpdateUserRoutingProfileOutput, UpdateUserRoutingProfileOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/users/\(instanceId)/\(userId)/routing-profile"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUserRoutingProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUserRoutingProfileInput, UpdateUserRoutingProfileOutput, UpdateUserRoutingProfileOutputError>(id: "updateUserRoutingProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserRoutingProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserRoutingProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateUserRoutingProfileInput, UpdateUserRoutingProfileOutput, UpdateUserRoutingProfileOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserRoutingProfileInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Assigns the specified security profiles to the specified user.</p>
    public func updateUserSecurityProfiles(input: UpdateUserSecurityProfilesInput, completion: @escaping (SdkResult<UpdateUserSecurityProfilesOutput, UpdateUserSecurityProfilesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/users/\(instanceId)/\(userId)/security-profiles"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUserSecurityProfiles")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUserSecurityProfilesInput, UpdateUserSecurityProfilesOutput, UpdateUserSecurityProfilesOutputError>(id: "updateUserSecurityProfiles")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserSecurityProfilesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserSecurityProfilesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateUserSecurityProfilesInput, UpdateUserSecurityProfilesOutput, UpdateUserSecurityProfilesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserSecurityProfilesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
