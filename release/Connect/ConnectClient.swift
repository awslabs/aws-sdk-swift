// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation
import Logging

public class ConnectClient {
    let client: SdkHttpClient
    let config: AWSClientConfiguration
    let serviceName = "Connect"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: AWSClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public convenience init(region: String? = nil) throws {
        let unwrappedRegion = region ?? "us-east-1"
        let config = try ConnectClientConfiguration(region: unwrappedRegion)
        self.init(config: config)
    }

    deinit {
        client.close()
    }

    public class ConnectClientConfiguration: AWSClientConfiguration {

        public var clientLogMode: ClientLogMode
        public var decoder: ResponseDecoder?
        public var encoder: RequestEncoder?
        public var httpClientConfiguration: HttpClientConfiguration
        public var httpClientEngine: HttpClientEngine
        public var idempotencyTokenGenerator: IdempotencyTokenGenerator
        public var logger: LogAgent
        public var retrier: Retrier

        public var credentialsProvider: AWSCredentialsProvider
        public var endpointResolver: EndpointResolver
        public var region: String
        public var signingRegion: String

        public init(
            credentialsProvider: AWSCredentialsProvider? = nil,
            endpointResolver: EndpointResolver? = nil,
            region: String,
            signingRegion: String? = nil,
            runtimeConfig: SDKRuntimeConfiguration
        ) throws {
            self.region = region
            self.signingRegion = signingRegion ?? region
            self.endpointResolver = endpointResolver ?? DefaultEndpointResolver()
            if let credProvider = credentialsProvider {
                self.credentialsProvider = credProvider
            } else {
                self.credentialsProvider = try AWSCredentialsProvider.fromChain()
            }
            self.clientLogMode = runtimeConfig.clientLogMode
            self.decoder = runtimeConfig.decoder
            self.encoder = runtimeConfig.encoder
            self.httpClientConfiguration = runtimeConfig.httpClientConfiguration
            self.httpClientEngine = runtimeConfig.httpClientEngine
            self.idempotencyTokenGenerator = runtimeConfig.idempotencyTokenGenerator
            self.logger = runtimeConfig.logger
            self.retrier = runtimeConfig.retrier
        }

        public convenience init(
            credentialsProvider: AWSCredentialsProvider? = nil,
            endpointResolver: EndpointResolver? = nil,
            region: String,
            signingRegion: String? = nil
        ) throws {
            let defaultRuntimeConfig = try DefaultSDKRuntimeConfiguration("ConnectClient")
            try self.init(credentialsProvider: credentialsProvider, endpointResolver: endpointResolver, region: region, signingRegion: signingRegion, runtimeConfig: defaultRuntimeConfig)
        }
    }
}

public struct ConnectClientLogHandlerFactory: SDKLogHandlerFactory {
    public var label = "ConnectClient"
    let logLevel: SDKLogLevel
    public func construct(label: String) -> LogHandler {
        var handler = StreamLogHandler.standardOutput(label: label)
        handler.logLevel = logLevel.toLoggerType()
        return handler
    }
    public init(logLevel: SDKLogLevel) {
        self.logLevel = logLevel
    }
}

extension ConnectClient: ConnectClientProtocol {
    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Associates an approved origin to an Amazon Connect instance.</p>
    public func associateApprovedOrigin(input: AssociateApprovedOriginInput, completion: @escaping (SdkResult<AssociateApprovedOriginOutputResponse, AssociateApprovedOriginOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/approved-origin"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateApprovedOrigin")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateApprovedOriginInput, AssociateApprovedOriginOutputResponse, AssociateApprovedOriginOutputError>(id: "associateApprovedOrigin")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateApprovedOriginInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateApprovedOriginInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateApprovedOriginInput, AssociateApprovedOriginOutputResponse, AssociateApprovedOriginOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateApprovedOriginInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Associates a storage resource type for the first time. You can only associate one type of
    ///    storage configuration in a single call. This means, for example, that you can't define an
    ///    instance with multiple S3 buckets for storing chat transcripts.</p>
    ///          <p>This API does not create a resource that doesn't exist. It only associates it to the
    ///    instance. Ensure that the resource being specified in the storage configuration, like an S3
    ///    bucket, exists when being used for association.</p>
    public func associateInstanceStorageConfig(input: AssociateInstanceStorageConfigInput, completion: @escaping (SdkResult<AssociateInstanceStorageConfigOutputResponse, AssociateInstanceStorageConfigOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/storage-config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateInstanceStorageConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateInstanceStorageConfigInput, AssociateInstanceStorageConfigOutputResponse, AssociateInstanceStorageConfigOutputError>(id: "associateInstanceStorageConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateInstanceStorageConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateInstanceStorageConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateInstanceStorageConfigInput, AssociateInstanceStorageConfigOutputResponse, AssociateInstanceStorageConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateInstanceStorageConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Allows the specified Amazon Connect instance to access the specified Lambda function.</p>
    public func associateLambdaFunction(input: AssociateLambdaFunctionInput, completion: @escaping (SdkResult<AssociateLambdaFunctionOutputResponse, AssociateLambdaFunctionOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/lambda-function"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateLambdaFunction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateLambdaFunctionInput, AssociateLambdaFunctionOutputResponse, AssociateLambdaFunctionOutputError>(id: "associateLambdaFunction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateLambdaFunctionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateLambdaFunctionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateLambdaFunctionInput, AssociateLambdaFunctionOutputResponse, AssociateLambdaFunctionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateLambdaFunctionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Allows the specified Amazon Connect instance to access the specified Amazon Lex bot.</p>
    public func associateLexBot(input: AssociateLexBotInput, completion: @escaping (SdkResult<AssociateLexBotOutputResponse, AssociateLexBotOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/lex-bot"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateLexBot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateLexBotInput, AssociateLexBotOutputResponse, AssociateLexBotOutputError>(id: "associateLexBot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateLexBotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateLexBotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateLexBotInput, AssociateLexBotOutputResponse, AssociateLexBotOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateLexBotInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Associates a set of quick connects with a queue.</p>
    public func associateQueueQuickConnects(input: AssociateQueueQuickConnectsInput, completion: @escaping (SdkResult<AssociateQueueQuickConnectsOutputResponse, AssociateQueueQuickConnectsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)/associate-quick-connects"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateQueueQuickConnects")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateQueueQuickConnectsInput, AssociateQueueQuickConnectsOutputResponse, AssociateQueueQuickConnectsOutputError>(id: "associateQueueQuickConnects")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateQueueQuickConnectsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateQueueQuickConnectsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateQueueQuickConnectsInput, AssociateQueueQuickConnectsOutputResponse, AssociateQueueQuickConnectsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateQueueQuickConnectsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Associates a set of queues with a routing profile.</p>
    public func associateRoutingProfileQueues(input: AssociateRoutingProfileQueuesInput, completion: @escaping (SdkResult<AssociateRoutingProfileQueuesOutputResponse, AssociateRoutingProfileQueuesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let routingProfileId = input.routingProfileId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routingProfileId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)/\(routingProfileId)/associate-queues"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateRoutingProfileQueues")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateRoutingProfileQueuesInput, AssociateRoutingProfileQueuesOutputResponse, AssociateRoutingProfileQueuesOutputError>(id: "associateRoutingProfileQueues")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateRoutingProfileQueuesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateRoutingProfileQueuesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateRoutingProfileQueuesInput, AssociateRoutingProfileQueuesOutputResponse, AssociateRoutingProfileQueuesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateRoutingProfileQueuesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Associates a security key to the instance.</p>
    public func associateSecurityKey(input: AssociateSecurityKeyInput, completion: @escaping (SdkResult<AssociateSecurityKeyOutputResponse, AssociateSecurityKeyOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/security-key"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateSecurityKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateSecurityKeyInput, AssociateSecurityKeyOutputResponse, AssociateSecurityKeyOutputError>(id: "associateSecurityKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateSecurityKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateSecurityKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateSecurityKeyInput, AssociateSecurityKeyOutputResponse, AssociateSecurityKeyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateSecurityKeyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a contact flow for the specified Amazon Connect instance.</p>
    ///          <p>You can also create and update contact flows using the <a href="https://docs.aws.amazon.com/connect/latest/adminguide/flow-language.html">Amazon Connect
    ///    Flow language</a>.</p>
    public func createContactFlow(input: CreateContactFlowInput, completion: @escaping (SdkResult<CreateContactFlowOutputResponse, CreateContactFlowOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/contact-flows/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createContactFlow")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateContactFlowInput, CreateContactFlowOutputResponse, CreateContactFlowOutputError>(id: "createContactFlow")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateContactFlowInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateContactFlowInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateContactFlowInput, CreateContactFlowOutputResponse, CreateContactFlowOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateContactFlowInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Initiates an Amazon Connect instance with all the supported channels enabled. It does not attach any
    ///    storage, such as Amazon Simple Storage Service (Amazon S3) or Amazon Kinesis. It also does not
    ///    allow for any configurations on features, such as Contact Lens for Amazon Connect. </p>
    ///          <p>Amazon Connect enforces a limit on the total number of instances that you can create or delete in 30 days.
    /// If you exceed this limit, you will get an error message indicating there has been an excessive number of attempts at creating or deleting instances.
    /// You must wait 30 days before you can restart creating and deleting instances in your account.</p>
    public func createInstance(input: CreateInstanceInput, completion: @escaping (SdkResult<CreateInstanceOutputResponse, CreateInstanceOutputError>) -> Void)
    {
        let urlPath = "/instance"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createInstance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateInstanceInput, CreateInstanceOutputResponse, CreateInstanceOutputError>(id: "createInstance")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateInstanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateInstanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateInstanceInput, CreateInstanceOutputResponse, CreateInstanceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateInstanceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create an AppIntegration association with an Amazon Connect instance.</p>
    public func createIntegrationAssociation(input: CreateIntegrationAssociationInput, completion: @escaping (SdkResult<CreateIntegrationAssociationOutputResponse, CreateIntegrationAssociationOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/integration-associations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createIntegrationAssociation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateIntegrationAssociationInput, CreateIntegrationAssociationOutputResponse, CreateIntegrationAssociationOutputError>(id: "createIntegrationAssociation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateIntegrationAssociationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateIntegrationAssociationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateIntegrationAssociationInput, CreateIntegrationAssociationOutputResponse, CreateIntegrationAssociationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateIntegrationAssociationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Creates a new queue for the specified Amazon Connect instance.</p>
    public func createQueue(input: CreateQueueInput, completion: @escaping (SdkResult<CreateQueueOutputResponse, CreateQueueOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createQueue")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateQueueInput, CreateQueueOutputResponse, CreateQueueOutputError>(id: "createQueue")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateQueueInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateQueueInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateQueueInput, CreateQueueOutputResponse, CreateQueueOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateQueueInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Creates a quick connect for the specified Amazon Connect instance.</p>
    public func createQuickConnect(input: CreateQuickConnectInput, completion: @escaping (SdkResult<CreateQuickConnectOutputResponse, CreateQuickConnectOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/quick-connects/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createQuickConnect")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateQuickConnectInput, CreateQuickConnectOutputResponse, CreateQuickConnectOutputError>(id: "createQuickConnect")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateQuickConnectInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateQuickConnectInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateQuickConnectInput, CreateQuickConnectOutputResponse, CreateQuickConnectOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateQuickConnectInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new routing profile.</p>
    public func createRoutingProfile(input: CreateRoutingProfileInput, completion: @escaping (SdkResult<CreateRoutingProfileOutputResponse, CreateRoutingProfileOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createRoutingProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateRoutingProfileInput, CreateRoutingProfileOutputResponse, CreateRoutingProfileOutputError>(id: "createRoutingProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateRoutingProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateRoutingProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateRoutingProfileInput, CreateRoutingProfileOutputResponse, CreateRoutingProfileOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateRoutingProfileInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a use case for an AppIntegration association.</p>
    public func createUseCase(input: CreateUseCaseInput, completion: @escaping (SdkResult<CreateUseCaseOutputResponse, CreateUseCaseOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let integrationAssociationId = input.integrationAssociationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component integrationAssociationId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/integration-associations/\(integrationAssociationId)/use-cases"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createUseCase")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateUseCaseInput, CreateUseCaseOutputResponse, CreateUseCaseOutputError>(id: "createUseCase")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateUseCaseInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateUseCaseInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateUseCaseInput, CreateUseCaseOutputResponse, CreateUseCaseOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateUseCaseInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a user account for the specified Amazon Connect instance.</p>
    ///          <p>For information about how to create user accounts using the Amazon Connect console, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/user-management.html">Add Users</a> in
    ///    the <i>Amazon Connect Administrator Guide</i>.</p>
    public func createUser(input: CreateUserInput, completion: @escaping (SdkResult<CreateUserOutputResponse, CreateUserOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/users/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createUser")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateUserInput, CreateUserOutputResponse, CreateUserOutputError>(id: "createUser")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateUserInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateUserInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateUserInput, CreateUserOutputResponse, CreateUserOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateUserInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new user hierarchy group.</p>
    public func createUserHierarchyGroup(input: CreateUserHierarchyGroupInput, completion: @escaping (SdkResult<CreateUserHierarchyGroupOutputResponse, CreateUserHierarchyGroupOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/user-hierarchy-groups/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createUserHierarchyGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateUserHierarchyGroupInput, CreateUserHierarchyGroupOutputResponse, CreateUserHierarchyGroupOutputError>(id: "createUserHierarchyGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateUserHierarchyGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateUserHierarchyGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateUserHierarchyGroupInput, CreateUserHierarchyGroupOutputResponse, CreateUserHierarchyGroupOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateUserHierarchyGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Deletes the Amazon Connect instance.</p>
    ///          <p>Amazon Connect enforces a limit on the total number of instances that you can create or delete in 30 days.
    /// If you exceed this limit, you will get an error message indicating there has been an excessive number of attempts at creating or deleting instances.
    /// You must wait 30 days before you can restart creating and deleting instances in your account.</p>
    public func deleteInstance(input: DeleteInstanceInput, completion: @escaping (SdkResult<DeleteInstanceOutputResponse, DeleteInstanceOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteInstance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteInstanceInput, DeleteInstanceOutputResponse, DeleteInstanceOutputError>(id: "deleteInstance")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteInstanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteInstanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteInstanceInput, DeleteInstanceOutputResponse, DeleteInstanceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an AppIntegration association from an Amazon Connect instance. The association must not have
    ///    any use cases associated with it.</p>
    public func deleteIntegrationAssociation(input: DeleteIntegrationAssociationInput, completion: @escaping (SdkResult<DeleteIntegrationAssociationOutputResponse, DeleteIntegrationAssociationOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let integrationAssociationId = input.integrationAssociationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component integrationAssociationId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/integration-associations/\(integrationAssociationId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteIntegrationAssociation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteIntegrationAssociationInput, DeleteIntegrationAssociationOutputResponse, DeleteIntegrationAssociationOutputError>(id: "deleteIntegrationAssociation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntegrationAssociationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntegrationAssociationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteIntegrationAssociationInput, DeleteIntegrationAssociationOutputResponse, DeleteIntegrationAssociationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Deletes a quick connect.</p>
    public func deleteQuickConnect(input: DeleteQuickConnectInput, completion: @escaping (SdkResult<DeleteQuickConnectOutputResponse, DeleteQuickConnectOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let quickConnectId = input.quickConnectId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component quickConnectId unexpectedly nil"))))
            return
        }
        let urlPath = "/quick-connects/\(instanceId)/\(quickConnectId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteQuickConnect")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteQuickConnectInput, DeleteQuickConnectOutputResponse, DeleteQuickConnectOutputError>(id: "deleteQuickConnect")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteQuickConnectInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteQuickConnectInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteQuickConnectInput, DeleteQuickConnectOutputResponse, DeleteQuickConnectOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a use case from an AppIntegration association.</p>
    public func deleteUseCase(input: DeleteUseCaseInput, completion: @escaping (SdkResult<DeleteUseCaseOutputResponse, DeleteUseCaseOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let integrationAssociationId = input.integrationAssociationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component integrationAssociationId unexpectedly nil"))))
            return
        }
        guard let useCaseId = input.useCaseId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component useCaseId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/integration-associations/\(integrationAssociationId)/use-cases/\(useCaseId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteUseCase")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteUseCaseInput, DeleteUseCaseOutputResponse, DeleteUseCaseOutputError>(id: "deleteUseCase")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteUseCaseInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteUseCaseInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteUseCaseInput, DeleteUseCaseOutputResponse, DeleteUseCaseOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a user account from the specified Amazon Connect instance.</p>
    ///          <p>For information about what happens to a user's data when their account is deleted, see
    ///     <a href="https://docs.aws.amazon.com/connect/latest/adminguide/delete-users.html">Delete Users from
    ///     Your Amazon Connect Instance</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func deleteUser(input: DeleteUserInput, completion: @escaping (SdkResult<DeleteUserOutputResponse, DeleteUserOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/users/\(instanceId)/\(userId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteUser")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteUserInput, DeleteUserOutputResponse, DeleteUserOutputError>(id: "deleteUser")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteUserInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteUserInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteUserInput, DeleteUserOutputResponse, DeleteUserOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an existing user hierarchy group. It must not be associated with any agents or have
    ///    any active child groups.</p>
    public func deleteUserHierarchyGroup(input: DeleteUserHierarchyGroupInput, completion: @escaping (SdkResult<DeleteUserHierarchyGroupOutputResponse, DeleteUserHierarchyGroupOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let hierarchyGroupId = input.hierarchyGroupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hierarchyGroupId unexpectedly nil"))))
            return
        }
        let urlPath = "/user-hierarchy-groups/\(instanceId)/\(hierarchyGroupId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteUserHierarchyGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteUserHierarchyGroupInput, DeleteUserHierarchyGroupOutputResponse, DeleteUserHierarchyGroupOutputError>(id: "deleteUserHierarchyGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteUserHierarchyGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteUserHierarchyGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteUserHierarchyGroupInput, DeleteUserHierarchyGroupOutputResponse, DeleteUserHierarchyGroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the specified contact flow.</p>
    ///          <p>You can also create and update contact flows using the <a href="https://docs.aws.amazon.com/connect/latest/adminguide/flow-language.html">Amazon Connect
    ///    Flow language</a>.</p>
    public func describeContactFlow(input: DescribeContactFlowInput, completion: @escaping (SdkResult<DescribeContactFlowOutputResponse, DescribeContactFlowOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let contactFlowId = input.contactFlowId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component contactFlowId unexpectedly nil"))))
            return
        }
        let urlPath = "/contact-flows/\(instanceId)/\(contactFlowId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeContactFlow")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeContactFlowInput, DescribeContactFlowOutputResponse, DescribeContactFlowOutputError>(id: "describeContactFlow")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeContactFlowInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeContactFlowInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeContactFlowInput, DescribeContactFlowOutputResponse, DescribeContactFlowOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Describes the hours of operation.</p>
    public func describeHoursOfOperation(input: DescribeHoursOfOperationInput, completion: @escaping (SdkResult<DescribeHoursOfOperationOutputResponse, DescribeHoursOfOperationOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let hoursOfOperationId = input.hoursOfOperationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hoursOfOperationId unexpectedly nil"))))
            return
        }
        let urlPath = "/hours-of-operations/\(instanceId)/\(hoursOfOperationId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeHoursOfOperation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeHoursOfOperationInput, DescribeHoursOfOperationOutputResponse, DescribeHoursOfOperationOutputError>(id: "describeHoursOfOperation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeHoursOfOperationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeHoursOfOperationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeHoursOfOperationInput, DescribeHoursOfOperationOutputResponse, DescribeHoursOfOperationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Returns the current state of the specified instance identifier. It tracks the instance while
    ///    it is being created and returns an error status, if applicable. </p>
    ///          <p>If an instance is not created successfully, the instance status reason field returns details
    ///    relevant to the reason. The instance in a failed state is returned only for 24 hours after the
    ///    CreateInstance API was invoked.</p>
    public func describeInstance(input: DescribeInstanceInput, completion: @escaping (SdkResult<DescribeInstanceOutputResponse, DescribeInstanceOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeInstance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeInstanceInput, DescribeInstanceOutputResponse, DescribeInstanceOutputError>(id: "describeInstance")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeInstanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeInstanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeInstanceInput, DescribeInstanceOutputResponse, DescribeInstanceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Describes the specified instance attribute.</p>
    public func describeInstanceAttribute(input: DescribeInstanceAttributeInput, completion: @escaping (SdkResult<DescribeInstanceAttributeOutputResponse, DescribeInstanceAttributeOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let attributeType = input.attributeType else {
            completion(.failure(.client(ClientError.serializationFailed("uri component attributeType unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/attribute/\(attributeType.rawValue)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeInstanceAttribute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeInstanceAttributeInput, DescribeInstanceAttributeOutputResponse, DescribeInstanceAttributeOutputError>(id: "describeInstanceAttribute")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeInstanceAttributeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeInstanceAttributeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeInstanceAttributeInput, DescribeInstanceAttributeOutputResponse, DescribeInstanceAttributeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Retrieves the current storage configurations for the specified resource type, association
    ///    ID, and instance ID.</p>
    public func describeInstanceStorageConfig(input: DescribeInstanceStorageConfigInput, completion: @escaping (SdkResult<DescribeInstanceStorageConfigOutputResponse, DescribeInstanceStorageConfigOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let associationId = input.associationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component associationId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/storage-config/\(associationId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeInstanceStorageConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeInstanceStorageConfigInput, DescribeInstanceStorageConfigOutputResponse, DescribeInstanceStorageConfigOutputError>(id: "describeInstanceStorageConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeInstanceStorageConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeInstanceStorageConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeInstanceStorageConfigInput, DescribeInstanceStorageConfigOutputResponse, DescribeInstanceStorageConfigOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Describes the specified queue.</p>
    public func describeQueue(input: DescribeQueueInput, completion: @escaping (SdkResult<DescribeQueueOutputResponse, DescribeQueueOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeQueue")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeQueueInput, DescribeQueueOutputResponse, DescribeQueueOutputError>(id: "describeQueue")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeQueueInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeQueueInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeQueueInput, DescribeQueueOutputResponse, DescribeQueueOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Describes the quick connect.</p>
    public func describeQuickConnect(input: DescribeQuickConnectInput, completion: @escaping (SdkResult<DescribeQuickConnectOutputResponse, DescribeQuickConnectOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let quickConnectId = input.quickConnectId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component quickConnectId unexpectedly nil"))))
            return
        }
        let urlPath = "/quick-connects/\(instanceId)/\(quickConnectId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeQuickConnect")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeQuickConnectInput, DescribeQuickConnectOutputResponse, DescribeQuickConnectOutputError>(id: "describeQuickConnect")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeQuickConnectInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeQuickConnectInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeQuickConnectInput, DescribeQuickConnectOutputResponse, DescribeQuickConnectOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the specified routing profile.</p>
    public func describeRoutingProfile(input: DescribeRoutingProfileInput, completion: @escaping (SdkResult<DescribeRoutingProfileOutputResponse, DescribeRoutingProfileOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let routingProfileId = input.routingProfileId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routingProfileId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)/\(routingProfileId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeRoutingProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeRoutingProfileInput, DescribeRoutingProfileOutputResponse, DescribeRoutingProfileOutputError>(id: "describeRoutingProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeRoutingProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeRoutingProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeRoutingProfileInput, DescribeRoutingProfileOutputResponse, DescribeRoutingProfileOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the specified user account. You can find the instance ID in the console (its the
    ///    final part of the ARN). The console does not display the user IDs. Instead, list the users and
    ///    note the IDs provided in the output.</p>
    public func describeUser(input: DescribeUserInput, completion: @escaping (SdkResult<DescribeUserOutputResponse, DescribeUserOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/users/\(instanceId)/\(userId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeUser")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeUserInput, DescribeUserOutputResponse, DescribeUserOutputError>(id: "describeUser")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeUserInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeUserInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeUserInput, DescribeUserOutputResponse, DescribeUserOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the specified hierarchy group.</p>
    public func describeUserHierarchyGroup(input: DescribeUserHierarchyGroupInput, completion: @escaping (SdkResult<DescribeUserHierarchyGroupOutputResponse, DescribeUserHierarchyGroupOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let hierarchyGroupId = input.hierarchyGroupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hierarchyGroupId unexpectedly nil"))))
            return
        }
        let urlPath = "/user-hierarchy-groups/\(instanceId)/\(hierarchyGroupId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeUserHierarchyGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeUserHierarchyGroupInput, DescribeUserHierarchyGroupOutputResponse, DescribeUserHierarchyGroupOutputError>(id: "describeUserHierarchyGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeUserHierarchyGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeUserHierarchyGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeUserHierarchyGroupInput, DescribeUserHierarchyGroupOutputResponse, DescribeUserHierarchyGroupOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the hierarchy structure of the specified Amazon Connect instance.</p>
    public func describeUserHierarchyStructure(input: DescribeUserHierarchyStructureInput, completion: @escaping (SdkResult<DescribeUserHierarchyStructureOutputResponse, DescribeUserHierarchyStructureOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/user-hierarchy-structure/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeUserHierarchyStructure")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeUserHierarchyStructureInput, DescribeUserHierarchyStructureOutputResponse, DescribeUserHierarchyStructureOutputError>(id: "describeUserHierarchyStructure")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeUserHierarchyStructureInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeUserHierarchyStructureInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeUserHierarchyStructureInput, DescribeUserHierarchyStructureOutputResponse, DescribeUserHierarchyStructureOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Revokes access to integrated applications from Amazon Connect.</p>
    public func disassociateApprovedOrigin(input: DisassociateApprovedOriginInput, completion: @escaping (SdkResult<DisassociateApprovedOriginOutputResponse, DisassociateApprovedOriginOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/approved-origin"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateApprovedOrigin")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateApprovedOriginInput, DisassociateApprovedOriginOutputResponse, DisassociateApprovedOriginOutputError>(id: "disassociateApprovedOrigin")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateApprovedOriginInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateApprovedOriginInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateApprovedOriginInput, DisassociateApprovedOriginOutputResponse, DisassociateApprovedOriginOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Removes the storage type configurations for the specified resource type and association
    ///    ID.</p>
    public func disassociateInstanceStorageConfig(input: DisassociateInstanceStorageConfigInput, completion: @escaping (SdkResult<DisassociateInstanceStorageConfigOutputResponse, DisassociateInstanceStorageConfigOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let associationId = input.associationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component associationId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/storage-config/\(associationId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateInstanceStorageConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateInstanceStorageConfigInput, DisassociateInstanceStorageConfigOutputResponse, DisassociateInstanceStorageConfigOutputError>(id: "disassociateInstanceStorageConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateInstanceStorageConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateInstanceStorageConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateInstanceStorageConfigInput, DisassociateInstanceStorageConfigOutputResponse, DisassociateInstanceStorageConfigOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Remove the Lambda function from the dropdown options available in the relevant contact flow
    ///    blocks.</p>
    public func disassociateLambdaFunction(input: DisassociateLambdaFunctionInput, completion: @escaping (SdkResult<DisassociateLambdaFunctionOutputResponse, DisassociateLambdaFunctionOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/lambda-function"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateLambdaFunction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateLambdaFunctionInput, DisassociateLambdaFunctionOutputResponse, DisassociateLambdaFunctionOutputError>(id: "disassociateLambdaFunction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateLambdaFunctionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateLambdaFunctionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateLambdaFunctionInput, DisassociateLambdaFunctionOutputResponse, DisassociateLambdaFunctionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Revokes authorization from the specified instance to access the specified Amazon Lex bot.</p>
    public func disassociateLexBot(input: DisassociateLexBotInput, completion: @escaping (SdkResult<DisassociateLexBotOutputResponse, DisassociateLexBotOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/lex-bot"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateLexBot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateLexBotInput, DisassociateLexBotOutputResponse, DisassociateLexBotOutputError>(id: "disassociateLexBot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateLexBotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateLexBotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateLexBotInput, DisassociateLexBotOutputResponse, DisassociateLexBotOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Disassociates a set of quick connects from a queue.</p>
    public func disassociateQueueQuickConnects(input: DisassociateQueueQuickConnectsInput, completion: @escaping (SdkResult<DisassociateQueueQuickConnectsOutputResponse, DisassociateQueueQuickConnectsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)/disassociate-quick-connects"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateQueueQuickConnects")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateQueueQuickConnectsInput, DisassociateQueueQuickConnectsOutputResponse, DisassociateQueueQuickConnectsOutputError>(id: "disassociateQueueQuickConnects")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateQueueQuickConnectsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateQueueQuickConnectsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateQueueQuickConnectsInput, DisassociateQueueQuickConnectsOutputResponse, DisassociateQueueQuickConnectsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DisassociateQueueQuickConnectsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Disassociates a set of queues from a routing profile.</p>
    public func disassociateRoutingProfileQueues(input: DisassociateRoutingProfileQueuesInput, completion: @escaping (SdkResult<DisassociateRoutingProfileQueuesOutputResponse, DisassociateRoutingProfileQueuesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let routingProfileId = input.routingProfileId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routingProfileId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)/\(routingProfileId)/disassociate-queues"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateRoutingProfileQueues")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateRoutingProfileQueuesInput, DisassociateRoutingProfileQueuesOutputResponse, DisassociateRoutingProfileQueuesOutputError>(id: "disassociateRoutingProfileQueues")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateRoutingProfileQueuesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateRoutingProfileQueuesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateRoutingProfileQueuesInput, DisassociateRoutingProfileQueuesOutputResponse, DisassociateRoutingProfileQueuesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DisassociateRoutingProfileQueuesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Deletes the specified security key.</p>
    public func disassociateSecurityKey(input: DisassociateSecurityKeyInput, completion: @escaping (SdkResult<DisassociateSecurityKeyOutputResponse, DisassociateSecurityKeyOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let associationId = input.associationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component associationId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/security-key/\(associationId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateSecurityKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateSecurityKeyInput, DisassociateSecurityKeyOutputResponse, DisassociateSecurityKeyOutputError>(id: "disassociateSecurityKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateSecurityKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateSecurityKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateSecurityKeyInput, DisassociateSecurityKeyOutputResponse, DisassociateSecurityKeyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the contact attributes for the specified contact.</p>
    public func getContactAttributes(input: GetContactAttributesInput, completion: @escaping (SdkResult<GetContactAttributesOutputResponse, GetContactAttributesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let initialContactId = input.initialContactId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component initialContactId unexpectedly nil"))))
            return
        }
        let urlPath = "/contact/attributes/\(instanceId)/\(initialContactId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getContactAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetContactAttributesInput, GetContactAttributesOutputResponse, GetContactAttributesOutputError>(id: "getContactAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetContactAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetContactAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetContactAttributesInput, GetContactAttributesOutputResponse, GetContactAttributesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the real-time metric data from the specified Amazon Connect instance.</p>
    ///          <p>For a description of each metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html">Real-time Metrics
    ///     Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func getCurrentMetricData(input: GetCurrentMetricDataInput, completion: @escaping (SdkResult<GetCurrentMetricDataOutputResponse, GetCurrentMetricDataOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/metrics/current/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getCurrentMetricData")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetCurrentMetricDataInput, GetCurrentMetricDataOutputResponse, GetCurrentMetricDataOutputError>(id: "getCurrentMetricData")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetCurrentMetricDataInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetCurrentMetricDataInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetCurrentMetricDataInput, GetCurrentMetricDataOutputResponse, GetCurrentMetricDataOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: GetCurrentMetricDataInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a token for federation.</p>
    ///          <note>
    ///             <p>This API doesn't support root users. If you try to invoke GetFederationToken with root
    ///     credentials, an error message similar to the following one appears: </p>
    ///             <p>
    ///                <code>Provided identity: Principal: .... User: .... cannot be used for federation with
    ///      Amazon Connect</code>
    ///             </p>
    ///          </note>
    public func getFederationToken(input: GetFederationTokenInput, completion: @escaping (SdkResult<GetFederationTokenOutputResponse, GetFederationTokenOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/user/federate/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getFederationToken")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetFederationTokenInput, GetFederationTokenOutputResponse, GetFederationTokenOutputError>(id: "getFederationToken")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetFederationTokenInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetFederationTokenInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetFederationTokenInput, GetFederationTokenOutputResponse, GetFederationTokenOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets historical metric data from the specified Amazon Connect instance.</p>
    ///
    ///          <p>For a description of each historical metric, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical Metrics
    ///     Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func getMetricData(input: GetMetricDataInput, completion: @escaping (SdkResult<GetMetricDataOutputResponse, GetMetricDataOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/metrics/historical/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getMetricData")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetMetricDataInput, GetMetricDataOutputResponse, GetMetricDataOutputError>(id: "getMetricData")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetMetricDataInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetMetricDataInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetMetricDataInput, GetMetricDataOutputResponse, GetMetricDataOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: GetMetricDataInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Returns a paginated list of all approved origins associated with the instance.</p>
    public func listApprovedOrigins(input: ListApprovedOriginsInput, completion: @escaping (SdkResult<ListApprovedOriginsOutputResponse, ListApprovedOriginsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/approved-origins"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listApprovedOrigins")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListApprovedOriginsInput, ListApprovedOriginsOutputResponse, ListApprovedOriginsOutputError>(id: "listApprovedOrigins")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListApprovedOriginsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListApprovedOriginsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListApprovedOriginsInput, ListApprovedOriginsOutputResponse, ListApprovedOriginsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides information about the contact flows for the specified Amazon Connect instance.</p>
    ///          <p>You can also create and update contact flows using the <a href="https://docs.aws.amazon.com/connect/latest/adminguide/flow-language.html">Amazon Connect
    ///    Flow language</a>.</p>
    ///          <p>For more information about contact flows, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-contact-flows.html">Contact Flows</a> in the
    ///     <i>Amazon Connect Administrator Guide</i>.</p>
    public func listContactFlows(input: ListContactFlowsInput, completion: @escaping (SdkResult<ListContactFlowsOutputResponse, ListContactFlowsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/contact-flows-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listContactFlows")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListContactFlowsInput, ListContactFlowsOutputResponse, ListContactFlowsOutputError>(id: "listContactFlows")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListContactFlowsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListContactFlowsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListContactFlowsInput, ListContactFlowsOutputResponse, ListContactFlowsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides information about the hours of operation for the specified Amazon Connect instance.</p>
    ///          <p>For more information about hours of operation, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/set-hours-operation.html">Set the Hours of Operation for a
    ///     Queue</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func listHoursOfOperations(input: ListHoursOfOperationsInput, completion: @escaping (SdkResult<ListHoursOfOperationsOutputResponse, ListHoursOfOperationsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/hours-of-operations-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listHoursOfOperations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListHoursOfOperationsInput, ListHoursOfOperationsOutputResponse, ListHoursOfOperationsOutputError>(id: "listHoursOfOperations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListHoursOfOperationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListHoursOfOperationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListHoursOfOperationsInput, ListHoursOfOperationsOutputResponse, ListHoursOfOperationsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Returns a paginated list of all attribute types for the given instance.</p>
    public func listInstanceAttributes(input: ListInstanceAttributesInput, completion: @escaping (SdkResult<ListInstanceAttributesOutputResponse, ListInstanceAttributesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/attributes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listInstanceAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListInstanceAttributesInput, ListInstanceAttributesOutputResponse, ListInstanceAttributesOutputError>(id: "listInstanceAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListInstanceAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListInstanceAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListInstanceAttributesInput, ListInstanceAttributesOutputResponse, ListInstanceAttributesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///
    ///          <p>Returns a paginated list of storage configs for the identified instance and resource
    ///    type.</p>
    public func listInstanceStorageConfigs(input: ListInstanceStorageConfigsInput, completion: @escaping (SdkResult<ListInstanceStorageConfigsOutputResponse, ListInstanceStorageConfigsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/storage-configs"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listInstanceStorageConfigs")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListInstanceStorageConfigsInput, ListInstanceStorageConfigsOutputResponse, ListInstanceStorageConfigsOutputError>(id: "listInstanceStorageConfigs")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListInstanceStorageConfigsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListInstanceStorageConfigsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListInstanceStorageConfigsInput, ListInstanceStorageConfigsOutputResponse, ListInstanceStorageConfigsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Return a list of instances which are in active state, creation-in-progress state, and failed
    ///    state. Instances that aren't successfully created (they are in a failed state) are returned only
    ///    for 24 hours after the CreateInstance API was invoked.</p>
    public func listInstances(input: ListInstancesInput, completion: @escaping (SdkResult<ListInstancesOutputResponse, ListInstancesOutputError>) -> Void)
    {
        let urlPath = "/instance"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listInstances")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListInstancesInput, ListInstancesOutputResponse, ListInstancesOutputError>(id: "listInstances")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListInstancesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListInstancesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListInstancesInput, ListInstancesOutputResponse, ListInstancesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides summary information about the AppIntegration associations for the specified Amazon Connect
    ///    instance.</p>
    public func listIntegrationAssociations(input: ListIntegrationAssociationsInput, completion: @escaping (SdkResult<ListIntegrationAssociationsOutputResponse, ListIntegrationAssociationsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/integration-associations"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listIntegrationAssociations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListIntegrationAssociationsInput, ListIntegrationAssociationsOutputResponse, ListIntegrationAssociationsOutputError>(id: "listIntegrationAssociations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListIntegrationAssociationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListIntegrationAssociationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListIntegrationAssociationsInput, ListIntegrationAssociationsOutputResponse, ListIntegrationAssociationsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Returns a paginated list of all Lambda functions that display in the dropdown options in the
    ///    relevant contact flow blocks.</p>
    public func listLambdaFunctions(input: ListLambdaFunctionsInput, completion: @escaping (SdkResult<ListLambdaFunctionsOutputResponse, ListLambdaFunctionsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/lambda-functions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listLambdaFunctions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListLambdaFunctionsInput, ListLambdaFunctionsOutputResponse, ListLambdaFunctionsOutputError>(id: "listLambdaFunctions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListLambdaFunctionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListLambdaFunctionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListLambdaFunctionsInput, ListLambdaFunctionsOutputResponse, ListLambdaFunctionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Returns a paginated list of all the Amazon Lex bots currently associated with the
    ///    instance.</p>
    public func listLexBots(input: ListLexBotsInput, completion: @escaping (SdkResult<ListLexBotsOutputResponse, ListLexBotsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/lex-bots"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listLexBots")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListLexBotsInput, ListLexBotsOutputResponse, ListLexBotsOutputError>(id: "listLexBots")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListLexBotsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListLexBotsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListLexBotsInput, ListLexBotsOutputResponse, ListLexBotsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides information about the phone numbers for the specified Amazon Connect instance. </p>
    ///          <p>For more information about phone numbers, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-center-phone-number.html">Set Up Phone Numbers for Your
    ///     Contact Center</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func listPhoneNumbers(input: ListPhoneNumbersInput, completion: @escaping (SdkResult<ListPhoneNumbersOutputResponse, ListPhoneNumbersOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/phone-numbers-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPhoneNumbers")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPhoneNumbersInput, ListPhoneNumbersOutputResponse, ListPhoneNumbersOutputError>(id: "listPhoneNumbers")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPhoneNumbersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPhoneNumbersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPhoneNumbersInput, ListPhoneNumbersOutputResponse, ListPhoneNumbersOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides information about the prompts for the specified Amazon Connect instance.</p>
    public func listPrompts(input: ListPromptsInput, completion: @escaping (SdkResult<ListPromptsOutputResponse, ListPromptsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/prompts-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPrompts")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPromptsInput, ListPromptsOutputResponse, ListPromptsOutputError>(id: "listPrompts")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPromptsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPromptsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPromptsInput, ListPromptsOutputResponse, ListPromptsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Lists the quick connects associated with a queue.</p>
    public func listQueueQuickConnects(input: ListQueueQuickConnectsInput, completion: @escaping (SdkResult<ListQueueQuickConnectsOutputResponse, ListQueueQuickConnectsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)/quick-connects"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listQueueQuickConnects")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListQueueQuickConnectsInput, ListQueueQuickConnectsOutputResponse, ListQueueQuickConnectsOutputError>(id: "listQueueQuickConnects")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListQueueQuickConnectsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListQueueQuickConnectsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListQueueQuickConnectsInput, ListQueueQuickConnectsOutputResponse, ListQueueQuickConnectsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides information about the queues for the specified Amazon Connect instance.</p>
    ///          <p>If you do not specify a <code>QueueTypes</code>
    ///    parameter, both standard and agent queues are returned. This might cause an unexpected truncation
    ///    of results if you have more than 1000 agents and you limit the number of results of the API call
    ///    in code.</p>
    ///          <p>For more information about queues, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-queues-standard-and-agent.html">Queues: Standard and
    ///     Agent</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func listQueues(input: ListQueuesInput, completion: @escaping (SdkResult<ListQueuesOutputResponse, ListQueuesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listQueues")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListQueuesInput, ListQueuesOutputResponse, ListQueuesOutputError>(id: "listQueues")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListQueuesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListQueuesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListQueuesInput, ListQueuesOutputResponse, ListQueuesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Provides information about the quick connects for the specified Amazon Connect instance. </p>
    public func listQuickConnects(input: ListQuickConnectsInput, completion: @escaping (SdkResult<ListQuickConnectsOutputResponse, ListQuickConnectsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/quick-connects/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listQuickConnects")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListQuickConnectsInput, ListQuickConnectsOutputResponse, ListQuickConnectsOutputError>(id: "listQuickConnects")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListQuickConnectsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListQuickConnectsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListQuickConnectsInput, ListQuickConnectsOutputResponse, ListQuickConnectsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the queues associated with a routing profile.</p>
    public func listRoutingProfileQueues(input: ListRoutingProfileQueuesInput, completion: @escaping (SdkResult<ListRoutingProfileQueuesOutputResponse, ListRoutingProfileQueuesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let routingProfileId = input.routingProfileId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routingProfileId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)/\(routingProfileId)/queues"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listRoutingProfileQueues")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListRoutingProfileQueuesInput, ListRoutingProfileQueuesOutputResponse, ListRoutingProfileQueuesOutputError>(id: "listRoutingProfileQueues")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListRoutingProfileQueuesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListRoutingProfileQueuesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListRoutingProfileQueuesInput, ListRoutingProfileQueuesOutputResponse, ListRoutingProfileQueuesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides summary information about the routing profiles for the specified Amazon Connect
    ///    instance.</p>
    ///          <p>For more information about routing profiles, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing.html">Routing Profiles</a> and <a href="https://docs.aws.amazon.com/connect/latest/adminguide/routing-profiles.html">Create a Routing
    ///     Profile</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func listRoutingProfiles(input: ListRoutingProfilesInput, completion: @escaping (SdkResult<ListRoutingProfilesOutputResponse, ListRoutingProfilesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listRoutingProfiles")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListRoutingProfilesInput, ListRoutingProfilesOutputResponse, ListRoutingProfilesOutputError>(id: "listRoutingProfiles")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListRoutingProfilesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListRoutingProfilesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListRoutingProfilesInput, ListRoutingProfilesOutputResponse, ListRoutingProfilesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Returns a paginated list of all security keys associated with the instance.</p>
    public func listSecurityKeys(input: ListSecurityKeysInput, completion: @escaping (SdkResult<ListSecurityKeysOutputResponse, ListSecurityKeysOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/security-keys"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listSecurityKeys")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListSecurityKeysInput, ListSecurityKeysOutputResponse, ListSecurityKeysOutputError>(id: "listSecurityKeys")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListSecurityKeysInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListSecurityKeysInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListSecurityKeysInput, ListSecurityKeysOutputResponse, ListSecurityKeysOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides summary information about the security profiles for the specified Amazon Connect
    ///    instance.</p>
    ///          <p>For more information about security profiles, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/connect-security-profiles.html">Security Profiles</a> in the
    ///     <i>Amazon Connect Administrator Guide</i>.</p>
    public func listSecurityProfiles(input: ListSecurityProfilesInput, completion: @escaping (SdkResult<ListSecurityProfilesOutputResponse, ListSecurityProfilesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/security-profiles-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listSecurityProfiles")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListSecurityProfilesInput, ListSecurityProfilesOutputResponse, ListSecurityProfilesOutputError>(id: "listSecurityProfiles")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListSecurityProfilesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListSecurityProfilesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListSecurityProfilesInput, ListSecurityProfilesOutputResponse, ListSecurityProfilesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the tags for the specified resource.</p>
    ///          <p>For sample policies that use tags, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/security_iam_id-based-policy-examples.html">Amazon Connect Identity-Based
    ///     Policy Examples</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the use cases. </p>
    public func listUseCases(input: ListUseCasesInput, completion: @escaping (SdkResult<ListUseCasesOutputResponse, ListUseCasesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let integrationAssociationId = input.integrationAssociationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component integrationAssociationId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/integration-associations/\(integrationAssociationId)/use-cases"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listUseCases")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListUseCasesInput, ListUseCasesOutputResponse, ListUseCasesOutputError>(id: "listUseCases")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListUseCasesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListUseCasesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListUseCasesInput, ListUseCasesOutputResponse, ListUseCasesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides summary information about the hierarchy groups for the specified Amazon Connect
    ///    instance.</p>
    ///          <p>For more information about agent hierarchies, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/agent-hierarchy.html">Set Up Agent Hierarchies</a> in the
    ///     <i>Amazon Connect Administrator Guide</i>.</p>
    public func listUserHierarchyGroups(input: ListUserHierarchyGroupsInput, completion: @escaping (SdkResult<ListUserHierarchyGroupsOutputResponse, ListUserHierarchyGroupsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/user-hierarchy-groups-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listUserHierarchyGroups")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListUserHierarchyGroupsInput, ListUserHierarchyGroupsOutputResponse, ListUserHierarchyGroupsOutputError>(id: "listUserHierarchyGroups")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListUserHierarchyGroupsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListUserHierarchyGroupsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListUserHierarchyGroupsInput, ListUserHierarchyGroupsOutputResponse, ListUserHierarchyGroupsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Provides summary information about the users for the specified Amazon Connect instance.</p>
    public func listUsers(input: ListUsersInput, completion: @escaping (SdkResult<ListUsersOutputResponse, ListUsersOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/users-summary/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listUsers")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListUsersInput, ListUsersOutputResponse, ListUsersOutputError>(id: "listUsers")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListUsersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListUsersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListUsersInput, ListUsersOutputResponse, ListUsersOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>When a contact is being recorded, and the recording has been suspended using
    ///    SuspendContactRecording, this API resumes recording the call.</p>
    ///
    ///          <p>Only voice recordings are supported at this time.</p>
    public func resumeContactRecording(input: ResumeContactRecordingInput, completion: @escaping (SdkResult<ResumeContactRecordingOutputResponse, ResumeContactRecordingOutputError>) -> Void)
    {
        let urlPath = "/contact/resume-recording"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "resumeContactRecording")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ResumeContactRecordingInput, ResumeContactRecordingOutputResponse, ResumeContactRecordingOutputError>(id: "resumeContactRecording")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ResumeContactRecordingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ResumeContactRecordingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ResumeContactRecordingInput, ResumeContactRecordingOutputResponse, ResumeContactRecordingOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ResumeContactRecordingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Initiates a contact flow to start a new chat for the customer. Response of this API provides
    ///    a token required to obtain credentials from the <a href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html">CreateParticipantConnection</a> API in the Amazon Connect Participant Service.</p>
    ///
    ///          <p>When a new chat contact is successfully created, clients must subscribe to the participants
    ///    connection for the created chat within 5 minutes. This is achieved by invoking <a href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html">CreateParticipantConnection</a> with WEBSOCKET and CONNECTION_CREDENTIALS. </p>
    ///
    ///          <p>A 429 error occurs in two situations:</p>
    ///          <ul>
    ///             <li>
    ///                <p>API rate limit is exceeded. API TPS throttling returns a <code>TooManyRequests</code>
    ///      exception.</p>
    ///             </li>
    ///             <li>
    ///                <p>The <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">quota for concurrent active
    ///       chats</a> is exceeded. Active chat throttling returns a
    ///       <code>LimitExceededException</code>.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>For more information about chat, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat.html">Chat</a> in the <i>Amazon Connect Administrator
    ///     Guide</i>.</p>
    public func startChatContact(input: StartChatContactInput, completion: @escaping (SdkResult<StartChatContactOutputResponse, StartChatContactOutputError>) -> Void)
    {
        let urlPath = "/contact/chat"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startChatContact")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartChatContactInput, StartChatContactOutputResponse, StartChatContactOutputError>(id: "startChatContact")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<StartChatContactOutputResponse>, SdkError<StartChatContactOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: StartChatContactInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartChatContactInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartChatContactInput, StartChatContactOutputResponse, StartChatContactOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartChatContactInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Starts recording the contact when the agent joins the call. StartContactRecording is a
    ///    one-time action. For example, if you use StopContactRecording to stop recording an ongoing call,
    ///    you can't use StartContactRecording to restart it. For scenarios where the recording has started
    ///    and you want to suspend and resume it, such as when collecting sensitive information (for
    ///    example, a credit card number), use SuspendContactRecording and ResumeContactRecording.</p>
    ///          <p>You can use this API to override the recording behavior configured in the <a href="https://docs.aws.amazon.com/connect/latest/adminguide/set-recording-behavior.html">Set recording
    ///     behavior</a> block.</p>
    ///          <p>Only voice recordings are supported at this time.</p>
    public func startContactRecording(input: StartContactRecordingInput, completion: @escaping (SdkResult<StartContactRecordingOutputResponse, StartContactRecordingOutputError>) -> Void)
    {
        let urlPath = "/contact/start-recording"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startContactRecording")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartContactRecordingInput, StartContactRecordingOutputResponse, StartContactRecordingOutputError>(id: "startContactRecording")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartContactRecordingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartContactRecordingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartContactRecordingInput, StartContactRecordingOutputResponse, StartContactRecordingOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartContactRecordingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Places an outbound call to a contact, and then initiates the contact flow. It performs the
    ///    actions in the contact flow that's specified (in <code>ContactFlowId</code>).</p>
    ///
    ///          <p>Agents do not initiate the outbound API, which means that they do not dial the contact. If
    ///    the contact flow places an outbound call to a contact, and then puts the contact in queue, the
    ///    call is then routed to the agent, like any other inbound case.</p>
    ///
    ///          <p>There is a 60-second dialing timeout for this operation. If the call is not connected after
    ///    60 seconds, it fails.</p>
    ///          <note>
    ///             <p>UK numbers with a 447 prefix are not allowed by default. Before you can dial these UK
    ///     mobile numbers, you must submit a service quota increase request. For more information, see
    ///      <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">Amazon Connect Service Quotas</a> in the <i>Amazon Connect Administrator Guide</i>. </p>
    ///          </note>
    public func startOutboundVoiceContact(input: StartOutboundVoiceContactInput, completion: @escaping (SdkResult<StartOutboundVoiceContactOutputResponse, StartOutboundVoiceContactOutputError>) -> Void)
    {
        let urlPath = "/contact/outbound-voice"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startOutboundVoiceContact")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartOutboundVoiceContactInput, StartOutboundVoiceContactOutputResponse, StartOutboundVoiceContactOutputError>(id: "startOutboundVoiceContact")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<StartOutboundVoiceContactOutputResponse>, SdkError<StartOutboundVoiceContactOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: StartOutboundVoiceContactInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartOutboundVoiceContactInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartOutboundVoiceContactInput, StartOutboundVoiceContactOutputResponse, StartOutboundVoiceContactOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartOutboundVoiceContactInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Initiates a contact flow to start a new task.</p>
    public func startTaskContact(input: StartTaskContactInput, completion: @escaping (SdkResult<StartTaskContactOutputResponse, StartTaskContactOutputError>) -> Void)
    {
        let urlPath = "/contact/task"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startTaskContact")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartTaskContactInput, StartTaskContactOutputResponse, StartTaskContactOutputError>(id: "startTaskContact")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<StartTaskContactOutputResponse>, SdkError<StartTaskContactOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: StartTaskContactInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartTaskContactInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartTaskContactInput, StartTaskContactOutputResponse, StartTaskContactOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartTaskContactInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Ends the specified contact.</p>
    public func stopContact(input: StopContactInput, completion: @escaping (SdkResult<StopContactOutputResponse, StopContactOutputError>) -> Void)
    {
        let urlPath = "/contact/stop"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "stopContact")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StopContactInput, StopContactOutputResponse, StopContactOutputError>(id: "stopContact")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StopContactInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StopContactInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StopContactInput, StopContactOutputResponse, StopContactOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StopContactInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Stops recording a call when a contact is being recorded. StopContactRecording is a one-time
    ///    action. If you use StopContactRecording to stop recording an ongoing call, you can't use
    ///    StartContactRecording to restart it. For scenarios where the recording has started and you want
    ///    to suspend it for sensitive information (for example, to collect a credit card number), and then
    ///    restart it, use SuspendContactRecording and ResumeContactRecording.</p>
    ///
    ///          <p>Only voice recordings are supported at this time.</p>
    public func stopContactRecording(input: StopContactRecordingInput, completion: @escaping (SdkResult<StopContactRecordingOutputResponse, StopContactRecordingOutputError>) -> Void)
    {
        let urlPath = "/contact/stop-recording"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "stopContactRecording")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StopContactRecordingInput, StopContactRecordingOutputResponse, StopContactRecordingOutputError>(id: "stopContactRecording")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StopContactRecordingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StopContactRecordingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StopContactRecordingInput, StopContactRecordingOutputResponse, StopContactRecordingOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StopContactRecordingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>When a contact is being recorded, this API suspends recording the call. For example, you
    ///    might suspend the call recording while collecting sensitive information, such as a credit card
    ///    number. Then use ResumeContactRecording to restart recording. </p>
    ///          <p>The period of time that the recording is suspended is filled with silence in the final
    ///    recording. </p>
    ///          <p>Only voice recordings are supported at this time.</p>
    public func suspendContactRecording(input: SuspendContactRecordingInput, completion: @escaping (SdkResult<SuspendContactRecordingOutputResponse, SuspendContactRecordingOutputError>) -> Void)
    {
        let urlPath = "/contact/suspend-recording"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "suspendContactRecording")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SuspendContactRecordingInput, SuspendContactRecordingOutputResponse, SuspendContactRecordingOutputError>(id: "suspendContactRecording")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SuspendContactRecordingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SuspendContactRecordingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SuspendContactRecordingInput, SuspendContactRecordingOutputResponse, SuspendContactRecordingOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: SuspendContactRecordingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds the specified tags to the specified resource.</p>
    ///          <p>The supported resource types are users, routing profiles, queues, quick connects, and
    ///    contact flows.</p>
    ///          <p>For sample policies that use tags, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/security_iam_id-based-policy-examples.html">Amazon Connect Identity-Based
    ///     Policy Examples</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes the specified tags from the specified resource.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates or updates
    ///    user-defined contact attributes
    ///    associated with the specified contact.</p>
    ///          <p>You can create or update user-defined attributes for both ongoing and completed contacts.
    ///    For example, while the call is active, you can update the customer's name or the reason the
    ///    customer called. You can add notes about steps that the agent took during the call that display
    ///    to the next agent that takes the call. You can also update attributes for a contact using data
    ///    from your CRM application and save the data with the contact in Amazon Connect. You could also flag calls
    ///    for additional analysis, such as legal review or to identify abusive callers.</p>
    ///          <p>Contact attributes are available in Amazon Connect for 24 months, and are then deleted. For
    ///    information about CTR retention and the maximum size of the CTR attributes section, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html#feature-limits">Feature
    ///     specifications</a> in the <i>Amazon Connect Administrator Guide</i>. </p>
    ///
    ///          <p>
    ///             <b>Important:</b> You cannot use the operation to update
    ///    attributes for contacts that occurred prior to the release of the API, which was September 12,
    ///    2018. You can update attributes only for contacts that started after the release of the API. If
    ///    you attempt to update attributes for a contact that occurred prior to the release of the API, a
    ///    400 error is returned. This applies also to queued callbacks that were initiated prior to the
    ///    release of the API but are still active in your instance.</p>
    public func updateContactAttributes(input: UpdateContactAttributesInput, completion: @escaping (SdkResult<UpdateContactAttributesOutputResponse, UpdateContactAttributesOutputError>) -> Void)
    {
        let urlPath = "/contact/attributes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateContactAttributes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateContactAttributesInput, UpdateContactAttributesOutputResponse, UpdateContactAttributesOutputError>(id: "updateContactAttributes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactAttributesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactAttributesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateContactAttributesInput, UpdateContactAttributesOutputResponse, UpdateContactAttributesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactAttributesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the specified contact flow.</p>
    ///          <p>You can also create and update contact flows using the <a href="https://docs.aws.amazon.com/connect/latest/adminguide/flow-language.html">Amazon Connect
    ///    Flow language</a>.</p>
    public func updateContactFlowContent(input: UpdateContactFlowContentInput, completion: @escaping (SdkResult<UpdateContactFlowContentOutputResponse, UpdateContactFlowContentOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let contactFlowId = input.contactFlowId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component contactFlowId unexpectedly nil"))))
            return
        }
        let urlPath = "/contact-flows/\(instanceId)/\(contactFlowId)/content"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateContactFlowContent")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateContactFlowContentInput, UpdateContactFlowContentOutputResponse, UpdateContactFlowContentOutputError>(id: "updateContactFlowContent")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactFlowContentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactFlowContentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateContactFlowContentInput, UpdateContactFlowContentOutputResponse, UpdateContactFlowContentOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactFlowContentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>The name of the contact flow.</p>
    ///          <p>You can also create and update contact flows using the <a href="https://docs.aws.amazon.com/connect/latest/adminguide/flow-language.html">Amazon Connect
    ///    Flow language</a>.</p>
    public func updateContactFlowName(input: UpdateContactFlowNameInput, completion: @escaping (SdkResult<UpdateContactFlowNameOutputResponse, UpdateContactFlowNameOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let contactFlowId = input.contactFlowId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component contactFlowId unexpectedly nil"))))
            return
        }
        let urlPath = "/contact-flows/\(instanceId)/\(contactFlowId)/name"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateContactFlowName")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateContactFlowNameInput, UpdateContactFlowNameOutputResponse, UpdateContactFlowNameOutputError>(id: "updateContactFlowName")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactFlowNameInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactFlowNameInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateContactFlowNameInput, UpdateContactFlowNameOutputResponse, UpdateContactFlowNameOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateContactFlowNameInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates the value for the specified attribute type.</p>
    public func updateInstanceAttribute(input: UpdateInstanceAttributeInput, completion: @escaping (SdkResult<UpdateInstanceAttributeOutputResponse, UpdateInstanceAttributeOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let attributeType = input.attributeType else {
            completion(.failure(.client(ClientError.serializationFailed("uri component attributeType unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/attribute/\(attributeType.rawValue)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateInstanceAttribute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateInstanceAttributeInput, UpdateInstanceAttributeOutputResponse, UpdateInstanceAttributeOutputError>(id: "updateInstanceAttribute")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateInstanceAttributeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateInstanceAttributeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateInstanceAttributeInput, UpdateInstanceAttributeOutputResponse, UpdateInstanceAttributeOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateInstanceAttributeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates an existing configuration for a resource type. This API is idempotent.</p>
    public func updateInstanceStorageConfig(input: UpdateInstanceStorageConfigInput, completion: @escaping (SdkResult<UpdateInstanceStorageConfigOutputResponse, UpdateInstanceStorageConfigOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let associationId = input.associationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component associationId unexpectedly nil"))))
            return
        }
        let urlPath = "/instance/\(instanceId)/storage-config/\(associationId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateInstanceStorageConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateInstanceStorageConfigInput, UpdateInstanceStorageConfigOutputResponse, UpdateInstanceStorageConfigOutputError>(id: "updateInstanceStorageConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateInstanceStorageConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateInstanceStorageConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateInstanceStorageConfigInput, UpdateInstanceStorageConfigOutputResponse, UpdateInstanceStorageConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateInstanceStorageConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates the hours of operation for the specified queue.</p>
    public func updateQueueHoursOfOperation(input: UpdateQueueHoursOfOperationInput, completion: @escaping (SdkResult<UpdateQueueHoursOfOperationOutputResponse, UpdateQueueHoursOfOperationOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)/hours-of-operation"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateQueueHoursOfOperation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateQueueHoursOfOperationInput, UpdateQueueHoursOfOperationOutputResponse, UpdateQueueHoursOfOperationOutputError>(id: "updateQueueHoursOfOperation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueHoursOfOperationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueHoursOfOperationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateQueueHoursOfOperationInput, UpdateQueueHoursOfOperationOutputResponse, UpdateQueueHoursOfOperationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueHoursOfOperationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates the maximum number of contacts allowed in a queue before it is considered
    ///    full.</p>
    public func updateQueueMaxContacts(input: UpdateQueueMaxContactsInput, completion: @escaping (SdkResult<UpdateQueueMaxContactsOutputResponse, UpdateQueueMaxContactsOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)/max-contacts"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateQueueMaxContacts")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateQueueMaxContactsInput, UpdateQueueMaxContactsOutputResponse, UpdateQueueMaxContactsOutputError>(id: "updateQueueMaxContacts")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueMaxContactsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueMaxContactsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateQueueMaxContactsInput, UpdateQueueMaxContactsOutputResponse, UpdateQueueMaxContactsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueMaxContactsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates the name and description of a queue. At least <code>Name</code> or <code>Description</code> must be provided.</p>
    public func updateQueueName(input: UpdateQueueNameInput, completion: @escaping (SdkResult<UpdateQueueNameOutputResponse, UpdateQueueNameOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)/name"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateQueueName")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateQueueNameInput, UpdateQueueNameOutputResponse, UpdateQueueNameOutputError>(id: "updateQueueName")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueNameInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueNameInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateQueueNameInput, UpdateQueueNameOutputResponse, UpdateQueueNameOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueNameInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates the outbound caller ID name, number, and outbound whisper flow for a specified
    ///    queue.</p>
    public func updateQueueOutboundCallerConfig(input: UpdateQueueOutboundCallerConfigInput, completion: @escaping (SdkResult<UpdateQueueOutboundCallerConfigOutputResponse, UpdateQueueOutboundCallerConfigOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)/outbound-caller-config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateQueueOutboundCallerConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateQueueOutboundCallerConfigInput, UpdateQueueOutboundCallerConfigOutputResponse, UpdateQueueOutboundCallerConfigOutputError>(id: "updateQueueOutboundCallerConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueOutboundCallerConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueOutboundCallerConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateQueueOutboundCallerConfigInput, UpdateQueueOutboundCallerConfigOutputResponse, UpdateQueueOutboundCallerConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueOutboundCallerConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates the status of the queue.</p>
    public func updateQueueStatus(input: UpdateQueueStatusInput, completion: @escaping (SdkResult<UpdateQueueStatusOutputResponse, UpdateQueueStatusOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let queueId = input.queueId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component queueId unexpectedly nil"))))
            return
        }
        let urlPath = "/queues/\(instanceId)/\(queueId)/status"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateQueueStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateQueueStatusInput, UpdateQueueStatusOutputResponse, UpdateQueueStatusOutputError>(id: "updateQueueStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateQueueStatusInput, UpdateQueueStatusOutputResponse, UpdateQueueStatusOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateQueueStatusInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates the configuration settings for the specified quick connect.</p>
    public func updateQuickConnectConfig(input: UpdateQuickConnectConfigInput, completion: @escaping (SdkResult<UpdateQuickConnectConfigOutputResponse, UpdateQuickConnectConfigOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let quickConnectId = input.quickConnectId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component quickConnectId unexpectedly nil"))))
            return
        }
        let urlPath = "/quick-connects/\(instanceId)/\(quickConnectId)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateQuickConnectConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateQuickConnectConfigInput, UpdateQuickConnectConfigOutputResponse, UpdateQuickConnectConfigOutputError>(id: "updateQuickConnectConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateQuickConnectConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateQuickConnectConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateQuickConnectConfigInput, UpdateQuickConnectConfigOutputResponse, UpdateQuickConnectConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateQuickConnectConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is in preview release for Amazon Connect and is subject to change.</p>
    ///          <p>Updates the name and description of a quick connect. The request accepts the following data in JSON format. At least <code>Name</code> or <code>Description</code> must be provided.</p>
    public func updateQuickConnectName(input: UpdateQuickConnectNameInput, completion: @escaping (SdkResult<UpdateQuickConnectNameOutputResponse, UpdateQuickConnectNameOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let quickConnectId = input.quickConnectId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component quickConnectId unexpectedly nil"))))
            return
        }
        let urlPath = "/quick-connects/\(instanceId)/\(quickConnectId)/name"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateQuickConnectName")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateQuickConnectNameInput, UpdateQuickConnectNameOutputResponse, UpdateQuickConnectNameOutputError>(id: "updateQuickConnectName")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateQuickConnectNameInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateQuickConnectNameInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateQuickConnectNameInput, UpdateQuickConnectNameOutputResponse, UpdateQuickConnectNameOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateQuickConnectNameInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the channels that agents can handle in the Contact Control Panel (CCP) for a routing
    ///    profile.</p>
    public func updateRoutingProfileConcurrency(input: UpdateRoutingProfileConcurrencyInput, completion: @escaping (SdkResult<UpdateRoutingProfileConcurrencyOutputResponse, UpdateRoutingProfileConcurrencyOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let routingProfileId = input.routingProfileId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routingProfileId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)/\(routingProfileId)/concurrency"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateRoutingProfileConcurrency")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateRoutingProfileConcurrencyInput, UpdateRoutingProfileConcurrencyOutputResponse, UpdateRoutingProfileConcurrencyOutputError>(id: "updateRoutingProfileConcurrency")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileConcurrencyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileConcurrencyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateRoutingProfileConcurrencyInput, UpdateRoutingProfileConcurrencyOutputResponse, UpdateRoutingProfileConcurrencyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileConcurrencyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the default outbound queue of a routing profile.</p>
    public func updateRoutingProfileDefaultOutboundQueue(input: UpdateRoutingProfileDefaultOutboundQueueInput, completion: @escaping (SdkResult<UpdateRoutingProfileDefaultOutboundQueueOutputResponse, UpdateRoutingProfileDefaultOutboundQueueOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let routingProfileId = input.routingProfileId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routingProfileId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)/\(routingProfileId)/default-outbound-queue"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateRoutingProfileDefaultOutboundQueue")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateRoutingProfileDefaultOutboundQueueInput, UpdateRoutingProfileDefaultOutboundQueueOutputResponse, UpdateRoutingProfileDefaultOutboundQueueOutputError>(id: "updateRoutingProfileDefaultOutboundQueue")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileDefaultOutboundQueueInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileDefaultOutboundQueueInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateRoutingProfileDefaultOutboundQueueInput, UpdateRoutingProfileDefaultOutboundQueueOutputResponse, UpdateRoutingProfileDefaultOutboundQueueOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileDefaultOutboundQueueInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the name and description of a routing profile. The request accepts the following data in JSON format.
    ///    At least <code>Name</code> or <code>Description</code> must be provided.</p>
    public func updateRoutingProfileName(input: UpdateRoutingProfileNameInput, completion: @escaping (SdkResult<UpdateRoutingProfileNameOutputResponse, UpdateRoutingProfileNameOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let routingProfileId = input.routingProfileId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routingProfileId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)/\(routingProfileId)/name"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateRoutingProfileName")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateRoutingProfileNameInput, UpdateRoutingProfileNameOutputResponse, UpdateRoutingProfileNameOutputError>(id: "updateRoutingProfileName")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileNameInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileNameInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateRoutingProfileNameInput, UpdateRoutingProfileNameOutputResponse, UpdateRoutingProfileNameOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileNameInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the properties associated with a set of queues for a routing profile.</p>
    public func updateRoutingProfileQueues(input: UpdateRoutingProfileQueuesInput, completion: @escaping (SdkResult<UpdateRoutingProfileQueuesOutputResponse, UpdateRoutingProfileQueuesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let routingProfileId = input.routingProfileId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routingProfileId unexpectedly nil"))))
            return
        }
        let urlPath = "/routing-profiles/\(instanceId)/\(routingProfileId)/queues"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateRoutingProfileQueues")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateRoutingProfileQueuesInput, UpdateRoutingProfileQueuesOutputResponse, UpdateRoutingProfileQueuesOutputError>(id: "updateRoutingProfileQueues")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileQueuesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileQueuesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateRoutingProfileQueuesInput, UpdateRoutingProfileQueuesOutputResponse, UpdateRoutingProfileQueuesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateRoutingProfileQueuesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Assigns the specified hierarchy group to the specified user.</p>
    public func updateUserHierarchy(input: UpdateUserHierarchyInput, completion: @escaping (SdkResult<UpdateUserHierarchyOutputResponse, UpdateUserHierarchyOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/users/\(instanceId)/\(userId)/hierarchy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUserHierarchy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUserHierarchyInput, UpdateUserHierarchyOutputResponse, UpdateUserHierarchyOutputError>(id: "updateUserHierarchy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateUserHierarchyInput, UpdateUserHierarchyOutputResponse, UpdateUserHierarchyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the name of the user hierarchy group. </p>
    public func updateUserHierarchyGroupName(input: UpdateUserHierarchyGroupNameInput, completion: @escaping (SdkResult<UpdateUserHierarchyGroupNameOutputResponse, UpdateUserHierarchyGroupNameOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let hierarchyGroupId = input.hierarchyGroupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component hierarchyGroupId unexpectedly nil"))))
            return
        }
        let urlPath = "/user-hierarchy-groups/\(instanceId)/\(hierarchyGroupId)/name"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUserHierarchyGroupName")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUserHierarchyGroupNameInput, UpdateUserHierarchyGroupNameOutputResponse, UpdateUserHierarchyGroupNameOutputError>(id: "updateUserHierarchyGroupName")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyGroupNameInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyGroupNameInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateUserHierarchyGroupNameInput, UpdateUserHierarchyGroupNameOutputResponse, UpdateUserHierarchyGroupNameOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyGroupNameInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the user hierarchy structure: add, remove, and rename user hierarchy levels.</p>
    public func updateUserHierarchyStructure(input: UpdateUserHierarchyStructureInput, completion: @escaping (SdkResult<UpdateUserHierarchyStructureOutputResponse, UpdateUserHierarchyStructureOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        let urlPath = "/user-hierarchy-structure/\(instanceId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUserHierarchyStructure")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUserHierarchyStructureInput, UpdateUserHierarchyStructureOutputResponse, UpdateUserHierarchyStructureOutputError>(id: "updateUserHierarchyStructure")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyStructureInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyStructureInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateUserHierarchyStructureInput, UpdateUserHierarchyStructureOutputResponse, UpdateUserHierarchyStructureOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserHierarchyStructureInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the identity information for the specified user.</p>
    ///          <important>
    ///             <p>We strongly recommend limiting who has the ability to invoke
    ///      <code>UpdateUserIdentityInfo</code>. Someone with that ability can change the login credentials
    ///     of other users by changing their email address. This poses a security risk to your organization.
    ///     They can change the email address of a user to the attacker's email address, and then reset the
    ///     password through email. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-best-practices.html">Best Practices for
    ///      Security Profiles</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    ///          </important>
    public func updateUserIdentityInfo(input: UpdateUserIdentityInfoInput, completion: @escaping (SdkResult<UpdateUserIdentityInfoOutputResponse, UpdateUserIdentityInfoOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/users/\(instanceId)/\(userId)/identity-info"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUserIdentityInfo")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUserIdentityInfoInput, UpdateUserIdentityInfoOutputResponse, UpdateUserIdentityInfoOutputError>(id: "updateUserIdentityInfo")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserIdentityInfoInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserIdentityInfoInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateUserIdentityInfoInput, UpdateUserIdentityInfoOutputResponse, UpdateUserIdentityInfoOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserIdentityInfoInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the phone configuration settings for the specified user.</p>
    public func updateUserPhoneConfig(input: UpdateUserPhoneConfigInput, completion: @escaping (SdkResult<UpdateUserPhoneConfigOutputResponse, UpdateUserPhoneConfigOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/users/\(instanceId)/\(userId)/phone-config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUserPhoneConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUserPhoneConfigInput, UpdateUserPhoneConfigOutputResponse, UpdateUserPhoneConfigOutputError>(id: "updateUserPhoneConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserPhoneConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserPhoneConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateUserPhoneConfigInput, UpdateUserPhoneConfigOutputResponse, UpdateUserPhoneConfigOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserPhoneConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Assigns the specified routing profile to the specified user.</p>
    public func updateUserRoutingProfile(input: UpdateUserRoutingProfileInput, completion: @escaping (SdkResult<UpdateUserRoutingProfileOutputResponse, UpdateUserRoutingProfileOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/users/\(instanceId)/\(userId)/routing-profile"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUserRoutingProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUserRoutingProfileInput, UpdateUserRoutingProfileOutputResponse, UpdateUserRoutingProfileOutputError>(id: "updateUserRoutingProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserRoutingProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserRoutingProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateUserRoutingProfileInput, UpdateUserRoutingProfileOutputResponse, UpdateUserRoutingProfileOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserRoutingProfileInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Assigns the specified security profiles to the specified user.</p>
    public func updateUserSecurityProfiles(input: UpdateUserSecurityProfilesInput, completion: @escaping (SdkResult<UpdateUserSecurityProfilesOutputResponse, UpdateUserSecurityProfilesOutputError>) -> Void)
    {
        guard let instanceId = input.instanceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component instanceId unexpectedly nil"))))
            return
        }
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/users/\(instanceId)/\(userId)/security-profiles"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUserSecurityProfiles")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "connect.\(config.region).amazonaws.com")
                      .withSigningName(value: "connect")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUserSecurityProfilesInput, UpdateUserSecurityProfilesOutputResponse, UpdateUserSecurityProfilesOutputError>(id: "updateUserSecurityProfiles")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserSecurityProfilesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserSecurityProfilesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateUserSecurityProfilesInput, UpdateUserSecurityProfilesOutputResponse, UpdateUserSecurityProfilesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserSecurityProfilesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
