// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AddFlowMediaStreamsInputBodyMiddleware: Middleware {
    public let id: String = "AddFlowMediaStreamsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddFlowMediaStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddFlowMediaStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddFlowMediaStreamsInput>
    public typealias MOutput = OperationOutput<AddFlowMediaStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddFlowMediaStreamsOutputError>
}

extension AddFlowMediaStreamsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddFlowMediaStreamsInput(flowArn: \(String(describing: flowArn)), mediaStreams: \(String(describing: mediaStreams)))"}
}

extension AddFlowMediaStreamsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mediaStreams = "mediaStreams"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaStreams = mediaStreams {
            var mediaStreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreams)
            for __listofaddmediastreamrequest0 in mediaStreams {
                try mediaStreamsContainer.encode(__listofaddmediastreamrequest0)
            }
        }
    }
}

public struct AddFlowMediaStreamsInputHeadersMiddleware: Middleware {
    public let id: String = "AddFlowMediaStreamsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddFlowMediaStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddFlowMediaStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddFlowMediaStreamsInput>
    public typealias MOutput = OperationOutput<AddFlowMediaStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddFlowMediaStreamsOutputError>
}

public struct AddFlowMediaStreamsInputQueryItemMiddleware: Middleware {
    public let id: String = "AddFlowMediaStreamsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddFlowMediaStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddFlowMediaStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddFlowMediaStreamsInput>
    public typealias MOutput = OperationOutput<AddFlowMediaStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddFlowMediaStreamsOutputError>
}

/// A request to add media streams to the flow.
public struct AddFlowMediaStreamsInput: Equatable {
    /// The Amazon Resource Name (ARN) of the flow.
    public let flowArn: String?
    /// The media streams that you want to add to the flow.
    public let mediaStreams: [AddMediaStreamRequest]?

    public init (
        flowArn: String? = nil,
        mediaStreams: [AddMediaStreamRequest]? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStreams = mediaStreams
    }
}

struct AddFlowMediaStreamsInputBody: Equatable {
    public let mediaStreams: [AddMediaStreamRequest]?
}

extension AddFlowMediaStreamsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mediaStreams = "mediaStreams"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaStreamsContainer = try containerValues.decodeIfPresent([AddMediaStreamRequest?].self, forKey: .mediaStreams)
        var mediaStreamsDecoded0:[AddMediaStreamRequest]? = nil
        if let mediaStreamsContainer = mediaStreamsContainer {
            mediaStreamsDecoded0 = [AddMediaStreamRequest]()
            for structure0 in mediaStreamsContainer {
                if let structure0 = structure0 {
                    mediaStreamsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreams = mediaStreamsDecoded0
    }
}

extension AddFlowMediaStreamsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddFlowMediaStreamsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddFlowMediaStreamsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddFlowMediaStreamsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddFlowMediaStreamsOutputResponse(flowArn: \(String(describing: flowArn)), mediaStreams: \(String(describing: mediaStreams)))"}
}

extension AddFlowMediaStreamsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddFlowMediaStreamsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flowArn = output.flowArn
            self.mediaStreams = output.mediaStreams
        } else {
            self.flowArn = nil
            self.mediaStreams = nil
        }
    }
}

public struct AddFlowMediaStreamsOutputResponse: Equatable {
    /// The ARN of the flow that you added media streams to.
    public let flowArn: String?
    /// The media streams that you added to the flow.
    public let mediaStreams: [MediaStream]?

    public init (
        flowArn: String? = nil,
        mediaStreams: [MediaStream]? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStreams = mediaStreams
    }
}

struct AddFlowMediaStreamsOutputResponseBody: Equatable {
    public let flowArn: String?
    public let mediaStreams: [MediaStream]?
}

extension AddFlowMediaStreamsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowArn = "flowArn"
        case mediaStreams = "mediaStreams"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let mediaStreamsContainer = try containerValues.decodeIfPresent([MediaStream?].self, forKey: .mediaStreams)
        var mediaStreamsDecoded0:[MediaStream]? = nil
        if let mediaStreamsContainer = mediaStreamsContainer {
            mediaStreamsDecoded0 = [MediaStream]()
            for structure0 in mediaStreamsContainer {
                if let structure0 = structure0 {
                    mediaStreamsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreams = mediaStreamsDecoded0
    }
}

extension AddFlowOutputs420Exception: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddFlowOutputs420Exception(message: \(String(describing: message)))"}
}

extension AddFlowOutputs420Exception: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddFlowOutputs420ExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct AddFlowOutputs420Exception: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The error message returned by AWS Elemental MediaConnect.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AddFlowOutputs420ExceptionBody: Equatable {
    public let message: String?
}

extension AddFlowOutputs420ExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AddFlowOutputsInputBodyMiddleware: Middleware {
    public let id: String = "AddFlowOutputsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddFlowOutputsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddFlowOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddFlowOutputsInput>
    public typealias MOutput = OperationOutput<AddFlowOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddFlowOutputsOutputError>
}

extension AddFlowOutputsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddFlowOutputsInput(flowArn: \(String(describing: flowArn)), outputs: \(String(describing: outputs)))"}
}

extension AddFlowOutputsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case outputs = "outputs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for __listofaddoutputrequest0 in outputs {
                try outputsContainer.encode(__listofaddoutputrequest0)
            }
        }
    }
}

public struct AddFlowOutputsInputHeadersMiddleware: Middleware {
    public let id: String = "AddFlowOutputsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddFlowOutputsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddFlowOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddFlowOutputsInput>
    public typealias MOutput = OperationOutput<AddFlowOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddFlowOutputsOutputError>
}

public struct AddFlowOutputsInputQueryItemMiddleware: Middleware {
    public let id: String = "AddFlowOutputsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddFlowOutputsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddFlowOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddFlowOutputsInput>
    public typealias MOutput = OperationOutput<AddFlowOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddFlowOutputsOutputError>
}

/// A request to add outputs to the specified flow.
public struct AddFlowOutputsInput: Equatable {
    /// The flow that you want to add outputs to.
    public let flowArn: String?
    /// A list of outputs that you want to add.
    public let outputs: [AddOutputRequest]?

    public init (
        flowArn: String? = nil,
        outputs: [AddOutputRequest]? = nil
    )
    {
        self.flowArn = flowArn
        self.outputs = outputs
    }
}

struct AddFlowOutputsInputBody: Equatable {
    public let outputs: [AddOutputRequest]?
}

extension AddFlowOutputsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case outputs = "outputs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputsContainer = try containerValues.decodeIfPresent([AddOutputRequest?].self, forKey: .outputs)
        var outputsDecoded0:[AddOutputRequest]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [AddOutputRequest]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

extension AddFlowOutputsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddFlowOutputsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AddFlowOutputs420Exception" : self = .addFlowOutputs420Exception(try AddFlowOutputs420Exception(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddFlowOutputsOutputError: Equatable {
    case addFlowOutputs420Exception(AddFlowOutputs420Exception)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddFlowOutputsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddFlowOutputsOutputResponse(flowArn: \(String(describing: flowArn)), outputs: \(String(describing: outputs)))"}
}

extension AddFlowOutputsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddFlowOutputsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flowArn = output.flowArn
            self.outputs = output.outputs
        } else {
            self.flowArn = nil
            self.outputs = nil
        }
    }
}

public struct AddFlowOutputsOutputResponse: Equatable {
    /// The ARN of the flow that these outputs were added to.
    public let flowArn: String?
    /// The details of the newly added outputs.
    public let outputs: [Output]?

    public init (
        flowArn: String? = nil,
        outputs: [Output]? = nil
    )
    {
        self.flowArn = flowArn
        self.outputs = outputs
    }
}

struct AddFlowOutputsOutputResponseBody: Equatable {
    public let flowArn: String?
    public let outputs: [Output]?
}

extension AddFlowOutputsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowArn = "flowArn"
        case outputs = "outputs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let outputsContainer = try containerValues.decodeIfPresent([Output?].self, forKey: .outputs)
        var outputsDecoded0:[Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

public struct AddFlowSourcesInputBodyMiddleware: Middleware {
    public let id: String = "AddFlowSourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddFlowSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<AddFlowSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddFlowSourcesInput>
    public typealias MOutput = OperationOutput<AddFlowSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddFlowSourcesOutputError>
}

extension AddFlowSourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddFlowSourcesInput(flowArn: \(String(describing: flowArn)), sources: \(String(describing: sources)))"}
}

extension AddFlowSourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sources = "sources"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for __listofsetsourcerequest0 in sources {
                try sourcesContainer.encode(__listofsetsourcerequest0)
            }
        }
    }
}

public struct AddFlowSourcesInputHeadersMiddleware: Middleware {
    public let id: String = "AddFlowSourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddFlowSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<AddFlowSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddFlowSourcesInput>
    public typealias MOutput = OperationOutput<AddFlowSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddFlowSourcesOutputError>
}

public struct AddFlowSourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "AddFlowSourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddFlowSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<AddFlowSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddFlowSourcesInput>
    public typealias MOutput = OperationOutput<AddFlowSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddFlowSourcesOutputError>
}

/// A request to add sources to the flow.
public struct AddFlowSourcesInput: Equatable {
    /// The flow that you want to mutate.
    public let flowArn: String?
    /// A list of sources that you want to add.
    public let sources: [SetSourceRequest]?

    public init (
        flowArn: String? = nil,
        sources: [SetSourceRequest]? = nil
    )
    {
        self.flowArn = flowArn
        self.sources = sources
    }
}

struct AddFlowSourcesInputBody: Equatable {
    public let sources: [SetSourceRequest]?
}

extension AddFlowSourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sources = "sources"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcesContainer = try containerValues.decodeIfPresent([SetSourceRequest?].self, forKey: .sources)
        var sourcesDecoded0:[SetSourceRequest]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SetSourceRequest]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension AddFlowSourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddFlowSourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddFlowSourcesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddFlowSourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddFlowSourcesOutputResponse(flowArn: \(String(describing: flowArn)), sources: \(String(describing: sources)))"}
}

extension AddFlowSourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddFlowSourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flowArn = output.flowArn
            self.sources = output.sources
        } else {
            self.flowArn = nil
            self.sources = nil
        }
    }
}

public struct AddFlowSourcesOutputResponse: Equatable {
    /// The ARN of the flow that these sources were added to.
    public let flowArn: String?
    /// The details of the newly added sources.
    public let sources: [Source]?

    public init (
        flowArn: String? = nil,
        sources: [Source]? = nil
    )
    {
        self.flowArn = flowArn
        self.sources = sources
    }
}

struct AddFlowSourcesOutputResponseBody: Equatable {
    public let flowArn: String?
    public let sources: [Source]?
}

extension AddFlowSourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowArn = "flowArn"
        case sources = "sources"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([Source?].self, forKey: .sources)
        var sourcesDecoded0:[Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

public struct AddFlowVpcInterfacesInputBodyMiddleware: Middleware {
    public let id: String = "AddFlowVpcInterfacesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddFlowVpcInterfacesInput>,
                  next: H) -> Swift.Result<OperationOutput<AddFlowVpcInterfacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddFlowVpcInterfacesInput>
    public typealias MOutput = OperationOutput<AddFlowVpcInterfacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddFlowVpcInterfacesOutputError>
}

extension AddFlowVpcInterfacesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddFlowVpcInterfacesInput(flowArn: \(String(describing: flowArn)), vpcInterfaces: \(String(describing: vpcInterfaces)))"}
}

extension AddFlowVpcInterfacesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case vpcInterfaces = "vpcInterfaces"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcInterfaces = vpcInterfaces {
            var vpcInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcInterfaces)
            for __listofvpcinterfacerequest0 in vpcInterfaces {
                try vpcInterfacesContainer.encode(__listofvpcinterfacerequest0)
            }
        }
    }
}

public struct AddFlowVpcInterfacesInputHeadersMiddleware: Middleware {
    public let id: String = "AddFlowVpcInterfacesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddFlowVpcInterfacesInput>,
                  next: H) -> Swift.Result<OperationOutput<AddFlowVpcInterfacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddFlowVpcInterfacesInput>
    public typealias MOutput = OperationOutput<AddFlowVpcInterfacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddFlowVpcInterfacesOutputError>
}

public struct AddFlowVpcInterfacesInputQueryItemMiddleware: Middleware {
    public let id: String = "AddFlowVpcInterfacesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddFlowVpcInterfacesInput>,
                  next: H) -> Swift.Result<OperationOutput<AddFlowVpcInterfacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddFlowVpcInterfacesInput>
    public typealias MOutput = OperationOutput<AddFlowVpcInterfacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddFlowVpcInterfacesOutputError>
}

/// A request to add VPC interfaces to the flow.
public struct AddFlowVpcInterfacesInput: Equatable {
    /// The flow that you want to mutate.
    public let flowArn: String?
    /// A list of VPC interfaces that you want to add.
    public let vpcInterfaces: [VpcInterfaceRequest]?

    public init (
        flowArn: String? = nil,
        vpcInterfaces: [VpcInterfaceRequest]? = nil
    )
    {
        self.flowArn = flowArn
        self.vpcInterfaces = vpcInterfaces
    }
}

struct AddFlowVpcInterfacesInputBody: Equatable {
    public let vpcInterfaces: [VpcInterfaceRequest]?
}

extension AddFlowVpcInterfacesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case vpcInterfaces = "vpcInterfaces"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcInterfacesContainer = try containerValues.decodeIfPresent([VpcInterfaceRequest?].self, forKey: .vpcInterfaces)
        var vpcInterfacesDecoded0:[VpcInterfaceRequest]? = nil
        if let vpcInterfacesContainer = vpcInterfacesContainer {
            vpcInterfacesDecoded0 = [VpcInterfaceRequest]()
            for structure0 in vpcInterfacesContainer {
                if let structure0 = structure0 {
                    vpcInterfacesDecoded0?.append(structure0)
                }
            }
        }
        vpcInterfaces = vpcInterfacesDecoded0
    }
}

extension AddFlowVpcInterfacesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddFlowVpcInterfacesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddFlowVpcInterfacesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddFlowVpcInterfacesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddFlowVpcInterfacesOutputResponse(flowArn: \(String(describing: flowArn)), vpcInterfaces: \(String(describing: vpcInterfaces)))"}
}

extension AddFlowVpcInterfacesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddFlowVpcInterfacesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flowArn = output.flowArn
            self.vpcInterfaces = output.vpcInterfaces
        } else {
            self.flowArn = nil
            self.vpcInterfaces = nil
        }
    }
}

public struct AddFlowVpcInterfacesOutputResponse: Equatable {
    /// The ARN of the flow that these VPC interfaces were added to.
    public let flowArn: String?
    /// The details of the newly added VPC interfaces.
    public let vpcInterfaces: [VpcInterface]?

    public init (
        flowArn: String? = nil,
        vpcInterfaces: [VpcInterface]? = nil
    )
    {
        self.flowArn = flowArn
        self.vpcInterfaces = vpcInterfaces
    }
}

struct AddFlowVpcInterfacesOutputResponseBody: Equatable {
    public let flowArn: String?
    public let vpcInterfaces: [VpcInterface]?
}

extension AddFlowVpcInterfacesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowArn = "flowArn"
        case vpcInterfaces = "vpcInterfaces"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let vpcInterfacesContainer = try containerValues.decodeIfPresent([VpcInterface?].self, forKey: .vpcInterfaces)
        var vpcInterfacesDecoded0:[VpcInterface]? = nil
        if let vpcInterfacesContainer = vpcInterfacesContainer {
            vpcInterfacesDecoded0 = [VpcInterface]()
            for structure0 in vpcInterfacesContainer {
                if let structure0 = structure0 {
                    vpcInterfacesDecoded0?.append(structure0)
                }
            }
        }
        vpcInterfaces = vpcInterfacesDecoded0
    }
}

extension AddMediaStreamRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "attributes"
        case clockRate = "clockRate"
        case description = "description"
        case mediaStreamId = "mediaStreamId"
        case mediaStreamName = "mediaStreamName"
        case mediaStreamType = "mediaStreamType"
        case videoFormat = "videoFormat"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if clockRate != 0 {
            try encodeContainer.encode(clockRate, forKey: .clockRate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if mediaStreamId != 0 {
            try encodeContainer.encode(mediaStreamId, forKey: .mediaStreamId)
        }
        if let mediaStreamName = mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
        if let mediaStreamType = mediaStreamType {
            try encodeContainer.encode(mediaStreamType.rawValue, forKey: .mediaStreamType)
        }
        if let videoFormat = videoFormat {
            try encodeContainer.encode(videoFormat, forKey: .videoFormat)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesDecoded = try containerValues.decodeIfPresent(MediaStreamAttributesRequest.self, forKey: .attributes)
        attributes = attributesDecoded
        let clockRateDecoded = try containerValues.decode(Int.self, forKey: .clockRate)
        clockRate = clockRateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let mediaStreamIdDecoded = try containerValues.decode(Int.self, forKey: .mediaStreamId)
        mediaStreamId = mediaStreamIdDecoded
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
        let mediaStreamTypeDecoded = try containerValues.decodeIfPresent(MediaStreamType.self, forKey: .mediaStreamType)
        mediaStreamType = mediaStreamTypeDecoded
        let videoFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .videoFormat)
        videoFormat = videoFormatDecoded
    }
}

extension AddMediaStreamRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddMediaStreamRequest(attributes: \(String(describing: attributes)), clockRate: \(String(describing: clockRate)), description: \(String(describing: description)), mediaStreamId: \(String(describing: mediaStreamId)), mediaStreamName: \(String(describing: mediaStreamName)), mediaStreamType: \(String(describing: mediaStreamType)), videoFormat: \(String(describing: videoFormat)))"}
}

/// The media stream that you want to add to the flow.
public struct AddMediaStreamRequest: Equatable {
    /// The attributes that you want to assign to the new media stream.
    public let attributes: MediaStreamAttributesRequest?
    /// The sample rate (in Hz) for the stream. If the media stream type is video or ancillary data, set this value to 90000. If the media stream type is audio, set this value to either 48000 or 96000.
    public let clockRate: Int
    /// A description that can help you quickly identify what your media stream is used for.
    public let description: String?
    /// A unique identifier for the media stream.
    public let mediaStreamId: Int
    /// A name that helps you distinguish one media stream from another.
    public let mediaStreamName: String?
    /// The type of media stream.
    public let mediaStreamType: MediaStreamType?
    /// The resolution of the video.
    public let videoFormat: String?

    public init (
        attributes: MediaStreamAttributesRequest? = nil,
        clockRate: Int = 0,
        description: String? = nil,
        mediaStreamId: Int = 0,
        mediaStreamName: String? = nil,
        mediaStreamType: MediaStreamType? = nil,
        videoFormat: String? = nil
    )
    {
        self.attributes = attributes
        self.clockRate = clockRate
        self.description = description
        self.mediaStreamId = mediaStreamId
        self.mediaStreamName = mediaStreamName
        self.mediaStreamType = mediaStreamType
        self.videoFormat = videoFormat
    }
}

extension AddOutputRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidrAllowList = "cidrAllowList"
        case description = "description"
        case destination = "destination"
        case encryption = "encryption"
        case maxLatency = "maxLatency"
        case mediaStreamOutputConfigurations = "mediaStreamOutputConfigurations"
        case minLatency = "minLatency"
        case name = "name"
        case port = "port"
        case `protocol` = "protocol"
        case remoteId = "remoteId"
        case smoothingLatency = "smoothingLatency"
        case streamId = "streamId"
        case vpcInterfaceAttachment = "vpcInterfaceAttachment"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrAllowList = cidrAllowList {
            var cidrAllowListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrAllowList)
            for __listof__string0 in cidrAllowList {
                try cidrAllowListContainer.encode(__listof__string0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if maxLatency != 0 {
            try encodeContainer.encode(maxLatency, forKey: .maxLatency)
        }
        if let mediaStreamOutputConfigurations = mediaStreamOutputConfigurations {
            var mediaStreamOutputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamOutputConfigurations)
            for __listofmediastreamoutputconfigurationrequest0 in mediaStreamOutputConfigurations {
                try mediaStreamOutputConfigurationsContainer.encode(__listofmediastreamoutputconfigurationrequest0)
            }
        }
        if minLatency != 0 {
            try encodeContainer.encode(minLatency, forKey: .minLatency)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let remoteId = remoteId {
            try encodeContainer.encode(remoteId, forKey: .remoteId)
        }
        if smoothingLatency != 0 {
            try encodeContainer.encode(smoothingLatency, forKey: .smoothingLatency)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let vpcInterfaceAttachment = vpcInterfaceAttachment {
            try encodeContainer.encode(vpcInterfaceAttachment, forKey: .vpcInterfaceAttachment)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrAllowListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .cidrAllowList)
        var cidrAllowListDecoded0:[String]? = nil
        if let cidrAllowListContainer = cidrAllowListContainer {
            cidrAllowListDecoded0 = [String]()
            for string0 in cidrAllowListContainer {
                if let string0 = string0 {
                    cidrAllowListDecoded0?.append(string0)
                }
            }
        }
        cidrAllowList = cidrAllowListDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destination)
        destination = destinationDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let maxLatencyDecoded = try containerValues.decode(Int.self, forKey: .maxLatency)
        maxLatency = maxLatencyDecoded
        let mediaStreamOutputConfigurationsContainer = try containerValues.decodeIfPresent([MediaStreamOutputConfigurationRequest?].self, forKey: .mediaStreamOutputConfigurations)
        var mediaStreamOutputConfigurationsDecoded0:[MediaStreamOutputConfigurationRequest]? = nil
        if let mediaStreamOutputConfigurationsContainer = mediaStreamOutputConfigurationsContainer {
            mediaStreamOutputConfigurationsDecoded0 = [MediaStreamOutputConfigurationRequest]()
            for structure0 in mediaStreamOutputConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamOutputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamOutputConfigurations = mediaStreamOutputConfigurationsDecoded0
        let minLatencyDecoded = try containerValues.decode(Int.self, forKey: .minLatency)
        minLatency = minLatencyDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(`Protocol`.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let remoteIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remoteId)
        remoteId = remoteIdDecoded
        let smoothingLatencyDecoded = try containerValues.decode(Int.self, forKey: .smoothingLatency)
        smoothingLatency = smoothingLatencyDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let vpcInterfaceAttachmentDecoded = try containerValues.decodeIfPresent(VpcInterfaceAttachment.self, forKey: .vpcInterfaceAttachment)
        vpcInterfaceAttachment = vpcInterfaceAttachmentDecoded
    }
}

extension AddOutputRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddOutputRequest(cidrAllowList: \(String(describing: cidrAllowList)), description: \(String(describing: description)), destination: \(String(describing: destination)), encryption: \(String(describing: encryption)), maxLatency: \(String(describing: maxLatency)), mediaStreamOutputConfigurations: \(String(describing: mediaStreamOutputConfigurations)), minLatency: \(String(describing: minLatency)), name: \(String(describing: name)), port: \(String(describing: port)), protocol: \(String(describing: `protocol`)), remoteId: \(String(describing: remoteId)), smoothingLatency: \(String(describing: smoothingLatency)), streamId: \(String(describing: streamId)), vpcInterfaceAttachment: \(String(describing: vpcInterfaceAttachment)))"}
}

/// The output that you want to add to this flow.
public struct AddOutputRequest: Equatable {
    /// The protocol to use for the output.
    public let `protocol`: `Protocol`?
    /// The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    public let cidrAllowList: [String]?
    /// A description of the output. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the end user.
    public let description: String?
    /// The IP address from which video will be sent to output destinations.
    public let destination: String?
    /// The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
    public let encryption: Encryption?
    /// The maximum latency in milliseconds for Zixi-based streams.
    public let maxLatency: Int
    /// The media streams that are associated with the output, and the parameters for those associations.
    public let mediaStreamOutputConfigurations: [MediaStreamOutputConfigurationRequest]?
    /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
    public let minLatency: Int
    /// The name of the output. This value must be unique within the current flow.
    public let name: String?
    /// The port to use when content is distributed to this output.
    public let port: Int
    /// The remote ID for the Zixi-pull output stream.
    public let remoteId: String?
    /// The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
    public let smoothingLatency: Int
    /// The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
    public let streamId: String?
    /// The name of the VPC interface attachment to use for this output.
    public let vpcInterfaceAttachment: VpcInterfaceAttachment?

    public init (
        `protocol`: `Protocol`? = nil,
        cidrAllowList: [String]? = nil,
        description: String? = nil,
        destination: String? = nil,
        encryption: Encryption? = nil,
        maxLatency: Int = 0,
        mediaStreamOutputConfigurations: [MediaStreamOutputConfigurationRequest]? = nil,
        minLatency: Int = 0,
        name: String? = nil,
        port: Int = 0,
        remoteId: String? = nil,
        smoothingLatency: Int = 0,
        streamId: String? = nil,
        vpcInterfaceAttachment: VpcInterfaceAttachment? = nil
    )
    {
        self.`protocol` = `protocol`
        self.cidrAllowList = cidrAllowList
        self.description = description
        self.destination = destination
        self.encryption = encryption
        self.maxLatency = maxLatency
        self.mediaStreamOutputConfigurations = mediaStreamOutputConfigurations
        self.minLatency = minLatency
        self.name = name
        self.port = port
        self.remoteId = remoteId
        self.smoothingLatency = smoothingLatency
        self.streamId = streamId
        self.vpcInterfaceAttachment = vpcInterfaceAttachment
    }
}

public enum Algorithm {
    case aes128
    case aes192
    case aes256
    case sdkUnknown(String)
}

extension Algorithm : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Algorithm] {
        return [
            .aes128,
            .aes192,
            .aes256,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aes128: return "aes128"
        case .aes192: return "aes192"
        case .aes256: return "aes256"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Algorithm(rawValue: rawValue) ?? Algorithm.sdkUnknown(rawValue)
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The error message returned by AWS Elemental MediaConnect.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Colorimetry {
    case bt2020
    case bt2100
    case bt601
    case bt709
    case st20651
    case st20653
    case xyz
    case sdkUnknown(String)
}

extension Colorimetry : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Colorimetry] {
        return [
            .bt2020,
            .bt2100,
            .bt601,
            .bt709,
            .st20651,
            .st20653,
            .xyz,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bt2020: return "BT2020"
        case .bt2100: return "BT2100"
        case .bt601: return "BT601"
        case .bt709: return "BT709"
        case .st20651: return "ST2065-1"
        case .st20653: return "ST2065-3"
        case .xyz: return "XYZ"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Colorimetry(rawValue: rawValue) ?? Colorimetry.sdkUnknown(rawValue)
    }
}

extension CreateFlow420Exception: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFlow420Exception(message: \(String(describing: message)))"}
}

extension CreateFlow420Exception: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFlow420ExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct CreateFlow420Exception: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The error message returned by AWS Elemental MediaConnect.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CreateFlow420ExceptionBody: Equatable {
    public let message: String?
}

extension CreateFlow420ExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateFlowInputBodyMiddleware: Middleware {
    public let id: String = "CreateFlowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFlowInput>
    public typealias MOutput = OperationOutput<CreateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFlowOutputError>
}

extension CreateFlowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFlowInput(availabilityZone: \(String(describing: availabilityZone)), entitlements: \(String(describing: entitlements)), mediaStreams: \(String(describing: mediaStreams)), name: \(String(describing: name)), outputs: \(String(describing: outputs)), source: \(String(describing: source)), sourceFailoverConfig: \(String(describing: sourceFailoverConfig)), sources: \(String(describing: sources)), vpcInterfaces: \(String(describing: vpcInterfaces)))"}
}

extension CreateFlowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "availabilityZone"
        case entitlements = "entitlements"
        case mediaStreams = "mediaStreams"
        case name = "name"
        case outputs = "outputs"
        case source = "source"
        case sourceFailoverConfig = "sourceFailoverConfig"
        case sources = "sources"
        case vpcInterfaces = "vpcInterfaces"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for __listofgrantentitlementrequest0 in entitlements {
                try entitlementsContainer.encode(__listofgrantentitlementrequest0)
            }
        }
        if let mediaStreams = mediaStreams {
            var mediaStreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreams)
            for __listofaddmediastreamrequest0 in mediaStreams {
                try mediaStreamsContainer.encode(__listofaddmediastreamrequest0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for __listofaddoutputrequest0 in outputs {
                try outputsContainer.encode(__listofaddoutputrequest0)
            }
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceFailoverConfig = sourceFailoverConfig {
            try encodeContainer.encode(sourceFailoverConfig, forKey: .sourceFailoverConfig)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for __listofsetsourcerequest0 in sources {
                try sourcesContainer.encode(__listofsetsourcerequest0)
            }
        }
        if let vpcInterfaces = vpcInterfaces {
            var vpcInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcInterfaces)
            for __listofvpcinterfacerequest0 in vpcInterfaces {
                try vpcInterfacesContainer.encode(__listofvpcinterfacerequest0)
            }
        }
    }
}

public struct CreateFlowInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFlowInput>
    public typealias MOutput = OperationOutput<CreateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFlowOutputError>
}

public struct CreateFlowInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFlowInput>
    public typealias MOutput = OperationOutput<CreateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFlowOutputError>
}

/// Creates a new flow. The request must include one source. The request optionally can include outputs (up to 50) and entitlements (up to 50).
public struct CreateFlowInput: Equatable {
    /// The Availability Zone that you want to create the flow in. These options are limited to the Availability Zones within the current AWS Region.
    public let availabilityZone: String?
    /// The entitlements that you want to grant on a flow.
    public let entitlements: [GrantEntitlementRequest]?
    /// The media streams that you want to add to the flow. You can associate these media streams with sources and outputs on the flow.
    public let mediaStreams: [AddMediaStreamRequest]?
    /// The name of the flow.
    public let name: String?
    /// The outputs that you want to add to this flow.
    public let outputs: [AddOutputRequest]?
    /// The settings for the source of the flow.
    public let source: SetSourceRequest?
    /// The settings for source failover
    public let sourceFailoverConfig: FailoverConfig?
    public let sources: [SetSourceRequest]?
    /// The VPC interfaces you want on the flow.
    public let vpcInterfaces: [VpcInterfaceRequest]?

    public init (
        availabilityZone: String? = nil,
        entitlements: [GrantEntitlementRequest]? = nil,
        mediaStreams: [AddMediaStreamRequest]? = nil,
        name: String? = nil,
        outputs: [AddOutputRequest]? = nil,
        source: SetSourceRequest? = nil,
        sourceFailoverConfig: FailoverConfig? = nil,
        sources: [SetSourceRequest]? = nil,
        vpcInterfaces: [VpcInterfaceRequest]? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.entitlements = entitlements
        self.mediaStreams = mediaStreams
        self.name = name
        self.outputs = outputs
        self.source = source
        self.sourceFailoverConfig = sourceFailoverConfig
        self.sources = sources
        self.vpcInterfaces = vpcInterfaces
    }
}

struct CreateFlowInputBody: Equatable {
    public let availabilityZone: String?
    public let entitlements: [GrantEntitlementRequest]?
    public let mediaStreams: [AddMediaStreamRequest]?
    public let name: String?
    public let outputs: [AddOutputRequest]?
    public let source: SetSourceRequest?
    public let sourceFailoverConfig: FailoverConfig?
    public let sources: [SetSourceRequest]?
    public let vpcInterfaces: [VpcInterfaceRequest]?
}

extension CreateFlowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "availabilityZone"
        case entitlements = "entitlements"
        case mediaStreams = "mediaStreams"
        case name = "name"
        case outputs = "outputs"
        case source = "source"
        case sourceFailoverConfig = "sourceFailoverConfig"
        case sources = "sources"
        case vpcInterfaces = "vpcInterfaces"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([GrantEntitlementRequest?].self, forKey: .entitlements)
        var entitlementsDecoded0:[GrantEntitlementRequest]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [GrantEntitlementRequest]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let mediaStreamsContainer = try containerValues.decodeIfPresent([AddMediaStreamRequest?].self, forKey: .mediaStreams)
        var mediaStreamsDecoded0:[AddMediaStreamRequest]? = nil
        if let mediaStreamsContainer = mediaStreamsContainer {
            mediaStreamsDecoded0 = [AddMediaStreamRequest]()
            for structure0 in mediaStreamsContainer {
                if let structure0 = structure0 {
                    mediaStreamsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreams = mediaStreamsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let outputsContainer = try containerValues.decodeIfPresent([AddOutputRequest?].self, forKey: .outputs)
        var outputsDecoded0:[AddOutputRequest]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [AddOutputRequest]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(SetSourceRequest.self, forKey: .source)
        source = sourceDecoded
        let sourceFailoverConfigDecoded = try containerValues.decodeIfPresent(FailoverConfig.self, forKey: .sourceFailoverConfig)
        sourceFailoverConfig = sourceFailoverConfigDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SetSourceRequest?].self, forKey: .sources)
        var sourcesDecoded0:[SetSourceRequest]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SetSourceRequest]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let vpcInterfacesContainer = try containerValues.decodeIfPresent([VpcInterfaceRequest?].self, forKey: .vpcInterfaces)
        var vpcInterfacesDecoded0:[VpcInterfaceRequest]? = nil
        if let vpcInterfacesContainer = vpcInterfacesContainer {
            vpcInterfacesDecoded0 = [VpcInterfaceRequest]()
            for structure0 in vpcInterfacesContainer {
                if let structure0 = structure0 {
                    vpcInterfacesDecoded0?.append(structure0)
                }
            }
        }
        vpcInterfaces = vpcInterfacesDecoded0
    }
}

extension CreateFlowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFlowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CreateFlow420Exception" : self = .createFlow420Exception(try CreateFlow420Exception(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFlowOutputError: Equatable {
    case badRequestException(BadRequestException)
    case createFlow420Exception(CreateFlow420Exception)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFlowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFlowOutputResponse(flow: \(String(describing: flow)))"}
}

extension CreateFlowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFlowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flow = output.flow
        } else {
            self.flow = nil
        }
    }
}

public struct CreateFlowOutputResponse: Equatable {
    /// The settings for a flow, including its source, outputs, and entitlements.
    public let flow: Flow?

    public init (
        flow: Flow? = nil
    )
    {
        self.flow = flow
    }
}

struct CreateFlowOutputResponseBody: Equatable {
    public let flow: Flow?
}

extension CreateFlowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flow = "flow"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowDecoded = try containerValues.decodeIfPresent(Flow.self, forKey: .flow)
        flow = flowDecoded
    }
}

extension DeleteFlowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFlowInput(flowArn: \(String(describing: flowArn)))"}
}

extension DeleteFlowInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteFlowInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFlowInput>
    public typealias MOutput = OperationOutput<DeleteFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFlowOutputError>
}

public struct DeleteFlowInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFlowInput>
    public typealias MOutput = OperationOutput<DeleteFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFlowOutputError>
}

public struct DeleteFlowInput: Equatable {
    /// The ARN of the flow that you want to delete.
    public let flowArn: String?

    public init (
        flowArn: String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

struct DeleteFlowInputBody: Equatable {
}

extension DeleteFlowInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFlowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFlowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFlowOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFlowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFlowOutputResponse(flowArn: \(String(describing: flowArn)), status: \(String(describing: status)))"}
}

extension DeleteFlowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteFlowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flowArn = output.flowArn
            self.status = output.status
        } else {
            self.flowArn = nil
            self.status = nil
        }
    }
}

public struct DeleteFlowOutputResponse: Equatable {
    /// The ARN of the flow that was deleted.
    public let flowArn: String?
    /// The status of the flow when the DeleteFlow process begins.
    public let status: Status?

    public init (
        flowArn: String? = nil,
        status: Status? = nil
    )
    {
        self.flowArn = flowArn
        self.status = status
    }
}

struct DeleteFlowOutputResponseBody: Equatable {
    public let flowArn: String?
    public let status: Status?
}

extension DeleteFlowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowArn = "flowArn"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeFlowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFlowInput(flowArn: \(String(describing: flowArn)))"}
}

extension DescribeFlowInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeFlowInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFlowInput>
    public typealias MOutput = OperationOutput<DescribeFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFlowOutputError>
}

public struct DescribeFlowInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFlowInput>
    public typealias MOutput = OperationOutput<DescribeFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFlowOutputError>
}

public struct DescribeFlowInput: Equatable {
    /// The ARN of the flow that you want to describe.
    public let flowArn: String?

    public init (
        flowArn: String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

struct DescribeFlowInputBody: Equatable {
}

extension DescribeFlowInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeFlowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFlowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFlowOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFlowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFlowOutputResponse(flow: \(String(describing: flow)), messages: \(String(describing: messages)))"}
}

extension DescribeFlowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFlowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flow = output.flow
            self.messages = output.messages
        } else {
            self.flow = nil
            self.messages = nil
        }
    }
}

public struct DescribeFlowOutputResponse: Equatable {
    /// The settings for a flow, including its source, outputs, and entitlements.
    public let flow: Flow?
    /// Messages that provide the state of the flow.
    public let messages: Messages?

    public init (
        flow: Flow? = nil,
        messages: Messages? = nil
    )
    {
        self.flow = flow
        self.messages = messages
    }
}

struct DescribeFlowOutputResponseBody: Equatable {
    public let flow: Flow?
    public let messages: Messages?
}

extension DescribeFlowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flow = "flow"
        case messages = "messages"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowDecoded = try containerValues.decodeIfPresent(Flow.self, forKey: .flow)
        flow = flowDecoded
        let messagesDecoded = try containerValues.decodeIfPresent(Messages.self, forKey: .messages)
        messages = messagesDecoded
    }
}

extension DescribeOfferingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOfferingInput(offeringArn: \(String(describing: offeringArn)))"}
}

extension DescribeOfferingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeOfferingInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOfferingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOfferingInput>
    public typealias MOutput = OperationOutput<DescribeOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOfferingOutputError>
}

public struct DescribeOfferingInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOfferingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOfferingInput>
    public typealias MOutput = OperationOutput<DescribeOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOfferingOutputError>
}

public struct DescribeOfferingInput: Equatable {
    /// The Amazon Resource Name (ARN) of the offering.
    public let offeringArn: String?

    public init (
        offeringArn: String? = nil
    )
    {
        self.offeringArn = offeringArn
    }
}

struct DescribeOfferingInputBody: Equatable {
}

extension DescribeOfferingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeOfferingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOfferingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOfferingOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOfferingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOfferingOutputResponse(offering: \(String(describing: offering)))"}
}

extension DescribeOfferingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOfferingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.offering = output.offering
        } else {
            self.offering = nil
        }
    }
}

public struct DescribeOfferingOutputResponse: Equatable {
    /// A savings plan that reserves a certain amount of outbound bandwidth usage at a discounted rate each month over a period of time.
    public let offering: Offering?

    public init (
        offering: Offering? = nil
    )
    {
        self.offering = offering
    }
}

struct DescribeOfferingOutputResponseBody: Equatable {
    public let offering: Offering?
}

extension DescribeOfferingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case offering = "offering"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringDecoded = try containerValues.decodeIfPresent(Offering.self, forKey: .offering)
        offering = offeringDecoded
    }
}

extension DescribeReservationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReservationInput(reservationArn: \(String(describing: reservationArn)))"}
}

extension DescribeReservationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeReservationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReservationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReservationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReservationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReservationInput>
    public typealias MOutput = OperationOutput<DescribeReservationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReservationOutputError>
}

public struct DescribeReservationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReservationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReservationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReservationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReservationInput>
    public typealias MOutput = OperationOutput<DescribeReservationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReservationOutputError>
}

public struct DescribeReservationInput: Equatable {
    /// The Amazon Resource Name (ARN) of the reservation.
    public let reservationArn: String?

    public init (
        reservationArn: String? = nil
    )
    {
        self.reservationArn = reservationArn
    }
}

struct DescribeReservationInputBody: Equatable {
}

extension DescribeReservationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeReservationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReservationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReservationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReservationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReservationOutputResponse(reservation: \(String(describing: reservation)))"}
}

extension DescribeReservationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReservationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.reservation = output.reservation
        } else {
            self.reservation = nil
        }
    }
}

public struct DescribeReservationOutputResponse: Equatable {
    /// A pricing agreement for a discounted rate for a specific outbound bandwidth that your MediaConnect account will use each month over a specific time period. The discounted rate in the reservation applies to outbound bandwidth for all flows from your account until your account reaches the amount of bandwidth in your reservation. If you use more outbound bandwidth than the agreed upon amount in a single month, the overage is charged at the on-demand rate.
    public let reservation: Reservation?

    public init (
        reservation: Reservation? = nil
    )
    {
        self.reservation = reservation
    }
}

struct DescribeReservationOutputResponseBody: Equatable {
    public let reservation: Reservation?
}

extension DescribeReservationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reservation = "reservation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservationDecoded = try containerValues.decodeIfPresent(Reservation.self, forKey: .reservation)
        reservation = reservationDecoded
    }
}

extension DestinationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationIp = "destinationIp"
        case destinationPort = "destinationPort"
        case interface = "interface"
        case outboundIp = "outboundIp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationIp = destinationIp {
            try encodeContainer.encode(destinationIp, forKey: .destinationIp)
        }
        if destinationPort != 0 {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let interface = interface {
            try encodeContainer.encode(interface, forKey: .interface)
        }
        if let outboundIp = outboundIp {
            try encodeContainer.encode(outboundIp, forKey: .outboundIp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationIp)
        destinationIp = destinationIpDecoded
        let destinationPortDecoded = try containerValues.decode(Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let interfaceDecoded = try containerValues.decodeIfPresent(Interface.self, forKey: .interface)
        interface = interfaceDecoded
        let outboundIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outboundIp)
        outboundIp = outboundIpDecoded
    }
}

extension DestinationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DestinationConfiguration(destinationIp: \(String(describing: destinationIp)), destinationPort: \(String(describing: destinationPort)), interface: \(String(describing: interface)), outboundIp: \(String(describing: outboundIp)))"}
}

/// The transport parameters that are associated with an outbound media stream.
public struct DestinationConfiguration: Equatable {
    /// The IP address where contents of the media stream will be sent.
    public let destinationIp: String?
    /// The port to use when the content of the media stream is distributed to the output.
    public let destinationPort: Int
    /// The VPC interface that is used for the media stream associated with the output.
    public let interface: Interface?
    /// The IP address that the receiver requires in order to establish a connection with the flow. This value is represented by the elastic network interface IP address of the VPC. This field applies only to outputs that use the CDI or ST 2110 JPEG XS protocol.
    public let outboundIp: String?

    public init (
        destinationIp: String? = nil,
        destinationPort: Int = 0,
        interface: Interface? = nil,
        outboundIp: String? = nil
    )
    {
        self.destinationIp = destinationIp
        self.destinationPort = destinationPort
        self.interface = interface
        self.outboundIp = outboundIp
    }
}

extension DestinationConfigurationRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationIp = "destinationIp"
        case destinationPort = "destinationPort"
        case interface = "interface"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationIp = destinationIp {
            try encodeContainer.encode(destinationIp, forKey: .destinationIp)
        }
        if destinationPort != 0 {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let interface = interface {
            try encodeContainer.encode(interface, forKey: .interface)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationIp)
        destinationIp = destinationIpDecoded
        let destinationPortDecoded = try containerValues.decode(Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let interfaceDecoded = try containerValues.decodeIfPresent(InterfaceRequest.self, forKey: .interface)
        interface = interfaceDecoded
    }
}

extension DestinationConfigurationRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DestinationConfigurationRequest(destinationIp: \(String(describing: destinationIp)), destinationPort: \(String(describing: destinationPort)), interface: \(String(describing: interface)))"}
}

/// The transport parameters that you want to associate with an outbound media stream.
public struct DestinationConfigurationRequest: Equatable {
    /// The IP address where you want MediaConnect to send contents of the media stream.
    public let destinationIp: String?
    /// The port that you want MediaConnect to use when it distributes the media stream to the output.
    public let destinationPort: Int
    /// The VPC interface that you want to use for the media stream associated with the output.
    public let interface: InterfaceRequest?

    public init (
        destinationIp: String? = nil,
        destinationPort: Int = 0,
        interface: InterfaceRequest? = nil
    )
    {
        self.destinationIp = destinationIp
        self.destinationPort = destinationPort
        self.interface = interface
    }
}

public enum DurationUnits {
    case months
    case sdkUnknown(String)
}

extension DurationUnits : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DurationUnits] {
        return [
            .months,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .months: return "MONTHS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DurationUnits(rawValue: rawValue) ?? DurationUnits.sdkUnknown(rawValue)
    }
}

public enum EncoderProfile {
    case high
    case main
    case sdkUnknown(String)
}

extension EncoderProfile : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncoderProfile] {
        return [
            .high,
            .main,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .high: return "high"
        case .main: return "main"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncoderProfile(rawValue: rawValue) ?? EncoderProfile.sdkUnknown(rawValue)
    }
}

public enum EncodingName {
    case jxsv
    case pcm
    case raw
    case smpte291
    case sdkUnknown(String)
}

extension EncodingName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncodingName] {
        return [
            .jxsv,
            .pcm,
            .raw,
            .smpte291,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .jxsv: return "jxsv"
        case .pcm: return "pcm"
        case .raw: return "raw"
        case .smpte291: return "smpte291"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncodingName(rawValue: rawValue) ?? EncodingName.sdkUnknown(rawValue)
    }
}

extension EncodingParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compressionFactor = "compressionFactor"
        case encoderProfile = "encoderProfile"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if compressionFactor != 0.0 {
            try encodeContainer.encode(compressionFactor, forKey: .compressionFactor)
        }
        if let encoderProfile = encoderProfile {
            try encodeContainer.encode(encoderProfile.rawValue, forKey: .encoderProfile)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compressionFactorDecoded = try containerValues.decode(Double.self, forKey: .compressionFactor)
        compressionFactor = compressionFactorDecoded
        let encoderProfileDecoded = try containerValues.decodeIfPresent(EncoderProfile.self, forKey: .encoderProfile)
        encoderProfile = encoderProfileDecoded
    }
}

extension EncodingParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncodingParameters(compressionFactor: \(String(describing: compressionFactor)), encoderProfile: \(String(describing: encoderProfile)))"}
}

/// A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
public struct EncodingParameters: Equatable {
    /// A value that is used to calculate compression for an output. The bitrate of the output is calculated as follows: Output bitrate = (1 / compressionFactor) * (source bitrate) This property only applies to outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol. Valid values are floating point numbers in the range of 3.0 to 10.0, inclusive.
    public let compressionFactor: Double
    /// A setting on the encoder that drives compression settings. This property only applies to video media streams associated with outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol.
    public let encoderProfile: EncoderProfile?

    public init (
        compressionFactor: Double = 0.0,
        encoderProfile: EncoderProfile? = nil
    )
    {
        self.compressionFactor = compressionFactor
        self.encoderProfile = encoderProfile
    }
}

extension EncodingParametersRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compressionFactor = "compressionFactor"
        case encoderProfile = "encoderProfile"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if compressionFactor != 0.0 {
            try encodeContainer.encode(compressionFactor, forKey: .compressionFactor)
        }
        if let encoderProfile = encoderProfile {
            try encodeContainer.encode(encoderProfile.rawValue, forKey: .encoderProfile)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compressionFactorDecoded = try containerValues.decode(Double.self, forKey: .compressionFactor)
        compressionFactor = compressionFactorDecoded
        let encoderProfileDecoded = try containerValues.decodeIfPresent(EncoderProfile.self, forKey: .encoderProfile)
        encoderProfile = encoderProfileDecoded
    }
}

extension EncodingParametersRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncodingParametersRequest(compressionFactor: \(String(describing: compressionFactor)), encoderProfile: \(String(describing: encoderProfile)))"}
}

/// A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
public struct EncodingParametersRequest: Equatable {
    /// A value that is used to calculate compression for an output. The bitrate of the output is calculated as follows: Output bitrate = (1 / compressionFactor) * (source bitrate) This property only applies to outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol. Valid values are floating point numbers in the range of 3.0 to 10.0, inclusive.
    public let compressionFactor: Double
    /// A setting on the encoder that drives compression settings. This property only applies to video media streams associated with outputs that use the ST 2110 JPEG XS protocol, if at least one source on the flow uses the CDI protocol.
    public let encoderProfile: EncoderProfile?

    public init (
        compressionFactor: Double = 0.0,
        encoderProfile: EncoderProfile? = nil
    )
    {
        self.compressionFactor = compressionFactor
        self.encoderProfile = encoderProfile
    }
}

extension Encryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case algorithm = "algorithm"
        case constantInitializationVector = "constantInitializationVector"
        case deviceId = "deviceId"
        case keyType = "keyType"
        case region = "region"
        case resourceId = "resourceId"
        case roleArn = "roleArn"
        case secretArn = "secretArn"
        case url = "url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithm = algorithm {
            try encodeContainer.encode(algorithm.rawValue, forKey: .algorithm)
        }
        if let constantInitializationVector = constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let keyType = keyType {
            try encodeContainer.encode(keyType.rawValue, forKey: .keyType)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmDecoded = try containerValues.decodeIfPresent(Algorithm.self, forKey: .algorithm)
        algorithm = algorithmDecoded
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(KeyType.self, forKey: .keyType)
        keyType = keyTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension Encryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Encryption(algorithm: \(String(describing: algorithm)), constantInitializationVector: \(String(describing: constantInitializationVector)), deviceId: \(String(describing: deviceId)), keyType: \(String(describing: keyType)), region: \(String(describing: region)), resourceId: \(String(describing: resourceId)), roleArn: \(String(describing: roleArn)), secretArn: \(String(describing: secretArn)), url: \(String(describing: url)))"}
}

/// Information about the encryption of the flow.
public struct Encryption: Equatable {
    /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
    public let algorithm: Algorithm?
    /// A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
    public let constantInitializationVector: String?
    /// The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
    public let deviceId: String?
    /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
    public let keyType: KeyType?
    /// The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
    public let region: String?
    /// An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
    public let resourceId: String?
    /// The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
    public let roleArn: String?
    /// The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
    public let secretArn: String?
    /// The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
    public let url: String?

    public init (
        algorithm: Algorithm? = nil,
        constantInitializationVector: String? = nil,
        deviceId: String? = nil,
        keyType: KeyType? = nil,
        region: String? = nil,
        resourceId: String? = nil,
        roleArn: String? = nil,
        secretArn: String? = nil,
        url: String? = nil
    )
    {
        self.algorithm = algorithm
        self.constantInitializationVector = constantInitializationVector
        self.deviceId = deviceId
        self.keyType = keyType
        self.region = region
        self.resourceId = resourceId
        self.roleArn = roleArn
        self.secretArn = secretArn
        self.url = url
    }
}

extension Entitlement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataTransferSubscriberFeePercent = "dataTransferSubscriberFeePercent"
        case description = "description"
        case encryption = "encryption"
        case entitlementArn = "entitlementArn"
        case entitlementStatus = "entitlementStatus"
        case name = "name"
        case subscribers = "subscribers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dataTransferSubscriberFeePercent != 0 {
            try encodeContainer.encode(dataTransferSubscriberFeePercent, forKey: .dataTransferSubscriberFeePercent)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let entitlementArn = entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if let entitlementStatus = entitlementStatus {
            try encodeContainer.encode(entitlementStatus.rawValue, forKey: .entitlementStatus)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for __listof__string0 in subscribers {
                try subscribersContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTransferSubscriberFeePercentDecoded = try containerValues.decode(Int.self, forKey: .dataTransferSubscriberFeePercent)
        dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let entitlementStatusDecoded = try containerValues.decodeIfPresent(EntitlementStatus.self, forKey: .entitlementStatus)
        entitlementStatus = entitlementStatusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subscribers)
        var subscribersDecoded0:[String]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [String]()
            for string0 in subscribersContainer {
                if let string0 = string0 {
                    subscribersDecoded0?.append(string0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension Entitlement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Entitlement(dataTransferSubscriberFeePercent: \(String(describing: dataTransferSubscriberFeePercent)), description: \(String(describing: description)), encryption: \(String(describing: encryption)), entitlementArn: \(String(describing: entitlementArn)), entitlementStatus: \(String(describing: entitlementStatus)), name: \(String(describing: name)), subscribers: \(String(describing: subscribers)))"}
}

/// The settings for a flow entitlement.
public struct Entitlement: Equatable {
    /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
    public let dataTransferSubscriberFeePercent: Int
    /// A description of the entitlement.
    public let description: String?
    /// The type of encryption that will be used on the output that is associated with this entitlement.
    public let encryption: Encryption?
    /// The ARN of the entitlement.
    public let entitlementArn: String?
    /// An indication of whether the entitlement is enabled.
    public let entitlementStatus: EntitlementStatus?
    /// The name of the entitlement.
    public let name: String?
    /// The AWS account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flow using your content as the source.
    public let subscribers: [String]?

    public init (
        dataTransferSubscriberFeePercent: Int = 0,
        description: String? = nil,
        encryption: Encryption? = nil,
        entitlementArn: String? = nil,
        entitlementStatus: EntitlementStatus? = nil,
        name: String? = nil,
        subscribers: [String]? = nil
    )
    {
        self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
        self.description = description
        self.encryption = encryption
        self.entitlementArn = entitlementArn
        self.entitlementStatus = entitlementStatus
        self.name = name
        self.subscribers = subscribers
    }
}

public enum EntitlementStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension EntitlementStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EntitlementStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EntitlementStatus(rawValue: rawValue) ?? EntitlementStatus.sdkUnknown(rawValue)
    }
}

extension FailoverConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recoveryWindow = "recoveryWindow"
        case state = "state"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if recoveryWindow != 0 {
            try encodeContainer.encode(recoveryWindow, forKey: .recoveryWindow)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryWindowDecoded = try containerValues.decode(Int.self, forKey: .recoveryWindow)
        recoveryWindow = recoveryWindowDecoded
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
    }
}

extension FailoverConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailoverConfig(recoveryWindow: \(String(describing: recoveryWindow)), state: \(String(describing: state)))"}
}

/// The settings for source failover
public struct FailoverConfig: Equatable {
    /// Search window time to look for dash-7 packets
    public let recoveryWindow: Int
    public let state: State?

    public init (
        recoveryWindow: Int = 0,
        state: State? = nil
    )
    {
        self.recoveryWindow = recoveryWindow
        self.state = state
    }
}

extension Flow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "availabilityZone"
        case description = "description"
        case egressIp = "egressIp"
        case entitlements = "entitlements"
        case flowArn = "flowArn"
        case mediaStreams = "mediaStreams"
        case name = "name"
        case outputs = "outputs"
        case source = "source"
        case sourceFailoverConfig = "sourceFailoverConfig"
        case sources = "sources"
        case status = "status"
        case vpcInterfaces = "vpcInterfaces"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let egressIp = egressIp {
            try encodeContainer.encode(egressIp, forKey: .egressIp)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for __listofentitlement0 in entitlements {
                try entitlementsContainer.encode(__listofentitlement0)
            }
        }
        if let flowArn = flowArn {
            try encodeContainer.encode(flowArn, forKey: .flowArn)
        }
        if let mediaStreams = mediaStreams {
            var mediaStreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreams)
            for __listofmediastream0 in mediaStreams {
                try mediaStreamsContainer.encode(__listofmediastream0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for __listofoutput0 in outputs {
                try outputsContainer.encode(__listofoutput0)
            }
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceFailoverConfig = sourceFailoverConfig {
            try encodeContainer.encode(sourceFailoverConfig, forKey: .sourceFailoverConfig)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for __listofsource0 in sources {
                try sourcesContainer.encode(__listofsource0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let vpcInterfaces = vpcInterfaces {
            var vpcInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcInterfaces)
            for __listofvpcinterface0 in vpcInterfaces {
                try vpcInterfacesContainer.encode(__listofvpcinterface0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let egressIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .egressIp)
        egressIp = egressIpDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let mediaStreamsContainer = try containerValues.decodeIfPresent([MediaStream?].self, forKey: .mediaStreams)
        var mediaStreamsDecoded0:[MediaStream]? = nil
        if let mediaStreamsContainer = mediaStreamsContainer {
            mediaStreamsDecoded0 = [MediaStream]()
            for structure0 in mediaStreamsContainer {
                if let structure0 = structure0 {
                    mediaStreamsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreams = mediaStreamsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let outputsContainer = try containerValues.decodeIfPresent([Output?].self, forKey: .outputs)
        var outputsDecoded0:[Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .source)
        source = sourceDecoded
        let sourceFailoverConfigDecoded = try containerValues.decodeIfPresent(FailoverConfig.self, forKey: .sourceFailoverConfig)
        sourceFailoverConfig = sourceFailoverConfigDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([Source?].self, forKey: .sources)
        var sourcesDecoded0:[Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
        let vpcInterfacesContainer = try containerValues.decodeIfPresent([VpcInterface?].self, forKey: .vpcInterfaces)
        var vpcInterfacesDecoded0:[VpcInterface]? = nil
        if let vpcInterfacesContainer = vpcInterfacesContainer {
            vpcInterfacesDecoded0 = [VpcInterface]()
            for structure0 in vpcInterfacesContainer {
                if let structure0 = structure0 {
                    vpcInterfacesDecoded0?.append(structure0)
                }
            }
        }
        vpcInterfaces = vpcInterfacesDecoded0
    }
}

extension Flow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Flow(availabilityZone: \(String(describing: availabilityZone)), description: \(String(describing: description)), egressIp: \(String(describing: egressIp)), entitlements: \(String(describing: entitlements)), flowArn: \(String(describing: flowArn)), mediaStreams: \(String(describing: mediaStreams)), name: \(String(describing: name)), outputs: \(String(describing: outputs)), source: \(String(describing: source)), sourceFailoverConfig: \(String(describing: sourceFailoverConfig)), sources: \(String(describing: sources)), status: \(String(describing: status)), vpcInterfaces: \(String(describing: vpcInterfaces)))"}
}

/// The settings for a flow, including its source, outputs, and entitlements.
public struct Flow: Equatable {
    /// The Availability Zone that you want to create the flow in. These options are limited to the Availability Zones within the current AWS.
    public let availabilityZone: String?
    /// A description of the flow. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
    public let description: String?
    /// The IP address from which video will be sent to output destinations.
    public let egressIp: String?
    /// The entitlements in this flow.
    public let entitlements: [Entitlement]?
    /// The Amazon Resource Name (ARN), a unique identifier for any AWS resource, of the flow.
    public let flowArn: String?
    /// The media streams that are associated with the flow. After you associate a media stream with a source, you can also associate it with outputs on the flow.
    public let mediaStreams: [MediaStream]?
    /// The name of the flow.
    public let name: String?
    /// The outputs in this flow.
    public let outputs: [Output]?
    /// The settings for the source of the flow.
    public let source: Source?
    /// The settings for source failover
    public let sourceFailoverConfig: FailoverConfig?
    public let sources: [Source]?
    /// The current status of the flow.
    public let status: Status?
    /// The VPC Interfaces for this flow.
    public let vpcInterfaces: [VpcInterface]?

    public init (
        availabilityZone: String? = nil,
        description: String? = nil,
        egressIp: String? = nil,
        entitlements: [Entitlement]? = nil,
        flowArn: String? = nil,
        mediaStreams: [MediaStream]? = nil,
        name: String? = nil,
        outputs: [Output]? = nil,
        source: Source? = nil,
        sourceFailoverConfig: FailoverConfig? = nil,
        sources: [Source]? = nil,
        status: Status? = nil,
        vpcInterfaces: [VpcInterface]? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.description = description
        self.egressIp = egressIp
        self.entitlements = entitlements
        self.flowArn = flowArn
        self.mediaStreams = mediaStreams
        self.name = name
        self.outputs = outputs
        self.source = source
        self.sourceFailoverConfig = sourceFailoverConfig
        self.sources = sources
        self.status = status
        self.vpcInterfaces = vpcInterfaces
    }
}

extension Fmtp: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelOrder = "channelOrder"
        case colorimetry = "colorimetry"
        case exactFramerate = "exactFramerate"
        case par = "par"
        case range = "range"
        case scanMode = "scanMode"
        case tcs = "tcs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelOrder = channelOrder {
            try encodeContainer.encode(channelOrder, forKey: .channelOrder)
        }
        if let colorimetry = colorimetry {
            try encodeContainer.encode(colorimetry.rawValue, forKey: .colorimetry)
        }
        if let exactFramerate = exactFramerate {
            try encodeContainer.encode(exactFramerate, forKey: .exactFramerate)
        }
        if let par = par {
            try encodeContainer.encode(par, forKey: .par)
        }
        if let range = range {
            try encodeContainer.encode(range.rawValue, forKey: .range)
        }
        if let scanMode = scanMode {
            try encodeContainer.encode(scanMode.rawValue, forKey: .scanMode)
        }
        if let tcs = tcs {
            try encodeContainer.encode(tcs.rawValue, forKey: .tcs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelOrderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelOrder)
        channelOrder = channelOrderDecoded
        let colorimetryDecoded = try containerValues.decodeIfPresent(Colorimetry.self, forKey: .colorimetry)
        colorimetry = colorimetryDecoded
        let exactFramerateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exactFramerate)
        exactFramerate = exactFramerateDecoded
        let parDecoded = try containerValues.decodeIfPresent(String.self, forKey: .par)
        par = parDecoded
        let rangeDecoded = try containerValues.decodeIfPresent(Range.self, forKey: .range)
        range = rangeDecoded
        let scanModeDecoded = try containerValues.decodeIfPresent(ScanMode.self, forKey: .scanMode)
        scanMode = scanModeDecoded
        let tcsDecoded = try containerValues.decodeIfPresent(Tcs.self, forKey: .tcs)
        tcs = tcsDecoded
    }
}

extension Fmtp: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Fmtp(channelOrder: \(String(describing: channelOrder)), colorimetry: \(String(describing: colorimetry)), exactFramerate: \(String(describing: exactFramerate)), par: \(String(describing: par)), range: \(String(describing: range)), scanMode: \(String(describing: scanMode)), tcs: \(String(describing: tcs)))"}
}

/// FMTP
public struct Fmtp: Equatable {
    /// The format of the audio channel.
    public let channelOrder: String?
    /// The format that is used for the representation of color.
    public let colorimetry: Colorimetry?
    /// The frame rate for the video stream, in frames/second. For example: 60000/1001. If you specify a whole number, MediaConnect uses a ratio of N/1. For example, if you specify 60, MediaConnect uses 60/1 as the exactFramerate.
    public let exactFramerate: String?
    /// The pixel aspect ratio (PAR) of the video.
    public let par: String?
    /// The encoding range of the video.
    public let range: Range?
    /// The type of compression that was used to smooth the video’s appearance
    public let scanMode: ScanMode?
    /// The transfer characteristic system (TCS) that is used in the video.
    public let tcs: Tcs?

    public init (
        channelOrder: String? = nil,
        colorimetry: Colorimetry? = nil,
        exactFramerate: String? = nil,
        par: String? = nil,
        range: Range? = nil,
        scanMode: ScanMode? = nil,
        tcs: Tcs? = nil
    )
    {
        self.channelOrder = channelOrder
        self.colorimetry = colorimetry
        self.exactFramerate = exactFramerate
        self.par = par
        self.range = range
        self.scanMode = scanMode
        self.tcs = tcs
    }
}

extension FmtpRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelOrder = "channelOrder"
        case colorimetry = "colorimetry"
        case exactFramerate = "exactFramerate"
        case par = "par"
        case range = "range"
        case scanMode = "scanMode"
        case tcs = "tcs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelOrder = channelOrder {
            try encodeContainer.encode(channelOrder, forKey: .channelOrder)
        }
        if let colorimetry = colorimetry {
            try encodeContainer.encode(colorimetry.rawValue, forKey: .colorimetry)
        }
        if let exactFramerate = exactFramerate {
            try encodeContainer.encode(exactFramerate, forKey: .exactFramerate)
        }
        if let par = par {
            try encodeContainer.encode(par, forKey: .par)
        }
        if let range = range {
            try encodeContainer.encode(range.rawValue, forKey: .range)
        }
        if let scanMode = scanMode {
            try encodeContainer.encode(scanMode.rawValue, forKey: .scanMode)
        }
        if let tcs = tcs {
            try encodeContainer.encode(tcs.rawValue, forKey: .tcs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelOrderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelOrder)
        channelOrder = channelOrderDecoded
        let colorimetryDecoded = try containerValues.decodeIfPresent(Colorimetry.self, forKey: .colorimetry)
        colorimetry = colorimetryDecoded
        let exactFramerateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exactFramerate)
        exactFramerate = exactFramerateDecoded
        let parDecoded = try containerValues.decodeIfPresent(String.self, forKey: .par)
        par = parDecoded
        let rangeDecoded = try containerValues.decodeIfPresent(Range.self, forKey: .range)
        range = rangeDecoded
        let scanModeDecoded = try containerValues.decodeIfPresent(ScanMode.self, forKey: .scanMode)
        scanMode = scanModeDecoded
        let tcsDecoded = try containerValues.decodeIfPresent(Tcs.self, forKey: .tcs)
        tcs = tcsDecoded
    }
}

extension FmtpRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FmtpRequest(channelOrder: \(String(describing: channelOrder)), colorimetry: \(String(describing: colorimetry)), exactFramerate: \(String(describing: exactFramerate)), par: \(String(describing: par)), range: \(String(describing: range)), scanMode: \(String(describing: scanMode)), tcs: \(String(describing: tcs)))"}
}

/// The settings that you want to use to define the media stream.
public struct FmtpRequest: Equatable {
    /// The format of the audio channel.
    public let channelOrder: String?
    /// The format that is used for the representation of color.
    public let colorimetry: Colorimetry?
    /// The frame rate for the video stream, in frames/second. For example: 60000/1001. If you specify a whole number, MediaConnect uses a ratio of N/1. For example, if you specify 60, MediaConnect uses 60/1 as the exactFramerate.
    public let exactFramerate: String?
    /// The pixel aspect ratio (PAR) of the video.
    public let par: String?
    /// The encoding range of the video.
    public let range: Range?
    /// The type of compression that was used to smooth the video’s appearance.
    public let scanMode: ScanMode?
    /// The transfer characteristic system (TCS) that is used in the video.
    public let tcs: Tcs?

    public init (
        channelOrder: String? = nil,
        colorimetry: Colorimetry? = nil,
        exactFramerate: String? = nil,
        par: String? = nil,
        range: Range? = nil,
        scanMode: ScanMode? = nil,
        tcs: Tcs? = nil
    )
    {
        self.channelOrder = channelOrder
        self.colorimetry = colorimetry
        self.exactFramerate = exactFramerate
        self.par = par
        self.range = range
        self.scanMode = scanMode
        self.tcs = tcs
    }
}

extension ForbiddenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForbiddenException(message: \(String(describing: message)))"}
}

extension ForbiddenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct ForbiddenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The error message returned by AWS Elemental MediaConnect.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ForbiddenExceptionBody: Equatable {
    public let message: String?
}

extension ForbiddenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GrantEntitlementRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataTransferSubscriberFeePercent = "dataTransferSubscriberFeePercent"
        case description = "description"
        case encryption = "encryption"
        case entitlementStatus = "entitlementStatus"
        case name = "name"
        case subscribers = "subscribers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dataTransferSubscriberFeePercent != 0 {
            try encodeContainer.encode(dataTransferSubscriberFeePercent, forKey: .dataTransferSubscriberFeePercent)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let entitlementStatus = entitlementStatus {
            try encodeContainer.encode(entitlementStatus.rawValue, forKey: .entitlementStatus)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for __listof__string0 in subscribers {
                try subscribersContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTransferSubscriberFeePercentDecoded = try containerValues.decode(Int.self, forKey: .dataTransferSubscriberFeePercent)
        dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let entitlementStatusDecoded = try containerValues.decodeIfPresent(EntitlementStatus.self, forKey: .entitlementStatus)
        entitlementStatus = entitlementStatusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subscribers)
        var subscribersDecoded0:[String]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [String]()
            for string0 in subscribersContainer {
                if let string0 = string0 {
                    subscribersDecoded0?.append(string0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension GrantEntitlementRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrantEntitlementRequest(dataTransferSubscriberFeePercent: \(String(describing: dataTransferSubscriberFeePercent)), description: \(String(describing: description)), encryption: \(String(describing: encryption)), entitlementStatus: \(String(describing: entitlementStatus)), name: \(String(describing: name)), subscribers: \(String(describing: subscribers)))"}
}

/// The entitlements that you want to grant on a flow.
public struct GrantEntitlementRequest: Equatable {
    /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
    public let dataTransferSubscriberFeePercent: Int
    /// A description of the entitlement. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the subscriber or end user.
    public let description: String?
    /// The type of encryption that will be used on the output that is associated with this entitlement.
    public let encryption: Encryption?
    /// An indication of whether the new entitlement should be enabled or disabled as soon as it is created. If you don’t specify the entitlementStatus field in your request, MediaConnect sets it to ENABLED.
    public let entitlementStatus: EntitlementStatus?
    /// The name of the entitlement. This value must be unique within the current flow.
    public let name: String?
    /// The AWS account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flows using your content as the source.
    public let subscribers: [String]?

    public init (
        dataTransferSubscriberFeePercent: Int = 0,
        description: String? = nil,
        encryption: Encryption? = nil,
        entitlementStatus: EntitlementStatus? = nil,
        name: String? = nil,
        subscribers: [String]? = nil
    )
    {
        self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
        self.description = description
        self.encryption = encryption
        self.entitlementStatus = entitlementStatus
        self.name = name
        self.subscribers = subscribers
    }
}

extension GrantFlowEntitlements420Exception: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrantFlowEntitlements420Exception(message: \(String(describing: message)))"}
}

extension GrantFlowEntitlements420Exception: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GrantFlowEntitlements420ExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct GrantFlowEntitlements420Exception: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The error message returned by AWS Elemental MediaConnect.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct GrantFlowEntitlements420ExceptionBody: Equatable {
    public let message: String?
}

extension GrantFlowEntitlements420ExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GrantFlowEntitlementsInputBodyMiddleware: Middleware {
    public let id: String = "GrantFlowEntitlementsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GrantFlowEntitlementsInput>,
                  next: H) -> Swift.Result<OperationOutput<GrantFlowEntitlementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GrantFlowEntitlementsInput>
    public typealias MOutput = OperationOutput<GrantFlowEntitlementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GrantFlowEntitlementsOutputError>
}

extension GrantFlowEntitlementsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrantFlowEntitlementsInput(entitlements: \(String(describing: entitlements)), flowArn: \(String(describing: flowArn)))"}
}

extension GrantFlowEntitlementsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entitlements = "entitlements"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for __listofgrantentitlementrequest0 in entitlements {
                try entitlementsContainer.encode(__listofgrantentitlementrequest0)
            }
        }
    }
}

public struct GrantFlowEntitlementsInputHeadersMiddleware: Middleware {
    public let id: String = "GrantFlowEntitlementsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GrantFlowEntitlementsInput>,
                  next: H) -> Swift.Result<OperationOutput<GrantFlowEntitlementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GrantFlowEntitlementsInput>
    public typealias MOutput = OperationOutput<GrantFlowEntitlementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GrantFlowEntitlementsOutputError>
}

public struct GrantFlowEntitlementsInputQueryItemMiddleware: Middleware {
    public let id: String = "GrantFlowEntitlementsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GrantFlowEntitlementsInput>,
                  next: H) -> Swift.Result<OperationOutput<GrantFlowEntitlementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GrantFlowEntitlementsInput>
    public typealias MOutput = OperationOutput<GrantFlowEntitlementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GrantFlowEntitlementsOutputError>
}

/// A request to grant entitlements on a flow.
public struct GrantFlowEntitlementsInput: Equatable {
    /// The list of entitlements that you want to grant.
    public let entitlements: [GrantEntitlementRequest]?
    /// The flow that you want to grant entitlements on.
    public let flowArn: String?

    public init (
        entitlements: [GrantEntitlementRequest]? = nil,
        flowArn: String? = nil
    )
    {
        self.entitlements = entitlements
        self.flowArn = flowArn
    }
}

struct GrantFlowEntitlementsInputBody: Equatable {
    public let entitlements: [GrantEntitlementRequest]?
}

extension GrantFlowEntitlementsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entitlements = "entitlements"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementsContainer = try containerValues.decodeIfPresent([GrantEntitlementRequest?].self, forKey: .entitlements)
        var entitlementsDecoded0:[GrantEntitlementRequest]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [GrantEntitlementRequest]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
    }
}

extension GrantFlowEntitlementsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GrantFlowEntitlementsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GrantFlowEntitlements420Exception" : self = .grantFlowEntitlements420Exception(try GrantFlowEntitlements420Exception(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GrantFlowEntitlementsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case grantFlowEntitlements420Exception(GrantFlowEntitlements420Exception)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GrantFlowEntitlementsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrantFlowEntitlementsOutputResponse(entitlements: \(String(describing: entitlements)), flowArn: \(String(describing: flowArn)))"}
}

extension GrantFlowEntitlementsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GrantFlowEntitlementsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entitlements = output.entitlements
            self.flowArn = output.flowArn
        } else {
            self.entitlements = nil
            self.flowArn = nil
        }
    }
}

public struct GrantFlowEntitlementsOutputResponse: Equatable {
    /// The entitlements that were just granted.
    public let entitlements: [Entitlement]?
    /// The ARN of the flow that these entitlements were granted to.
    public let flowArn: String?

    public init (
        entitlements: [Entitlement]? = nil,
        flowArn: String? = nil
    )
    {
        self.entitlements = entitlements
        self.flowArn = flowArn
    }
}

struct GrantFlowEntitlementsOutputResponseBody: Equatable {
    public let entitlements: [Entitlement]?
    public let flowArn: String?
}

extension GrantFlowEntitlementsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entitlements = "entitlements"
        case flowArn = "flowArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementsContainer = try containerValues.decodeIfPresent([Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
    }
}

extension InputConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputIp = "inputIp"
        case inputPort = "inputPort"
        case interface = "interface"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputIp = inputIp {
            try encodeContainer.encode(inputIp, forKey: .inputIp)
        }
        if inputPort != 0 {
            try encodeContainer.encode(inputPort, forKey: .inputPort)
        }
        if let interface = interface {
            try encodeContainer.encode(interface, forKey: .interface)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputIp)
        inputIp = inputIpDecoded
        let inputPortDecoded = try containerValues.decode(Int.self, forKey: .inputPort)
        inputPort = inputPortDecoded
        let interfaceDecoded = try containerValues.decodeIfPresent(Interface.self, forKey: .interface)
        interface = interfaceDecoded
    }
}

extension InputConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputConfiguration(inputIp: \(String(describing: inputIp)), inputPort: \(String(describing: inputPort)), interface: \(String(describing: interface)))"}
}

/// The transport parameters that are associated with an incoming media stream.
public struct InputConfiguration: Equatable {
    /// The IP address that the flow listens on for incoming content for a media stream.
    public let inputIp: String?
    /// The port that the flow listens on for an incoming media stream.
    public let inputPort: Int
    /// The VPC interface where the media stream comes in from.
    public let interface: Interface?

    public init (
        inputIp: String? = nil,
        inputPort: Int = 0,
        interface: Interface? = nil
    )
    {
        self.inputIp = inputIp
        self.inputPort = inputPort
        self.interface = interface
    }
}

extension InputConfigurationRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputPort = "inputPort"
        case interface = "interface"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if inputPort != 0 {
            try encodeContainer.encode(inputPort, forKey: .inputPort)
        }
        if let interface = interface {
            try encodeContainer.encode(interface, forKey: .interface)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputPortDecoded = try containerValues.decode(Int.self, forKey: .inputPort)
        inputPort = inputPortDecoded
        let interfaceDecoded = try containerValues.decodeIfPresent(InterfaceRequest.self, forKey: .interface)
        interface = interfaceDecoded
    }
}

extension InputConfigurationRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputConfigurationRequest(inputPort: \(String(describing: inputPort)), interface: \(String(describing: interface)))"}
}

/// The transport parameters that you want to associate with an incoming media stream.
public struct InputConfigurationRequest: Equatable {
    /// The port that you want the flow to listen on for an incoming media stream.
    public let inputPort: Int
    /// The VPC interface that you want to use for the incoming media stream.
    public let interface: InterfaceRequest?

    public init (
        inputPort: Int = 0,
        interface: InterfaceRequest? = nil
    )
    {
        self.inputPort = inputPort
        self.interface = interface
    }
}

extension Interface: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension Interface: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Interface(name: \(String(describing: name)))"}
}

/// The VPC interface that is used for the media stream associated with the source or output.
public struct Interface: Equatable {
    /// The name of the VPC interface.
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension InterfaceRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension InterfaceRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InterfaceRequest(name: \(String(describing: name)))"}
}

/// The VPC interface that you want to designate where the media stream is coming from or going to.
public struct InterfaceRequest: Equatable {
    /// The name of the VPC interface.
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension InternalServerErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerErrorException(message: \(String(describing: message)))"}
}

extension InternalServerErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct InternalServerErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// The error message returned by AWS Elemental MediaConnect.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum KeyType {
    case speke
    case srtPassword
    case staticKey
    case sdkUnknown(String)
}

extension KeyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [KeyType] {
        return [
            .speke,
            .srtPassword,
            .staticKey,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .speke: return "speke"
        case .srtPassword: return "srt-password"
        case .staticKey: return "static-key"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = KeyType(rawValue: rawValue) ?? KeyType.sdkUnknown(rawValue)
    }
}

extension ListEntitlementsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEntitlementsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEntitlementsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListEntitlementsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEntitlementsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntitlementsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntitlementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntitlementsInput>
    public typealias MOutput = OperationOutput<ListEntitlementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntitlementsOutputError>
}

public struct ListEntitlementsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEntitlementsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEntitlementsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEntitlementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEntitlementsInput>
    public typealias MOutput = OperationOutput<ListEntitlementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEntitlementsOutputError>
}

public struct ListEntitlementsInput: Equatable {
    /// The maximum number of results to return per API request. For example, you submit a ListEntitlements request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 20 results per page.
    public let maxResults: Int
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListEntitlements request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListEntitlements request a second time and specify the NextToken value.
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEntitlementsInputBody: Equatable {
}

extension ListEntitlementsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListEntitlementsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEntitlementsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEntitlementsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEntitlementsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEntitlementsOutputResponse(entitlements: \(String(describing: entitlements)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEntitlementsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEntitlementsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entitlements = output.entitlements
            self.nextToken = output.nextToken
        } else {
            self.entitlements = nil
            self.nextToken = nil
        }
    }
}

public struct ListEntitlementsOutputResponse: Equatable {
    /// A list of entitlements that have been granted to you from other AWS accounts.
    public let entitlements: [ListedEntitlement]?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListEntitlements request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListEntitlements request a second time and specify the NextToken value.
    public let nextToken: String?

    public init (
        entitlements: [ListedEntitlement]? = nil,
        nextToken: String? = nil
    )
    {
        self.entitlements = entitlements
        self.nextToken = nextToken
    }
}

struct ListEntitlementsOutputResponseBody: Equatable {
    public let entitlements: [ListedEntitlement]?
    public let nextToken: String?
}

extension ListEntitlementsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entitlements = "entitlements"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementsContainer = try containerValues.decodeIfPresent([ListedEntitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[ListedEntitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [ListedEntitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFlowsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFlowsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFlowsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListFlowsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFlowsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFlowsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFlowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFlowsInput>
    public typealias MOutput = OperationOutput<ListFlowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFlowsOutputError>
}

public struct ListFlowsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFlowsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFlowsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFlowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFlowsInput>
    public typealias MOutput = OperationOutput<ListFlowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFlowsOutputError>
}

public struct ListFlowsInput: Equatable {
    /// The maximum number of results to return per API request. For example, you submit a ListFlows request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public let maxResults: Int
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListFlows request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListFlows request a second time and specify the NextToken value.
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFlowsInputBody: Equatable {
}

extension ListFlowsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListFlowsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFlowsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFlowsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFlowsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFlowsOutputResponse(flows: \(String(describing: flows)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFlowsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFlowsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flows = output.flows
            self.nextToken = output.nextToken
        } else {
            self.flows = nil
            self.nextToken = nil
        }
    }
}

public struct ListFlowsOutputResponse: Equatable {
    /// A list of flow summaries.
    public let flows: [ListedFlow]?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListFlows request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListFlows request a second time and specify the NextToken value.
    public let nextToken: String?

    public init (
        flows: [ListedFlow]? = nil,
        nextToken: String? = nil
    )
    {
        self.flows = flows
        self.nextToken = nextToken
    }
}

struct ListFlowsOutputResponseBody: Equatable {
    public let flows: [ListedFlow]?
    public let nextToken: String?
}

extension ListFlowsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flows = "flows"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowsContainer = try containerValues.decodeIfPresent([ListedFlow?].self, forKey: .flows)
        var flowsDecoded0:[ListedFlow]? = nil
        if let flowsContainer = flowsContainer {
            flowsDecoded0 = [ListedFlow]()
            for structure0 in flowsContainer {
                if let structure0 = structure0 {
                    flowsDecoded0?.append(structure0)
                }
            }
        }
        flows = flowsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOfferingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOfferingsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListOfferingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListOfferingsInputHeadersMiddleware: Middleware {
    public let id: String = "ListOfferingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOfferingsInput>
    public typealias MOutput = OperationOutput<ListOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOfferingsOutputError>
}

public struct ListOfferingsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOfferingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOfferingsInput>
    public typealias MOutput = OperationOutput<ListOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOfferingsOutputError>
}

public struct ListOfferingsInput: Equatable {
    /// The maximum number of results to return per API request. For example, you submit a ListOfferings request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public let maxResults: Int
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListOfferings request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOfferingsInputBody: Equatable {
}

extension ListOfferingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListOfferingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOfferingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOfferingsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOfferingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOfferingsOutputResponse(nextToken: \(String(describing: nextToken)), offerings: \(String(describing: offerings)))"}
}

extension ListOfferingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOfferingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.offerings = output.offerings
        } else {
            self.nextToken = nil
            self.offerings = nil
        }
    }
}

public struct ListOfferingsOutputResponse: Equatable {
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListOfferings request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
    public let nextToken: String?
    /// A list of offerings that are available to this account in the current AWS Region.
    public let offerings: [Offering]?

    public init (
        nextToken: String? = nil,
        offerings: [Offering]? = nil
    )
    {
        self.nextToken = nextToken
        self.offerings = offerings
    }
}

struct ListOfferingsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let offerings: [Offering]?
}

extension ListOfferingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "nextToken"
        case offerings = "offerings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let offeringsContainer = try containerValues.decodeIfPresent([Offering?].self, forKey: .offerings)
        var offeringsDecoded0:[Offering]? = nil
        if let offeringsContainer = offeringsContainer {
            offeringsDecoded0 = [Offering]()
            for structure0 in offeringsContainer {
                if let structure0 = structure0 {
                    offeringsDecoded0?.append(structure0)
                }
            }
        }
        offerings = offeringsDecoded0
    }
}

extension ListReservationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReservationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListReservationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListReservationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListReservationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReservationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReservationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReservationsInput>
    public typealias MOutput = OperationOutput<ListReservationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReservationsOutputError>
}

public struct ListReservationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListReservationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReservationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReservationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReservationsInput>
    public typealias MOutput = OperationOutput<ListReservationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReservationsOutputError>
}

public struct ListReservationsInput: Equatable {
    /// The maximum number of results to return per API request. For example, you submit a ListReservations request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public let maxResults: Int
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListReservations request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReservationsInputBody: Equatable {
}

extension ListReservationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListReservationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReservationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReservationsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReservationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReservationsOutputResponse(nextToken: \(String(describing: nextToken)), reservations: \(String(describing: reservations)))"}
}

extension ListReservationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListReservationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.reservations = output.reservations
        } else {
            self.nextToken = nil
            self.reservations = nil
        }
    }
}

public struct ListReservationsOutputResponse: Equatable {
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListReservations request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListReservations request a second time and specify the NextToken value.
    public let nextToken: String?
    /// A list of all reservations that have been purchased by this account in the current AWS Region.
    public let reservations: [Reservation]?

    public init (
        nextToken: String? = nil,
        reservations: [Reservation]? = nil
    )
    {
        self.nextToken = nextToken
        self.reservations = reservations
    }
}

struct ListReservationsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let reservations: [Reservation]?
}

extension ListReservationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "nextToken"
        case reservations = "reservations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let reservationsContainer = try containerValues.decodeIfPresent([Reservation?].self, forKey: .reservations)
        var reservationsDecoded0:[Reservation]? = nil
        if let reservationsContainer = reservationsContainer {
            reservationsDecoded0 = [Reservation]()
            for structure0 in reservationsContainer {
                if let structure0 = structure0 {
                    reservationsDecoded0?.append(structure0)
                }
            }
        }
        reservations = reservationsDecoded0
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource for which to list the tags.
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// A map from tag keys to values. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListedEntitlement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataTransferSubscriberFeePercent = "dataTransferSubscriberFeePercent"
        case entitlementArn = "entitlementArn"
        case entitlementName = "entitlementName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dataTransferSubscriberFeePercent != 0 {
            try encodeContainer.encode(dataTransferSubscriberFeePercent, forKey: .dataTransferSubscriberFeePercent)
        }
        if let entitlementArn = entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if let entitlementName = entitlementName {
            try encodeContainer.encode(entitlementName, forKey: .entitlementName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTransferSubscriberFeePercentDecoded = try containerValues.decode(Int.self, forKey: .dataTransferSubscriberFeePercent)
        dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercentDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let entitlementNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entitlementName)
        entitlementName = entitlementNameDecoded
    }
}

extension ListedEntitlement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListedEntitlement(dataTransferSubscriberFeePercent: \(String(describing: dataTransferSubscriberFeePercent)), entitlementArn: \(String(describing: entitlementArn)), entitlementName: \(String(describing: entitlementName)))"}
}

/// An entitlement that has been granted to you from other AWS accounts.
public struct ListedEntitlement: Equatable {
    /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
    public let dataTransferSubscriberFeePercent: Int
    /// The ARN of the entitlement.
    public let entitlementArn: String?
    /// The name of the entitlement.
    public let entitlementName: String?

    public init (
        dataTransferSubscriberFeePercent: Int = 0,
        entitlementArn: String? = nil,
        entitlementName: String? = nil
    )
    {
        self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
        self.entitlementArn = entitlementArn
        self.entitlementName = entitlementName
    }
}

extension ListedFlow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "availabilityZone"
        case description = "description"
        case flowArn = "flowArn"
        case name = "name"
        case sourceType = "sourceType"
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let flowArn = flowArn {
            try encodeContainer.encode(flowArn, forKey: .flowArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListedFlow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListedFlow(availabilityZone: \(String(describing: availabilityZone)), description: \(String(describing: description)), flowArn: \(String(describing: flowArn)), name: \(String(describing: name)), sourceType: \(String(describing: sourceType)), status: \(String(describing: status)))"}
}

/// Provides a summary of a flow, including its ARN, Availability Zone, and source type.
public struct ListedFlow: Equatable {
    /// The Availability Zone that the flow was created in.
    public let availabilityZone: String?
    /// A description of the flow.
    public let description: String?
    /// The ARN of the flow.
    public let flowArn: String?
    /// The name of the flow.
    public let name: String?
    /// The type of source. This value is either owned (originated somewhere other than an AWS Elemental MediaConnect flow owned by another AWS account) or entitled (originated at an AWS Elemental MediaConnect flow owned by another AWS account).
    public let sourceType: SourceType?
    /// The current status of the flow.
    public let status: Status?

    public init (
        availabilityZone: String? = nil,
        description: String? = nil,
        flowArn: String? = nil,
        name: String? = nil,
        sourceType: SourceType? = nil,
        status: Status? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.description = description
        self.flowArn = flowArn
        self.name = name
        self.sourceType = sourceType
        self.status = status
    }
}

extension MediaStream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "attributes"
        case clockRate = "clockRate"
        case description = "description"
        case fmt = "fmt"
        case mediaStreamId = "mediaStreamId"
        case mediaStreamName = "mediaStreamName"
        case mediaStreamType = "mediaStreamType"
        case videoFormat = "videoFormat"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if clockRate != 0 {
            try encodeContainer.encode(clockRate, forKey: .clockRate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if fmt != 0 {
            try encodeContainer.encode(fmt, forKey: .fmt)
        }
        if mediaStreamId != 0 {
            try encodeContainer.encode(mediaStreamId, forKey: .mediaStreamId)
        }
        if let mediaStreamName = mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
        if let mediaStreamType = mediaStreamType {
            try encodeContainer.encode(mediaStreamType.rawValue, forKey: .mediaStreamType)
        }
        if let videoFormat = videoFormat {
            try encodeContainer.encode(videoFormat, forKey: .videoFormat)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesDecoded = try containerValues.decodeIfPresent(MediaStreamAttributes.self, forKey: .attributes)
        attributes = attributesDecoded
        let clockRateDecoded = try containerValues.decode(Int.self, forKey: .clockRate)
        clockRate = clockRateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let fmtDecoded = try containerValues.decode(Int.self, forKey: .fmt)
        fmt = fmtDecoded
        let mediaStreamIdDecoded = try containerValues.decode(Int.self, forKey: .mediaStreamId)
        mediaStreamId = mediaStreamIdDecoded
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
        let mediaStreamTypeDecoded = try containerValues.decodeIfPresent(MediaStreamType.self, forKey: .mediaStreamType)
        mediaStreamType = mediaStreamTypeDecoded
        let videoFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .videoFormat)
        videoFormat = videoFormatDecoded
    }
}

extension MediaStream: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MediaStream(attributes: \(String(describing: attributes)), clockRate: \(String(describing: clockRate)), description: \(String(describing: description)), fmt: \(String(describing: fmt)), mediaStreamId: \(String(describing: mediaStreamId)), mediaStreamName: \(String(describing: mediaStreamName)), mediaStreamType: \(String(describing: mediaStreamType)), videoFormat: \(String(describing: videoFormat)))"}
}

/// A single track or stream of media that contains video, audio, or ancillary data. After you add a media stream to a flow, you can associate it with sources and outputs on that flow, as long as they use the CDI protocol or the ST 2110 JPEG XS protocol. Each source or output can consist of one or many media streams.
public struct MediaStream: Equatable {
    /// Attributes that are related to the media stream.
    public let attributes: MediaStreamAttributes?
    /// The sample rate for the stream. This value is measured in Hz.
    public let clockRate: Int
    /// A description that can help you quickly identify what your media stream is used for.
    public let description: String?
    /// The format type number (sometimes referred to as RTP payload type) of the media stream. MediaConnect assigns this value to the media stream. For ST 2110 JPEG XS outputs, you need to provide this value to the receiver.
    public let fmt: Int
    /// A unique identifier for the media stream.
    public let mediaStreamId: Int
    /// A name that helps you distinguish one media stream from another.
    public let mediaStreamName: String?
    /// The type of media stream.
    public let mediaStreamType: MediaStreamType?
    /// The resolution of the video.
    public let videoFormat: String?

    public init (
        attributes: MediaStreamAttributes? = nil,
        clockRate: Int = 0,
        description: String? = nil,
        fmt: Int = 0,
        mediaStreamId: Int = 0,
        mediaStreamName: String? = nil,
        mediaStreamType: MediaStreamType? = nil,
        videoFormat: String? = nil
    )
    {
        self.attributes = attributes
        self.clockRate = clockRate
        self.description = description
        self.fmt = fmt
        self.mediaStreamId = mediaStreamId
        self.mediaStreamName = mediaStreamName
        self.mediaStreamType = mediaStreamType
        self.videoFormat = videoFormat
    }
}

extension MediaStreamAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fmtp = "fmtp"
        case lang = "lang"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fmtp = fmtp {
            try encodeContainer.encode(fmtp, forKey: .fmtp)
        }
        if let lang = lang {
            try encodeContainer.encode(lang, forKey: .lang)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fmtpDecoded = try containerValues.decodeIfPresent(Fmtp.self, forKey: .fmtp)
        fmtp = fmtpDecoded
        let langDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lang)
        lang = langDecoded
    }
}

extension MediaStreamAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MediaStreamAttributes(fmtp: \(String(describing: fmtp)), lang: \(String(describing: lang)))"}
}

/// Attributes that are related to the media stream.
public struct MediaStreamAttributes: Equatable {
    /// A set of parameters that define the media stream.
    public let fmtp: Fmtp?
    /// The audio language, in a format that is recognized by the receiver.
    public let lang: String?

    public init (
        fmtp: Fmtp? = nil,
        lang: String? = nil
    )
    {
        self.fmtp = fmtp
        self.lang = lang
    }
}

extension MediaStreamAttributesRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fmtp = "fmtp"
        case lang = "lang"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fmtp = fmtp {
            try encodeContainer.encode(fmtp, forKey: .fmtp)
        }
        if let lang = lang {
            try encodeContainer.encode(lang, forKey: .lang)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fmtpDecoded = try containerValues.decodeIfPresent(FmtpRequest.self, forKey: .fmtp)
        fmtp = fmtpDecoded
        let langDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lang)
        lang = langDecoded
    }
}

extension MediaStreamAttributesRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MediaStreamAttributesRequest(fmtp: \(String(describing: fmtp)), lang: \(String(describing: lang)))"}
}

/// Attributes that are related to the media stream.
public struct MediaStreamAttributesRequest: Equatable {
    /// The settings that you want to use to define the media stream.
    public let fmtp: FmtpRequest?
    /// The audio language, in a format that is recognized by the receiver.
    public let lang: String?

    public init (
        fmtp: FmtpRequest? = nil,
        lang: String? = nil
    )
    {
        self.fmtp = fmtp
        self.lang = lang
    }
}

extension MediaStreamOutputConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationConfigurations = "destinationConfigurations"
        case encodingName = "encodingName"
        case encodingParameters = "encodingParameters"
        case mediaStreamName = "mediaStreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfigurations = destinationConfigurations {
            var destinationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationConfigurations)
            for __listofdestinationconfiguration0 in destinationConfigurations {
                try destinationConfigurationsContainer.encode(__listofdestinationconfiguration0)
            }
        }
        if let encodingName = encodingName {
            try encodeContainer.encode(encodingName.rawValue, forKey: .encodingName)
        }
        if let encodingParameters = encodingParameters {
            try encodeContainer.encode(encodingParameters, forKey: .encodingParameters)
        }
        if let mediaStreamName = mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationConfigurationsContainer = try containerValues.decodeIfPresent([DestinationConfiguration?].self, forKey: .destinationConfigurations)
        var destinationConfigurationsDecoded0:[DestinationConfiguration]? = nil
        if let destinationConfigurationsContainer = destinationConfigurationsContainer {
            destinationConfigurationsDecoded0 = [DestinationConfiguration]()
            for structure0 in destinationConfigurationsContainer {
                if let structure0 = structure0 {
                    destinationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        destinationConfigurations = destinationConfigurationsDecoded0
        let encodingNameDecoded = try containerValues.decodeIfPresent(EncodingName.self, forKey: .encodingName)
        encodingName = encodingNameDecoded
        let encodingParametersDecoded = try containerValues.decodeIfPresent(EncodingParameters.self, forKey: .encodingParameters)
        encodingParameters = encodingParametersDecoded
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
    }
}

extension MediaStreamOutputConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MediaStreamOutputConfiguration(destinationConfigurations: \(String(describing: destinationConfigurations)), encodingName: \(String(describing: encodingName)), encodingParameters: \(String(describing: encodingParameters)), mediaStreamName: \(String(describing: mediaStreamName)))"}
}

/// The media stream that is associated with the output, and the parameters for that association.
public struct MediaStreamOutputConfiguration: Equatable {
    /// The transport parameters that are associated with each outbound media stream.
    public let destinationConfigurations: [DestinationConfiguration]?
    /// The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
    public let encodingName: EncodingName?
    /// Encoding parameters
    public let encodingParameters: EncodingParameters?
    /// The name of the media stream.
    public let mediaStreamName: String?

    public init (
        destinationConfigurations: [DestinationConfiguration]? = nil,
        encodingName: EncodingName? = nil,
        encodingParameters: EncodingParameters? = nil,
        mediaStreamName: String? = nil
    )
    {
        self.destinationConfigurations = destinationConfigurations
        self.encodingName = encodingName
        self.encodingParameters = encodingParameters
        self.mediaStreamName = mediaStreamName
    }
}

extension MediaStreamOutputConfigurationRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationConfigurations = "destinationConfigurations"
        case encodingName = "encodingName"
        case encodingParameters = "encodingParameters"
        case mediaStreamName = "mediaStreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfigurations = destinationConfigurations {
            var destinationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationConfigurations)
            for __listofdestinationconfigurationrequest0 in destinationConfigurations {
                try destinationConfigurationsContainer.encode(__listofdestinationconfigurationrequest0)
            }
        }
        if let encodingName = encodingName {
            try encodeContainer.encode(encodingName.rawValue, forKey: .encodingName)
        }
        if let encodingParameters = encodingParameters {
            try encodeContainer.encode(encodingParameters, forKey: .encodingParameters)
        }
        if let mediaStreamName = mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationConfigurationsContainer = try containerValues.decodeIfPresent([DestinationConfigurationRequest?].self, forKey: .destinationConfigurations)
        var destinationConfigurationsDecoded0:[DestinationConfigurationRequest]? = nil
        if let destinationConfigurationsContainer = destinationConfigurationsContainer {
            destinationConfigurationsDecoded0 = [DestinationConfigurationRequest]()
            for structure0 in destinationConfigurationsContainer {
                if let structure0 = structure0 {
                    destinationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        destinationConfigurations = destinationConfigurationsDecoded0
        let encodingNameDecoded = try containerValues.decodeIfPresent(EncodingName.self, forKey: .encodingName)
        encodingName = encodingNameDecoded
        let encodingParametersDecoded = try containerValues.decodeIfPresent(EncodingParametersRequest.self, forKey: .encodingParameters)
        encodingParameters = encodingParametersDecoded
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
    }
}

extension MediaStreamOutputConfigurationRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MediaStreamOutputConfigurationRequest(destinationConfigurations: \(String(describing: destinationConfigurations)), encodingName: \(String(describing: encodingName)), encodingParameters: \(String(describing: encodingParameters)), mediaStreamName: \(String(describing: mediaStreamName)))"}
}

/// The media stream that you want to associate with the output, and the parameters for that association.
public struct MediaStreamOutputConfigurationRequest: Equatable {
    /// The transport parameters that you want to associate with the media stream.
    public let destinationConfigurations: [DestinationConfigurationRequest]?
    /// The format that will be used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
    public let encodingName: EncodingName?
    /// A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
    public let encodingParameters: EncodingParametersRequest?
    /// The name of the media stream that is associated with the output.
    public let mediaStreamName: String?

    public init (
        destinationConfigurations: [DestinationConfigurationRequest]? = nil,
        encodingName: EncodingName? = nil,
        encodingParameters: EncodingParametersRequest? = nil,
        mediaStreamName: String? = nil
    )
    {
        self.destinationConfigurations = destinationConfigurations
        self.encodingName = encodingName
        self.encodingParameters = encodingParameters
        self.mediaStreamName = mediaStreamName
    }
}

extension MediaStreamSourceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encodingName = "encodingName"
        case inputConfigurations = "inputConfigurations"
        case mediaStreamName = "mediaStreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encodingName = encodingName {
            try encodeContainer.encode(encodingName.rawValue, forKey: .encodingName)
        }
        if let inputConfigurations = inputConfigurations {
            var inputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputConfigurations)
            for __listofinputconfiguration0 in inputConfigurations {
                try inputConfigurationsContainer.encode(__listofinputconfiguration0)
            }
        }
        if let mediaStreamName = mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encodingNameDecoded = try containerValues.decodeIfPresent(EncodingName.self, forKey: .encodingName)
        encodingName = encodingNameDecoded
        let inputConfigurationsContainer = try containerValues.decodeIfPresent([InputConfiguration?].self, forKey: .inputConfigurations)
        var inputConfigurationsDecoded0:[InputConfiguration]? = nil
        if let inputConfigurationsContainer = inputConfigurationsContainer {
            inputConfigurationsDecoded0 = [InputConfiguration]()
            for structure0 in inputConfigurationsContainer {
                if let structure0 = structure0 {
                    inputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        inputConfigurations = inputConfigurationsDecoded0
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
    }
}

extension MediaStreamSourceConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MediaStreamSourceConfiguration(encodingName: \(String(describing: encodingName)), inputConfigurations: \(String(describing: inputConfigurations)), mediaStreamName: \(String(describing: mediaStreamName)))"}
}

/// The media stream that is associated with the source, and the parameters for that association.
public struct MediaStreamSourceConfiguration: Equatable {
    /// The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
    public let encodingName: EncodingName?
    /// The transport parameters that are associated with an incoming media stream.
    public let inputConfigurations: [InputConfiguration]?
    /// The name of the media stream.
    public let mediaStreamName: String?

    public init (
        encodingName: EncodingName? = nil,
        inputConfigurations: [InputConfiguration]? = nil,
        mediaStreamName: String? = nil
    )
    {
        self.encodingName = encodingName
        self.inputConfigurations = inputConfigurations
        self.mediaStreamName = mediaStreamName
    }
}

extension MediaStreamSourceConfigurationRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encodingName = "encodingName"
        case inputConfigurations = "inputConfigurations"
        case mediaStreamName = "mediaStreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encodingName = encodingName {
            try encodeContainer.encode(encodingName.rawValue, forKey: .encodingName)
        }
        if let inputConfigurations = inputConfigurations {
            var inputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputConfigurations)
            for __listofinputconfigurationrequest0 in inputConfigurations {
                try inputConfigurationsContainer.encode(__listofinputconfigurationrequest0)
            }
        }
        if let mediaStreamName = mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encodingNameDecoded = try containerValues.decodeIfPresent(EncodingName.self, forKey: .encodingName)
        encodingName = encodingNameDecoded
        let inputConfigurationsContainer = try containerValues.decodeIfPresent([InputConfigurationRequest?].self, forKey: .inputConfigurations)
        var inputConfigurationsDecoded0:[InputConfigurationRequest]? = nil
        if let inputConfigurationsContainer = inputConfigurationsContainer {
            inputConfigurationsDecoded0 = [InputConfigurationRequest]()
            for structure0 in inputConfigurationsContainer {
                if let structure0 = structure0 {
                    inputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        inputConfigurations = inputConfigurationsDecoded0
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
    }
}

extension MediaStreamSourceConfigurationRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MediaStreamSourceConfigurationRequest(encodingName: \(String(describing: encodingName)), inputConfigurations: \(String(describing: inputConfigurations)), mediaStreamName: \(String(describing: mediaStreamName)))"}
}

/// The definition of a media stream that you want to associate with the source.
public struct MediaStreamSourceConfigurationRequest: Equatable {
    /// The format you want to use to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
    public let encodingName: EncodingName?
    /// The transport parameters that you want to associate with the media stream.
    public let inputConfigurations: [InputConfigurationRequest]?
    /// The name of the media stream.
    public let mediaStreamName: String?

    public init (
        encodingName: EncodingName? = nil,
        inputConfigurations: [InputConfigurationRequest]? = nil,
        mediaStreamName: String? = nil
    )
    {
        self.encodingName = encodingName
        self.inputConfigurations = inputConfigurations
        self.mediaStreamName = mediaStreamName
    }
}

public enum MediaStreamType {
    case ancillaryData
    case audio
    case video
    case sdkUnknown(String)
}

extension MediaStreamType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MediaStreamType] {
        return [
            .ancillaryData,
            .audio,
            .video,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ancillaryData: return "ancillary-data"
        case .audio: return "audio"
        case .video: return "video"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MediaStreamType(rawValue: rawValue) ?? MediaStreamType.sdkUnknown(rawValue)
    }
}

extension Messages: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errors = "errors"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for __listof__string0 in errors {
                try errorsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .errors)
        var errorsDecoded0:[String]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [String]()
            for string0 in errorsContainer {
                if let string0 = string0 {
                    errorsDecoded0?.append(string0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension Messages: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Messages(errors: \(String(describing: errors)))"}
}

/// Messages that provide the state of the flow.
public struct Messages: Equatable {
    /// A list of errors that might have been generated from processes on this flow.
    public let errors: [String]?

    public init (
        errors: [String]? = nil
    )
    {
        self.errors = errors
    }
}

public enum NetworkInterfaceType {
    case efa
    case ena
    case sdkUnknown(String)
}

extension NetworkInterfaceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NetworkInterfaceType] {
        return [
            .efa,
            .ena,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .efa: return "efa"
        case .ena: return "ena"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NetworkInterfaceType(rawValue: rawValue) ?? NetworkInterfaceType.sdkUnknown(rawValue)
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The error message returned by AWS Elemental MediaConnect.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Offering: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currencyCode = "currencyCode"
        case duration = "duration"
        case durationUnits = "durationUnits"
        case offeringArn = "offeringArn"
        case offeringDescription = "offeringDescription"
        case pricePerUnit = "pricePerUnit"
        case priceUnits = "priceUnits"
        case resourceSpecification = "resourceSpecification"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let durationUnits = durationUnits {
            try encodeContainer.encode(durationUnits.rawValue, forKey: .durationUnits)
        }
        if let offeringArn = offeringArn {
            try encodeContainer.encode(offeringArn, forKey: .offeringArn)
        }
        if let offeringDescription = offeringDescription {
            try encodeContainer.encode(offeringDescription, forKey: .offeringDescription)
        }
        if let pricePerUnit = pricePerUnit {
            try encodeContainer.encode(pricePerUnit, forKey: .pricePerUnit)
        }
        if let priceUnits = priceUnits {
            try encodeContainer.encode(priceUnits.rawValue, forKey: .priceUnits)
        }
        if let resourceSpecification = resourceSpecification {
            try encodeContainer.encode(resourceSpecification, forKey: .resourceSpecification)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currencyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let durationDecoded = try containerValues.decode(Int.self, forKey: .duration)
        duration = durationDecoded
        let durationUnitsDecoded = try containerValues.decodeIfPresent(DurationUnits.self, forKey: .durationUnits)
        durationUnits = durationUnitsDecoded
        let offeringArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringArn)
        offeringArn = offeringArnDecoded
        let offeringDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringDescription)
        offeringDescription = offeringDescriptionDecoded
        let pricePerUnitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pricePerUnit)
        pricePerUnit = pricePerUnitDecoded
        let priceUnitsDecoded = try containerValues.decodeIfPresent(PriceUnits.self, forKey: .priceUnits)
        priceUnits = priceUnitsDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(ResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
    }
}

extension Offering: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Offering(currencyCode: \(String(describing: currencyCode)), duration: \(String(describing: duration)), durationUnits: \(String(describing: durationUnits)), offeringArn: \(String(describing: offeringArn)), offeringDescription: \(String(describing: offeringDescription)), pricePerUnit: \(String(describing: pricePerUnit)), priceUnits: \(String(describing: priceUnits)), resourceSpecification: \(String(describing: resourceSpecification)))"}
}

/// A savings plan that reserves a certain amount of outbound bandwidth usage at a discounted rate each month over a period of time.
public struct Offering: Equatable {
    /// The type of currency that is used for billing. The currencyCode used for all reservations is US dollars.
    public let currencyCode: String?
    /// The length of time that your reservation would be active.
    public let duration: Int
    /// The unit of measurement for the duration of the offering.
    public let durationUnits: DurationUnits?
    /// The Amazon Resource Name (ARN) that MediaConnect assigns to the offering.
    public let offeringArn: String?
    /// A description of the offering.
    public let offeringDescription: String?
    /// The cost of a single unit. This value, in combination with priceUnits, makes up the rate.
    public let pricePerUnit: String?
    /// The unit of measurement that is used for billing. This value, in combination with pricePerUnit, makes up the rate.
    public let priceUnits: PriceUnits?
    /// A definition of the amount of outbound bandwidth that you would be reserving if you purchase the offering.
    public let resourceSpecification: ResourceSpecification?

    public init (
        currencyCode: String? = nil,
        duration: Int = 0,
        durationUnits: DurationUnits? = nil,
        offeringArn: String? = nil,
        offeringDescription: String? = nil,
        pricePerUnit: String? = nil,
        priceUnits: PriceUnits? = nil,
        resourceSpecification: ResourceSpecification? = nil
    )
    {
        self.currencyCode = currencyCode
        self.duration = duration
        self.durationUnits = durationUnits
        self.offeringArn = offeringArn
        self.offeringDescription = offeringDescription
        self.pricePerUnit = pricePerUnit
        self.priceUnits = priceUnits
        self.resourceSpecification = resourceSpecification
    }
}

extension Output: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataTransferSubscriberFeePercent = "dataTransferSubscriberFeePercent"
        case description = "description"
        case destination = "destination"
        case encryption = "encryption"
        case entitlementArn = "entitlementArn"
        case listenerAddress = "listenerAddress"
        case mediaLiveInputArn = "mediaLiveInputArn"
        case mediaStreamOutputConfigurations = "mediaStreamOutputConfigurations"
        case name = "name"
        case outputArn = "outputArn"
        case port = "port"
        case transport = "transport"
        case vpcInterfaceAttachment = "vpcInterfaceAttachment"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dataTransferSubscriberFeePercent != 0 {
            try encodeContainer.encode(dataTransferSubscriberFeePercent, forKey: .dataTransferSubscriberFeePercent)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let entitlementArn = entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if let listenerAddress = listenerAddress {
            try encodeContainer.encode(listenerAddress, forKey: .listenerAddress)
        }
        if let mediaLiveInputArn = mediaLiveInputArn {
            try encodeContainer.encode(mediaLiveInputArn, forKey: .mediaLiveInputArn)
        }
        if let mediaStreamOutputConfigurations = mediaStreamOutputConfigurations {
            var mediaStreamOutputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamOutputConfigurations)
            for __listofmediastreamoutputconfiguration0 in mediaStreamOutputConfigurations {
                try mediaStreamOutputConfigurationsContainer.encode(__listofmediastreamoutputconfiguration0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputArn = outputArn {
            try encodeContainer.encode(outputArn, forKey: .outputArn)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let transport = transport {
            try encodeContainer.encode(transport, forKey: .transport)
        }
        if let vpcInterfaceAttachment = vpcInterfaceAttachment {
            try encodeContainer.encode(vpcInterfaceAttachment, forKey: .vpcInterfaceAttachment)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTransferSubscriberFeePercentDecoded = try containerValues.decode(Int.self, forKey: .dataTransferSubscriberFeePercent)
        dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destination)
        destination = destinationDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let listenerAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listenerAddress)
        listenerAddress = listenerAddressDecoded
        let mediaLiveInputArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaLiveInputArn)
        mediaLiveInputArn = mediaLiveInputArnDecoded
        let mediaStreamOutputConfigurationsContainer = try containerValues.decodeIfPresent([MediaStreamOutputConfiguration?].self, forKey: .mediaStreamOutputConfigurations)
        var mediaStreamOutputConfigurationsDecoded0:[MediaStreamOutputConfiguration]? = nil
        if let mediaStreamOutputConfigurationsContainer = mediaStreamOutputConfigurationsContainer {
            mediaStreamOutputConfigurationsDecoded0 = [MediaStreamOutputConfiguration]()
            for structure0 in mediaStreamOutputConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamOutputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamOutputConfigurations = mediaStreamOutputConfigurationsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let outputArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputArn)
        outputArn = outputArnDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let transportDecoded = try containerValues.decodeIfPresent(Transport.self, forKey: .transport)
        transport = transportDecoded
        let vpcInterfaceAttachmentDecoded = try containerValues.decodeIfPresent(VpcInterfaceAttachment.self, forKey: .vpcInterfaceAttachment)
        vpcInterfaceAttachment = vpcInterfaceAttachmentDecoded
    }
}

extension Output: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Output(dataTransferSubscriberFeePercent: \(String(describing: dataTransferSubscriberFeePercent)), description: \(String(describing: description)), destination: \(String(describing: destination)), encryption: \(String(describing: encryption)), entitlementArn: \(String(describing: entitlementArn)), listenerAddress: \(String(describing: listenerAddress)), mediaLiveInputArn: \(String(describing: mediaLiveInputArn)), mediaStreamOutputConfigurations: \(String(describing: mediaStreamOutputConfigurations)), name: \(String(describing: name)), outputArn: \(String(describing: outputArn)), port: \(String(describing: port)), transport: \(String(describing: transport)), vpcInterfaceAttachment: \(String(describing: vpcInterfaceAttachment)))"}
}

/// The settings for an output.
public struct Output: Equatable {
    /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
    public let dataTransferSubscriberFeePercent: Int
    /// A description of the output.
    public let description: String?
    /// The address where you want to send the output.
    public let destination: String?
    /// The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
    public let encryption: Encryption?
    /// The ARN of the entitlement on the originator''s flow. This value is relevant only on entitled flows.
    public let entitlementArn: String?
    /// The IP address that the receiver requires in order to establish a connection with the flow. For public networking, the ListenerAddress is represented by the elastic IP address of the flow. For private networking, the ListenerAddress is represented by the elastic network interface IP address of the VPC. This field applies only to outputs that use the Zixi pull or SRT listener protocol.
    public let listenerAddress: String?
    /// The input ARN of the AWS Elemental MediaLive channel. This parameter is relevant only for outputs that were added by creating a MediaLive input.
    public let mediaLiveInputArn: String?
    /// The configuration for each media stream that is associated with the output.
    public let mediaStreamOutputConfigurations: [MediaStreamOutputConfiguration]?
    /// The name of the output. This value must be unique within the current flow.
    public let name: String?
    /// The ARN of the output.
    public let outputArn: String?
    /// The port to use when content is distributed to this output.
    public let port: Int
    /// Attributes related to the transport stream that are used in the output.
    public let transport: Transport?
    /// The name of the VPC interface attachment to use for this output.
    public let vpcInterfaceAttachment: VpcInterfaceAttachment?

    public init (
        dataTransferSubscriberFeePercent: Int = 0,
        description: String? = nil,
        destination: String? = nil,
        encryption: Encryption? = nil,
        entitlementArn: String? = nil,
        listenerAddress: String? = nil,
        mediaLiveInputArn: String? = nil,
        mediaStreamOutputConfigurations: [MediaStreamOutputConfiguration]? = nil,
        name: String? = nil,
        outputArn: String? = nil,
        port: Int = 0,
        transport: Transport? = nil,
        vpcInterfaceAttachment: VpcInterfaceAttachment? = nil
    )
    {
        self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
        self.description = description
        self.destination = destination
        self.encryption = encryption
        self.entitlementArn = entitlementArn
        self.listenerAddress = listenerAddress
        self.mediaLiveInputArn = mediaLiveInputArn
        self.mediaStreamOutputConfigurations = mediaStreamOutputConfigurations
        self.name = name
        self.outputArn = outputArn
        self.port = port
        self.transport = transport
        self.vpcInterfaceAttachment = vpcInterfaceAttachment
    }
}

public enum PriceUnits {
    case hourly
    case sdkUnknown(String)
}

extension PriceUnits : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PriceUnits] {
        return [
            .hourly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .hourly: return "HOURLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PriceUnits(rawValue: rawValue) ?? PriceUnits.sdkUnknown(rawValue)
    }
}

public enum `Protocol` {
    case cdi
    case rist
    case rtp
    case rtpFec
    case srtListener
    case st2110Jpegxs
    case zixiPull
    case zixiPush
    case sdkUnknown(String)
}

extension `Protocol` : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [`Protocol`] {
        return [
            .cdi,
            .rist,
            .rtp,
            .rtpFec,
            .srtListener,
            .st2110Jpegxs,
            .zixiPull,
            .zixiPush,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cdi: return "cdi"
        case .rist: return "rist"
        case .rtp: return "rtp"
        case .rtpFec: return "rtp-fec"
        case .srtListener: return "srt-listener"
        case .st2110Jpegxs: return "st2110-jpegxs"
        case .zixiPull: return "zixi-pull"
        case .zixiPush: return "zixi-push"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = `Protocol`(rawValue: rawValue) ?? `Protocol`.sdkUnknown(rawValue)
    }
}

public struct PurchaseOfferingInputBodyMiddleware: Middleware {
    public let id: String = "PurchaseOfferingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PurchaseOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<PurchaseOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PurchaseOfferingInput>
    public typealias MOutput = OperationOutput<PurchaseOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PurchaseOfferingOutputError>
}

extension PurchaseOfferingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PurchaseOfferingInput(offeringArn: \(String(describing: offeringArn)), reservationName: \(String(describing: reservationName)), start: \(String(describing: start)))"}
}

extension PurchaseOfferingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reservationName = "reservationName"
        case start = "start"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reservationName = reservationName {
            try encodeContainer.encode(reservationName, forKey: .reservationName)
        }
        if let start = start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }
}

public struct PurchaseOfferingInputHeadersMiddleware: Middleware {
    public let id: String = "PurchaseOfferingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PurchaseOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<PurchaseOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PurchaseOfferingInput>
    public typealias MOutput = OperationOutput<PurchaseOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PurchaseOfferingOutputError>
}

public struct PurchaseOfferingInputQueryItemMiddleware: Middleware {
    public let id: String = "PurchaseOfferingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PurchaseOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<PurchaseOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PurchaseOfferingInput>
    public typealias MOutput = OperationOutput<PurchaseOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PurchaseOfferingOutputError>
}

/// A request to purchase a offering.
public struct PurchaseOfferingInput: Equatable {
    /// The Amazon Resource Name (ARN) of the offering.
    public let offeringArn: String?
    /// The name that you want to use for the reservation.
    public let reservationName: String?
    /// The date and time that you want the reservation to begin, in Coordinated Universal Time (UTC). You can specify any date and time between 12:00am on the first day of the current month to the current time on today's date, inclusive. Specify the start in a 24-hour notation. Use the following format: YYYY-MM-DDTHH:mm:SSZ, where T and Z are literal characters. For example, to specify 11:30pm on March 5, 2020, enter 2020-03-05T23:30:00Z.
    public let start: String?

    public init (
        offeringArn: String? = nil,
        reservationName: String? = nil,
        start: String? = nil
    )
    {
        self.offeringArn = offeringArn
        self.reservationName = reservationName
        self.start = start
    }
}

struct PurchaseOfferingInputBody: Equatable {
    public let reservationName: String?
    public let start: String?
}

extension PurchaseOfferingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reservationName = "reservationName"
        case start = "start"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reservationName)
        reservationName = reservationNameDecoded
        let startDecoded = try containerValues.decodeIfPresent(String.self, forKey: .start)
        start = startDecoded
    }
}

extension PurchaseOfferingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PurchaseOfferingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PurchaseOfferingOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PurchaseOfferingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PurchaseOfferingOutputResponse(reservation: \(String(describing: reservation)))"}
}

extension PurchaseOfferingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PurchaseOfferingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.reservation = output.reservation
        } else {
            self.reservation = nil
        }
    }
}

public struct PurchaseOfferingOutputResponse: Equatable {
    /// A pricing agreement for a discounted rate for a specific outbound bandwidth that your MediaConnect account will use each month over a specific time period. The discounted rate in the reservation applies to outbound bandwidth for all flows from your account until your account reaches the amount of bandwidth in your reservation. If you use more outbound bandwidth than the agreed upon amount in a single month, the overage is charged at the on-demand rate.
    public let reservation: Reservation?

    public init (
        reservation: Reservation? = nil
    )
    {
        self.reservation = reservation
    }
}

struct PurchaseOfferingOutputResponseBody: Equatable {
    public let reservation: Reservation?
}

extension PurchaseOfferingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reservation = "reservation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservationDecoded = try containerValues.decodeIfPresent(Reservation.self, forKey: .reservation)
        reservation = reservationDecoded
    }
}

public enum Range {
    case full
    case fullprotect
    case narrow
    case sdkUnknown(String)
}

extension Range : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Range] {
        return [
            .full,
            .fullprotect,
            .narrow,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .full: return "FULL"
        case .fullprotect: return "FULLPROTECT"
        case .narrow: return "NARROW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Range(rawValue: rawValue) ?? Range.sdkUnknown(rawValue)
    }
}

extension RemoveFlowMediaStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveFlowMediaStreamInput(flowArn: \(String(describing: flowArn)), mediaStreamName: \(String(describing: mediaStreamName)))"}
}

extension RemoveFlowMediaStreamInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RemoveFlowMediaStreamInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveFlowMediaStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveFlowMediaStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveFlowMediaStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveFlowMediaStreamInput>
    public typealias MOutput = OperationOutput<RemoveFlowMediaStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveFlowMediaStreamOutputError>
}

public struct RemoveFlowMediaStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveFlowMediaStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveFlowMediaStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveFlowMediaStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveFlowMediaStreamInput>
    public typealias MOutput = OperationOutput<RemoveFlowMediaStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveFlowMediaStreamOutputError>
}

public struct RemoveFlowMediaStreamInput: Equatable {
    /// The Amazon Resource Name (ARN) of the flow.
    public let flowArn: String?
    /// The name of the media stream that you want to remove.
    public let mediaStreamName: String?

    public init (
        flowArn: String? = nil,
        mediaStreamName: String? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStreamName = mediaStreamName
    }
}

struct RemoveFlowMediaStreamInputBody: Equatable {
}

extension RemoveFlowMediaStreamInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RemoveFlowMediaStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveFlowMediaStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveFlowMediaStreamOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveFlowMediaStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveFlowMediaStreamOutputResponse(flowArn: \(String(describing: flowArn)), mediaStreamName: \(String(describing: mediaStreamName)))"}
}

extension RemoveFlowMediaStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemoveFlowMediaStreamOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flowArn = output.flowArn
            self.mediaStreamName = output.mediaStreamName
        } else {
            self.flowArn = nil
            self.mediaStreamName = nil
        }
    }
}

public struct RemoveFlowMediaStreamOutputResponse: Equatable {
    /// The Amazon Resource Name (ARN) of the flow.
    public let flowArn: String?
    /// The name of the media stream that was removed.
    public let mediaStreamName: String?

    public init (
        flowArn: String? = nil,
        mediaStreamName: String? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStreamName = mediaStreamName
    }
}

struct RemoveFlowMediaStreamOutputResponseBody: Equatable {
    public let flowArn: String?
    public let mediaStreamName: String?
}

extension RemoveFlowMediaStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowArn = "flowArn"
        case mediaStreamName = "mediaStreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
    }
}

extension RemoveFlowOutputInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveFlowOutputInput(flowArn: \(String(describing: flowArn)), outputArn: \(String(describing: outputArn)))"}
}

extension RemoveFlowOutputInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RemoveFlowOutputInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveFlowOutputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveFlowOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveFlowOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveFlowOutputInput>
    public typealias MOutput = OperationOutput<RemoveFlowOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveFlowOutputOutputError>
}

public struct RemoveFlowOutputInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveFlowOutputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveFlowOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveFlowOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveFlowOutputInput>
    public typealias MOutput = OperationOutput<RemoveFlowOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveFlowOutputOutputError>
}

public struct RemoveFlowOutputInput: Equatable {
    /// The flow that you want to remove an output from.
    public let flowArn: String?
    /// The ARN of the output that you want to remove.
    public let outputArn: String?

    public init (
        flowArn: String? = nil,
        outputArn: String? = nil
    )
    {
        self.flowArn = flowArn
        self.outputArn = outputArn
    }
}

struct RemoveFlowOutputInputBody: Equatable {
}

extension RemoveFlowOutputInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RemoveFlowOutputOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveFlowOutputOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveFlowOutputOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveFlowOutputOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveFlowOutputOutputResponse(flowArn: \(String(describing: flowArn)), outputArn: \(String(describing: outputArn)))"}
}

extension RemoveFlowOutputOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemoveFlowOutputOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flowArn = output.flowArn
            self.outputArn = output.outputArn
        } else {
            self.flowArn = nil
            self.outputArn = nil
        }
    }
}

public struct RemoveFlowOutputOutputResponse: Equatable {
    /// The ARN of the flow that is associated with the output you removed.
    public let flowArn: String?
    /// The ARN of the output that was removed.
    public let outputArn: String?

    public init (
        flowArn: String? = nil,
        outputArn: String? = nil
    )
    {
        self.flowArn = flowArn
        self.outputArn = outputArn
    }
}

struct RemoveFlowOutputOutputResponseBody: Equatable {
    public let flowArn: String?
    public let outputArn: String?
}

extension RemoveFlowOutputOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowArn = "flowArn"
        case outputArn = "outputArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let outputArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputArn)
        outputArn = outputArnDecoded
    }
}

extension RemoveFlowSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveFlowSourceInput(flowArn: \(String(describing: flowArn)), sourceArn: \(String(describing: sourceArn)))"}
}

extension RemoveFlowSourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RemoveFlowSourceInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveFlowSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveFlowSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveFlowSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveFlowSourceInput>
    public typealias MOutput = OperationOutput<RemoveFlowSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveFlowSourceOutputError>
}

public struct RemoveFlowSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveFlowSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveFlowSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveFlowSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveFlowSourceInput>
    public typealias MOutput = OperationOutput<RemoveFlowSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveFlowSourceOutputError>
}

public struct RemoveFlowSourceInput: Equatable {
    /// The flow that you want to remove a source from.
    public let flowArn: String?
    /// The ARN of the source that you want to remove.
    public let sourceArn: String?

    public init (
        flowArn: String? = nil,
        sourceArn: String? = nil
    )
    {
        self.flowArn = flowArn
        self.sourceArn = sourceArn
    }
}

struct RemoveFlowSourceInputBody: Equatable {
}

extension RemoveFlowSourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RemoveFlowSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveFlowSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveFlowSourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveFlowSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveFlowSourceOutputResponse(flowArn: \(String(describing: flowArn)), sourceArn: \(String(describing: sourceArn)))"}
}

extension RemoveFlowSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemoveFlowSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flowArn = output.flowArn
            self.sourceArn = output.sourceArn
        } else {
            self.flowArn = nil
            self.sourceArn = nil
        }
    }
}

public struct RemoveFlowSourceOutputResponse: Equatable {
    /// The ARN of the flow that is associated with the source you removed.
    public let flowArn: String?
    /// The ARN of the source that was removed.
    public let sourceArn: String?

    public init (
        flowArn: String? = nil,
        sourceArn: String? = nil
    )
    {
        self.flowArn = flowArn
        self.sourceArn = sourceArn
    }
}

struct RemoveFlowSourceOutputResponseBody: Equatable {
    public let flowArn: String?
    public let sourceArn: String?
}

extension RemoveFlowSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowArn = "flowArn"
        case sourceArn = "sourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
    }
}

extension RemoveFlowVpcInterfaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveFlowVpcInterfaceInput(flowArn: \(String(describing: flowArn)), vpcInterfaceName: \(String(describing: vpcInterfaceName)))"}
}

extension RemoveFlowVpcInterfaceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RemoveFlowVpcInterfaceInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveFlowVpcInterfaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveFlowVpcInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveFlowVpcInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveFlowVpcInterfaceInput>
    public typealias MOutput = OperationOutput<RemoveFlowVpcInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveFlowVpcInterfaceOutputError>
}

public struct RemoveFlowVpcInterfaceInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveFlowVpcInterfaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveFlowVpcInterfaceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveFlowVpcInterfaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveFlowVpcInterfaceInput>
    public typealias MOutput = OperationOutput<RemoveFlowVpcInterfaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveFlowVpcInterfaceOutputError>
}

public struct RemoveFlowVpcInterfaceInput: Equatable {
    /// The flow that you want to remove a VPC interface from.
    public let flowArn: String?
    /// The name of the VPC interface that you want to remove.
    public let vpcInterfaceName: String?

    public init (
        flowArn: String? = nil,
        vpcInterfaceName: String? = nil
    )
    {
        self.flowArn = flowArn
        self.vpcInterfaceName = vpcInterfaceName
    }
}

struct RemoveFlowVpcInterfaceInputBody: Equatable {
}

extension RemoveFlowVpcInterfaceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RemoveFlowVpcInterfaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveFlowVpcInterfaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveFlowVpcInterfaceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveFlowVpcInterfaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveFlowVpcInterfaceOutputResponse(flowArn: \(String(describing: flowArn)), nonDeletedNetworkInterfaceIds: \(String(describing: nonDeletedNetworkInterfaceIds)), vpcInterfaceName: \(String(describing: vpcInterfaceName)))"}
}

extension RemoveFlowVpcInterfaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemoveFlowVpcInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flowArn = output.flowArn
            self.nonDeletedNetworkInterfaceIds = output.nonDeletedNetworkInterfaceIds
            self.vpcInterfaceName = output.vpcInterfaceName
        } else {
            self.flowArn = nil
            self.nonDeletedNetworkInterfaceIds = nil
            self.vpcInterfaceName = nil
        }
    }
}

public struct RemoveFlowVpcInterfaceOutputResponse: Equatable {
    /// The ARN of the flow that is associated with the VPC interface you removed.
    public let flowArn: String?
    /// IDs of network interfaces associated with the removed VPC interface that Media Connect was unable to remove.
    public let nonDeletedNetworkInterfaceIds: [String]?
    /// The name of the VPC interface that was removed.
    public let vpcInterfaceName: String?

    public init (
        flowArn: String? = nil,
        nonDeletedNetworkInterfaceIds: [String]? = nil,
        vpcInterfaceName: String? = nil
    )
    {
        self.flowArn = flowArn
        self.nonDeletedNetworkInterfaceIds = nonDeletedNetworkInterfaceIds
        self.vpcInterfaceName = vpcInterfaceName
    }
}

struct RemoveFlowVpcInterfaceOutputResponseBody: Equatable {
    public let flowArn: String?
    public let nonDeletedNetworkInterfaceIds: [String]?
    public let vpcInterfaceName: String?
}

extension RemoveFlowVpcInterfaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowArn = "flowArn"
        case nonDeletedNetworkInterfaceIds = "nonDeletedNetworkInterfaceIds"
        case vpcInterfaceName = "vpcInterfaceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let nonDeletedNetworkInterfaceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .nonDeletedNetworkInterfaceIds)
        var nonDeletedNetworkInterfaceIdsDecoded0:[String]? = nil
        if let nonDeletedNetworkInterfaceIdsContainer = nonDeletedNetworkInterfaceIdsContainer {
            nonDeletedNetworkInterfaceIdsDecoded0 = [String]()
            for string0 in nonDeletedNetworkInterfaceIdsContainer {
                if let string0 = string0 {
                    nonDeletedNetworkInterfaceIdsDecoded0?.append(string0)
                }
            }
        }
        nonDeletedNetworkInterfaceIds = nonDeletedNetworkInterfaceIdsDecoded0
        let vpcInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcInterfaceName)
        vpcInterfaceName = vpcInterfaceNameDecoded
    }
}

extension Reservation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currencyCode = "currencyCode"
        case duration = "duration"
        case durationUnits = "durationUnits"
        case end = "end"
        case offeringArn = "offeringArn"
        case offeringDescription = "offeringDescription"
        case pricePerUnit = "pricePerUnit"
        case priceUnits = "priceUnits"
        case reservationArn = "reservationArn"
        case reservationName = "reservationName"
        case reservationState = "reservationState"
        case resourceSpecification = "resourceSpecification"
        case start = "start"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let durationUnits = durationUnits {
            try encodeContainer.encode(durationUnits.rawValue, forKey: .durationUnits)
        }
        if let end = end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let offeringArn = offeringArn {
            try encodeContainer.encode(offeringArn, forKey: .offeringArn)
        }
        if let offeringDescription = offeringDescription {
            try encodeContainer.encode(offeringDescription, forKey: .offeringDescription)
        }
        if let pricePerUnit = pricePerUnit {
            try encodeContainer.encode(pricePerUnit, forKey: .pricePerUnit)
        }
        if let priceUnits = priceUnits {
            try encodeContainer.encode(priceUnits.rawValue, forKey: .priceUnits)
        }
        if let reservationArn = reservationArn {
            try encodeContainer.encode(reservationArn, forKey: .reservationArn)
        }
        if let reservationName = reservationName {
            try encodeContainer.encode(reservationName, forKey: .reservationName)
        }
        if let reservationState = reservationState {
            try encodeContainer.encode(reservationState.rawValue, forKey: .reservationState)
        }
        if let resourceSpecification = resourceSpecification {
            try encodeContainer.encode(resourceSpecification, forKey: .resourceSpecification)
        }
        if let start = start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currencyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let durationDecoded = try containerValues.decode(Int.self, forKey: .duration)
        duration = durationDecoded
        let durationUnitsDecoded = try containerValues.decodeIfPresent(DurationUnits.self, forKey: .durationUnits)
        durationUnits = durationUnitsDecoded
        let endDecoded = try containerValues.decodeIfPresent(String.self, forKey: .end)
        end = endDecoded
        let offeringArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringArn)
        offeringArn = offeringArnDecoded
        let offeringDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringDescription)
        offeringDescription = offeringDescriptionDecoded
        let pricePerUnitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pricePerUnit)
        pricePerUnit = pricePerUnitDecoded
        let priceUnitsDecoded = try containerValues.decodeIfPresent(PriceUnits.self, forKey: .priceUnits)
        priceUnits = priceUnitsDecoded
        let reservationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reservationArn)
        reservationArn = reservationArnDecoded
        let reservationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reservationName)
        reservationName = reservationNameDecoded
        let reservationStateDecoded = try containerValues.decodeIfPresent(ReservationState.self, forKey: .reservationState)
        reservationState = reservationStateDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(ResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let startDecoded = try containerValues.decodeIfPresent(String.self, forKey: .start)
        start = startDecoded
    }
}

extension Reservation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Reservation(currencyCode: \(String(describing: currencyCode)), duration: \(String(describing: duration)), durationUnits: \(String(describing: durationUnits)), end: \(String(describing: end)), offeringArn: \(String(describing: offeringArn)), offeringDescription: \(String(describing: offeringDescription)), pricePerUnit: \(String(describing: pricePerUnit)), priceUnits: \(String(describing: priceUnits)), reservationArn: \(String(describing: reservationArn)), reservationName: \(String(describing: reservationName)), reservationState: \(String(describing: reservationState)), resourceSpecification: \(String(describing: resourceSpecification)), start: \(String(describing: start)))"}
}

/// A pricing agreement for a discounted rate for a specific outbound bandwidth that your MediaConnect account will use each month over a specific time period. The discounted rate in the reservation applies to outbound bandwidth for all flows from your account until your account reaches the amount of bandwidth in your reservation. If you use more outbound bandwidth than the agreed upon amount in a single month, the overage is charged at the on-demand rate.
public struct Reservation: Equatable {
    /// The type of currency that is used for billing. The currencyCode used for your reservation is US dollars.
    public let currencyCode: String?
    /// The length of time that this reservation is active. MediaConnect defines this value in the offering.
    public let duration: Int
    /// The unit of measurement for the duration of the reservation. MediaConnect defines this value in the offering.
    public let durationUnits: DurationUnits?
    /// The day and time that this reservation expires. This value is calculated based on the start date and time that you set and the offering's duration.
    public let end: String?
    /// The Amazon Resource Name (ARN) that MediaConnect assigns to the offering.
    public let offeringArn: String?
    /// A description of the offering. MediaConnect defines this value in the offering.
    public let offeringDescription: String?
    /// The cost of a single unit. This value, in combination with priceUnits, makes up the rate. MediaConnect defines this value in the offering.
    public let pricePerUnit: String?
    /// The unit of measurement that is used for billing. This value, in combination with pricePerUnit, makes up the rate. MediaConnect defines this value in the offering.
    public let priceUnits: PriceUnits?
    /// The Amazon Resource Name (ARN) that MediaConnect assigns to the reservation when you purchase an offering.
    public let reservationArn: String?
    /// The name that you assigned to the reservation when you purchased the offering.
    public let reservationName: String?
    /// The status of your reservation.
    public let reservationState: ReservationState?
    /// A definition of the amount of outbound bandwidth that you would be reserving if you purchase the offering. MediaConnect defines the values that make up the resourceSpecification in the offering.
    public let resourceSpecification: ResourceSpecification?
    /// The day and time that the reservation becomes active. You set this value when you purchase the offering.
    public let start: String?

    public init (
        currencyCode: String? = nil,
        duration: Int = 0,
        durationUnits: DurationUnits? = nil,
        end: String? = nil,
        offeringArn: String? = nil,
        offeringDescription: String? = nil,
        pricePerUnit: String? = nil,
        priceUnits: PriceUnits? = nil,
        reservationArn: String? = nil,
        reservationName: String? = nil,
        reservationState: ReservationState? = nil,
        resourceSpecification: ResourceSpecification? = nil,
        start: String? = nil
    )
    {
        self.currencyCode = currencyCode
        self.duration = duration
        self.durationUnits = durationUnits
        self.end = end
        self.offeringArn = offeringArn
        self.offeringDescription = offeringDescription
        self.pricePerUnit = pricePerUnit
        self.priceUnits = priceUnits
        self.reservationArn = reservationArn
        self.reservationName = reservationName
        self.reservationState = reservationState
        self.resourceSpecification = resourceSpecification
        self.start = start
    }
}

public enum ReservationState {
    case active
    case canceled
    case expired
    case processing
    case sdkUnknown(String)
}

extension ReservationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReservationState] {
        return [
            .active,
            .canceled,
            .expired,
            .processing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .canceled: return "CANCELED"
        case .expired: return "EXPIRED"
        case .processing: return "PROCESSING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReservationState(rawValue: rawValue) ?? ReservationState.sdkUnknown(rawValue)
    }
}

extension ResourceSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reservedBitrate = "reservedBitrate"
        case resourceType = "resourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if reservedBitrate != 0 {
            try encodeContainer.encode(reservedBitrate, forKey: .reservedBitrate)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedBitrateDecoded = try containerValues.decode(Int.self, forKey: .reservedBitrate)
        reservedBitrate = reservedBitrateDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceSpecification(reservedBitrate: \(String(describing: reservedBitrate)), resourceType: \(String(describing: resourceType)))"}
}

/// A definition of what is being billed for, including the type and amount.
public struct ResourceSpecification: Equatable {
    /// The amount of outbound bandwidth that is discounted in the offering.
    public let reservedBitrate: Int
    /// The type of resource and the unit that is being billed for.
    public let resourceType: ResourceType?

    public init (
        reservedBitrate: Int = 0,
        resourceType: ResourceType? = nil
    )
    {
        self.reservedBitrate = reservedBitrate
        self.resourceType = resourceType
    }
}

public enum ResourceType {
    case mbpsOutboundBandwidth
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .mbpsOutboundBandwidth,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .mbpsOutboundBandwidth: return "Mbps_Outbound_Bandwidth"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

extension RevokeFlowEntitlementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeFlowEntitlementInput(entitlementArn: \(String(describing: entitlementArn)), flowArn: \(String(describing: flowArn)))"}
}

extension RevokeFlowEntitlementInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RevokeFlowEntitlementInputHeadersMiddleware: Middleware {
    public let id: String = "RevokeFlowEntitlementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeFlowEntitlementInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeFlowEntitlementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeFlowEntitlementInput>
    public typealias MOutput = OperationOutput<RevokeFlowEntitlementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeFlowEntitlementOutputError>
}

public struct RevokeFlowEntitlementInputQueryItemMiddleware: Middleware {
    public let id: String = "RevokeFlowEntitlementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeFlowEntitlementInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeFlowEntitlementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeFlowEntitlementInput>
    public typealias MOutput = OperationOutput<RevokeFlowEntitlementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeFlowEntitlementOutputError>
}

public struct RevokeFlowEntitlementInput: Equatable {
    /// The ARN of the entitlement that you want to revoke.
    public let entitlementArn: String?
    /// The flow that you want to revoke an entitlement from.
    public let flowArn: String?

    public init (
        entitlementArn: String? = nil,
        flowArn: String? = nil
    )
    {
        self.entitlementArn = entitlementArn
        self.flowArn = flowArn
    }
}

struct RevokeFlowEntitlementInputBody: Equatable {
}

extension RevokeFlowEntitlementInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RevokeFlowEntitlementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeFlowEntitlementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeFlowEntitlementOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeFlowEntitlementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeFlowEntitlementOutputResponse(entitlementArn: \(String(describing: entitlementArn)), flowArn: \(String(describing: flowArn)))"}
}

extension RevokeFlowEntitlementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RevokeFlowEntitlementOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entitlementArn = output.entitlementArn
            self.flowArn = output.flowArn
        } else {
            self.entitlementArn = nil
            self.flowArn = nil
        }
    }
}

public struct RevokeFlowEntitlementOutputResponse: Equatable {
    /// The ARN of the entitlement that was revoked.
    public let entitlementArn: String?
    /// The ARN of the flow that the entitlement was revoked from.
    public let flowArn: String?

    public init (
        entitlementArn: String? = nil,
        flowArn: String? = nil
    )
    {
        self.entitlementArn = entitlementArn
        self.flowArn = flowArn
    }
}

struct RevokeFlowEntitlementOutputResponseBody: Equatable {
    public let entitlementArn: String?
    public let flowArn: String?
}

extension RevokeFlowEntitlementOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entitlementArn = "entitlementArn"
        case flowArn = "flowArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
    }
}

public enum ScanMode {
    case interlace
    case progressive
    case progressiveSegmentedFrame
    case sdkUnknown(String)
}

extension ScanMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScanMode] {
        return [
            .interlace,
            .progressive,
            .progressiveSegmentedFrame,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .interlace: return "interlace"
        case .progressive: return "progressive"
        case .progressiveSegmentedFrame: return "progressive-segmented-frame"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScanMode(rawValue: rawValue) ?? ScanMode.sdkUnknown(rawValue)
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// The error message returned by AWS Elemental MediaConnect.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SetSourceRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case decryption = "decryption"
        case description = "description"
        case entitlementArn = "entitlementArn"
        case ingestPort = "ingestPort"
        case maxBitrate = "maxBitrate"
        case maxLatency = "maxLatency"
        case maxSyncBuffer = "maxSyncBuffer"
        case mediaStreamSourceConfigurations = "mediaStreamSourceConfigurations"
        case minLatency = "minLatency"
        case name = "name"
        case `protocol` = "protocol"
        case streamId = "streamId"
        case vpcInterfaceName = "vpcInterfaceName"
        case whitelistCidr = "whitelistCidr"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decryption = decryption {
            try encodeContainer.encode(decryption, forKey: .decryption)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entitlementArn = entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if ingestPort != 0 {
            try encodeContainer.encode(ingestPort, forKey: .ingestPort)
        }
        if maxBitrate != 0 {
            try encodeContainer.encode(maxBitrate, forKey: .maxBitrate)
        }
        if maxLatency != 0 {
            try encodeContainer.encode(maxLatency, forKey: .maxLatency)
        }
        if maxSyncBuffer != 0 {
            try encodeContainer.encode(maxSyncBuffer, forKey: .maxSyncBuffer)
        }
        if let mediaStreamSourceConfigurations = mediaStreamSourceConfigurations {
            var mediaStreamSourceConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamSourceConfigurations)
            for __listofmediastreamsourceconfigurationrequest0 in mediaStreamSourceConfigurations {
                try mediaStreamSourceConfigurationsContainer.encode(__listofmediastreamsourceconfigurationrequest0)
            }
        }
        if minLatency != 0 {
            try encodeContainer.encode(minLatency, forKey: .minLatency)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let vpcInterfaceName = vpcInterfaceName {
            try encodeContainer.encode(vpcInterfaceName, forKey: .vpcInterfaceName)
        }
        if let whitelistCidr = whitelistCidr {
            try encodeContainer.encode(whitelistCidr, forKey: .whitelistCidr)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .decryption)
        decryption = decryptionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let ingestPortDecoded = try containerValues.decode(Int.self, forKey: .ingestPort)
        ingestPort = ingestPortDecoded
        let maxBitrateDecoded = try containerValues.decode(Int.self, forKey: .maxBitrate)
        maxBitrate = maxBitrateDecoded
        let maxLatencyDecoded = try containerValues.decode(Int.self, forKey: .maxLatency)
        maxLatency = maxLatencyDecoded
        let maxSyncBufferDecoded = try containerValues.decode(Int.self, forKey: .maxSyncBuffer)
        maxSyncBuffer = maxSyncBufferDecoded
        let mediaStreamSourceConfigurationsContainer = try containerValues.decodeIfPresent([MediaStreamSourceConfigurationRequest?].self, forKey: .mediaStreamSourceConfigurations)
        var mediaStreamSourceConfigurationsDecoded0:[MediaStreamSourceConfigurationRequest]? = nil
        if let mediaStreamSourceConfigurationsContainer = mediaStreamSourceConfigurationsContainer {
            mediaStreamSourceConfigurationsDecoded0 = [MediaStreamSourceConfigurationRequest]()
            for structure0 in mediaStreamSourceConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamSourceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamSourceConfigurations = mediaStreamSourceConfigurationsDecoded0
        let minLatencyDecoded = try containerValues.decode(Int.self, forKey: .minLatency)
        minLatency = minLatencyDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(`Protocol`.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let vpcInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcInterfaceName)
        vpcInterfaceName = vpcInterfaceNameDecoded
        let whitelistCidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .whitelistCidr)
        whitelistCidr = whitelistCidrDecoded
    }
}

extension SetSourceRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetSourceRequest(decryption: \(String(describing: decryption)), description: \(String(describing: description)), entitlementArn: \(String(describing: entitlementArn)), ingestPort: \(String(describing: ingestPort)), maxBitrate: \(String(describing: maxBitrate)), maxLatency: \(String(describing: maxLatency)), maxSyncBuffer: \(String(describing: maxSyncBuffer)), mediaStreamSourceConfigurations: \(String(describing: mediaStreamSourceConfigurations)), minLatency: \(String(describing: minLatency)), name: \(String(describing: name)), protocol: \(String(describing: `protocol`)), streamId: \(String(describing: streamId)), vpcInterfaceName: \(String(describing: vpcInterfaceName)), whitelistCidr: \(String(describing: whitelistCidr)))"}
}

/// The settings for the source of the flow.
public struct SetSourceRequest: Equatable {
    /// The protocol that is used by the source.
    public let `protocol`: `Protocol`?
    /// The type of encryption that is used on the content ingested from this source.
    public let decryption: Encryption?
    /// A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
    public let description: String?
    /// The ARN of the entitlement that allows you to subscribe to this flow. The entitlement is set by the flow originator, and the ARN is generated as part of the originator's flow.
    public let entitlementArn: String?
    /// The port that the flow will be listening on for incoming content.
    public let ingestPort: Int
    /// The smoothing max bitrate for RIST, RTP, and RTP-FEC streams.
    public let maxBitrate: Int
    /// The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
    public let maxLatency: Int
    /// The size of the buffer (in milliseconds) to use to sync incoming source data.
    public let maxSyncBuffer: Int
    /// The media streams that are associated with the source, and the parameters for those associations.
    public let mediaStreamSourceConfigurations: [MediaStreamSourceConfigurationRequest]?
    /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
    public let minLatency: Int
    /// The name of the source.
    public let name: String?
    /// The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
    public let streamId: String?
    /// The name of the VPC interface to use for this source.
    public let vpcInterfaceName: String?
    /// The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    public let whitelistCidr: String?

    public init (
        `protocol`: `Protocol`? = nil,
        decryption: Encryption? = nil,
        description: String? = nil,
        entitlementArn: String? = nil,
        ingestPort: Int = 0,
        maxBitrate: Int = 0,
        maxLatency: Int = 0,
        maxSyncBuffer: Int = 0,
        mediaStreamSourceConfigurations: [MediaStreamSourceConfigurationRequest]? = nil,
        minLatency: Int = 0,
        name: String? = nil,
        streamId: String? = nil,
        vpcInterfaceName: String? = nil,
        whitelistCidr: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.decryption = decryption
        self.description = description
        self.entitlementArn = entitlementArn
        self.ingestPort = ingestPort
        self.maxBitrate = maxBitrate
        self.maxLatency = maxLatency
        self.maxSyncBuffer = maxSyncBuffer
        self.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations
        self.minLatency = minLatency
        self.name = name
        self.streamId = streamId
        self.vpcInterfaceName = vpcInterfaceName
        self.whitelistCidr = whitelistCidr
    }
}

extension Source: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataTransferSubscriberFeePercent = "dataTransferSubscriberFeePercent"
        case decryption = "decryption"
        case description = "description"
        case entitlementArn = "entitlementArn"
        case ingestIp = "ingestIp"
        case ingestPort = "ingestPort"
        case mediaStreamSourceConfigurations = "mediaStreamSourceConfigurations"
        case name = "name"
        case sourceArn = "sourceArn"
        case transport = "transport"
        case vpcInterfaceName = "vpcInterfaceName"
        case whitelistCidr = "whitelistCidr"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dataTransferSubscriberFeePercent != 0 {
            try encodeContainer.encode(dataTransferSubscriberFeePercent, forKey: .dataTransferSubscriberFeePercent)
        }
        if let decryption = decryption {
            try encodeContainer.encode(decryption, forKey: .decryption)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entitlementArn = entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if let ingestIp = ingestIp {
            try encodeContainer.encode(ingestIp, forKey: .ingestIp)
        }
        if ingestPort != 0 {
            try encodeContainer.encode(ingestPort, forKey: .ingestPort)
        }
        if let mediaStreamSourceConfigurations = mediaStreamSourceConfigurations {
            var mediaStreamSourceConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamSourceConfigurations)
            for __listofmediastreamsourceconfiguration0 in mediaStreamSourceConfigurations {
                try mediaStreamSourceConfigurationsContainer.encode(__listofmediastreamsourceconfiguration0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceArn = sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let transport = transport {
            try encodeContainer.encode(transport, forKey: .transport)
        }
        if let vpcInterfaceName = vpcInterfaceName {
            try encodeContainer.encode(vpcInterfaceName, forKey: .vpcInterfaceName)
        }
        if let whitelistCidr = whitelistCidr {
            try encodeContainer.encode(whitelistCidr, forKey: .whitelistCidr)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTransferSubscriberFeePercentDecoded = try containerValues.decode(Int.self, forKey: .dataTransferSubscriberFeePercent)
        dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercentDecoded
        let decryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .decryption)
        decryption = decryptionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let ingestIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ingestIp)
        ingestIp = ingestIpDecoded
        let ingestPortDecoded = try containerValues.decode(Int.self, forKey: .ingestPort)
        ingestPort = ingestPortDecoded
        let mediaStreamSourceConfigurationsContainer = try containerValues.decodeIfPresent([MediaStreamSourceConfiguration?].self, forKey: .mediaStreamSourceConfigurations)
        var mediaStreamSourceConfigurationsDecoded0:[MediaStreamSourceConfiguration]? = nil
        if let mediaStreamSourceConfigurationsContainer = mediaStreamSourceConfigurationsContainer {
            mediaStreamSourceConfigurationsDecoded0 = [MediaStreamSourceConfiguration]()
            for structure0 in mediaStreamSourceConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamSourceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamSourceConfigurations = mediaStreamSourceConfigurationsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let transportDecoded = try containerValues.decodeIfPresent(Transport.self, forKey: .transport)
        transport = transportDecoded
        let vpcInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcInterfaceName)
        vpcInterfaceName = vpcInterfaceNameDecoded
        let whitelistCidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .whitelistCidr)
        whitelistCidr = whitelistCidrDecoded
    }
}

extension Source: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Source(dataTransferSubscriberFeePercent: \(String(describing: dataTransferSubscriberFeePercent)), decryption: \(String(describing: decryption)), description: \(String(describing: description)), entitlementArn: \(String(describing: entitlementArn)), ingestIp: \(String(describing: ingestIp)), ingestPort: \(String(describing: ingestPort)), mediaStreamSourceConfigurations: \(String(describing: mediaStreamSourceConfigurations)), name: \(String(describing: name)), sourceArn: \(String(describing: sourceArn)), transport: \(String(describing: transport)), vpcInterfaceName: \(String(describing: vpcInterfaceName)), whitelistCidr: \(String(describing: whitelistCidr)))"}
}

/// The settings for the source of the flow.
public struct Source: Equatable {
    /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
    public let dataTransferSubscriberFeePercent: Int
    /// The type of encryption that is used on the content ingested from this source.
    public let decryption: Encryption?
    /// A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
    public let description: String?
    /// The ARN of the entitlement that allows you to subscribe to content that comes from another AWS account. The entitlement is set by the content originator and the ARN is generated as part of the originator's flow.
    public let entitlementArn: String?
    /// The IP address that the flow will be listening on for incoming content.
    public let ingestIp: String?
    /// The port that the flow will be listening on for incoming content.
    public let ingestPort: Int
    /// The media streams that are associated with the source, and the parameters for those associations.
    public let mediaStreamSourceConfigurations: [MediaStreamSourceConfiguration]?
    /// The name of the source.
    public let name: String?
    /// The ARN of the source.
    public let sourceArn: String?
    /// Attributes related to the transport stream that are used in the source.
    public let transport: Transport?
    /// The name of the VPC interface that is used for this source.
    public let vpcInterfaceName: String?
    /// The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    public let whitelistCidr: String?

    public init (
        dataTransferSubscriberFeePercent: Int = 0,
        decryption: Encryption? = nil,
        description: String? = nil,
        entitlementArn: String? = nil,
        ingestIp: String? = nil,
        ingestPort: Int = 0,
        mediaStreamSourceConfigurations: [MediaStreamSourceConfiguration]? = nil,
        name: String? = nil,
        sourceArn: String? = nil,
        transport: Transport? = nil,
        vpcInterfaceName: String? = nil,
        whitelistCidr: String? = nil
    )
    {
        self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
        self.decryption = decryption
        self.description = description
        self.entitlementArn = entitlementArn
        self.ingestIp = ingestIp
        self.ingestPort = ingestPort
        self.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations
        self.name = name
        self.sourceArn = sourceArn
        self.transport = transport
        self.vpcInterfaceName = vpcInterfaceName
        self.whitelistCidr = whitelistCidr
    }
}

public enum SourceType {
    case entitled
    case owned
    case sdkUnknown(String)
}

extension SourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceType] {
        return [
            .entitled,
            .owned,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .entitled: return "ENTITLED"
        case .owned: return "OWNED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
    }
}

extension StartFlowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartFlowInput(flowArn: \(String(describing: flowArn)))"}
}

extension StartFlowInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StartFlowInputHeadersMiddleware: Middleware {
    public let id: String = "StartFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<StartFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartFlowInput>
    public typealias MOutput = OperationOutput<StartFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartFlowOutputError>
}

public struct StartFlowInputQueryItemMiddleware: Middleware {
    public let id: String = "StartFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<StartFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartFlowInput>
    public typealias MOutput = OperationOutput<StartFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartFlowOutputError>
}

public struct StartFlowInput: Equatable {
    /// The ARN of the flow that you want to start.
    public let flowArn: String?

    public init (
        flowArn: String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

struct StartFlowInputBody: Equatable {
}

extension StartFlowInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StartFlowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFlowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFlowOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFlowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartFlowOutputResponse(flowArn: \(String(describing: flowArn)), status: \(String(describing: status)))"}
}

extension StartFlowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartFlowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flowArn = output.flowArn
            self.status = output.status
        } else {
            self.flowArn = nil
            self.status = nil
        }
    }
}

public struct StartFlowOutputResponse: Equatable {
    /// The ARN of the flow that you started.
    public let flowArn: String?
    /// The status of the flow when the StartFlow process begins.
    public let status: Status?

    public init (
        flowArn: String? = nil,
        status: Status? = nil
    )
    {
        self.flowArn = flowArn
        self.status = status
    }
}

struct StartFlowOutputResponseBody: Equatable {
    public let flowArn: String?
    public let status: Status?
}

extension StartFlowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowArn = "flowArn"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
    }
}

public enum State {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension State : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [State] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
    }
}

public enum Status {
    case active
    case deleting
    case error
    case standby
    case starting
    case stopping
    case updating
    case sdkUnknown(String)
}

extension Status : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Status] {
        return [
            .active,
            .deleting,
            .error,
            .standby,
            .starting,
            .stopping,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleting: return "DELETING"
        case .error: return "ERROR"
        case .standby: return "STANDBY"
        case .starting: return "STARTING"
        case .stopping: return "STOPPING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
    }
}

extension StopFlowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopFlowInput(flowArn: \(String(describing: flowArn)))"}
}

extension StopFlowInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StopFlowInputHeadersMiddleware: Middleware {
    public let id: String = "StopFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<StopFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopFlowInput>
    public typealias MOutput = OperationOutput<StopFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopFlowOutputError>
}

public struct StopFlowInputQueryItemMiddleware: Middleware {
    public let id: String = "StopFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<StopFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopFlowInput>
    public typealias MOutput = OperationOutput<StopFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopFlowOutputError>
}

public struct StopFlowInput: Equatable {
    /// The ARN of the flow that you want to stop.
    public let flowArn: String?

    public init (
        flowArn: String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

struct StopFlowInputBody: Equatable {
}

extension StopFlowInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StopFlowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopFlowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopFlowOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopFlowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopFlowOutputResponse(flowArn: \(String(describing: flowArn)), status: \(String(describing: status)))"}
}

extension StopFlowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopFlowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flowArn = output.flowArn
            self.status = output.status
        } else {
            self.flowArn = nil
            self.status = nil
        }
    }
}

public struct StopFlowOutputResponse: Equatable {
    /// The ARN of the flow that you stopped.
    public let flowArn: String?
    /// The status of the flow when the StopFlow process begins.
    public let status: Status?

    public init (
        flowArn: String? = nil,
        status: Status? = nil
    )
    {
        self.flowArn = flowArn
        self.status = status
    }
}

struct StopFlowOutputResponseBody: Equatable {
    public let flowArn: String?
    public let status: Status?
}

extension StopFlowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowArn = "flowArn"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

/// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
public struct TagResourceInput: Equatable {
    /// The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource to which to add tags.
    public let resourceArn: String?
    /// A map from tag keys to values. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum Tcs {
    case bt2100linhlg
    case bt2100linpq
    case density
    case hlg
    case linear
    case pq
    case sdr
    case st20651
    case st4281
    case sdkUnknown(String)
}

extension Tcs : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Tcs] {
        return [
            .bt2100linhlg,
            .bt2100linpq,
            .density,
            .hlg,
            .linear,
            .pq,
            .sdr,
            .st20651,
            .st4281,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bt2100linhlg: return "BT2100LINHLG"
        case .bt2100linpq: return "BT2100LINPQ"
        case .density: return "DENSITY"
        case .hlg: return "HLG"
        case .linear: return "LINEAR"
        case .pq: return "PQ"
        case .sdr: return "SDR"
        case .st20651: return "ST2065-1"
        case .st4281: return "ST428-1"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Tcs(rawValue: rawValue) ?? Tcs.sdkUnknown(rawValue)
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The error message returned by AWS Elemental MediaConnect.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Transport: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidrAllowList = "cidrAllowList"
        case maxBitrate = "maxBitrate"
        case maxLatency = "maxLatency"
        case maxSyncBuffer = "maxSyncBuffer"
        case minLatency = "minLatency"
        case `protocol` = "protocol"
        case remoteId = "remoteId"
        case smoothingLatency = "smoothingLatency"
        case streamId = "streamId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrAllowList = cidrAllowList {
            var cidrAllowListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrAllowList)
            for __listof__string0 in cidrAllowList {
                try cidrAllowListContainer.encode(__listof__string0)
            }
        }
        if maxBitrate != 0 {
            try encodeContainer.encode(maxBitrate, forKey: .maxBitrate)
        }
        if maxLatency != 0 {
            try encodeContainer.encode(maxLatency, forKey: .maxLatency)
        }
        if maxSyncBuffer != 0 {
            try encodeContainer.encode(maxSyncBuffer, forKey: .maxSyncBuffer)
        }
        if minLatency != 0 {
            try encodeContainer.encode(minLatency, forKey: .minLatency)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let remoteId = remoteId {
            try encodeContainer.encode(remoteId, forKey: .remoteId)
        }
        if smoothingLatency != 0 {
            try encodeContainer.encode(smoothingLatency, forKey: .smoothingLatency)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrAllowListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .cidrAllowList)
        var cidrAllowListDecoded0:[String]? = nil
        if let cidrAllowListContainer = cidrAllowListContainer {
            cidrAllowListDecoded0 = [String]()
            for string0 in cidrAllowListContainer {
                if let string0 = string0 {
                    cidrAllowListDecoded0?.append(string0)
                }
            }
        }
        cidrAllowList = cidrAllowListDecoded0
        let maxBitrateDecoded = try containerValues.decode(Int.self, forKey: .maxBitrate)
        maxBitrate = maxBitrateDecoded
        let maxLatencyDecoded = try containerValues.decode(Int.self, forKey: .maxLatency)
        maxLatency = maxLatencyDecoded
        let maxSyncBufferDecoded = try containerValues.decode(Int.self, forKey: .maxSyncBuffer)
        maxSyncBuffer = maxSyncBufferDecoded
        let minLatencyDecoded = try containerValues.decode(Int.self, forKey: .minLatency)
        minLatency = minLatencyDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(`Protocol`.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let remoteIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remoteId)
        remoteId = remoteIdDecoded
        let smoothingLatencyDecoded = try containerValues.decode(Int.self, forKey: .smoothingLatency)
        smoothingLatency = smoothingLatencyDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamId)
        streamId = streamIdDecoded
    }
}

extension Transport: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Transport(cidrAllowList: \(String(describing: cidrAllowList)), maxBitrate: \(String(describing: maxBitrate)), maxLatency: \(String(describing: maxLatency)), maxSyncBuffer: \(String(describing: maxSyncBuffer)), minLatency: \(String(describing: minLatency)), protocol: \(String(describing: `protocol`)), remoteId: \(String(describing: remoteId)), smoothingLatency: \(String(describing: smoothingLatency)), streamId: \(String(describing: streamId)))"}
}

/// Attributes related to the transport stream that are used in a source or output.
public struct Transport: Equatable {
    /// The protocol that is used by the source or output.
    public let `protocol`: `Protocol`?
    /// The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    public let cidrAllowList: [String]?
    /// The smoothing max bitrate for RIST, RTP, and RTP-FEC streams.
    public let maxBitrate: Int
    /// The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
    public let maxLatency: Int
    /// The size of the buffer (in milliseconds) to use to sync incoming source data.
    public let maxSyncBuffer: Int
    /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
    public let minLatency: Int
    /// The remote ID for the Zixi-pull stream.
    public let remoteId: String?
    /// The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
    public let smoothingLatency: Int
    /// The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
    public let streamId: String?

    public init (
        `protocol`: `Protocol`? = nil,
        cidrAllowList: [String]? = nil,
        maxBitrate: Int = 0,
        maxLatency: Int = 0,
        maxSyncBuffer: Int = 0,
        minLatency: Int = 0,
        remoteId: String? = nil,
        smoothingLatency: Int = 0,
        streamId: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.cidrAllowList = cidrAllowList
        self.maxBitrate = maxBitrate
        self.maxLatency = maxLatency
        self.maxSyncBuffer = maxSyncBuffer
        self.minLatency = minLatency
        self.remoteId = remoteId
        self.smoothingLatency = smoothingLatency
        self.streamId = streamId
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource from which to delete tags.
    public let resourceArn: String?
    /// The keys of the tags to be removed.
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case algorithm = "algorithm"
        case constantInitializationVector = "constantInitializationVector"
        case deviceId = "deviceId"
        case keyType = "keyType"
        case region = "region"
        case resourceId = "resourceId"
        case roleArn = "roleArn"
        case secretArn = "secretArn"
        case url = "url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithm = algorithm {
            try encodeContainer.encode(algorithm.rawValue, forKey: .algorithm)
        }
        if let constantInitializationVector = constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let keyType = keyType {
            try encodeContainer.encode(keyType.rawValue, forKey: .keyType)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmDecoded = try containerValues.decodeIfPresent(Algorithm.self, forKey: .algorithm)
        algorithm = algorithmDecoded
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(KeyType.self, forKey: .keyType)
        keyType = keyTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension UpdateEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEncryption(algorithm: \(String(describing: algorithm)), constantInitializationVector: \(String(describing: constantInitializationVector)), deviceId: \(String(describing: deviceId)), keyType: \(String(describing: keyType)), region: \(String(describing: region)), resourceId: \(String(describing: resourceId)), roleArn: \(String(describing: roleArn)), secretArn: \(String(describing: secretArn)), url: \(String(describing: url)))"}
}

/// Information about the encryption of the flow.
public struct UpdateEncryption: Equatable {
    /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
    public let algorithm: Algorithm?
    /// A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
    public let constantInitializationVector: String?
    /// The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
    public let deviceId: String?
    /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
    public let keyType: KeyType?
    /// The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
    public let region: String?
    /// An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
    public let resourceId: String?
    /// The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
    public let roleArn: String?
    /// The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
    public let secretArn: String?
    /// The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
    public let url: String?

    public init (
        algorithm: Algorithm? = nil,
        constantInitializationVector: String? = nil,
        deviceId: String? = nil,
        keyType: KeyType? = nil,
        region: String? = nil,
        resourceId: String? = nil,
        roleArn: String? = nil,
        secretArn: String? = nil,
        url: String? = nil
    )
    {
        self.algorithm = algorithm
        self.constantInitializationVector = constantInitializationVector
        self.deviceId = deviceId
        self.keyType = keyType
        self.region = region
        self.resourceId = resourceId
        self.roleArn = roleArn
        self.secretArn = secretArn
        self.url = url
    }
}

extension UpdateFailoverConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recoveryWindow = "recoveryWindow"
        case state = "state"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if recoveryWindow != 0 {
            try encodeContainer.encode(recoveryWindow, forKey: .recoveryWindow)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryWindowDecoded = try containerValues.decode(Int.self, forKey: .recoveryWindow)
        recoveryWindow = recoveryWindowDecoded
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
    }
}

extension UpdateFailoverConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFailoverConfig(recoveryWindow: \(String(describing: recoveryWindow)), state: \(String(describing: state)))"}
}

/// The settings for source failover
public struct UpdateFailoverConfig: Equatable {
    /// Recovery window time to look for dash-7 packets
    public let recoveryWindow: Int
    public let state: State?

    public init (
        recoveryWindow: Int = 0,
        state: State? = nil
    )
    {
        self.recoveryWindow = recoveryWindow
        self.state = state
    }
}

public struct UpdateFlowEntitlementInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFlowEntitlementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowEntitlementInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowEntitlementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowEntitlementInput>
    public typealias MOutput = OperationOutput<UpdateFlowEntitlementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowEntitlementOutputError>
}

extension UpdateFlowEntitlementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFlowEntitlementInput(description: \(String(describing: description)), encryption: \(String(describing: encryption)), entitlementArn: \(String(describing: entitlementArn)), entitlementStatus: \(String(describing: entitlementStatus)), flowArn: \(String(describing: flowArn)), subscribers: \(String(describing: subscribers)))"}
}

extension UpdateFlowEntitlementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case encryption = "encryption"
        case entitlementStatus = "entitlementStatus"
        case subscribers = "subscribers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let entitlementStatus = entitlementStatus {
            try encodeContainer.encode(entitlementStatus.rawValue, forKey: .entitlementStatus)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for __listof__string0 in subscribers {
                try subscribersContainer.encode(__listof__string0)
            }
        }
    }
}

public struct UpdateFlowEntitlementInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFlowEntitlementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowEntitlementInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowEntitlementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowEntitlementInput>
    public typealias MOutput = OperationOutput<UpdateFlowEntitlementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowEntitlementOutputError>
}

public struct UpdateFlowEntitlementInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFlowEntitlementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowEntitlementInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowEntitlementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowEntitlementInput>
    public typealias MOutput = OperationOutput<UpdateFlowEntitlementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowEntitlementOutputError>
}

/// The entitlement fields that you want to update.
public struct UpdateFlowEntitlementInput: Equatable {
    /// A description of the entitlement. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the subscriber or end user.
    public let description: String?
    /// The type of encryption that will be used on the output associated with this entitlement.
    public let encryption: UpdateEncryption?
    /// The ARN of the entitlement that you want to update.
    public let entitlementArn: String?
    /// An indication of whether you want to enable the entitlement to allow access, or disable it to stop streaming content to the subscriber’s flow temporarily. If you don’t specify the entitlementStatus field in your request, MediaConnect leaves the value unchanged.
    public let entitlementStatus: EntitlementStatus?
    /// The flow that is associated with the entitlement that you want to update.
    public let flowArn: String?
    /// The AWS account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flow using your content as the source.
    public let subscribers: [String]?

    public init (
        description: String? = nil,
        encryption: UpdateEncryption? = nil,
        entitlementArn: String? = nil,
        entitlementStatus: EntitlementStatus? = nil,
        flowArn: String? = nil,
        subscribers: [String]? = nil
    )
    {
        self.description = description
        self.encryption = encryption
        self.entitlementArn = entitlementArn
        self.entitlementStatus = entitlementStatus
        self.flowArn = flowArn
        self.subscribers = subscribers
    }
}

struct UpdateFlowEntitlementInputBody: Equatable {
    public let description: String?
    public let encryption: UpdateEncryption?
    public let entitlementStatus: EntitlementStatus?
    public let subscribers: [String]?
}

extension UpdateFlowEntitlementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case encryption = "encryption"
        case entitlementStatus = "entitlementStatus"
        case subscribers = "subscribers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(UpdateEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let entitlementStatusDecoded = try containerValues.decodeIfPresent(EntitlementStatus.self, forKey: .entitlementStatus)
        entitlementStatus = entitlementStatusDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subscribers)
        var subscribersDecoded0:[String]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [String]()
            for string0 in subscribersContainer {
                if let string0 = string0 {
                    subscribersDecoded0?.append(string0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension UpdateFlowEntitlementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFlowEntitlementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFlowEntitlementOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFlowEntitlementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFlowEntitlementOutputResponse(entitlement: \(String(describing: entitlement)), flowArn: \(String(describing: flowArn)))"}
}

extension UpdateFlowEntitlementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFlowEntitlementOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entitlement = output.entitlement
            self.flowArn = output.flowArn
        } else {
            self.entitlement = nil
            self.flowArn = nil
        }
    }
}

public struct UpdateFlowEntitlementOutputResponse: Equatable {
    /// The new configuration of the entitlement that you updated.
    public let entitlement: Entitlement?
    /// The ARN of the flow that this entitlement was granted on.
    public let flowArn: String?

    public init (
        entitlement: Entitlement? = nil,
        flowArn: String? = nil
    )
    {
        self.entitlement = entitlement
        self.flowArn = flowArn
    }
}

struct UpdateFlowEntitlementOutputResponseBody: Equatable {
    public let entitlement: Entitlement?
    public let flowArn: String?
}

extension UpdateFlowEntitlementOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entitlement = "entitlement"
        case flowArn = "flowArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementDecoded = try containerValues.decodeIfPresent(Entitlement.self, forKey: .entitlement)
        entitlement = entitlementDecoded
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
    }
}

public struct UpdateFlowInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFlowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowInput>
    public typealias MOutput = OperationOutput<UpdateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowOutputError>
}

extension UpdateFlowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFlowInput(flowArn: \(String(describing: flowArn)), sourceFailoverConfig: \(String(describing: sourceFailoverConfig)))"}
}

extension UpdateFlowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceFailoverConfig = "sourceFailoverConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceFailoverConfig = sourceFailoverConfig {
            try encodeContainer.encode(sourceFailoverConfig, forKey: .sourceFailoverConfig)
        }
    }
}

public struct UpdateFlowInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFlowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowInput>
    public typealias MOutput = OperationOutput<UpdateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowOutputError>
}

public struct UpdateFlowInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFlowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowInput>
    public typealias MOutput = OperationOutput<UpdateFlowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowOutputError>
}

/// A request to update flow.
public struct UpdateFlowInput: Equatable {
    /// The flow that you want to update.
    public let flowArn: String?
    /// The settings for source failover
    public let sourceFailoverConfig: UpdateFailoverConfig?

    public init (
        flowArn: String? = nil,
        sourceFailoverConfig: UpdateFailoverConfig? = nil
    )
    {
        self.flowArn = flowArn
        self.sourceFailoverConfig = sourceFailoverConfig
    }
}

struct UpdateFlowInputBody: Equatable {
    public let sourceFailoverConfig: UpdateFailoverConfig?
}

extension UpdateFlowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sourceFailoverConfig = "sourceFailoverConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFailoverConfigDecoded = try containerValues.decodeIfPresent(UpdateFailoverConfig.self, forKey: .sourceFailoverConfig)
        sourceFailoverConfig = sourceFailoverConfigDecoded
    }
}

public struct UpdateFlowMediaStreamInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFlowMediaStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowMediaStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowMediaStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowMediaStreamInput>
    public typealias MOutput = OperationOutput<UpdateFlowMediaStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowMediaStreamOutputError>
}

extension UpdateFlowMediaStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFlowMediaStreamInput(attributes: \(String(describing: attributes)), clockRate: \(String(describing: clockRate)), description: \(String(describing: description)), flowArn: \(String(describing: flowArn)), mediaStreamName: \(String(describing: mediaStreamName)), mediaStreamType: \(String(describing: mediaStreamType)), videoFormat: \(String(describing: videoFormat)))"}
}

extension UpdateFlowMediaStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "attributes"
        case clockRate = "clockRate"
        case description = "description"
        case mediaStreamType = "mediaStreamType"
        case videoFormat = "videoFormat"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if clockRate != 0 {
            try encodeContainer.encode(clockRate, forKey: .clockRate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mediaStreamType = mediaStreamType {
            try encodeContainer.encode(mediaStreamType.rawValue, forKey: .mediaStreamType)
        }
        if let videoFormat = videoFormat {
            try encodeContainer.encode(videoFormat, forKey: .videoFormat)
        }
    }
}

public struct UpdateFlowMediaStreamInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFlowMediaStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowMediaStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowMediaStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowMediaStreamInput>
    public typealias MOutput = OperationOutput<UpdateFlowMediaStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowMediaStreamOutputError>
}

public struct UpdateFlowMediaStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFlowMediaStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowMediaStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowMediaStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowMediaStreamInput>
    public typealias MOutput = OperationOutput<UpdateFlowMediaStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowMediaStreamOutputError>
}

/// The fields that you want to update in the media stream.
public struct UpdateFlowMediaStreamInput: Equatable {
    /// The attributes that you want to assign to the media stream.
    public let attributes: MediaStreamAttributesRequest?
    /// The sample rate (in Hz) for the stream. If the media stream type is video or ancillary data, set this value to 90000. If the media stream type is audio, set this value to either 48000 or 96000.
    public let clockRate: Int
    /// Description
    public let description: String?
    /// The Amazon Resource Name (ARN) of the flow.
    public let flowArn: String?
    /// The name of the media stream that you want to update.
    public let mediaStreamName: String?
    /// The type of media stream.
    public let mediaStreamType: MediaStreamType?
    /// The resolution of the video.
    public let videoFormat: String?

    public init (
        attributes: MediaStreamAttributesRequest? = nil,
        clockRate: Int = 0,
        description: String? = nil,
        flowArn: String? = nil,
        mediaStreamName: String? = nil,
        mediaStreamType: MediaStreamType? = nil,
        videoFormat: String? = nil
    )
    {
        self.attributes = attributes
        self.clockRate = clockRate
        self.description = description
        self.flowArn = flowArn
        self.mediaStreamName = mediaStreamName
        self.mediaStreamType = mediaStreamType
        self.videoFormat = videoFormat
    }
}

struct UpdateFlowMediaStreamInputBody: Equatable {
    public let attributes: MediaStreamAttributesRequest?
    public let clockRate: Int
    public let description: String?
    public let mediaStreamType: MediaStreamType?
    public let videoFormat: String?
}

extension UpdateFlowMediaStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "attributes"
        case clockRate = "clockRate"
        case description = "description"
        case mediaStreamType = "mediaStreamType"
        case videoFormat = "videoFormat"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesDecoded = try containerValues.decodeIfPresent(MediaStreamAttributesRequest.self, forKey: .attributes)
        attributes = attributesDecoded
        let clockRateDecoded = try containerValues.decode(Int.self, forKey: .clockRate)
        clockRate = clockRateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let mediaStreamTypeDecoded = try containerValues.decodeIfPresent(MediaStreamType.self, forKey: .mediaStreamType)
        mediaStreamType = mediaStreamTypeDecoded
        let videoFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .videoFormat)
        videoFormat = videoFormatDecoded
    }
}

extension UpdateFlowMediaStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFlowMediaStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFlowMediaStreamOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFlowMediaStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFlowMediaStreamOutputResponse(flowArn: \(String(describing: flowArn)), mediaStream: \(String(describing: mediaStream)))"}
}

extension UpdateFlowMediaStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFlowMediaStreamOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flowArn = output.flowArn
            self.mediaStream = output.mediaStream
        } else {
            self.flowArn = nil
            self.mediaStream = nil
        }
    }
}

public struct UpdateFlowMediaStreamOutputResponse: Equatable {
    /// The ARN of the flow that is associated with the media stream that you updated.
    public let flowArn: String?
    /// The media stream that you updated.
    public let mediaStream: MediaStream?

    public init (
        flowArn: String? = nil,
        mediaStream: MediaStream? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStream = mediaStream
    }
}

struct UpdateFlowMediaStreamOutputResponseBody: Equatable {
    public let flowArn: String?
    public let mediaStream: MediaStream?
}

extension UpdateFlowMediaStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowArn = "flowArn"
        case mediaStream = "mediaStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let mediaStreamDecoded = try containerValues.decodeIfPresent(MediaStream.self, forKey: .mediaStream)
        mediaStream = mediaStreamDecoded
    }
}

extension UpdateFlowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFlowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFlowOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

public struct UpdateFlowOutputInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFlowOutputInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowOutputInput>
    public typealias MOutput = OperationOutput<UpdateFlowOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowOutputOutputError>
}

extension UpdateFlowOutputInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFlowOutputInput(cidrAllowList: \(String(describing: cidrAllowList)), description: \(String(describing: description)), destination: \(String(describing: destination)), encryption: \(String(describing: encryption)), flowArn: \(String(describing: flowArn)), maxLatency: \(String(describing: maxLatency)), mediaStreamOutputConfigurations: \(String(describing: mediaStreamOutputConfigurations)), minLatency: \(String(describing: minLatency)), outputArn: \(String(describing: outputArn)), port: \(String(describing: port)), protocol: \(String(describing: `protocol`)), remoteId: \(String(describing: remoteId)), smoothingLatency: \(String(describing: smoothingLatency)), streamId: \(String(describing: streamId)), vpcInterfaceAttachment: \(String(describing: vpcInterfaceAttachment)))"}
}

extension UpdateFlowOutputInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidrAllowList = "cidrAllowList"
        case description = "description"
        case destination = "destination"
        case encryption = "encryption"
        case maxLatency = "maxLatency"
        case mediaStreamOutputConfigurations = "mediaStreamOutputConfigurations"
        case minLatency = "minLatency"
        case port = "port"
        case `protocol` = "protocol"
        case remoteId = "remoteId"
        case smoothingLatency = "smoothingLatency"
        case streamId = "streamId"
        case vpcInterfaceAttachment = "vpcInterfaceAttachment"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrAllowList = cidrAllowList {
            var cidrAllowListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrAllowList)
            for __listof__string0 in cidrAllowList {
                try cidrAllowListContainer.encode(__listof__string0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if maxLatency != 0 {
            try encodeContainer.encode(maxLatency, forKey: .maxLatency)
        }
        if let mediaStreamOutputConfigurations = mediaStreamOutputConfigurations {
            var mediaStreamOutputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamOutputConfigurations)
            for __listofmediastreamoutputconfigurationrequest0 in mediaStreamOutputConfigurations {
                try mediaStreamOutputConfigurationsContainer.encode(__listofmediastreamoutputconfigurationrequest0)
            }
        }
        if minLatency != 0 {
            try encodeContainer.encode(minLatency, forKey: .minLatency)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let remoteId = remoteId {
            try encodeContainer.encode(remoteId, forKey: .remoteId)
        }
        if smoothingLatency != 0 {
            try encodeContainer.encode(smoothingLatency, forKey: .smoothingLatency)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let vpcInterfaceAttachment = vpcInterfaceAttachment {
            try encodeContainer.encode(vpcInterfaceAttachment, forKey: .vpcInterfaceAttachment)
        }
    }
}

public struct UpdateFlowOutputInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFlowOutputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowOutputInput>
    public typealias MOutput = OperationOutput<UpdateFlowOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowOutputOutputError>
}

public struct UpdateFlowOutputInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFlowOutputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowOutputInput>
    public typealias MOutput = OperationOutput<UpdateFlowOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowOutputOutputError>
}

/// The fields that you want to update in the output.
public struct UpdateFlowOutputInput: Equatable {
    /// The protocol to use for the output.
    public let `protocol`: `Protocol`?
    /// The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    public let cidrAllowList: [String]?
    /// A description of the output. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the end user.
    public let description: String?
    /// The IP address where you want to send the output.
    public let destination: String?
    /// The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
    public let encryption: UpdateEncryption?
    /// The flow that is associated with the output that you want to update.
    public let flowArn: String?
    /// The maximum latency in milliseconds for Zixi-based streams.
    public let maxLatency: Int
    /// The media streams that are associated with the output, and the parameters for those associations.
    public let mediaStreamOutputConfigurations: [MediaStreamOutputConfigurationRequest]?
    /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
    public let minLatency: Int
    /// The ARN of the output that you want to update.
    public let outputArn: String?
    /// The port to use when content is distributed to this output.
    public let port: Int
    /// The remote ID for the Zixi-pull stream.
    public let remoteId: String?
    /// The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
    public let smoothingLatency: Int
    /// The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
    public let streamId: String?
    /// The name of the VPC interface attachment to use for this output.
    public let vpcInterfaceAttachment: VpcInterfaceAttachment?

    public init (
        `protocol`: `Protocol`? = nil,
        cidrAllowList: [String]? = nil,
        description: String? = nil,
        destination: String? = nil,
        encryption: UpdateEncryption? = nil,
        flowArn: String? = nil,
        maxLatency: Int = 0,
        mediaStreamOutputConfigurations: [MediaStreamOutputConfigurationRequest]? = nil,
        minLatency: Int = 0,
        outputArn: String? = nil,
        port: Int = 0,
        remoteId: String? = nil,
        smoothingLatency: Int = 0,
        streamId: String? = nil,
        vpcInterfaceAttachment: VpcInterfaceAttachment? = nil
    )
    {
        self.`protocol` = `protocol`
        self.cidrAllowList = cidrAllowList
        self.description = description
        self.destination = destination
        self.encryption = encryption
        self.flowArn = flowArn
        self.maxLatency = maxLatency
        self.mediaStreamOutputConfigurations = mediaStreamOutputConfigurations
        self.minLatency = minLatency
        self.outputArn = outputArn
        self.port = port
        self.remoteId = remoteId
        self.smoothingLatency = smoothingLatency
        self.streamId = streamId
        self.vpcInterfaceAttachment = vpcInterfaceAttachment
    }
}

struct UpdateFlowOutputInputBody: Equatable {
    public let cidrAllowList: [String]?
    public let description: String?
    public let destination: String?
    public let encryption: UpdateEncryption?
    public let maxLatency: Int
    public let mediaStreamOutputConfigurations: [MediaStreamOutputConfigurationRequest]?
    public let minLatency: Int
    public let port: Int
    public let `protocol`: `Protocol`?
    public let remoteId: String?
    public let smoothingLatency: Int
    public let streamId: String?
    public let vpcInterfaceAttachment: VpcInterfaceAttachment?
}

extension UpdateFlowOutputInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cidrAllowList = "cidrAllowList"
        case description = "description"
        case destination = "destination"
        case encryption = "encryption"
        case maxLatency = "maxLatency"
        case mediaStreamOutputConfigurations = "mediaStreamOutputConfigurations"
        case minLatency = "minLatency"
        case port = "port"
        case `protocol` = "protocol"
        case remoteId = "remoteId"
        case smoothingLatency = "smoothingLatency"
        case streamId = "streamId"
        case vpcInterfaceAttachment = "vpcInterfaceAttachment"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrAllowListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .cidrAllowList)
        var cidrAllowListDecoded0:[String]? = nil
        if let cidrAllowListContainer = cidrAllowListContainer {
            cidrAllowListDecoded0 = [String]()
            for string0 in cidrAllowListContainer {
                if let string0 = string0 {
                    cidrAllowListDecoded0?.append(string0)
                }
            }
        }
        cidrAllowList = cidrAllowListDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destination)
        destination = destinationDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(UpdateEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let maxLatencyDecoded = try containerValues.decode(Int.self, forKey: .maxLatency)
        maxLatency = maxLatencyDecoded
        let mediaStreamOutputConfigurationsContainer = try containerValues.decodeIfPresent([MediaStreamOutputConfigurationRequest?].self, forKey: .mediaStreamOutputConfigurations)
        var mediaStreamOutputConfigurationsDecoded0:[MediaStreamOutputConfigurationRequest]? = nil
        if let mediaStreamOutputConfigurationsContainer = mediaStreamOutputConfigurationsContainer {
            mediaStreamOutputConfigurationsDecoded0 = [MediaStreamOutputConfigurationRequest]()
            for structure0 in mediaStreamOutputConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamOutputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamOutputConfigurations = mediaStreamOutputConfigurationsDecoded0
        let minLatencyDecoded = try containerValues.decode(Int.self, forKey: .minLatency)
        minLatency = minLatencyDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(`Protocol`.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let remoteIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remoteId)
        remoteId = remoteIdDecoded
        let smoothingLatencyDecoded = try containerValues.decode(Int.self, forKey: .smoothingLatency)
        smoothingLatency = smoothingLatencyDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let vpcInterfaceAttachmentDecoded = try containerValues.decodeIfPresent(VpcInterfaceAttachment.self, forKey: .vpcInterfaceAttachment)
        vpcInterfaceAttachment = vpcInterfaceAttachmentDecoded
    }
}

extension UpdateFlowOutputOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFlowOutputOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFlowOutputOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFlowOutputOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFlowOutputOutputResponse(flowArn: \(String(describing: flowArn)), output: \(String(describing: output)))"}
}

extension UpdateFlowOutputOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFlowOutputOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flowArn = output.flowArn
            self.output = output.output
        } else {
            self.flowArn = nil
            self.output = nil
        }
    }
}

public struct UpdateFlowOutputOutputResponse: Equatable {
    /// The ARN of the flow that is associated with the updated output.
    public let flowArn: String?
    /// The new settings of the output that you updated.
    public let output: Output?

    public init (
        flowArn: String? = nil,
        output: Output? = nil
    )
    {
        self.flowArn = flowArn
        self.output = output
    }
}

struct UpdateFlowOutputOutputResponseBody: Equatable {
    public let flowArn: String?
    public let output: Output?
}

extension UpdateFlowOutputOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowArn = "flowArn"
        case output = "output"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let outputDecoded = try containerValues.decodeIfPresent(Output.self, forKey: .output)
        output = outputDecoded
    }
}

extension UpdateFlowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFlowOutputResponse(flow: \(String(describing: flow)))"}
}

extension UpdateFlowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFlowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flow = output.flow
        } else {
            self.flow = nil
        }
    }
}

public struct UpdateFlowOutputResponse: Equatable {
    /// The settings for a flow, including its source, outputs, and entitlements.
    public let flow: Flow?

    public init (
        flow: Flow? = nil
    )
    {
        self.flow = flow
    }
}

struct UpdateFlowOutputResponseBody: Equatable {
    public let flow: Flow?
}

extension UpdateFlowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flow = "flow"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowDecoded = try containerValues.decodeIfPresent(Flow.self, forKey: .flow)
        flow = flowDecoded
    }
}

public struct UpdateFlowSourceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFlowSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowSourceInput>
    public typealias MOutput = OperationOutput<UpdateFlowSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowSourceOutputError>
}

extension UpdateFlowSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFlowSourceInput(decryption: \(String(describing: decryption)), description: \(String(describing: description)), entitlementArn: \(String(describing: entitlementArn)), flowArn: \(String(describing: flowArn)), ingestPort: \(String(describing: ingestPort)), maxBitrate: \(String(describing: maxBitrate)), maxLatency: \(String(describing: maxLatency)), maxSyncBuffer: \(String(describing: maxSyncBuffer)), mediaStreamSourceConfigurations: \(String(describing: mediaStreamSourceConfigurations)), minLatency: \(String(describing: minLatency)), protocol: \(String(describing: `protocol`)), sourceArn: \(String(describing: sourceArn)), streamId: \(String(describing: streamId)), vpcInterfaceName: \(String(describing: vpcInterfaceName)), whitelistCidr: \(String(describing: whitelistCidr)))"}
}

extension UpdateFlowSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case decryption = "decryption"
        case description = "description"
        case entitlementArn = "entitlementArn"
        case ingestPort = "ingestPort"
        case maxBitrate = "maxBitrate"
        case maxLatency = "maxLatency"
        case maxSyncBuffer = "maxSyncBuffer"
        case mediaStreamSourceConfigurations = "mediaStreamSourceConfigurations"
        case minLatency = "minLatency"
        case `protocol` = "protocol"
        case streamId = "streamId"
        case vpcInterfaceName = "vpcInterfaceName"
        case whitelistCidr = "whitelistCidr"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decryption = decryption {
            try encodeContainer.encode(decryption, forKey: .decryption)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entitlementArn = entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if ingestPort != 0 {
            try encodeContainer.encode(ingestPort, forKey: .ingestPort)
        }
        if maxBitrate != 0 {
            try encodeContainer.encode(maxBitrate, forKey: .maxBitrate)
        }
        if maxLatency != 0 {
            try encodeContainer.encode(maxLatency, forKey: .maxLatency)
        }
        if maxSyncBuffer != 0 {
            try encodeContainer.encode(maxSyncBuffer, forKey: .maxSyncBuffer)
        }
        if let mediaStreamSourceConfigurations = mediaStreamSourceConfigurations {
            var mediaStreamSourceConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamSourceConfigurations)
            for __listofmediastreamsourceconfigurationrequest0 in mediaStreamSourceConfigurations {
                try mediaStreamSourceConfigurationsContainer.encode(__listofmediastreamsourceconfigurationrequest0)
            }
        }
        if minLatency != 0 {
            try encodeContainer.encode(minLatency, forKey: .minLatency)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let vpcInterfaceName = vpcInterfaceName {
            try encodeContainer.encode(vpcInterfaceName, forKey: .vpcInterfaceName)
        }
        if let whitelistCidr = whitelistCidr {
            try encodeContainer.encode(whitelistCidr, forKey: .whitelistCidr)
        }
    }
}

public struct UpdateFlowSourceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFlowSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowSourceInput>
    public typealias MOutput = OperationOutput<UpdateFlowSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowSourceOutputError>
}

public struct UpdateFlowSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFlowSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFlowSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFlowSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFlowSourceInput>
    public typealias MOutput = OperationOutput<UpdateFlowSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFlowSourceOutputError>
}

/// A request to update the source of a flow.
public struct UpdateFlowSourceInput: Equatable {
    /// The protocol that is used by the source.
    public let `protocol`: `Protocol`?
    /// The type of encryption used on the content ingested from this source.
    public let decryption: UpdateEncryption?
    /// A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
    public let description: String?
    /// The ARN of the entitlement that allows you to subscribe to this flow. The entitlement is set by the flow originator, and the ARN is generated as part of the originator's flow.
    public let entitlementArn: String?
    /// The flow that is associated with the source that you want to update.
    public let flowArn: String?
    /// The port that the flow will be listening on for incoming content.
    public let ingestPort: Int
    /// The smoothing max bitrate for RIST, RTP, and RTP-FEC streams.
    public let maxBitrate: Int
    /// The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
    public let maxLatency: Int
    /// The size of the buffer (in milliseconds) to use to sync incoming source data.
    public let maxSyncBuffer: Int
    /// The media streams that are associated with the source, and the parameters for those associations.
    public let mediaStreamSourceConfigurations: [MediaStreamSourceConfigurationRequest]?
    /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
    public let minLatency: Int
    /// The ARN of the source that you want to update.
    public let sourceArn: String?
    /// The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
    public let streamId: String?
    /// The name of the VPC interface to use for this source.
    public let vpcInterfaceName: String?
    /// The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    public let whitelistCidr: String?

    public init (
        `protocol`: `Protocol`? = nil,
        decryption: UpdateEncryption? = nil,
        description: String? = nil,
        entitlementArn: String? = nil,
        flowArn: String? = nil,
        ingestPort: Int = 0,
        maxBitrate: Int = 0,
        maxLatency: Int = 0,
        maxSyncBuffer: Int = 0,
        mediaStreamSourceConfigurations: [MediaStreamSourceConfigurationRequest]? = nil,
        minLatency: Int = 0,
        sourceArn: String? = nil,
        streamId: String? = nil,
        vpcInterfaceName: String? = nil,
        whitelistCidr: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.decryption = decryption
        self.description = description
        self.entitlementArn = entitlementArn
        self.flowArn = flowArn
        self.ingestPort = ingestPort
        self.maxBitrate = maxBitrate
        self.maxLatency = maxLatency
        self.maxSyncBuffer = maxSyncBuffer
        self.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations
        self.minLatency = minLatency
        self.sourceArn = sourceArn
        self.streamId = streamId
        self.vpcInterfaceName = vpcInterfaceName
        self.whitelistCidr = whitelistCidr
    }
}

struct UpdateFlowSourceInputBody: Equatable {
    public let decryption: UpdateEncryption?
    public let description: String?
    public let entitlementArn: String?
    public let ingestPort: Int
    public let maxBitrate: Int
    public let maxLatency: Int
    public let maxSyncBuffer: Int
    public let mediaStreamSourceConfigurations: [MediaStreamSourceConfigurationRequest]?
    public let minLatency: Int
    public let `protocol`: `Protocol`?
    public let streamId: String?
    public let vpcInterfaceName: String?
    public let whitelistCidr: String?
}

extension UpdateFlowSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case decryption = "decryption"
        case description = "description"
        case entitlementArn = "entitlementArn"
        case ingestPort = "ingestPort"
        case maxBitrate = "maxBitrate"
        case maxLatency = "maxLatency"
        case maxSyncBuffer = "maxSyncBuffer"
        case mediaStreamSourceConfigurations = "mediaStreamSourceConfigurations"
        case minLatency = "minLatency"
        case `protocol` = "protocol"
        case streamId = "streamId"
        case vpcInterfaceName = "vpcInterfaceName"
        case whitelistCidr = "whitelistCidr"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decryptionDecoded = try containerValues.decodeIfPresent(UpdateEncryption.self, forKey: .decryption)
        decryption = decryptionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let ingestPortDecoded = try containerValues.decode(Int.self, forKey: .ingestPort)
        ingestPort = ingestPortDecoded
        let maxBitrateDecoded = try containerValues.decode(Int.self, forKey: .maxBitrate)
        maxBitrate = maxBitrateDecoded
        let maxLatencyDecoded = try containerValues.decode(Int.self, forKey: .maxLatency)
        maxLatency = maxLatencyDecoded
        let maxSyncBufferDecoded = try containerValues.decode(Int.self, forKey: .maxSyncBuffer)
        maxSyncBuffer = maxSyncBufferDecoded
        let mediaStreamSourceConfigurationsContainer = try containerValues.decodeIfPresent([MediaStreamSourceConfigurationRequest?].self, forKey: .mediaStreamSourceConfigurations)
        var mediaStreamSourceConfigurationsDecoded0:[MediaStreamSourceConfigurationRequest]? = nil
        if let mediaStreamSourceConfigurationsContainer = mediaStreamSourceConfigurationsContainer {
            mediaStreamSourceConfigurationsDecoded0 = [MediaStreamSourceConfigurationRequest]()
            for structure0 in mediaStreamSourceConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamSourceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamSourceConfigurations = mediaStreamSourceConfigurationsDecoded0
        let minLatencyDecoded = try containerValues.decode(Int.self, forKey: .minLatency)
        minLatency = minLatencyDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(`Protocol`.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let vpcInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcInterfaceName)
        vpcInterfaceName = vpcInterfaceNameDecoded
        let whitelistCidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .whitelistCidr)
        whitelistCidr = whitelistCidrDecoded
    }
}

extension UpdateFlowSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFlowSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFlowSourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFlowSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFlowSourceOutputResponse(flowArn: \(String(describing: flowArn)), source: \(String(describing: source)))"}
}

extension UpdateFlowSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFlowSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.flowArn = output.flowArn
            self.source = output.source
        } else {
            self.flowArn = nil
            self.source = nil
        }
    }
}

public struct UpdateFlowSourceOutputResponse: Equatable {
    /// The ARN of the flow that you want to update.
    public let flowArn: String?
    /// The settings for the source of the flow.
    public let source: Source?

    public init (
        flowArn: String? = nil,
        source: Source? = nil
    )
    {
        self.flowArn = flowArn
        self.source = source
    }
}

struct UpdateFlowSourceOutputResponseBody: Equatable {
    public let flowArn: String?
    public let source: Source?
}

extension UpdateFlowSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case flowArn = "flowArn"
        case source = "source"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .source)
        source = sourceDecoded
    }
}

extension VpcInterface: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "name"
        case networkInterfaceIds = "networkInterfaceIds"
        case networkInterfaceType = "networkInterfaceType"
        case roleArn = "roleArn"
        case securityGroupIds = "securityGroupIds"
        case subnetId = "subnetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkInterfaceIds = networkInterfaceIds {
            var networkInterfaceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaceIds)
            for __listof__string0 in networkInterfaceIds {
                try networkInterfaceIdsContainer.encode(__listof__string0)
            }
        }
        if let networkInterfaceType = networkInterfaceType {
            try encodeContainer.encode(networkInterfaceType.rawValue, forKey: .networkInterfaceType)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for __listof__string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(__listof__string0)
            }
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let networkInterfaceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .networkInterfaceIds)
        var networkInterfaceIdsDecoded0:[String]? = nil
        if let networkInterfaceIdsContainer = networkInterfaceIdsContainer {
            networkInterfaceIdsDecoded0 = [String]()
            for string0 in networkInterfaceIdsContainer {
                if let string0 = string0 {
                    networkInterfaceIdsDecoded0?.append(string0)
                }
            }
        }
        networkInterfaceIds = networkInterfaceIdsDecoded0
        let networkInterfaceTypeDecoded = try containerValues.decodeIfPresent(NetworkInterfaceType.self, forKey: .networkInterfaceType)
        networkInterfaceType = networkInterfaceTypeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
    }
}

extension VpcInterface: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcInterface(name: \(String(describing: name)), networkInterfaceIds: \(String(describing: networkInterfaceIds)), networkInterfaceType: \(String(describing: networkInterfaceType)), roleArn: \(String(describing: roleArn)), securityGroupIds: \(String(describing: securityGroupIds)), subnetId: \(String(describing: subnetId)))"}
}

/// The settings for a VPC Source.
public struct VpcInterface: Equatable {
    /// Immutable and has to be a unique against other VpcInterfaces in this Flow
    public let name: String?
    /// IDs of the network interfaces created in customer's account by MediaConnect.
    public let networkInterfaceIds: [String]?
    /// The type of network interface.
    public let networkInterfaceType: NetworkInterfaceType?
    /// Role Arn MediaConnect can assumes to create ENIs in customer's account
    public let roleArn: String?
    /// Security Group IDs to be used on ENI.
    public let securityGroupIds: [String]?
    /// Subnet must be in the AZ of the Flow
    public let subnetId: String?

    public init (
        name: String? = nil,
        networkInterfaceIds: [String]? = nil,
        networkInterfaceType: NetworkInterfaceType? = nil,
        roleArn: String? = nil,
        securityGroupIds: [String]? = nil,
        subnetId: String? = nil
    )
    {
        self.name = name
        self.networkInterfaceIds = networkInterfaceIds
        self.networkInterfaceType = networkInterfaceType
        self.roleArn = roleArn
        self.securityGroupIds = securityGroupIds
        self.subnetId = subnetId
    }
}

extension VpcInterfaceAttachment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case vpcInterfaceName = "vpcInterfaceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcInterfaceName = vpcInterfaceName {
            try encodeContainer.encode(vpcInterfaceName, forKey: .vpcInterfaceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcInterfaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcInterfaceName)
        vpcInterfaceName = vpcInterfaceNameDecoded
    }
}

extension VpcInterfaceAttachment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcInterfaceAttachment(vpcInterfaceName: \(String(describing: vpcInterfaceName)))"}
}

/// The settings for attaching a VPC interface to an output.
public struct VpcInterfaceAttachment: Equatable {
    /// The name of the VPC interface to use for this output.
    public let vpcInterfaceName: String?

    public init (
        vpcInterfaceName: String? = nil
    )
    {
        self.vpcInterfaceName = vpcInterfaceName
    }
}

extension VpcInterfaceRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "name"
        case networkInterfaceType = "networkInterfaceType"
        case roleArn = "roleArn"
        case securityGroupIds = "securityGroupIds"
        case subnetId = "subnetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkInterfaceType = networkInterfaceType {
            try encodeContainer.encode(networkInterfaceType.rawValue, forKey: .networkInterfaceType)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for __listof__string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(__listof__string0)
            }
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let networkInterfaceTypeDecoded = try containerValues.decodeIfPresent(NetworkInterfaceType.self, forKey: .networkInterfaceType)
        networkInterfaceType = networkInterfaceTypeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
    }
}

extension VpcInterfaceRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcInterfaceRequest(name: \(String(describing: name)), networkInterfaceType: \(String(describing: networkInterfaceType)), roleArn: \(String(describing: roleArn)), securityGroupIds: \(String(describing: securityGroupIds)), subnetId: \(String(describing: subnetId)))"}
}

/// Desired VPC Interface for a Flow
public struct VpcInterfaceRequest: Equatable {
    /// The name of the VPC Interface. This value must be unique within the current flow.
    public let name: String?
    /// The type of network interface. If this value is not included in the request, MediaConnect uses ENA as the networkInterfaceType.
    public let networkInterfaceType: NetworkInterfaceType?
    /// Role Arn MediaConnect can assumes to create ENIs in customer's account
    public let roleArn: String?
    /// Security Group IDs to be used on ENI.
    public let securityGroupIds: [String]?
    /// Subnet must be in the AZ of the Flow
    public let subnetId: String?

    public init (
        name: String? = nil,
        networkInterfaceType: NetworkInterfaceType? = nil,
        roleArn: String? = nil,
        securityGroupIds: [String]? = nil,
        subnetId: String? = nil
    )
    {
        self.name = name
        self.networkInterfaceType = networkInterfaceType
        self.roleArn = roleArn
        self.securityGroupIds = securityGroupIds
        self.subnetId = subnetId
    }
}
