// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Flow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "availabilityZone"
        case description = "description"
        case egressIp = "egressIp"
        case entitlements = "entitlements"
        case flowArn = "flowArn"
        case mediaStreams = "mediaStreams"
        case name = "name"
        case outputs = "outputs"
        case source = "source"
        case sourceFailoverConfig = "sourceFailoverConfig"
        case sources = "sources"
        case status = "status"
        case vpcInterfaces = "vpcInterfaces"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let egressIp = egressIp {
            try encodeContainer.encode(egressIp, forKey: .egressIp)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for __listofentitlement0 in entitlements {
                try entitlementsContainer.encode(__listofentitlement0)
            }
        }
        if let flowArn = flowArn {
            try encodeContainer.encode(flowArn, forKey: .flowArn)
        }
        if let mediaStreams = mediaStreams {
            var mediaStreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreams)
            for __listofmediastream0 in mediaStreams {
                try mediaStreamsContainer.encode(__listofmediastream0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for __listofoutput0 in outputs {
                try outputsContainer.encode(__listofoutput0)
            }
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceFailoverConfig = sourceFailoverConfig {
            try encodeContainer.encode(sourceFailoverConfig, forKey: .sourceFailoverConfig)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for __listofsource0 in sources {
                try sourcesContainer.encode(__listofsource0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let vpcInterfaces = vpcInterfaces {
            var vpcInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcInterfaces)
            for __listofvpcinterface0 in vpcInterfaces {
                try vpcInterfacesContainer.encode(__listofvpcinterface0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let egressIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .egressIp)
        egressIp = egressIpDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let flowArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let mediaStreamsContainer = try containerValues.decodeIfPresent([MediaStream?].self, forKey: .mediaStreams)
        var mediaStreamsDecoded0:[MediaStream]? = nil
        if let mediaStreamsContainer = mediaStreamsContainer {
            mediaStreamsDecoded0 = [MediaStream]()
            for structure0 in mediaStreamsContainer {
                if let structure0 = structure0 {
                    mediaStreamsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreams = mediaStreamsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let outputsContainer = try containerValues.decodeIfPresent([Output?].self, forKey: .outputs)
        var outputsDecoded0:[Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .source)
        source = sourceDecoded
        let sourceFailoverConfigDecoded = try containerValues.decodeIfPresent(FailoverConfig.self, forKey: .sourceFailoverConfig)
        sourceFailoverConfig = sourceFailoverConfigDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([Source?].self, forKey: .sources)
        var sourcesDecoded0:[Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
        let vpcInterfacesContainer = try containerValues.decodeIfPresent([VpcInterface?].self, forKey: .vpcInterfaces)
        var vpcInterfacesDecoded0:[VpcInterface]? = nil
        if let vpcInterfacesContainer = vpcInterfacesContainer {
            vpcInterfacesDecoded0 = [VpcInterface]()
            for structure0 in vpcInterfacesContainer {
                if let structure0 = structure0 {
                    vpcInterfacesDecoded0?.append(structure0)
                }
            }
        }
        vpcInterfaces = vpcInterfacesDecoded0
    }
}
