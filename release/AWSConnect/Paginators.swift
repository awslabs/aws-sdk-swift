// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[GetCurrentMetricDataOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetCurrentMetricDataInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetCurrentMetricDataOutputResponse`
extension ConnectClient {
    public func getCurrentMetricDataPaginated(input: GetCurrentMetricDataInput) -> ClientRuntime.PaginatorSequence<GetCurrentMetricDataInput, GetCurrentMetricDataOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetCurrentMetricDataInput, GetCurrentMetricDataOutputResponse>(input: input, inputKey: \GetCurrentMetricDataInput.nextToken, outputKey: \GetCurrentMetricDataOutputResponse.nextToken, paginationFunction: self.getCurrentMetricData(input:))
    }
}

extension GetCurrentMetricDataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCurrentMetricDataInput {
        return GetCurrentMetricDataInput(
            currentMetrics: self.currentMetrics,
            filters: self.filters,
            groupings: self.groupings,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetCurrentUserDataOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetCurrentUserDataInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetCurrentUserDataOutputResponse`
extension ConnectClient {
    public func getCurrentUserDataPaginated(input: GetCurrentUserDataInput) -> ClientRuntime.PaginatorSequence<GetCurrentUserDataInput, GetCurrentUserDataOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetCurrentUserDataInput, GetCurrentUserDataOutputResponse>(input: input, inputKey: \GetCurrentUserDataInput.nextToken, outputKey: \GetCurrentUserDataOutputResponse.nextToken, paginationFunction: self.getCurrentUserData(input:))
    }
}

extension GetCurrentUserDataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCurrentUserDataInput {
        return GetCurrentUserDataInput(
            filters: self.filters,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetMetricDataOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetMetricDataInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetMetricDataOutputResponse`
extension ConnectClient {
    public func getMetricDataPaginated(input: GetMetricDataInput) -> ClientRuntime.PaginatorSequence<GetMetricDataInput, GetMetricDataOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetMetricDataInput, GetMetricDataOutputResponse>(input: input, inputKey: \GetMetricDataInput.nextToken, outputKey: \GetMetricDataOutputResponse.nextToken, paginationFunction: self.getMetricData(input:))
    }
}

extension GetMetricDataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetMetricDataInput {
        return GetMetricDataInput(
            endTime: self.endTime,
            filters: self.filters,
            groupings: self.groupings,
            historicalMetrics: self.historicalMetrics,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime
        )}
}

/// Paginate over `[ListAgentStatusesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAgentStatusesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAgentStatusesOutputResponse`
extension ConnectClient {
    public func listAgentStatusesPaginated(input: ListAgentStatusesInput) -> ClientRuntime.PaginatorSequence<ListAgentStatusesInput, ListAgentStatusesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAgentStatusesInput, ListAgentStatusesOutputResponse>(input: input, inputKey: \ListAgentStatusesInput.nextToken, outputKey: \ListAgentStatusesOutputResponse.nextToken, paginationFunction: self.listAgentStatuses(input:))
    }
}

extension ListAgentStatusesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAgentStatusesInput {
        return ListAgentStatusesInput(
            agentStatusTypes: self.agentStatusTypes,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAgentStatusesPaginated`
/// to access the nested member `[ConnectClientTypes.AgentStatusSummary]`
/// - Returns: `[ConnectClientTypes.AgentStatusSummary]`
extension PaginatorSequence where Input == ListAgentStatusesInput, Output == ListAgentStatusesOutputResponse {
    public func agentStatusSummaryList() async throws -> [ConnectClientTypes.AgentStatusSummary] {
        return try await self.asyncCompactMap { item in item.agentStatusSummaryList }
    }
}

/// Paginate over `[ListApprovedOriginsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListApprovedOriginsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListApprovedOriginsOutputResponse`
extension ConnectClient {
    public func listApprovedOriginsPaginated(input: ListApprovedOriginsInput) -> ClientRuntime.PaginatorSequence<ListApprovedOriginsInput, ListApprovedOriginsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListApprovedOriginsInput, ListApprovedOriginsOutputResponse>(input: input, inputKey: \ListApprovedOriginsInput.nextToken, outputKey: \ListApprovedOriginsOutputResponse.nextToken, paginationFunction: self.listApprovedOrigins(input:))
    }
}

extension ListApprovedOriginsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListApprovedOriginsInput {
        return ListApprovedOriginsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listApprovedOriginsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListApprovedOriginsInput, Output == ListApprovedOriginsOutputResponse {
    public func origins() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.origins }
    }
}

/// Paginate over `[ListBotsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListBotsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListBotsOutputResponse`
extension ConnectClient {
    public func listBotsPaginated(input: ListBotsInput) -> ClientRuntime.PaginatorSequence<ListBotsInput, ListBotsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBotsInput, ListBotsOutputResponse>(input: input, inputKey: \ListBotsInput.nextToken, outputKey: \ListBotsOutputResponse.nextToken, paginationFunction: self.listBots(input:))
    }
}

extension ListBotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBotsInput {
        return ListBotsInput(
            instanceId: self.instanceId,
            lexVersion: self.lexVersion,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listBotsPaginated`
/// to access the nested member `[ConnectClientTypes.LexBotConfig]`
/// - Returns: `[ConnectClientTypes.LexBotConfig]`
extension PaginatorSequence where Input == ListBotsInput, Output == ListBotsOutputResponse {
    public func lexBots() async throws -> [ConnectClientTypes.LexBotConfig] {
        return try await self.asyncCompactMap { item in item.lexBots }
    }
}

/// Paginate over `[ListContactFlowModulesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListContactFlowModulesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListContactFlowModulesOutputResponse`
extension ConnectClient {
    public func listContactFlowModulesPaginated(input: ListContactFlowModulesInput) -> ClientRuntime.PaginatorSequence<ListContactFlowModulesInput, ListContactFlowModulesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListContactFlowModulesInput, ListContactFlowModulesOutputResponse>(input: input, inputKey: \ListContactFlowModulesInput.nextToken, outputKey: \ListContactFlowModulesOutputResponse.nextToken, paginationFunction: self.listContactFlowModules(input:))
    }
}

extension ListContactFlowModulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListContactFlowModulesInput {
        return ListContactFlowModulesInput(
            contactFlowModuleState: self.contactFlowModuleState,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listContactFlowModulesPaginated`
/// to access the nested member `[ConnectClientTypes.ContactFlowModuleSummary]`
/// - Returns: `[ConnectClientTypes.ContactFlowModuleSummary]`
extension PaginatorSequence where Input == ListContactFlowModulesInput, Output == ListContactFlowModulesOutputResponse {
    public func contactFlowModulesSummaryList() async throws -> [ConnectClientTypes.ContactFlowModuleSummary] {
        return try await self.asyncCompactMap { item in item.contactFlowModulesSummaryList }
    }
}

/// Paginate over `[ListContactFlowsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListContactFlowsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListContactFlowsOutputResponse`
extension ConnectClient {
    public func listContactFlowsPaginated(input: ListContactFlowsInput) -> ClientRuntime.PaginatorSequence<ListContactFlowsInput, ListContactFlowsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListContactFlowsInput, ListContactFlowsOutputResponse>(input: input, inputKey: \ListContactFlowsInput.nextToken, outputKey: \ListContactFlowsOutputResponse.nextToken, paginationFunction: self.listContactFlows(input:))
    }
}

extension ListContactFlowsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListContactFlowsInput {
        return ListContactFlowsInput(
            contactFlowTypes: self.contactFlowTypes,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listContactFlowsPaginated`
/// to access the nested member `[ConnectClientTypes.ContactFlowSummary]`
/// - Returns: `[ConnectClientTypes.ContactFlowSummary]`
extension PaginatorSequence where Input == ListContactFlowsInput, Output == ListContactFlowsOutputResponse {
    public func contactFlowSummaryList() async throws -> [ConnectClientTypes.ContactFlowSummary] {
        return try await self.asyncCompactMap { item in item.contactFlowSummaryList }
    }
}

/// Paginate over `[ListContactReferencesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListContactReferencesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListContactReferencesOutputResponse`
extension ConnectClient {
    public func listContactReferencesPaginated(input: ListContactReferencesInput) -> ClientRuntime.PaginatorSequence<ListContactReferencesInput, ListContactReferencesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListContactReferencesInput, ListContactReferencesOutputResponse>(input: input, inputKey: \ListContactReferencesInput.nextToken, outputKey: \ListContactReferencesOutputResponse.nextToken, paginationFunction: self.listContactReferences(input:))
    }
}

extension ListContactReferencesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListContactReferencesInput {
        return ListContactReferencesInput(
            contactId: self.contactId,
            instanceId: self.instanceId,
            nextToken: token,
            referenceTypes: self.referenceTypes
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listContactReferencesPaginated`
/// to access the nested member `[ConnectClientTypes.ReferenceSummary]`
/// - Returns: `[ConnectClientTypes.ReferenceSummary]`
extension PaginatorSequence where Input == ListContactReferencesInput, Output == ListContactReferencesOutputResponse {
    public func referenceSummaryList() async throws -> [ConnectClientTypes.ReferenceSummary] {
        return try await self.asyncCompactMap { item in item.referenceSummaryList }
    }
}

/// Paginate over `[ListDefaultVocabulariesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDefaultVocabulariesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDefaultVocabulariesOutputResponse`
extension ConnectClient {
    public func listDefaultVocabulariesPaginated(input: ListDefaultVocabulariesInput) -> ClientRuntime.PaginatorSequence<ListDefaultVocabulariesInput, ListDefaultVocabulariesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDefaultVocabulariesInput, ListDefaultVocabulariesOutputResponse>(input: input, inputKey: \ListDefaultVocabulariesInput.nextToken, outputKey: \ListDefaultVocabulariesOutputResponse.nextToken, paginationFunction: self.listDefaultVocabularies(input:))
    }
}

extension ListDefaultVocabulariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDefaultVocabulariesInput {
        return ListDefaultVocabulariesInput(
            instanceId: self.instanceId,
            languageCode: self.languageCode,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDefaultVocabulariesPaginated`
/// to access the nested member `[ConnectClientTypes.DefaultVocabulary]`
/// - Returns: `[ConnectClientTypes.DefaultVocabulary]`
extension PaginatorSequence where Input == ListDefaultVocabulariesInput, Output == ListDefaultVocabulariesOutputResponse {
    public func defaultVocabularyList() async throws -> [ConnectClientTypes.DefaultVocabulary] {
        return try await self.asyncCompactMap { item in item.defaultVocabularyList }
    }
}

/// Paginate over `[ListHoursOfOperationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListHoursOfOperationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListHoursOfOperationsOutputResponse`
extension ConnectClient {
    public func listHoursOfOperationsPaginated(input: ListHoursOfOperationsInput) -> ClientRuntime.PaginatorSequence<ListHoursOfOperationsInput, ListHoursOfOperationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListHoursOfOperationsInput, ListHoursOfOperationsOutputResponse>(input: input, inputKey: \ListHoursOfOperationsInput.nextToken, outputKey: \ListHoursOfOperationsOutputResponse.nextToken, paginationFunction: self.listHoursOfOperations(input:))
    }
}

extension ListHoursOfOperationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListHoursOfOperationsInput {
        return ListHoursOfOperationsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listHoursOfOperationsPaginated`
/// to access the nested member `[ConnectClientTypes.HoursOfOperationSummary]`
/// - Returns: `[ConnectClientTypes.HoursOfOperationSummary]`
extension PaginatorSequence where Input == ListHoursOfOperationsInput, Output == ListHoursOfOperationsOutputResponse {
    public func hoursOfOperationSummaryList() async throws -> [ConnectClientTypes.HoursOfOperationSummary] {
        return try await self.asyncCompactMap { item in item.hoursOfOperationSummaryList }
    }
}

/// Paginate over `[ListInstanceAttributesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListInstanceAttributesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListInstanceAttributesOutputResponse`
extension ConnectClient {
    public func listInstanceAttributesPaginated(input: ListInstanceAttributesInput) -> ClientRuntime.PaginatorSequence<ListInstanceAttributesInput, ListInstanceAttributesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListInstanceAttributesInput, ListInstanceAttributesOutputResponse>(input: input, inputKey: \ListInstanceAttributesInput.nextToken, outputKey: \ListInstanceAttributesOutputResponse.nextToken, paginationFunction: self.listInstanceAttributes(input:))
    }
}

extension ListInstanceAttributesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInstanceAttributesInput {
        return ListInstanceAttributesInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listInstanceAttributesPaginated`
/// to access the nested member `[ConnectClientTypes.Attribute]`
/// - Returns: `[ConnectClientTypes.Attribute]`
extension PaginatorSequence where Input == ListInstanceAttributesInput, Output == ListInstanceAttributesOutputResponse {
    public func attributes() async throws -> [ConnectClientTypes.Attribute] {
        return try await self.asyncCompactMap { item in item.attributes }
    }
}

/// Paginate over `[ListInstancesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListInstancesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListInstancesOutputResponse`
extension ConnectClient {
    public func listInstancesPaginated(input: ListInstancesInput) -> ClientRuntime.PaginatorSequence<ListInstancesInput, ListInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListInstancesInput, ListInstancesOutputResponse>(input: input, inputKey: \ListInstancesInput.nextToken, outputKey: \ListInstancesOutputResponse.nextToken, paginationFunction: self.listInstances(input:))
    }
}

extension ListInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInstancesInput {
        return ListInstancesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listInstancesPaginated`
/// to access the nested member `[ConnectClientTypes.InstanceSummary]`
/// - Returns: `[ConnectClientTypes.InstanceSummary]`
extension PaginatorSequence where Input == ListInstancesInput, Output == ListInstancesOutputResponse {
    public func instanceSummaryList() async throws -> [ConnectClientTypes.InstanceSummary] {
        return try await self.asyncCompactMap { item in item.instanceSummaryList }
    }
}

/// Paginate over `[ListInstanceStorageConfigsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListInstanceStorageConfigsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListInstanceStorageConfigsOutputResponse`
extension ConnectClient {
    public func listInstanceStorageConfigsPaginated(input: ListInstanceStorageConfigsInput) -> ClientRuntime.PaginatorSequence<ListInstanceStorageConfigsInput, ListInstanceStorageConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListInstanceStorageConfigsInput, ListInstanceStorageConfigsOutputResponse>(input: input, inputKey: \ListInstanceStorageConfigsInput.nextToken, outputKey: \ListInstanceStorageConfigsOutputResponse.nextToken, paginationFunction: self.listInstanceStorageConfigs(input:))
    }
}

extension ListInstanceStorageConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInstanceStorageConfigsInput {
        return ListInstanceStorageConfigsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            resourceType: self.resourceType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listInstanceStorageConfigsPaginated`
/// to access the nested member `[ConnectClientTypes.InstanceStorageConfig]`
/// - Returns: `[ConnectClientTypes.InstanceStorageConfig]`
extension PaginatorSequence where Input == ListInstanceStorageConfigsInput, Output == ListInstanceStorageConfigsOutputResponse {
    public func storageConfigs() async throws -> [ConnectClientTypes.InstanceStorageConfig] {
        return try await self.asyncCompactMap { item in item.storageConfigs }
    }
}

/// Paginate over `[ListIntegrationAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListIntegrationAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListIntegrationAssociationsOutputResponse`
extension ConnectClient {
    public func listIntegrationAssociationsPaginated(input: ListIntegrationAssociationsInput) -> ClientRuntime.PaginatorSequence<ListIntegrationAssociationsInput, ListIntegrationAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListIntegrationAssociationsInput, ListIntegrationAssociationsOutputResponse>(input: input, inputKey: \ListIntegrationAssociationsInput.nextToken, outputKey: \ListIntegrationAssociationsOutputResponse.nextToken, paginationFunction: self.listIntegrationAssociations(input:))
    }
}

extension ListIntegrationAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIntegrationAssociationsInput {
        return ListIntegrationAssociationsInput(
            instanceId: self.instanceId,
            integrationType: self.integrationType,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listIntegrationAssociationsPaginated`
/// to access the nested member `[ConnectClientTypes.IntegrationAssociationSummary]`
/// - Returns: `[ConnectClientTypes.IntegrationAssociationSummary]`
extension PaginatorSequence where Input == ListIntegrationAssociationsInput, Output == ListIntegrationAssociationsOutputResponse {
    public func integrationAssociationSummaryList() async throws -> [ConnectClientTypes.IntegrationAssociationSummary] {
        return try await self.asyncCompactMap { item in item.integrationAssociationSummaryList }
    }
}

/// Paginate over `[ListLambdaFunctionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListLambdaFunctionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListLambdaFunctionsOutputResponse`
extension ConnectClient {
    public func listLambdaFunctionsPaginated(input: ListLambdaFunctionsInput) -> ClientRuntime.PaginatorSequence<ListLambdaFunctionsInput, ListLambdaFunctionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListLambdaFunctionsInput, ListLambdaFunctionsOutputResponse>(input: input, inputKey: \ListLambdaFunctionsInput.nextToken, outputKey: \ListLambdaFunctionsOutputResponse.nextToken, paginationFunction: self.listLambdaFunctions(input:))
    }
}

extension ListLambdaFunctionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLambdaFunctionsInput {
        return ListLambdaFunctionsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listLambdaFunctionsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListLambdaFunctionsInput, Output == ListLambdaFunctionsOutputResponse {
    public func lambdaFunctions() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.lambdaFunctions }
    }
}

/// Paginate over `[ListLexBotsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListLexBotsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListLexBotsOutputResponse`
extension ConnectClient {
    public func listLexBotsPaginated(input: ListLexBotsInput) -> ClientRuntime.PaginatorSequence<ListLexBotsInput, ListLexBotsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListLexBotsInput, ListLexBotsOutputResponse>(input: input, inputKey: \ListLexBotsInput.nextToken, outputKey: \ListLexBotsOutputResponse.nextToken, paginationFunction: self.listLexBots(input:))
    }
}

extension ListLexBotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLexBotsInput {
        return ListLexBotsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listLexBotsPaginated`
/// to access the nested member `[ConnectClientTypes.LexBot]`
/// - Returns: `[ConnectClientTypes.LexBot]`
extension PaginatorSequence where Input == ListLexBotsInput, Output == ListLexBotsOutputResponse {
    public func lexBots() async throws -> [ConnectClientTypes.LexBot] {
        return try await self.asyncCompactMap { item in item.lexBots }
    }
}

/// Paginate over `[ListPhoneNumbersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPhoneNumbersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPhoneNumbersOutputResponse`
extension ConnectClient {
    public func listPhoneNumbersPaginated(input: ListPhoneNumbersInput) -> ClientRuntime.PaginatorSequence<ListPhoneNumbersInput, ListPhoneNumbersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPhoneNumbersInput, ListPhoneNumbersOutputResponse>(input: input, inputKey: \ListPhoneNumbersInput.nextToken, outputKey: \ListPhoneNumbersOutputResponse.nextToken, paginationFunction: self.listPhoneNumbers(input:))
    }
}

extension ListPhoneNumbersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPhoneNumbersInput {
        return ListPhoneNumbersInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            phoneNumberCountryCodes: self.phoneNumberCountryCodes,
            phoneNumberTypes: self.phoneNumberTypes
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPhoneNumbersPaginated`
/// to access the nested member `[ConnectClientTypes.PhoneNumberSummary]`
/// - Returns: `[ConnectClientTypes.PhoneNumberSummary]`
extension PaginatorSequence where Input == ListPhoneNumbersInput, Output == ListPhoneNumbersOutputResponse {
    public func phoneNumberSummaryList() async throws -> [ConnectClientTypes.PhoneNumberSummary] {
        return try await self.asyncCompactMap { item in item.phoneNumberSummaryList }
    }
}

/// Paginate over `[ListPhoneNumbersV2OutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPhoneNumbersV2Input]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPhoneNumbersV2OutputResponse`
extension ConnectClient {
    public func listPhoneNumbersV2Paginated(input: ListPhoneNumbersV2Input) -> ClientRuntime.PaginatorSequence<ListPhoneNumbersV2Input, ListPhoneNumbersV2OutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPhoneNumbersV2Input, ListPhoneNumbersV2OutputResponse>(input: input, inputKey: \ListPhoneNumbersV2Input.nextToken, outputKey: \ListPhoneNumbersV2OutputResponse.nextToken, paginationFunction: self.listPhoneNumbersV2(input:))
    }
}

extension ListPhoneNumbersV2Input: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPhoneNumbersV2Input {
        return ListPhoneNumbersV2Input(
            maxResults: self.maxResults,
            nextToken: token,
            phoneNumberCountryCodes: self.phoneNumberCountryCodes,
            phoneNumberPrefix: self.phoneNumberPrefix,
            phoneNumberTypes: self.phoneNumberTypes,
            targetArn: self.targetArn
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPhoneNumbersV2Paginated`
/// to access the nested member `[ConnectClientTypes.ListPhoneNumbersSummary]`
/// - Returns: `[ConnectClientTypes.ListPhoneNumbersSummary]`
extension PaginatorSequence where Input == ListPhoneNumbersV2Input, Output == ListPhoneNumbersV2OutputResponse {
    public func listPhoneNumbersSummaryList() async throws -> [ConnectClientTypes.ListPhoneNumbersSummary] {
        return try await self.asyncCompactMap { item in item.listPhoneNumbersSummaryList }
    }
}

/// Paginate over `[ListPromptsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPromptsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPromptsOutputResponse`
extension ConnectClient {
    public func listPromptsPaginated(input: ListPromptsInput) -> ClientRuntime.PaginatorSequence<ListPromptsInput, ListPromptsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPromptsInput, ListPromptsOutputResponse>(input: input, inputKey: \ListPromptsInput.nextToken, outputKey: \ListPromptsOutputResponse.nextToken, paginationFunction: self.listPrompts(input:))
    }
}

extension ListPromptsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPromptsInput {
        return ListPromptsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPromptsPaginated`
/// to access the nested member `[ConnectClientTypes.PromptSummary]`
/// - Returns: `[ConnectClientTypes.PromptSummary]`
extension PaginatorSequence where Input == ListPromptsInput, Output == ListPromptsOutputResponse {
    public func promptSummaryList() async throws -> [ConnectClientTypes.PromptSummary] {
        return try await self.asyncCompactMap { item in item.promptSummaryList }
    }
}

/// Paginate over `[ListQueueQuickConnectsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListQueueQuickConnectsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListQueueQuickConnectsOutputResponse`
extension ConnectClient {
    public func listQueueQuickConnectsPaginated(input: ListQueueQuickConnectsInput) -> ClientRuntime.PaginatorSequence<ListQueueQuickConnectsInput, ListQueueQuickConnectsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListQueueQuickConnectsInput, ListQueueQuickConnectsOutputResponse>(input: input, inputKey: \ListQueueQuickConnectsInput.nextToken, outputKey: \ListQueueQuickConnectsOutputResponse.nextToken, paginationFunction: self.listQueueQuickConnects(input:))
    }
}

extension ListQueueQuickConnectsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListQueueQuickConnectsInput {
        return ListQueueQuickConnectsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            queueId: self.queueId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listQueueQuickConnectsPaginated`
/// to access the nested member `[ConnectClientTypes.QuickConnectSummary]`
/// - Returns: `[ConnectClientTypes.QuickConnectSummary]`
extension PaginatorSequence where Input == ListQueueQuickConnectsInput, Output == ListQueueQuickConnectsOutputResponse {
    public func quickConnectSummaryList() async throws -> [ConnectClientTypes.QuickConnectSummary] {
        return try await self.asyncCompactMap { item in item.quickConnectSummaryList }
    }
}

/// Paginate over `[ListQueuesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListQueuesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListQueuesOutputResponse`
extension ConnectClient {
    public func listQueuesPaginated(input: ListQueuesInput) -> ClientRuntime.PaginatorSequence<ListQueuesInput, ListQueuesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListQueuesInput, ListQueuesOutputResponse>(input: input, inputKey: \ListQueuesInput.nextToken, outputKey: \ListQueuesOutputResponse.nextToken, paginationFunction: self.listQueues(input:))
    }
}

extension ListQueuesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListQueuesInput {
        return ListQueuesInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            queueTypes: self.queueTypes
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listQueuesPaginated`
/// to access the nested member `[ConnectClientTypes.QueueSummary]`
/// - Returns: `[ConnectClientTypes.QueueSummary]`
extension PaginatorSequence where Input == ListQueuesInput, Output == ListQueuesOutputResponse {
    public func queueSummaryList() async throws -> [ConnectClientTypes.QueueSummary] {
        return try await self.asyncCompactMap { item in item.queueSummaryList }
    }
}

/// Paginate over `[ListQuickConnectsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListQuickConnectsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListQuickConnectsOutputResponse`
extension ConnectClient {
    public func listQuickConnectsPaginated(input: ListQuickConnectsInput) -> ClientRuntime.PaginatorSequence<ListQuickConnectsInput, ListQuickConnectsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListQuickConnectsInput, ListQuickConnectsOutputResponse>(input: input, inputKey: \ListQuickConnectsInput.nextToken, outputKey: \ListQuickConnectsOutputResponse.nextToken, paginationFunction: self.listQuickConnects(input:))
    }
}

extension ListQuickConnectsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListQuickConnectsInput {
        return ListQuickConnectsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            quickConnectTypes: self.quickConnectTypes
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listQuickConnectsPaginated`
/// to access the nested member `[ConnectClientTypes.QuickConnectSummary]`
/// - Returns: `[ConnectClientTypes.QuickConnectSummary]`
extension PaginatorSequence where Input == ListQuickConnectsInput, Output == ListQuickConnectsOutputResponse {
    public func quickConnectSummaryList() async throws -> [ConnectClientTypes.QuickConnectSummary] {
        return try await self.asyncCompactMap { item in item.quickConnectSummaryList }
    }
}

/// Paginate over `[ListRoutingProfileQueuesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListRoutingProfileQueuesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListRoutingProfileQueuesOutputResponse`
extension ConnectClient {
    public func listRoutingProfileQueuesPaginated(input: ListRoutingProfileQueuesInput) -> ClientRuntime.PaginatorSequence<ListRoutingProfileQueuesInput, ListRoutingProfileQueuesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRoutingProfileQueuesInput, ListRoutingProfileQueuesOutputResponse>(input: input, inputKey: \ListRoutingProfileQueuesInput.nextToken, outputKey: \ListRoutingProfileQueuesOutputResponse.nextToken, paginationFunction: self.listRoutingProfileQueues(input:))
    }
}

extension ListRoutingProfileQueuesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRoutingProfileQueuesInput {
        return ListRoutingProfileQueuesInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            routingProfileId: self.routingProfileId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listRoutingProfileQueuesPaginated`
/// to access the nested member `[ConnectClientTypes.RoutingProfileQueueConfigSummary]`
/// - Returns: `[ConnectClientTypes.RoutingProfileQueueConfigSummary]`
extension PaginatorSequence where Input == ListRoutingProfileQueuesInput, Output == ListRoutingProfileQueuesOutputResponse {
    public func routingProfileQueueConfigSummaryList() async throws -> [ConnectClientTypes.RoutingProfileQueueConfigSummary] {
        return try await self.asyncCompactMap { item in item.routingProfileQueueConfigSummaryList }
    }
}

/// Paginate over `[ListRoutingProfilesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListRoutingProfilesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListRoutingProfilesOutputResponse`
extension ConnectClient {
    public func listRoutingProfilesPaginated(input: ListRoutingProfilesInput) -> ClientRuntime.PaginatorSequence<ListRoutingProfilesInput, ListRoutingProfilesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRoutingProfilesInput, ListRoutingProfilesOutputResponse>(input: input, inputKey: \ListRoutingProfilesInput.nextToken, outputKey: \ListRoutingProfilesOutputResponse.nextToken, paginationFunction: self.listRoutingProfiles(input:))
    }
}

extension ListRoutingProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRoutingProfilesInput {
        return ListRoutingProfilesInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listRoutingProfilesPaginated`
/// to access the nested member `[ConnectClientTypes.RoutingProfileSummary]`
/// - Returns: `[ConnectClientTypes.RoutingProfileSummary]`
extension PaginatorSequence where Input == ListRoutingProfilesInput, Output == ListRoutingProfilesOutputResponse {
    public func routingProfileSummaryList() async throws -> [ConnectClientTypes.RoutingProfileSummary] {
        return try await self.asyncCompactMap { item in item.routingProfileSummaryList }
    }
}

/// Paginate over `[ListSecurityKeysOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSecurityKeysInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSecurityKeysOutputResponse`
extension ConnectClient {
    public func listSecurityKeysPaginated(input: ListSecurityKeysInput) -> ClientRuntime.PaginatorSequence<ListSecurityKeysInput, ListSecurityKeysOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSecurityKeysInput, ListSecurityKeysOutputResponse>(input: input, inputKey: \ListSecurityKeysInput.nextToken, outputKey: \ListSecurityKeysOutputResponse.nextToken, paginationFunction: self.listSecurityKeys(input:))
    }
}

extension ListSecurityKeysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSecurityKeysInput {
        return ListSecurityKeysInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSecurityKeysPaginated`
/// to access the nested member `[ConnectClientTypes.SecurityKey]`
/// - Returns: `[ConnectClientTypes.SecurityKey]`
extension PaginatorSequence where Input == ListSecurityKeysInput, Output == ListSecurityKeysOutputResponse {
    public func securityKeys() async throws -> [ConnectClientTypes.SecurityKey] {
        return try await self.asyncCompactMap { item in item.securityKeys }
    }
}

/// Paginate over `[ListSecurityProfilePermissionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSecurityProfilePermissionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSecurityProfilePermissionsOutputResponse`
extension ConnectClient {
    public func listSecurityProfilePermissionsPaginated(input: ListSecurityProfilePermissionsInput) -> ClientRuntime.PaginatorSequence<ListSecurityProfilePermissionsInput, ListSecurityProfilePermissionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSecurityProfilePermissionsInput, ListSecurityProfilePermissionsOutputResponse>(input: input, inputKey: \ListSecurityProfilePermissionsInput.nextToken, outputKey: \ListSecurityProfilePermissionsOutputResponse.nextToken, paginationFunction: self.listSecurityProfilePermissions(input:))
    }
}

extension ListSecurityProfilePermissionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSecurityProfilePermissionsInput {
        return ListSecurityProfilePermissionsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileId: self.securityProfileId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSecurityProfilePermissionsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListSecurityProfilePermissionsInput, Output == ListSecurityProfilePermissionsOutputResponse {
    public func permissions() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.permissions }
    }
}

/// Paginate over `[ListSecurityProfilesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSecurityProfilesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSecurityProfilesOutputResponse`
extension ConnectClient {
    public func listSecurityProfilesPaginated(input: ListSecurityProfilesInput) -> ClientRuntime.PaginatorSequence<ListSecurityProfilesInput, ListSecurityProfilesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSecurityProfilesInput, ListSecurityProfilesOutputResponse>(input: input, inputKey: \ListSecurityProfilesInput.nextToken, outputKey: \ListSecurityProfilesOutputResponse.nextToken, paginationFunction: self.listSecurityProfiles(input:))
    }
}

extension ListSecurityProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSecurityProfilesInput {
        return ListSecurityProfilesInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSecurityProfilesPaginated`
/// to access the nested member `[ConnectClientTypes.SecurityProfileSummary]`
/// - Returns: `[ConnectClientTypes.SecurityProfileSummary]`
extension PaginatorSequence where Input == ListSecurityProfilesInput, Output == ListSecurityProfilesOutputResponse {
    public func securityProfileSummaryList() async throws -> [ConnectClientTypes.SecurityProfileSummary] {
        return try await self.asyncCompactMap { item in item.securityProfileSummaryList }
    }
}

/// Paginate over `[ListTaskTemplatesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTaskTemplatesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTaskTemplatesOutputResponse`
extension ConnectClient {
    public func listTaskTemplatesPaginated(input: ListTaskTemplatesInput) -> ClientRuntime.PaginatorSequence<ListTaskTemplatesInput, ListTaskTemplatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTaskTemplatesInput, ListTaskTemplatesOutputResponse>(input: input, inputKey: \ListTaskTemplatesInput.nextToken, outputKey: \ListTaskTemplatesOutputResponse.nextToken, paginationFunction: self.listTaskTemplates(input:))
    }
}

extension ListTaskTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTaskTemplatesInput {
        return ListTaskTemplatesInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            status: self.status
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTaskTemplatesPaginated`
/// to access the nested member `[ConnectClientTypes.TaskTemplateMetadata]`
/// - Returns: `[ConnectClientTypes.TaskTemplateMetadata]`
extension PaginatorSequence where Input == ListTaskTemplatesInput, Output == ListTaskTemplatesOutputResponse {
    public func taskTemplates() async throws -> [ConnectClientTypes.TaskTemplateMetadata] {
        return try await self.asyncCompactMap { item in item.taskTemplates }
    }
}

/// Paginate over `[ListUseCasesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListUseCasesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListUseCasesOutputResponse`
extension ConnectClient {
    public func listUseCasesPaginated(input: ListUseCasesInput) -> ClientRuntime.PaginatorSequence<ListUseCasesInput, ListUseCasesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListUseCasesInput, ListUseCasesOutputResponse>(input: input, inputKey: \ListUseCasesInput.nextToken, outputKey: \ListUseCasesOutputResponse.nextToken, paginationFunction: self.listUseCases(input:))
    }
}

extension ListUseCasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUseCasesInput {
        return ListUseCasesInput(
            instanceId: self.instanceId,
            integrationAssociationId: self.integrationAssociationId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listUseCasesPaginated`
/// to access the nested member `[ConnectClientTypes.UseCase]`
/// - Returns: `[ConnectClientTypes.UseCase]`
extension PaginatorSequence where Input == ListUseCasesInput, Output == ListUseCasesOutputResponse {
    public func useCaseSummaryList() async throws -> [ConnectClientTypes.UseCase] {
        return try await self.asyncCompactMap { item in item.useCaseSummaryList }
    }
}

/// Paginate over `[ListUserHierarchyGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListUserHierarchyGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListUserHierarchyGroupsOutputResponse`
extension ConnectClient {
    public func listUserHierarchyGroupsPaginated(input: ListUserHierarchyGroupsInput) -> ClientRuntime.PaginatorSequence<ListUserHierarchyGroupsInput, ListUserHierarchyGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListUserHierarchyGroupsInput, ListUserHierarchyGroupsOutputResponse>(input: input, inputKey: \ListUserHierarchyGroupsInput.nextToken, outputKey: \ListUserHierarchyGroupsOutputResponse.nextToken, paginationFunction: self.listUserHierarchyGroups(input:))
    }
}

extension ListUserHierarchyGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUserHierarchyGroupsInput {
        return ListUserHierarchyGroupsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listUserHierarchyGroupsPaginated`
/// to access the nested member `[ConnectClientTypes.HierarchyGroupSummary]`
/// - Returns: `[ConnectClientTypes.HierarchyGroupSummary]`
extension PaginatorSequence where Input == ListUserHierarchyGroupsInput, Output == ListUserHierarchyGroupsOutputResponse {
    public func userHierarchyGroupSummaryList() async throws -> [ConnectClientTypes.HierarchyGroupSummary] {
        return try await self.asyncCompactMap { item in item.userHierarchyGroupSummaryList }
    }
}

/// Paginate over `[ListUsersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListUsersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListUsersOutputResponse`
extension ConnectClient {
    public func listUsersPaginated(input: ListUsersInput) -> ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutputResponse>(input: input, inputKey: \ListUsersInput.nextToken, outputKey: \ListUsersOutputResponse.nextToken, paginationFunction: self.listUsers(input:))
    }
}

extension ListUsersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUsersInput {
        return ListUsersInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listUsersPaginated`
/// to access the nested member `[ConnectClientTypes.UserSummary]`
/// - Returns: `[ConnectClientTypes.UserSummary]`
extension PaginatorSequence where Input == ListUsersInput, Output == ListUsersOutputResponse {
    public func userSummaryList() async throws -> [ConnectClientTypes.UserSummary] {
        return try await self.asyncCompactMap { item in item.userSummaryList }
    }
}

/// Paginate over `[SearchAvailablePhoneNumbersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SearchAvailablePhoneNumbersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SearchAvailablePhoneNumbersOutputResponse`
extension ConnectClient {
    public func searchAvailablePhoneNumbersPaginated(input: SearchAvailablePhoneNumbersInput) -> ClientRuntime.PaginatorSequence<SearchAvailablePhoneNumbersInput, SearchAvailablePhoneNumbersOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchAvailablePhoneNumbersInput, SearchAvailablePhoneNumbersOutputResponse>(input: input, inputKey: \SearchAvailablePhoneNumbersInput.nextToken, outputKey: \SearchAvailablePhoneNumbersOutputResponse.nextToken, paginationFunction: self.searchAvailablePhoneNumbers(input:))
    }
}

extension SearchAvailablePhoneNumbersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchAvailablePhoneNumbersInput {
        return SearchAvailablePhoneNumbersInput(
            maxResults: self.maxResults,
            nextToken: token,
            phoneNumberCountryCode: self.phoneNumberCountryCode,
            phoneNumberPrefix: self.phoneNumberPrefix,
            phoneNumberType: self.phoneNumberType,
            targetArn: self.targetArn
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `searchAvailablePhoneNumbersPaginated`
/// to access the nested member `[ConnectClientTypes.AvailableNumberSummary]`
/// - Returns: `[ConnectClientTypes.AvailableNumberSummary]`
extension PaginatorSequence where Input == SearchAvailablePhoneNumbersInput, Output == SearchAvailablePhoneNumbersOutputResponse {
    public func availableNumbersList() async throws -> [ConnectClientTypes.AvailableNumberSummary] {
        return try await self.asyncCompactMap { item in item.availableNumbersList }
    }
}

/// Paginate over `[SearchQueuesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SearchQueuesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SearchQueuesOutputResponse`
extension ConnectClient {
    public func searchQueuesPaginated(input: SearchQueuesInput) -> ClientRuntime.PaginatorSequence<SearchQueuesInput, SearchQueuesOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchQueuesInput, SearchQueuesOutputResponse>(input: input, inputKey: \SearchQueuesInput.nextToken, outputKey: \SearchQueuesOutputResponse.nextToken, paginationFunction: self.searchQueues(input:))
    }
}

extension SearchQueuesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchQueuesInput {
        return SearchQueuesInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            searchCriteria: self.searchCriteria,
            searchFilter: self.searchFilter
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `searchQueuesPaginated`
/// to access the nested member `[ConnectClientTypes.Queue]`
/// - Returns: `[ConnectClientTypes.Queue]`
extension PaginatorSequence where Input == SearchQueuesInput, Output == SearchQueuesOutputResponse {
    public func queues() async throws -> [ConnectClientTypes.Queue] {
        return try await self.asyncCompactMap { item in item.queues }
    }
}

/// Paginate over `[SearchRoutingProfilesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SearchRoutingProfilesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SearchRoutingProfilesOutputResponse`
extension ConnectClient {
    public func searchRoutingProfilesPaginated(input: SearchRoutingProfilesInput) -> ClientRuntime.PaginatorSequence<SearchRoutingProfilesInput, SearchRoutingProfilesOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchRoutingProfilesInput, SearchRoutingProfilesOutputResponse>(input: input, inputKey: \SearchRoutingProfilesInput.nextToken, outputKey: \SearchRoutingProfilesOutputResponse.nextToken, paginationFunction: self.searchRoutingProfiles(input:))
    }
}

extension SearchRoutingProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchRoutingProfilesInput {
        return SearchRoutingProfilesInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            searchCriteria: self.searchCriteria,
            searchFilter: self.searchFilter
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `searchRoutingProfilesPaginated`
/// to access the nested member `[ConnectClientTypes.RoutingProfile]`
/// - Returns: `[ConnectClientTypes.RoutingProfile]`
extension PaginatorSequence where Input == SearchRoutingProfilesInput, Output == SearchRoutingProfilesOutputResponse {
    public func routingProfiles() async throws -> [ConnectClientTypes.RoutingProfile] {
        return try await self.asyncCompactMap { item in item.routingProfiles }
    }
}

/// Paginate over `[SearchSecurityProfilesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SearchSecurityProfilesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SearchSecurityProfilesOutputResponse`
extension ConnectClient {
    public func searchSecurityProfilesPaginated(input: SearchSecurityProfilesInput) -> ClientRuntime.PaginatorSequence<SearchSecurityProfilesInput, SearchSecurityProfilesOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchSecurityProfilesInput, SearchSecurityProfilesOutputResponse>(input: input, inputKey: \SearchSecurityProfilesInput.nextToken, outputKey: \SearchSecurityProfilesOutputResponse.nextToken, paginationFunction: self.searchSecurityProfiles(input:))
    }
}

extension SearchSecurityProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchSecurityProfilesInput {
        return SearchSecurityProfilesInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            searchCriteria: self.searchCriteria,
            searchFilter: self.searchFilter
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `searchSecurityProfilesPaginated`
/// to access the nested member `[ConnectClientTypes.SecurityProfileSearchSummary]`
/// - Returns: `[ConnectClientTypes.SecurityProfileSearchSummary]`
extension PaginatorSequence where Input == SearchSecurityProfilesInput, Output == SearchSecurityProfilesOutputResponse {
    public func securityProfiles() async throws -> [ConnectClientTypes.SecurityProfileSearchSummary] {
        return try await self.asyncCompactMap { item in item.securityProfiles }
    }
}

/// Paginate over `[SearchUsersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SearchUsersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SearchUsersOutputResponse`
extension ConnectClient {
    public func searchUsersPaginated(input: SearchUsersInput) -> ClientRuntime.PaginatorSequence<SearchUsersInput, SearchUsersOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchUsersInput, SearchUsersOutputResponse>(input: input, inputKey: \SearchUsersInput.nextToken, outputKey: \SearchUsersOutputResponse.nextToken, paginationFunction: self.searchUsers(input:))
    }
}

extension SearchUsersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchUsersInput {
        return SearchUsersInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            searchCriteria: self.searchCriteria,
            searchFilter: self.searchFilter
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `searchUsersPaginated`
/// to access the nested member `[ConnectClientTypes.UserSearchSummary]`
/// - Returns: `[ConnectClientTypes.UserSearchSummary]`
extension PaginatorSequence where Input == SearchUsersInput, Output == SearchUsersOutputResponse {
    public func users() async throws -> [ConnectClientTypes.UserSearchSummary] {
        return try await self.asyncCompactMap { item in item.users }
    }
}

/// Paginate over `[SearchVocabulariesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SearchVocabulariesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SearchVocabulariesOutputResponse`
extension ConnectClient {
    public func searchVocabulariesPaginated(input: SearchVocabulariesInput) -> ClientRuntime.PaginatorSequence<SearchVocabulariesInput, SearchVocabulariesOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchVocabulariesInput, SearchVocabulariesOutputResponse>(input: input, inputKey: \SearchVocabulariesInput.nextToken, outputKey: \SearchVocabulariesOutputResponse.nextToken, paginationFunction: self.searchVocabularies(input:))
    }
}

extension SearchVocabulariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchVocabulariesInput {
        return SearchVocabulariesInput(
            instanceId: self.instanceId,
            languageCode: self.languageCode,
            maxResults: self.maxResults,
            nameStartsWith: self.nameStartsWith,
            nextToken: token,
            state: self.state
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `searchVocabulariesPaginated`
/// to access the nested member `[ConnectClientTypes.VocabularySummary]`
/// - Returns: `[ConnectClientTypes.VocabularySummary]`
extension PaginatorSequence where Input == SearchVocabulariesInput, Output == SearchVocabulariesOutputResponse {
    public func vocabularySummaryList() async throws -> [ConnectClientTypes.VocabularySummary] {
        return try await self.asyncCompactMap { item in item.vocabularySummaryList }
    }
}
