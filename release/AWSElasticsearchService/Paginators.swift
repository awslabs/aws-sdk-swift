// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[DescribeDomainAutoTunesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeDomainAutoTunesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeDomainAutoTunesOutputResponse`
extension ElasticsearchClient {
    public func describeDomainAutoTunesPaginated(input: DescribeDomainAutoTunesInput) -> ClientRuntime.PaginatorSequence<DescribeDomainAutoTunesInput, DescribeDomainAutoTunesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDomainAutoTunesInput, DescribeDomainAutoTunesOutputResponse>(input: input, inputKey: \DescribeDomainAutoTunesInput.nextToken, outputKey: \DescribeDomainAutoTunesOutputResponse.nextToken, paginationFunction: self.describeDomainAutoTunes(input:))
    }
}

extension DescribeDomainAutoTunesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDomainAutoTunesInput {
        return DescribeDomainAutoTunesInput(
            domainName: self.domainName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[DescribeInboundCrossClusterSearchConnectionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeInboundCrossClusterSearchConnectionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeInboundCrossClusterSearchConnectionsOutputResponse`
extension ElasticsearchClient {
    public func describeInboundCrossClusterSearchConnectionsPaginated(input: DescribeInboundCrossClusterSearchConnectionsInput) -> ClientRuntime.PaginatorSequence<DescribeInboundCrossClusterSearchConnectionsInput, DescribeInboundCrossClusterSearchConnectionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeInboundCrossClusterSearchConnectionsInput, DescribeInboundCrossClusterSearchConnectionsOutputResponse>(input: input, inputKey: \DescribeInboundCrossClusterSearchConnectionsInput.nextToken, outputKey: \DescribeInboundCrossClusterSearchConnectionsOutputResponse.nextToken, paginationFunction: self.describeInboundCrossClusterSearchConnections(input:))
    }
}

extension DescribeInboundCrossClusterSearchConnectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInboundCrossClusterSearchConnectionsInput {
        return DescribeInboundCrossClusterSearchConnectionsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[DescribeOutboundCrossClusterSearchConnectionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeOutboundCrossClusterSearchConnectionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeOutboundCrossClusterSearchConnectionsOutputResponse`
extension ElasticsearchClient {
    public func describeOutboundCrossClusterSearchConnectionsPaginated(input: DescribeOutboundCrossClusterSearchConnectionsInput) -> ClientRuntime.PaginatorSequence<DescribeOutboundCrossClusterSearchConnectionsInput, DescribeOutboundCrossClusterSearchConnectionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeOutboundCrossClusterSearchConnectionsInput, DescribeOutboundCrossClusterSearchConnectionsOutputResponse>(input: input, inputKey: \DescribeOutboundCrossClusterSearchConnectionsInput.nextToken, outputKey: \DescribeOutboundCrossClusterSearchConnectionsOutputResponse.nextToken, paginationFunction: self.describeOutboundCrossClusterSearchConnections(input:))
    }
}

extension DescribeOutboundCrossClusterSearchConnectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOutboundCrossClusterSearchConnectionsInput {
        return DescribeOutboundCrossClusterSearchConnectionsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[DescribePackagesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribePackagesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribePackagesOutputResponse`
extension ElasticsearchClient {
    public func describePackagesPaginated(input: DescribePackagesInput) -> ClientRuntime.PaginatorSequence<DescribePackagesInput, DescribePackagesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribePackagesInput, DescribePackagesOutputResponse>(input: input, inputKey: \DescribePackagesInput.nextToken, outputKey: \DescribePackagesOutputResponse.nextToken, paginationFunction: self.describePackages(input:))
    }
}

extension DescribePackagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePackagesInput {
        return DescribePackagesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[DescribeReservedElasticsearchInstanceOfferingsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeReservedElasticsearchInstanceOfferingsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedElasticsearchInstanceOfferingsOutputResponse`
extension ElasticsearchClient {
    public func describeReservedElasticsearchInstanceOfferingsPaginated(input: DescribeReservedElasticsearchInstanceOfferingsInput) -> ClientRuntime.PaginatorSequence<DescribeReservedElasticsearchInstanceOfferingsInput, DescribeReservedElasticsearchInstanceOfferingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReservedElasticsearchInstanceOfferingsInput, DescribeReservedElasticsearchInstanceOfferingsOutputResponse>(input: input, inputKey: \DescribeReservedElasticsearchInstanceOfferingsInput.nextToken, outputKey: \DescribeReservedElasticsearchInstanceOfferingsOutputResponse.nextToken, paginationFunction: self.describeReservedElasticsearchInstanceOfferings(input:))
    }
}

extension DescribeReservedElasticsearchInstanceOfferingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedElasticsearchInstanceOfferingsInput {
        return DescribeReservedElasticsearchInstanceOfferingsInput(
            maxResults: self.maxResults,
            nextToken: token,
            reservedElasticsearchInstanceOfferingId: self.reservedElasticsearchInstanceOfferingId
        )}
}

/// Paginate over `[DescribeReservedElasticsearchInstancesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeReservedElasticsearchInstancesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedElasticsearchInstancesOutputResponse`
extension ElasticsearchClient {
    public func describeReservedElasticsearchInstancesPaginated(input: DescribeReservedElasticsearchInstancesInput) -> ClientRuntime.PaginatorSequence<DescribeReservedElasticsearchInstancesInput, DescribeReservedElasticsearchInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReservedElasticsearchInstancesInput, DescribeReservedElasticsearchInstancesOutputResponse>(input: input, inputKey: \DescribeReservedElasticsearchInstancesInput.nextToken, outputKey: \DescribeReservedElasticsearchInstancesOutputResponse.nextToken, paginationFunction: self.describeReservedElasticsearchInstances(input:))
    }
}

extension DescribeReservedElasticsearchInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedElasticsearchInstancesInput {
        return DescribeReservedElasticsearchInstancesInput(
            maxResults: self.maxResults,
            nextToken: token,
            reservedElasticsearchInstanceId: self.reservedElasticsearchInstanceId
        )}
}

/// Paginate over `[GetPackageVersionHistoryOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetPackageVersionHistoryInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetPackageVersionHistoryOutputResponse`
extension ElasticsearchClient {
    public func getPackageVersionHistoryPaginated(input: GetPackageVersionHistoryInput) -> ClientRuntime.PaginatorSequence<GetPackageVersionHistoryInput, GetPackageVersionHistoryOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetPackageVersionHistoryInput, GetPackageVersionHistoryOutputResponse>(input: input, inputKey: \GetPackageVersionHistoryInput.nextToken, outputKey: \GetPackageVersionHistoryOutputResponse.nextToken, paginationFunction: self.getPackageVersionHistory(input:))
    }
}

extension GetPackageVersionHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetPackageVersionHistoryInput {
        return GetPackageVersionHistoryInput(
            maxResults: self.maxResults,
            nextToken: token,
            packageID: self.packageID
        )}
}

/// Paginate over `[GetUpgradeHistoryOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetUpgradeHistoryInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetUpgradeHistoryOutputResponse`
extension ElasticsearchClient {
    public func getUpgradeHistoryPaginated(input: GetUpgradeHistoryInput) -> ClientRuntime.PaginatorSequence<GetUpgradeHistoryInput, GetUpgradeHistoryOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetUpgradeHistoryInput, GetUpgradeHistoryOutputResponse>(input: input, inputKey: \GetUpgradeHistoryInput.nextToken, outputKey: \GetUpgradeHistoryOutputResponse.nextToken, paginationFunction: self.getUpgradeHistory(input:))
    }
}

extension GetUpgradeHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetUpgradeHistoryInput {
        return GetUpgradeHistoryInput(
            domainName: self.domainName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListDomainsForPackageOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDomainsForPackageInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDomainsForPackageOutputResponse`
extension ElasticsearchClient {
    public func listDomainsForPackagePaginated(input: ListDomainsForPackageInput) -> ClientRuntime.PaginatorSequence<ListDomainsForPackageInput, ListDomainsForPackageOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDomainsForPackageInput, ListDomainsForPackageOutputResponse>(input: input, inputKey: \ListDomainsForPackageInput.nextToken, outputKey: \ListDomainsForPackageOutputResponse.nextToken, paginationFunction: self.listDomainsForPackage(input:))
    }
}

extension ListDomainsForPackageInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDomainsForPackageInput {
        return ListDomainsForPackageInput(
            maxResults: self.maxResults,
            nextToken: token,
            packageID: self.packageID
        )}
}

/// Paginate over `[ListElasticsearchInstanceTypesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListElasticsearchInstanceTypesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListElasticsearchInstanceTypesOutputResponse`
extension ElasticsearchClient {
    public func listElasticsearchInstanceTypesPaginated(input: ListElasticsearchInstanceTypesInput) -> ClientRuntime.PaginatorSequence<ListElasticsearchInstanceTypesInput, ListElasticsearchInstanceTypesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListElasticsearchInstanceTypesInput, ListElasticsearchInstanceTypesOutputResponse>(input: input, inputKey: \ListElasticsearchInstanceTypesInput.nextToken, outputKey: \ListElasticsearchInstanceTypesOutputResponse.nextToken, paginationFunction: self.listElasticsearchInstanceTypes(input:))
    }
}

extension ListElasticsearchInstanceTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListElasticsearchInstanceTypesInput {
        return ListElasticsearchInstanceTypesInput(
            domainName: self.domainName,
            elasticsearchVersion: self.elasticsearchVersion,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListElasticsearchVersionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListElasticsearchVersionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListElasticsearchVersionsOutputResponse`
extension ElasticsearchClient {
    public func listElasticsearchVersionsPaginated(input: ListElasticsearchVersionsInput) -> ClientRuntime.PaginatorSequence<ListElasticsearchVersionsInput, ListElasticsearchVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListElasticsearchVersionsInput, ListElasticsearchVersionsOutputResponse>(input: input, inputKey: \ListElasticsearchVersionsInput.nextToken, outputKey: \ListElasticsearchVersionsOutputResponse.nextToken, paginationFunction: self.listElasticsearchVersions(input:))
    }
}

extension ListElasticsearchVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListElasticsearchVersionsInput {
        return ListElasticsearchVersionsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListPackagesForDomainOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPackagesForDomainInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPackagesForDomainOutputResponse`
extension ElasticsearchClient {
    public func listPackagesForDomainPaginated(input: ListPackagesForDomainInput) -> ClientRuntime.PaginatorSequence<ListPackagesForDomainInput, ListPackagesForDomainOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPackagesForDomainInput, ListPackagesForDomainOutputResponse>(input: input, inputKey: \ListPackagesForDomainInput.nextToken, outputKey: \ListPackagesForDomainOutputResponse.nextToken, paginationFunction: self.listPackagesForDomain(input:))
    }
}

extension ListPackagesForDomainInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPackagesForDomainInput {
        return ListPackagesForDomainInput(
            domainName: self.domainName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
