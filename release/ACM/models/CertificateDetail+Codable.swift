// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension CertificateDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case createdAt = "CreatedAt"
        case domainName = "DomainName"
        case domainValidationOptions = "DomainValidationOptions"
        case extendedKeyUsages = "ExtendedKeyUsages"
        case failureReason = "FailureReason"
        case importedAt = "ImportedAt"
        case inUseBy = "InUseBy"
        case issuedAt = "IssuedAt"
        case issuer = "Issuer"
        case keyAlgorithm = "KeyAlgorithm"
        case keyUsages = "KeyUsages"
        case notAfter = "NotAfter"
        case notBefore = "NotBefore"
        case options = "Options"
        case renewalEligibility = "RenewalEligibility"
        case renewalSummary = "RenewalSummary"
        case revocationReason = "RevocationReason"
        case revokedAt = "RevokedAt"
        case serial = "Serial"
        case signatureAlgorithm = "SignatureAlgorithm"
        case status = "Status"
        case subject = "Subject"
        case subjectAlternativeNames = "SubjectAlternativeNames"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainValidationOptions = domainValidationOptions {
            var domainValidationOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainValidationOptions)
            for domainvalidationlist0 in domainValidationOptions {
                try domainValidationOptionsContainer.encode(domainvalidationlist0)
            }
        }
        if let extendedKeyUsages = extendedKeyUsages {
            var extendedKeyUsagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extendedKeyUsages)
            for extendedkeyusagelist0 in extendedKeyUsages {
                try extendedKeyUsagesContainer.encode(extendedkeyusagelist0)
            }
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason.rawValue, forKey: .failureReason)
        }
        if let importedAt = importedAt {
            try encodeContainer.encode(importedAt.timeIntervalSince1970, forKey: .importedAt)
        }
        if let inUseBy = inUseBy {
            var inUseByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inUseBy)
            for inuselist0 in inUseBy {
                try inUseByContainer.encode(inuselist0)
            }
        }
        if let issuedAt = issuedAt {
            try encodeContainer.encode(issuedAt.timeIntervalSince1970, forKey: .issuedAt)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let keyAlgorithm = keyAlgorithm {
            try encodeContainer.encode(keyAlgorithm.rawValue, forKey: .keyAlgorithm)
        }
        if let keyUsages = keyUsages {
            var keyUsagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keyUsages)
            for keyusagelist0 in keyUsages {
                try keyUsagesContainer.encode(keyusagelist0)
            }
        }
        if let notAfter = notAfter {
            try encodeContainer.encode(notAfter.timeIntervalSince1970, forKey: .notAfter)
        }
        if let notBefore = notBefore {
            try encodeContainer.encode(notBefore.timeIntervalSince1970, forKey: .notBefore)
        }
        if let options = options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let renewalEligibility = renewalEligibility {
            try encodeContainer.encode(renewalEligibility.rawValue, forKey: .renewalEligibility)
        }
        if let renewalSummary = renewalSummary {
            try encodeContainer.encode(renewalSummary, forKey: .renewalSummary)
        }
        if let revocationReason = revocationReason {
            try encodeContainer.encode(revocationReason.rawValue, forKey: .revocationReason)
        }
        if let revokedAt = revokedAt {
            try encodeContainer.encode(revokedAt.timeIntervalSince1970, forKey: .revokedAt)
        }
        if let serial = serial {
            try encodeContainer.encode(serial, forKey: .serial)
        }
        if let signatureAlgorithm = signatureAlgorithm {
            try encodeContainer.encode(signatureAlgorithm, forKey: .signatureAlgorithm)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let subjectAlternativeNames = subjectAlternativeNames {
            var subjectAlternativeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subjectAlternativeNames)
            for domainlist0 in subjectAlternativeNames {
                try subjectAlternativeNamesContainer.encode(domainlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let subjectAlternativeNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subjectAlternativeNames)
        var subjectAlternativeNamesDecoded0:[String]? = nil
        if let subjectAlternativeNamesContainer = subjectAlternativeNamesContainer {
            subjectAlternativeNamesDecoded0 = [String]()
            for string0 in subjectAlternativeNamesContainer {
                if let string0 = string0 {
                    subjectAlternativeNamesDecoded0?.append(string0)
                }
            }
        }
        subjectAlternativeNames = subjectAlternativeNamesDecoded0
        let domainValidationOptionsContainer = try containerValues.decodeIfPresent([DomainValidation?].self, forKey: .domainValidationOptions)
        var domainValidationOptionsDecoded0:[DomainValidation]? = nil
        if let domainValidationOptionsContainer = domainValidationOptionsContainer {
            domainValidationOptionsDecoded0 = [DomainValidation]()
            for structure0 in domainValidationOptionsContainer {
                if let structure0 = structure0 {
                    domainValidationOptionsDecoded0?.append(structure0)
                }
            }
        }
        domainValidationOptions = domainValidationOptionsDecoded0
        let serialDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serial)
        serial = serialDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issuer)
        issuer = issuerDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let issuedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .issuedAt)
        issuedAt = issuedAtDecoded
        let importedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .importedAt)
        importedAt = importedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CertificateStatus.self, forKey: .status)
        status = statusDecoded
        let revokedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .revokedAt)
        revokedAt = revokedAtDecoded
        let revocationReasonDecoded = try containerValues.decodeIfPresent(RevocationReason.self, forKey: .revocationReason)
        revocationReason = revocationReasonDecoded
        let notBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .notBefore)
        notBefore = notBeforeDecoded
        let notAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .notAfter)
        notAfter = notAfterDecoded
        let keyAlgorithmDecoded = try containerValues.decodeIfPresent(KeyAlgorithm.self, forKey: .keyAlgorithm)
        keyAlgorithm = keyAlgorithmDecoded
        let signatureAlgorithmDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signatureAlgorithm)
        signatureAlgorithm = signatureAlgorithmDecoded
        let inUseByContainer = try containerValues.decodeIfPresent([String?].self, forKey: .inUseBy)
        var inUseByDecoded0:[String]? = nil
        if let inUseByContainer = inUseByContainer {
            inUseByDecoded0 = [String]()
            for string0 in inUseByContainer {
                if let string0 = string0 {
                    inUseByDecoded0?.append(string0)
                }
            }
        }
        inUseBy = inUseByDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(FailureReason.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CertificateType.self, forKey: .type)
        type = typeDecoded
        let renewalSummaryDecoded = try containerValues.decodeIfPresent(RenewalSummary.self, forKey: .renewalSummary)
        renewalSummary = renewalSummaryDecoded
        let keyUsagesContainer = try containerValues.decodeIfPresent([KeyUsage?].self, forKey: .keyUsages)
        var keyUsagesDecoded0:[KeyUsage]? = nil
        if let keyUsagesContainer = keyUsagesContainer {
            keyUsagesDecoded0 = [KeyUsage]()
            for structure0 in keyUsagesContainer {
                if let structure0 = structure0 {
                    keyUsagesDecoded0?.append(structure0)
                }
            }
        }
        keyUsages = keyUsagesDecoded0
        let extendedKeyUsagesContainer = try containerValues.decodeIfPresent([ExtendedKeyUsage?].self, forKey: .extendedKeyUsages)
        var extendedKeyUsagesDecoded0:[ExtendedKeyUsage]? = nil
        if let extendedKeyUsagesContainer = extendedKeyUsagesContainer {
            extendedKeyUsagesDecoded0 = [ExtendedKeyUsage]()
            for structure0 in extendedKeyUsagesContainer {
                if let structure0 = structure0 {
                    extendedKeyUsagesDecoded0?.append(structure0)
                }
            }
        }
        extendedKeyUsages = extendedKeyUsagesDecoded0
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let renewalEligibilityDecoded = try containerValues.decodeIfPresent(RenewalEligibility.self, forKey: .renewalEligibility)
        renewalEligibility = renewalEligibilityDecoded
        let optionsDecoded = try containerValues.decodeIfPresent(CertificateOptions.self, forKey: .options)
        options = optionsDecoded
    }
}
