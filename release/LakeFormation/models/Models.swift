// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Access to a resource was denied.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AddLFTagsToResourceInputBodyMiddleware: Middleware {
    public let id: String = "AddLFTagsToResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddLFTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddLFTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddLFTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddLFTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddLFTagsToResourceOutputError>
}

extension AddLFTagsToResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddLFTagsToResourceInput(catalogId: \(String(describing: catalogId)), lFTags: \(String(describing: lFTags)), resource: \(String(describing: resource)))"}
}

extension AddLFTagsToResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case lFTags = "LFTags"
        case resource = "Resource"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let lFTags = lFTags {
            var lFTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lFTags)
            for lftagslist0 in lFTags {
                try lFTagsContainer.encode(lftagslist0)
            }
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }
}

public struct AddLFTagsToResourceInputHeadersMiddleware: Middleware {
    public let id: String = "AddLFTagsToResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddLFTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddLFTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddLFTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddLFTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddLFTagsToResourceOutputError>
}

public struct AddLFTagsToResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "AddLFTagsToResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddLFTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddLFTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddLFTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddLFTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddLFTagsToResourceOutputError>
}

public struct AddLFTagsToResourceInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>The tags to attach to the resource.</p>
    public let lFTags: [LFTagPair]?
    /// <p>The resource to which to attach a tag.</p>
    public let resource: Resource?

    public init (
        catalogId: String? = nil,
        lFTags: [LFTagPair]? = nil,
        resource: Resource? = nil
    )
    {
        self.catalogId = catalogId
        self.lFTags = lFTags
        self.resource = resource
    }
}

struct AddLFTagsToResourceInputBody: Equatable {
    public let catalogId: String?
    public let resource: Resource?
    public let lFTags: [LFTagPair]?
}

extension AddLFTagsToResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case lFTags = "LFTags"
        case resource = "Resource"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Resource.self, forKey: .resource)
        resource = resourceDecoded
        let lFTagsContainer = try containerValues.decodeIfPresent([LFTagPair?].self, forKey: .lFTags)
        var lFTagsDecoded0:[LFTagPair]? = nil
        if let lFTagsContainer = lFTagsContainer {
            lFTagsDecoded0 = [LFTagPair]()
            for structure0 in lFTagsContainer {
                if let structure0 = structure0 {
                    lFTagsDecoded0?.append(structure0)
                }
            }
        }
        lFTags = lFTagsDecoded0
    }
}

extension AddLFTagsToResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddLFTagsToResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddLFTagsToResourceOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddLFTagsToResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddLFTagsToResourceOutputResponse(failures: \(String(describing: failures)))"}
}

extension AddLFTagsToResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddLFTagsToResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
        } else {
            self.failures = nil
        }
    }
}

public struct AddLFTagsToResourceOutputResponse: Equatable {
    /// <p>A list of failures to tag the resource.</p>
    public let failures: [LFTagError]?

    public init (
        failures: [LFTagError]? = nil
    )
    {
        self.failures = failures
    }
}

struct AddLFTagsToResourceOutputResponseBody: Equatable {
    public let failures: [LFTagError]?
}

extension AddLFTagsToResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failures = "Failures"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failuresContainer = try containerValues.decodeIfPresent([LFTagError?].self, forKey: .failures)
        var failuresDecoded0:[LFTagError]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [LFTagError]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

extension AlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlreadyExistsException(message: \(String(describing: message)))"}
}

extension AlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource to be created or added already exists.</p>
public struct AlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension AlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct BatchGrantPermissionsInputBodyMiddleware: Middleware {
    public let id: String = "BatchGrantPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGrantPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGrantPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGrantPermissionsInput>
    public typealias MOutput = OperationOutput<BatchGrantPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGrantPermissionsOutputError>
}

extension BatchGrantPermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGrantPermissionsInput(catalogId: \(String(describing: catalogId)), entries: \(String(describing: entries)))"}
}

extension BatchGrantPermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case entries = "Entries"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for batchpermissionsrequestentrylist0 in entries {
                try entriesContainer.encode(batchpermissionsrequestentrylist0)
            }
        }
    }
}

public struct BatchGrantPermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGrantPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGrantPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGrantPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGrantPermissionsInput>
    public typealias MOutput = OperationOutput<BatchGrantPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGrantPermissionsOutputError>
}

public struct BatchGrantPermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGrantPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGrantPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGrantPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGrantPermissionsInput>
    public typealias MOutput = OperationOutput<BatchGrantPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGrantPermissionsOutputError>
}

public struct BatchGrantPermissionsInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>A list of up to 20 entries for resource permissions to be granted by batch operation to the principal.</p>
    public let entries: [BatchPermissionsRequestEntry]?

    public init (
        catalogId: String? = nil,
        entries: [BatchPermissionsRequestEntry]? = nil
    )
    {
        self.catalogId = catalogId
        self.entries = entries
    }
}

struct BatchGrantPermissionsInputBody: Equatable {
    public let catalogId: String?
    public let entries: [BatchPermissionsRequestEntry]?
}

extension BatchGrantPermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case entries = "Entries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let entriesContainer = try containerValues.decodeIfPresent([BatchPermissionsRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[BatchPermissionsRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [BatchPermissionsRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchGrantPermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGrantPermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGrantPermissionsOutputError: Swift.Error, Equatable {
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGrantPermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGrantPermissionsOutputResponse(failures: \(String(describing: failures)))"}
}

extension BatchGrantPermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchGrantPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
        } else {
            self.failures = nil
        }
    }
}

public struct BatchGrantPermissionsOutputResponse: Equatable {
    /// <p>A list of failures to grant permissions to the resources.</p>
    public let failures: [BatchPermissionsFailureEntry]?

    public init (
        failures: [BatchPermissionsFailureEntry]? = nil
    )
    {
        self.failures = failures
    }
}

struct BatchGrantPermissionsOutputResponseBody: Equatable {
    public let failures: [BatchPermissionsFailureEntry]?
}

extension BatchGrantPermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failures = "Failures"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failuresContainer = try containerValues.decodeIfPresent([BatchPermissionsFailureEntry?].self, forKey: .failures)
        var failuresDecoded0:[BatchPermissionsFailureEntry]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [BatchPermissionsFailureEntry]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

extension BatchPermissionsFailureEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case error = "Error"
        case requestEntry = "RequestEntry"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let requestEntry = requestEntry {
            try encodeContainer.encode(requestEntry, forKey: .requestEntry)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestEntryDecoded = try containerValues.decodeIfPresent(BatchPermissionsRequestEntry.self, forKey: .requestEntry)
        requestEntry = requestEntryDecoded
        let errorDecoded = try containerValues.decodeIfPresent(ErrorDetail.self, forKey: .error)
        error = errorDecoded
    }
}

extension BatchPermissionsFailureEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPermissionsFailureEntry(error: \(String(describing: error)), requestEntry: \(String(describing: requestEntry)))"}
}

/// <p>A list of failures when performing a batch grant or batch revoke operation.</p>
public struct BatchPermissionsFailureEntry: Equatable {
    /// <p>An error message that applies to the failure of the entry.</p>
    public let error: ErrorDetail?
    /// <p>An identifier for an entry of the batch request.</p>
    public let requestEntry: BatchPermissionsRequestEntry?

    public init (
        error: ErrorDetail? = nil,
        requestEntry: BatchPermissionsRequestEntry? = nil
    )
    {
        self.error = error
        self.requestEntry = requestEntry
    }
}

extension BatchPermissionsRequestEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case permissions = "Permissions"
        case permissionsWithGrantOption = "PermissionsWithGrantOption"
        case principal = "Principal"
        case resource = "Resource"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permissionlist0 in permissions {
                try permissionsContainer.encode(permissionlist0.rawValue)
            }
        }
        if let permissionsWithGrantOption = permissionsWithGrantOption {
            var permissionsWithGrantOptionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionsWithGrantOption)
            for permissionlist0 in permissionsWithGrantOption {
                try permissionsWithGrantOptionContainer.encode(permissionlist0.rawValue)
            }
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let principalDecoded = try containerValues.decodeIfPresent(DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Resource.self, forKey: .resource)
        resource = resourceDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Permission]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
        let permissionsWithGrantOptionContainer = try containerValues.decodeIfPresent([Permission?].self, forKey: .permissionsWithGrantOption)
        var permissionsWithGrantOptionDecoded0:[Permission]? = nil
        if let permissionsWithGrantOptionContainer = permissionsWithGrantOptionContainer {
            permissionsWithGrantOptionDecoded0 = [Permission]()
            for string0 in permissionsWithGrantOptionContainer {
                if let string0 = string0 {
                    permissionsWithGrantOptionDecoded0?.append(string0)
                }
            }
        }
        permissionsWithGrantOption = permissionsWithGrantOptionDecoded0
    }
}

extension BatchPermissionsRequestEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPermissionsRequestEntry(id: \(String(describing: id)), permissions: \(String(describing: permissions)), permissionsWithGrantOption: \(String(describing: permissionsWithGrantOption)), principal: \(String(describing: principal)), resource: \(String(describing: resource)))"}
}

/// <p>A permission to a resource granted by batch operation to the principal.</p>
public struct BatchPermissionsRequestEntry: Equatable {
    /// <p>A unique identifier for the batch permissions request entry.</p>
    public let id: String?
    /// <p>The permissions to be granted.</p>
    public let permissions: [Permission]?
    /// <p>Indicates if the option to pass permissions is granted.</p>
    public let permissionsWithGrantOption: [Permission]?
    /// <p>The principal to be granted a permission.</p>
    public let principal: DataLakePrincipal?
    /// <p>The resource to which the principal is to be granted a permission.</p>
    public let resource: Resource?

    public init (
        id: String? = nil,
        permissions: [Permission]? = nil,
        permissionsWithGrantOption: [Permission]? = nil,
        principal: DataLakePrincipal? = nil,
        resource: Resource? = nil
    )
    {
        self.id = id
        self.permissions = permissions
        self.permissionsWithGrantOption = permissionsWithGrantOption
        self.principal = principal
        self.resource = resource
    }
}

public struct BatchRevokePermissionsInputBodyMiddleware: Middleware {
    public let id: String = "BatchRevokePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchRevokePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchRevokePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchRevokePermissionsInput>
    public typealias MOutput = OperationOutput<BatchRevokePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchRevokePermissionsOutputError>
}

extension BatchRevokePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchRevokePermissionsInput(catalogId: \(String(describing: catalogId)), entries: \(String(describing: entries)))"}
}

extension BatchRevokePermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case entries = "Entries"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for batchpermissionsrequestentrylist0 in entries {
                try entriesContainer.encode(batchpermissionsrequestentrylist0)
            }
        }
    }
}

public struct BatchRevokePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchRevokePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchRevokePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchRevokePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchRevokePermissionsInput>
    public typealias MOutput = OperationOutput<BatchRevokePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchRevokePermissionsOutputError>
}

public struct BatchRevokePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchRevokePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchRevokePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchRevokePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchRevokePermissionsInput>
    public typealias MOutput = OperationOutput<BatchRevokePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchRevokePermissionsOutputError>
}

public struct BatchRevokePermissionsInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>A list of up to 20 entries for resource permissions to be revoked by batch operation to the principal.</p>
    public let entries: [BatchPermissionsRequestEntry]?

    public init (
        catalogId: String? = nil,
        entries: [BatchPermissionsRequestEntry]? = nil
    )
    {
        self.catalogId = catalogId
        self.entries = entries
    }
}

struct BatchRevokePermissionsInputBody: Equatable {
    public let catalogId: String?
    public let entries: [BatchPermissionsRequestEntry]?
}

extension BatchRevokePermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case entries = "Entries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let entriesContainer = try containerValues.decodeIfPresent([BatchPermissionsRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[BatchPermissionsRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [BatchPermissionsRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchRevokePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchRevokePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchRevokePermissionsOutputError: Swift.Error, Equatable {
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchRevokePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchRevokePermissionsOutputResponse(failures: \(String(describing: failures)))"}
}

extension BatchRevokePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchRevokePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
        } else {
            self.failures = nil
        }
    }
}

public struct BatchRevokePermissionsOutputResponse: Equatable {
    /// <p>A list of failures to revoke permissions to the resources.</p>
    public let failures: [BatchPermissionsFailureEntry]?

    public init (
        failures: [BatchPermissionsFailureEntry]? = nil
    )
    {
        self.failures = failures
    }
}

struct BatchRevokePermissionsOutputResponseBody: Equatable {
    public let failures: [BatchPermissionsFailureEntry]?
}

extension BatchRevokePermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failures = "Failures"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failuresContainer = try containerValues.decodeIfPresent([BatchPermissionsFailureEntry?].self, forKey: .failures)
        var failuresDecoded0:[BatchPermissionsFailureEntry]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [BatchPermissionsFailureEntry]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

extension CatalogResource: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension CatalogResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CatalogResource()"}
}

/// <p>A structure for the catalog object.</p>
public struct CatalogResource: Equatable {

    public init() {}
}

extension ColumnLFTag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lFTags = "LFTags"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lFTags = lFTags {
            var lFTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lFTags)
            for lftagslist0 in lFTags {
                try lFTagsContainer.encode(lftagslist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let lFTagsContainer = try containerValues.decodeIfPresent([LFTagPair?].self, forKey: .lFTags)
        var lFTagsDecoded0:[LFTagPair]? = nil
        if let lFTagsContainer = lFTagsContainer {
            lFTagsDecoded0 = [LFTagPair]()
            for structure0 in lFTagsContainer {
                if let structure0 = structure0 {
                    lFTagsDecoded0?.append(structure0)
                }
            }
        }
        lFTags = lFTagsDecoded0
    }
}

extension ColumnLFTag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnLFTag(lFTags: \(String(describing: lFTags)), name: \(String(describing: name)))"}
}

/// <p>A structure containing the name of a column resource and the tags attached to it.</p>
public struct ColumnLFTag: Equatable {
    /// <p>The tags attached to a column resource.</p>
    public let lFTags: [LFTagPair]?
    /// <p>The name of a column resource.</p>
    public let name: String?

    public init (
        lFTags: [LFTagPair]? = nil,
        name: String? = nil
    )
    {
        self.lFTags = lFTags
        self.name = name
    }
}

extension ColumnWildcard: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case excludedColumnNames = "ExcludedColumnNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludedColumnNames = excludedColumnNames {
            var excludedColumnNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedColumnNames)
            for columnnames0 in excludedColumnNames {
                try excludedColumnNamesContainer.encode(columnnames0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludedColumnNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .excludedColumnNames)
        var excludedColumnNamesDecoded0:[String]? = nil
        if let excludedColumnNamesContainer = excludedColumnNamesContainer {
            excludedColumnNamesDecoded0 = [String]()
            for string0 in excludedColumnNamesContainer {
                if let string0 = string0 {
                    excludedColumnNamesDecoded0?.append(string0)
                }
            }
        }
        excludedColumnNames = excludedColumnNamesDecoded0
    }
}

extension ColumnWildcard: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnWildcard(excludedColumnNames: \(String(describing: excludedColumnNames)))"}
}

/// <p>A wildcard object, consisting of an optional list of excluded column names or indexes.</p>
public struct ColumnWildcard: Equatable {
    /// <p>Excludes column names. Any column with this name will be excluded.</p>
    public let excludedColumnNames: [String]?

    public init (
        excludedColumnNames: [String]? = nil
    )
    {
        self.excludedColumnNames = excludedColumnNames
    }
}

public enum ComparisonOperator {
    case beginsWith
    case between
    case contains
    case eq
    case ge
    case gt
    case `in`
    case le
    case lt
    case ne
    case notContains
    case sdkUnknown(String)
}

extension ComparisonOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComparisonOperator] {
        return [
            .beginsWith,
            .between,
            .contains,
            .eq,
            .ge,
            .gt,
            .in,
            .le,
            .lt,
            .ne,
            .notContains,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .beginsWith: return "BEGINS_WITH"
        case .between: return "BETWEEN"
        case .contains: return "CONTAINS"
        case .eq: return "EQ"
        case .ge: return "GE"
        case .gt: return "GT"
        case .in: return "IN"
        case .le: return "LE"
        case .lt: return "LT"
        case .ne: return "NE"
        case .notContains: return "NOT_CONTAINS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Two processes are trying to modify a resource simultaneously.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateLFTagInputBodyMiddleware: Middleware {
    public let id: String = "CreateLFTagInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLFTagInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLFTagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLFTagInput>
    public typealias MOutput = OperationOutput<CreateLFTagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLFTagOutputError>
}

extension CreateLFTagInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLFTagInput(catalogId: \(String(describing: catalogId)), tagKey: \(String(describing: tagKey)), tagValues: \(String(describing: tagValues)))"}
}

extension CreateLFTagInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let tagKey = tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagvaluelist0 in tagValues {
                try tagValuesContainer.encode(tagvaluelist0)
            }
        }
    }
}

public struct CreateLFTagInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLFTagInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLFTagInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLFTagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLFTagInput>
    public typealias MOutput = OperationOutput<CreateLFTagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLFTagOutputError>
}

public struct CreateLFTagInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLFTagInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLFTagInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLFTagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLFTagInput>
    public typealias MOutput = OperationOutput<CreateLFTagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLFTagOutputError>
}

public struct CreateLFTagInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>The key-name for the tag.</p>
    public let tagKey: String?
    /// <p>A list of possible values an attribute can take.</p>
    public let tagValues: [String]?

    public init (
        catalogId: String? = nil,
        tagKey: String? = nil,
        tagValues: [String]? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
        self.tagValues = tagValues
    }
}

struct CreateLFTagInputBody: Equatable {
    public let catalogId: String?
    public let tagKey: String?
    public let tagValues: [String]?
}

extension CreateLFTagInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
        case tagValues = "TagValues"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension CreateLFTagOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLFTagOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNumberLimitExceededException" : self = .resourceNumberLimitExceededException(try ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLFTagOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case resourceNumberLimitExceededException(ResourceNumberLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLFTagOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLFTagOutputResponse()"}
}

extension CreateLFTagOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateLFTagOutputResponse: Equatable {

    public init() {}
}

struct CreateLFTagOutputResponseBody: Equatable {
}

extension CreateLFTagOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DataLakePrincipal: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataLakePrincipalIdentifier = "DataLakePrincipalIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataLakePrincipalIdentifier = dataLakePrincipalIdentifier {
            try encodeContainer.encode(dataLakePrincipalIdentifier, forKey: .dataLakePrincipalIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLakePrincipalIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataLakePrincipalIdentifier)
        dataLakePrincipalIdentifier = dataLakePrincipalIdentifierDecoded
    }
}

extension DataLakePrincipal: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataLakePrincipal(dataLakePrincipalIdentifier: \(String(describing: dataLakePrincipalIdentifier)))"}
}

/// <p>The AWS Lake Formation principal. Supported principals are IAM users or IAM roles.</p>
public struct DataLakePrincipal: Equatable {
    /// <p>An identifier for the AWS Lake Formation principal.</p>
    public let dataLakePrincipalIdentifier: String?

    public init (
        dataLakePrincipalIdentifier: String? = nil
    )
    {
        self.dataLakePrincipalIdentifier = dataLakePrincipalIdentifier
    }
}

public enum DataLakeResourceType {
    case catalog
    case database
    case dataLocation
    case lfTag
    case lfTagPolicy
    case lfTagPolicyDatabase
    case lfTagPolicyTable
    case table
    case sdkUnknown(String)
}

extension DataLakeResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataLakeResourceType] {
        return [
            .catalog,
            .database,
            .dataLocation,
            .lfTag,
            .lfTagPolicy,
            .lfTagPolicyDatabase,
            .lfTagPolicyTable,
            .table,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .catalog: return "CATALOG"
        case .database: return "DATABASE"
        case .dataLocation: return "DATA_LOCATION"
        case .lfTag: return "LF_TAG"
        case .lfTagPolicy: return "LF_TAG_POLICY"
        case .lfTagPolicyDatabase: return "LF_TAG_POLICY_DATABASE"
        case .lfTagPolicyTable: return "LF_TAG_POLICY_TABLE"
        case .table: return "TABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataLakeResourceType(rawValue: rawValue) ?? DataLakeResourceType.sdkUnknown(rawValue)
    }
}

extension DataLakeSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createDatabaseDefaultPermissions = "CreateDatabaseDefaultPermissions"
        case createTableDefaultPermissions = "CreateTableDefaultPermissions"
        case dataLakeAdmins = "DataLakeAdmins"
        case trustedResourceOwners = "TrustedResourceOwners"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDatabaseDefaultPermissions = createDatabaseDefaultPermissions {
            var createDatabaseDefaultPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .createDatabaseDefaultPermissions)
            for principalpermissionslist0 in createDatabaseDefaultPermissions {
                try createDatabaseDefaultPermissionsContainer.encode(principalpermissionslist0)
            }
        }
        if let createTableDefaultPermissions = createTableDefaultPermissions {
            var createTableDefaultPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .createTableDefaultPermissions)
            for principalpermissionslist0 in createTableDefaultPermissions {
                try createTableDefaultPermissionsContainer.encode(principalpermissionslist0)
            }
        }
        if let dataLakeAdmins = dataLakeAdmins {
            var dataLakeAdminsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataLakeAdmins)
            for datalakeprincipallist0 in dataLakeAdmins {
                try dataLakeAdminsContainer.encode(datalakeprincipallist0)
            }
        }
        if let trustedResourceOwners = trustedResourceOwners {
            var trustedResourceOwnersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trustedResourceOwners)
            for trustedresourceowners0 in trustedResourceOwners {
                try trustedResourceOwnersContainer.encode(trustedresourceowners0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLakeAdminsContainer = try containerValues.decodeIfPresent([DataLakePrincipal?].self, forKey: .dataLakeAdmins)
        var dataLakeAdminsDecoded0:[DataLakePrincipal]? = nil
        if let dataLakeAdminsContainer = dataLakeAdminsContainer {
            dataLakeAdminsDecoded0 = [DataLakePrincipal]()
            for structure0 in dataLakeAdminsContainer {
                if let structure0 = structure0 {
                    dataLakeAdminsDecoded0?.append(structure0)
                }
            }
        }
        dataLakeAdmins = dataLakeAdminsDecoded0
        let createDatabaseDefaultPermissionsContainer = try containerValues.decodeIfPresent([PrincipalPermissions?].self, forKey: .createDatabaseDefaultPermissions)
        var createDatabaseDefaultPermissionsDecoded0:[PrincipalPermissions]? = nil
        if let createDatabaseDefaultPermissionsContainer = createDatabaseDefaultPermissionsContainer {
            createDatabaseDefaultPermissionsDecoded0 = [PrincipalPermissions]()
            for structure0 in createDatabaseDefaultPermissionsContainer {
                if let structure0 = structure0 {
                    createDatabaseDefaultPermissionsDecoded0?.append(structure0)
                }
            }
        }
        createDatabaseDefaultPermissions = createDatabaseDefaultPermissionsDecoded0
        let createTableDefaultPermissionsContainer = try containerValues.decodeIfPresent([PrincipalPermissions?].self, forKey: .createTableDefaultPermissions)
        var createTableDefaultPermissionsDecoded0:[PrincipalPermissions]? = nil
        if let createTableDefaultPermissionsContainer = createTableDefaultPermissionsContainer {
            createTableDefaultPermissionsDecoded0 = [PrincipalPermissions]()
            for structure0 in createTableDefaultPermissionsContainer {
                if let structure0 = structure0 {
                    createTableDefaultPermissionsDecoded0?.append(structure0)
                }
            }
        }
        createTableDefaultPermissions = createTableDefaultPermissionsDecoded0
        let trustedResourceOwnersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .trustedResourceOwners)
        var trustedResourceOwnersDecoded0:[String]? = nil
        if let trustedResourceOwnersContainer = trustedResourceOwnersContainer {
            trustedResourceOwnersDecoded0 = [String]()
            for string0 in trustedResourceOwnersContainer {
                if let string0 = string0 {
                    trustedResourceOwnersDecoded0?.append(string0)
                }
            }
        }
        trustedResourceOwners = trustedResourceOwnersDecoded0
    }
}

extension DataLakeSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataLakeSettings(createDatabaseDefaultPermissions: \(String(describing: createDatabaseDefaultPermissions)), createTableDefaultPermissions: \(String(describing: createTableDefaultPermissions)), dataLakeAdmins: \(String(describing: dataLakeAdmins)), trustedResourceOwners: \(String(describing: trustedResourceOwners)))"}
}

/// <p>A structure representing a list of AWS Lake Formation principals designated as data lake administrators and lists of principal permission entries for default create database and default create table permissions.</p>
public struct DataLakeSettings: Equatable {
    /// <p>A structure representing a list of up to three principal permissions entries for default create database permissions.</p>
    public let createDatabaseDefaultPermissions: [PrincipalPermissions]?
    /// <p>A structure representing a list of up to three principal permissions entries for default create table permissions.</p>
    public let createTableDefaultPermissions: [PrincipalPermissions]?
    /// <p>A list of AWS Lake Formation principals. Supported principals are IAM users or IAM roles.</p>
    public let dataLakeAdmins: [DataLakePrincipal]?
    /// <p>A list of the resource-owning account IDs that the caller's account can use to share their user access details (user ARNs). The user ARNs can be logged in the resource owner's AWS CloudTrail log.</p>
    /// 	
    /// 	        <p>You may want to specify this property when you are in a high-trust boundary, such as the same team or company. </p>
    public let trustedResourceOwners: [String]?

    public init (
        createDatabaseDefaultPermissions: [PrincipalPermissions]? = nil,
        createTableDefaultPermissions: [PrincipalPermissions]? = nil,
        dataLakeAdmins: [DataLakePrincipal]? = nil,
        trustedResourceOwners: [String]? = nil
    )
    {
        self.createDatabaseDefaultPermissions = createDatabaseDefaultPermissions
        self.createTableDefaultPermissions = createTableDefaultPermissions
        self.dataLakeAdmins = dataLakeAdmins
        self.trustedResourceOwners = trustedResourceOwners
    }
}

extension DataLocationResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DataLocationResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataLocationResource(catalogId: \(String(describing: catalogId)), resourceArn: \(String(describing: resourceArn)))"}
}

/// <p>A structure for a data location object where permissions are granted or revoked. </p>
public struct DataLocationResource: Equatable {
    /// <p>The identifier for the Data Catalog where the location is registered with AWS Lake Formation. By default, it is the account ID of the caller.</p>
    public let catalogId: String?
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the data location resource.</p>
    public let resourceArn: String?

    public init (
        catalogId: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.catalogId = catalogId
        self.resourceArn = resourceArn
    }
}

extension DatabaseResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DatabaseResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatabaseResource(catalogId: \(String(describing: catalogId)), name: \(String(describing: name)))"}
}

/// <p>A structure for the database object.</p>
public struct DatabaseResource: Equatable {
    /// <p>The identifier for the Data Catalog. By default, it is the account ID of the caller.</p>
    public let catalogId: String?
    /// <p>The name of the database resource. Unique to the Data Catalog.</p>
    public let name: String?

    public init (
        catalogId: String? = nil,
        name: String? = nil
    )
    {
        self.catalogId = catalogId
        self.name = name
    }
}

public struct DeleteLFTagInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLFTagInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLFTagInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLFTagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLFTagInput>
    public typealias MOutput = OperationOutput<DeleteLFTagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLFTagOutputError>
}

extension DeleteLFTagInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLFTagInput(catalogId: \(String(describing: catalogId)), tagKey: \(String(describing: tagKey)))"}
}

extension DeleteLFTagInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let tagKey = tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
    }
}

public struct DeleteLFTagInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLFTagInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLFTagInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLFTagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLFTagInput>
    public typealias MOutput = OperationOutput<DeleteLFTagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLFTagOutputError>
}

public struct DeleteLFTagInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLFTagInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLFTagInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLFTagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLFTagInput>
    public typealias MOutput = OperationOutput<DeleteLFTagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLFTagOutputError>
}

public struct DeleteLFTagInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>The key-name for the tag to delete.</p>
    public let tagKey: String?

    public init (
        catalogId: String? = nil,
        tagKey: String? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
    }
}

struct DeleteLFTagInputBody: Equatable {
    public let catalogId: String?
    public let tagKey: String?
}

extension DeleteLFTagInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
    }
}

extension DeleteLFTagOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLFTagOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLFTagOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLFTagOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLFTagOutputResponse()"}
}

extension DeleteLFTagOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLFTagOutputResponse: Equatable {

    public init() {}
}

struct DeleteLFTagOutputResponseBody: Equatable {
}

extension DeleteLFTagOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeregisterResourceInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterResourceInput>
    public typealias MOutput = OperationOutput<DeregisterResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterResourceOutputError>
}

extension DeregisterResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension DeregisterResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DeregisterResourceInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterResourceInput>
    public typealias MOutput = OperationOutput<DeregisterResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterResourceOutputError>
}

public struct DeregisterResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterResourceInput>
    public typealias MOutput = OperationOutput<DeregisterResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterResourceOutputError>
}

public struct DeregisterResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to deregister.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeregisterResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension DeregisterResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeregisterResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterResourceOutputError: Swift.Error, Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterResourceOutputResponse()"}
}

extension DeregisterResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterResourceOutputResponse: Equatable {

    public init() {}
}

struct DeregisterResourceOutputResponseBody: Equatable {
}

extension DeregisterResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeResourceInputBodyMiddleware: Middleware {
    public let id: String = "DescribeResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourceInput>
    public typealias MOutput = OperationOutput<DescribeResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourceOutputError>
}

extension DescribeResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension DescribeResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DescribeResourceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourceInput>
    public typealias MOutput = OperationOutput<DescribeResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourceOutputError>
}

public struct DescribeResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourceInput>
    public typealias MOutput = OperationOutput<DescribeResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourceOutputError>
}

public struct DescribeResourceInput: Equatable {
    /// <p>The resource ARN.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DescribeResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension DescribeResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DescribeResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeResourceOutputError: Swift.Error, Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResourceOutputResponse(resourceInfo: \(String(describing: resourceInfo)))"}
}

extension DescribeResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceInfo = output.resourceInfo
        } else {
            self.resourceInfo = nil
        }
    }
}

public struct DescribeResourceOutputResponse: Equatable {
    /// <p>A structure containing information about an AWS Lake Formation resource.</p>
    public let resourceInfo: ResourceInfo?

    public init (
        resourceInfo: ResourceInfo? = nil
    )
    {
        self.resourceInfo = resourceInfo
    }
}

struct DescribeResourceOutputResponseBody: Equatable {
    public let resourceInfo: ResourceInfo?
}

extension DescribeResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceInfo = "ResourceInfo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceInfoDecoded = try containerValues.decodeIfPresent(ResourceInfo.self, forKey: .resourceInfo)
        resourceInfo = resourceInfoDecoded
    }
}

extension DetailsMap: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceShare = "ResourceShare"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceShare = resourceShare {
            var resourceShareContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShare)
            for resourcesharelist0 in resourceShare {
                try resourceShareContainer.encode(resourcesharelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceShare)
        var resourceShareDecoded0:[String]? = nil
        if let resourceShareContainer = resourceShareContainer {
            resourceShareDecoded0 = [String]()
            for string0 in resourceShareContainer {
                if let string0 = string0 {
                    resourceShareDecoded0?.append(string0)
                }
            }
        }
        resourceShare = resourceShareDecoded0
    }
}

extension DetailsMap: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetailsMap(resourceShare: \(String(describing: resourceShare)))"}
}

/// <p>A structure containing the additional details to be returned in the <code>AdditionalDetails</code> attribute of <code>PrincipalResourcePermissions</code>.</p>
///
///          <p>If a catalog resource is shared through AWS Resource Access Manager (AWS RAM), then there will exist a corresponding RAM resource share ARN.</p>
public struct DetailsMap: Equatable {
    /// <p>A resource share ARN for a catalog resource shared through AWS Resource Access Manager (AWS RAM).</p>
    public let resourceShare: [String]?

    public init (
        resourceShare: [String]? = nil
    )
    {
        self.resourceShare = resourceShare
    }
}

extension EntityNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityNotFoundException(message: \(String(describing: message)))"}
}

extension EntityNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EntityNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified entity does not exist</p>
public struct EntityNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EntityNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension EntityNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ErrorDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ErrorDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorDetail(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>Contains details about an error.</p>
public struct ErrorDetail: Equatable {
    /// <p>The code associated with this error.</p>
    public let errorCode: String?
    /// <p>A message describing the error.</p>
    public let errorMessage: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }
}

public enum FieldNameString {
    case lastModified
    case resourceArn
    case roleArn
    case sdkUnknown(String)
}

extension FieldNameString : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FieldNameString] {
        return [
            .lastModified,
            .resourceArn,
            .roleArn,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lastModified: return "LAST_MODIFIED"
        case .resourceArn: return "RESOURCE_ARN"
        case .roleArn: return "ROLE_ARN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FieldNameString(rawValue: rawValue) ?? FieldNameString.sdkUnknown(rawValue)
    }
}

extension FilterCondition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case field = "Field"
        case stringValueList = "StringValueList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let field = field {
            try encodeContainer.encode(field.rawValue, forKey: .field)
        }
        if let stringValueList = stringValueList {
            var stringValueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringValueList)
            for stringvaluelist0 in stringValueList {
                try stringValueListContainer.encode(stringvaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(FieldNameString.self, forKey: .field)
        field = fieldDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let stringValueListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stringValueList)
        var stringValueListDecoded0:[String]? = nil
        if let stringValueListContainer = stringValueListContainer {
            stringValueListDecoded0 = [String]()
            for string0 in stringValueListContainer {
                if let string0 = string0 {
                    stringValueListDecoded0?.append(string0)
                }
            }
        }
        stringValueList = stringValueListDecoded0
    }
}

extension FilterCondition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FilterCondition(comparisonOperator: \(String(describing: comparisonOperator)), field: \(String(describing: field)), stringValueList: \(String(describing: stringValueList)))"}
}

/// <p>This structure describes the filtering of columns in a table based on a filter condition.</p>
public struct FilterCondition: Equatable {
    /// <p>The comparison operator used in the filter condition.</p>
    public let comparisonOperator: ComparisonOperator?
    /// <p>The field to filter in the filter condition.</p>
    public let field: FieldNameString?
    /// <p>A string with values used in evaluating the filter condition.</p>
    public let stringValueList: [String]?

    public init (
        comparisonOperator: ComparisonOperator? = nil,
        field: FieldNameString? = nil,
        stringValueList: [String]? = nil
    )
    {
        self.comparisonOperator = comparisonOperator
        self.field = field
        self.stringValueList = stringValueList
    }
}

public struct GetDataLakeSettingsInputBodyMiddleware: Middleware {
    public let id: String = "GetDataLakeSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataLakeSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataLakeSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataLakeSettingsInput>
    public typealias MOutput = OperationOutput<GetDataLakeSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataLakeSettingsOutputError>
}

extension GetDataLakeSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataLakeSettingsInput(catalogId: \(String(describing: catalogId)))"}
}

extension GetDataLakeSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
    }
}

public struct GetDataLakeSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDataLakeSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataLakeSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataLakeSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataLakeSettingsInput>
    public typealias MOutput = OperationOutput<GetDataLakeSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataLakeSettingsOutputError>
}

public struct GetDataLakeSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDataLakeSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataLakeSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataLakeSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataLakeSettingsInput>
    public typealias MOutput = OperationOutput<GetDataLakeSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataLakeSettingsOutputError>
}

public struct GetDataLakeSettingsInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?

    public init (
        catalogId: String? = nil
    )
    {
        self.catalogId = catalogId
    }
}

struct GetDataLakeSettingsInputBody: Equatable {
    public let catalogId: String?
}

extension GetDataLakeSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
    }
}

extension GetDataLakeSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataLakeSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataLakeSettingsOutputError: Swift.Error, Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataLakeSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataLakeSettingsOutputResponse(dataLakeSettings: \(String(describing: dataLakeSettings)))"}
}

extension GetDataLakeSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDataLakeSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataLakeSettings = output.dataLakeSettings
        } else {
            self.dataLakeSettings = nil
        }
    }
}

public struct GetDataLakeSettingsOutputResponse: Equatable {
    /// <p>A structure representing a list of AWS Lake Formation principals designated as data lake administrators.</p>
    public let dataLakeSettings: DataLakeSettings?

    public init (
        dataLakeSettings: DataLakeSettings? = nil
    )
    {
        self.dataLakeSettings = dataLakeSettings
    }
}

struct GetDataLakeSettingsOutputResponseBody: Equatable {
    public let dataLakeSettings: DataLakeSettings?
}

extension GetDataLakeSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataLakeSettings = "DataLakeSettings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLakeSettingsDecoded = try containerValues.decodeIfPresent(DataLakeSettings.self, forKey: .dataLakeSettings)
        dataLakeSettings = dataLakeSettingsDecoded
    }
}

public struct GetEffectivePermissionsForPathInputBodyMiddleware: Middleware {
    public let id: String = "GetEffectivePermissionsForPathInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEffectivePermissionsForPathInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEffectivePermissionsForPathOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEffectivePermissionsForPathInput>
    public typealias MOutput = OperationOutput<GetEffectivePermissionsForPathOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEffectivePermissionsForPathOutputError>
}

extension GetEffectivePermissionsForPathInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEffectivePermissionsForPathInput(catalogId: \(String(describing: catalogId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension GetEffectivePermissionsForPathInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct GetEffectivePermissionsForPathInputHeadersMiddleware: Middleware {
    public let id: String = "GetEffectivePermissionsForPathInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEffectivePermissionsForPathInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEffectivePermissionsForPathOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEffectivePermissionsForPathInput>
    public typealias MOutput = OperationOutput<GetEffectivePermissionsForPathOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEffectivePermissionsForPathOutputError>
}

public struct GetEffectivePermissionsForPathInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEffectivePermissionsForPathInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEffectivePermissionsForPathInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEffectivePermissionsForPathOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEffectivePermissionsForPathInput>
    public typealias MOutput = OperationOutput<GetEffectivePermissionsForPathOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEffectivePermissionsForPathOutputError>
}

public struct GetEffectivePermissionsForPathInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is not the first call to retrieve this list.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the resource for which you want to get permissions.</p>
    public let resourceArn: String?

    public init (
        catalogId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.catalogId = catalogId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct GetEffectivePermissionsForPathInputBody: Equatable {
    public let catalogId: String?
    public let resourceArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetEffectivePermissionsForPathInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetEffectivePermissionsForPathOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEffectivePermissionsForPathOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEffectivePermissionsForPathOutputError: Swift.Error, Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEffectivePermissionsForPathOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEffectivePermissionsForPathOutputResponse(nextToken: \(String(describing: nextToken)), permissions: \(String(describing: permissions)))"}
}

extension GetEffectivePermissionsForPathOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEffectivePermissionsForPathOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct GetEffectivePermissionsForPathOutputResponse: Equatable {
    /// <p>A continuation token, if this is not the first call to retrieve this list.</p>
    public let nextToken: String?
    /// <p>A list of the permissions for the specified table or database resource located at the path in Amazon S3.</p>
    public let permissions: [PrincipalResourcePermissions]?

    public init (
        nextToken: String? = nil,
        permissions: [PrincipalResourcePermissions]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct GetEffectivePermissionsForPathOutputResponseBody: Equatable {
    public let permissions: [PrincipalResourcePermissions]?
    public let nextToken: String?
}

extension GetEffectivePermissionsForPathOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case permissions = "Permissions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([PrincipalResourcePermissions?].self, forKey: .permissions)
        var permissionsDecoded0:[PrincipalResourcePermissions]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [PrincipalResourcePermissions]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetLFTagInputBodyMiddleware: Middleware {
    public let id: String = "GetLFTagInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLFTagInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLFTagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLFTagInput>
    public typealias MOutput = OperationOutput<GetLFTagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLFTagOutputError>
}

extension GetLFTagInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLFTagInput(catalogId: \(String(describing: catalogId)), tagKey: \(String(describing: tagKey)))"}
}

extension GetLFTagInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let tagKey = tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
    }
}

public struct GetLFTagInputHeadersMiddleware: Middleware {
    public let id: String = "GetLFTagInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLFTagInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLFTagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLFTagInput>
    public typealias MOutput = OperationOutput<GetLFTagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLFTagOutputError>
}

public struct GetLFTagInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLFTagInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLFTagInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLFTagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLFTagInput>
    public typealias MOutput = OperationOutput<GetLFTagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLFTagOutputError>
}

public struct GetLFTagInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>The key-name for the tag.</p>
    public let tagKey: String?

    public init (
        catalogId: String? = nil,
        tagKey: String? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
    }
}

struct GetLFTagInputBody: Equatable {
    public let catalogId: String?
    public let tagKey: String?
}

extension GetLFTagInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
    }
}

extension GetLFTagOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLFTagOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLFTagOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLFTagOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLFTagOutputResponse(catalogId: \(String(describing: catalogId)), tagKey: \(String(describing: tagKey)), tagValues: \(String(describing: tagValues)))"}
}

extension GetLFTagOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLFTagOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.catalogId = output.catalogId
            self.tagKey = output.tagKey
            self.tagValues = output.tagValues
        } else {
            self.catalogId = nil
            self.tagKey = nil
            self.tagValues = nil
        }
    }
}

public struct GetLFTagOutputResponse: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>The key-name for the tag.</p>
    public let tagKey: String?
    /// <p>A list of possible values an attribute can take.</p>
    public let tagValues: [String]?

    public init (
        catalogId: String? = nil,
        tagKey: String? = nil,
        tagValues: [String]? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
        self.tagValues = tagValues
    }
}

struct GetLFTagOutputResponseBody: Equatable {
    public let catalogId: String?
    public let tagKey: String?
    public let tagValues: [String]?
}

extension GetLFTagOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
        case tagValues = "TagValues"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

public struct GetResourceLFTagsInputBodyMiddleware: Middleware {
    public let id: String = "GetResourceLFTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceLFTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceLFTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceLFTagsInput>
    public typealias MOutput = OperationOutput<GetResourceLFTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceLFTagsOutputError>
}

extension GetResourceLFTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceLFTagsInput(catalogId: \(String(describing: catalogId)), resource: \(String(describing: resource)), showAssignedLFTags: \(String(describing: showAssignedLFTags)))"}
}

extension GetResourceLFTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case resource = "Resource"
        case showAssignedLFTags = "ShowAssignedLFTags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let showAssignedLFTags = showAssignedLFTags {
            try encodeContainer.encode(showAssignedLFTags, forKey: .showAssignedLFTags)
        }
    }
}

public struct GetResourceLFTagsInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourceLFTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceLFTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceLFTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceLFTagsInput>
    public typealias MOutput = OperationOutput<GetResourceLFTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceLFTagsOutputError>
}

public struct GetResourceLFTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourceLFTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceLFTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceLFTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceLFTagsInput>
    public typealias MOutput = OperationOutput<GetResourceLFTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceLFTagsOutputError>
}

public struct GetResourceLFTagsInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>The resource for which you want to return tags.</p>
    public let resource: Resource?
    /// <p>Indicates whether to show the assigned tags.</p>
    public let showAssignedLFTags: Bool?

    public init (
        catalogId: String? = nil,
        resource: Resource? = nil,
        showAssignedLFTags: Bool? = nil
    )
    {
        self.catalogId = catalogId
        self.resource = resource
        self.showAssignedLFTags = showAssignedLFTags
    }
}

struct GetResourceLFTagsInputBody: Equatable {
    public let catalogId: String?
    public let resource: Resource?
    public let showAssignedLFTags: Bool?
}

extension GetResourceLFTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case resource = "Resource"
        case showAssignedLFTags = "ShowAssignedLFTags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Resource.self, forKey: .resource)
        resource = resourceDecoded
        let showAssignedLFTagsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .showAssignedLFTags)
        showAssignedLFTags = showAssignedLFTagsDecoded
    }
}

extension GetResourceLFTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceLFTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceLFTagsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceLFTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceLFTagsOutputResponse(lFTagOnDatabase: \(String(describing: lFTagOnDatabase)), lFTagsOnColumns: \(String(describing: lFTagsOnColumns)), lFTagsOnTable: \(String(describing: lFTagsOnTable)))"}
}

extension GetResourceLFTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourceLFTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lFTagOnDatabase = output.lFTagOnDatabase
            self.lFTagsOnColumns = output.lFTagsOnColumns
            self.lFTagsOnTable = output.lFTagsOnTable
        } else {
            self.lFTagOnDatabase = nil
            self.lFTagsOnColumns = nil
            self.lFTagsOnTable = nil
        }
    }
}

public struct GetResourceLFTagsOutputResponse: Equatable {
    /// <p>A list of tags applied to a database resource.</p>
    public let lFTagOnDatabase: [LFTagPair]?
    /// <p>A list of tags applied to a column resource.</p>
    public let lFTagsOnColumns: [ColumnLFTag]?
    /// <p>A list of tags applied to a table resource.</p>
    public let lFTagsOnTable: [LFTagPair]?

    public init (
        lFTagOnDatabase: [LFTagPair]? = nil,
        lFTagsOnColumns: [ColumnLFTag]? = nil,
        lFTagsOnTable: [LFTagPair]? = nil
    )
    {
        self.lFTagOnDatabase = lFTagOnDatabase
        self.lFTagsOnColumns = lFTagsOnColumns
        self.lFTagsOnTable = lFTagsOnTable
    }
}

struct GetResourceLFTagsOutputResponseBody: Equatable {
    public let lFTagOnDatabase: [LFTagPair]?
    public let lFTagsOnTable: [LFTagPair]?
    public let lFTagsOnColumns: [ColumnLFTag]?
}

extension GetResourceLFTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lFTagOnDatabase = "LFTagOnDatabase"
        case lFTagsOnColumns = "LFTagsOnColumns"
        case lFTagsOnTable = "LFTagsOnTable"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lFTagOnDatabaseContainer = try containerValues.decodeIfPresent([LFTagPair?].self, forKey: .lFTagOnDatabase)
        var lFTagOnDatabaseDecoded0:[LFTagPair]? = nil
        if let lFTagOnDatabaseContainer = lFTagOnDatabaseContainer {
            lFTagOnDatabaseDecoded0 = [LFTagPair]()
            for structure0 in lFTagOnDatabaseContainer {
                if let structure0 = structure0 {
                    lFTagOnDatabaseDecoded0?.append(structure0)
                }
            }
        }
        lFTagOnDatabase = lFTagOnDatabaseDecoded0
        let lFTagsOnTableContainer = try containerValues.decodeIfPresent([LFTagPair?].self, forKey: .lFTagsOnTable)
        var lFTagsOnTableDecoded0:[LFTagPair]? = nil
        if let lFTagsOnTableContainer = lFTagsOnTableContainer {
            lFTagsOnTableDecoded0 = [LFTagPair]()
            for structure0 in lFTagsOnTableContainer {
                if let structure0 = structure0 {
                    lFTagsOnTableDecoded0?.append(structure0)
                }
            }
        }
        lFTagsOnTable = lFTagsOnTableDecoded0
        let lFTagsOnColumnsContainer = try containerValues.decodeIfPresent([ColumnLFTag?].self, forKey: .lFTagsOnColumns)
        var lFTagsOnColumnsDecoded0:[ColumnLFTag]? = nil
        if let lFTagsOnColumnsContainer = lFTagsOnColumnsContainer {
            lFTagsOnColumnsDecoded0 = [ColumnLFTag]()
            for structure0 in lFTagsOnColumnsContainer {
                if let structure0 = structure0 {
                    lFTagsOnColumnsDecoded0?.append(structure0)
                }
            }
        }
        lFTagsOnColumns = lFTagsOnColumnsDecoded0
    }
}

extension GlueEncryptionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlueEncryptionException(message: \(String(describing: message)))"}
}

extension GlueEncryptionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GlueEncryptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An encryption operation failed.</p>
public struct GlueEncryptionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct GlueEncryptionExceptionBody: Equatable {
    public let message: String?
}

extension GlueEncryptionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GrantPermissionsInputBodyMiddleware: Middleware {
    public let id: String = "GrantPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GrantPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GrantPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GrantPermissionsInput>
    public typealias MOutput = OperationOutput<GrantPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GrantPermissionsOutputError>
}

extension GrantPermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrantPermissionsInput(catalogId: \(String(describing: catalogId)), permissions: \(String(describing: permissions)), permissionsWithGrantOption: \(String(describing: permissionsWithGrantOption)), principal: \(String(describing: principal)), resource: \(String(describing: resource)))"}
}

extension GrantPermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case permissions = "Permissions"
        case permissionsWithGrantOption = "PermissionsWithGrantOption"
        case principal = "Principal"
        case resource = "Resource"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permissionlist0 in permissions {
                try permissionsContainer.encode(permissionlist0.rawValue)
            }
        }
        if let permissionsWithGrantOption = permissionsWithGrantOption {
            var permissionsWithGrantOptionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionsWithGrantOption)
            for permissionlist0 in permissionsWithGrantOption {
                try permissionsWithGrantOptionContainer.encode(permissionlist0.rawValue)
            }
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }
}

public struct GrantPermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "GrantPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GrantPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GrantPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GrantPermissionsInput>
    public typealias MOutput = OperationOutput<GrantPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GrantPermissionsOutputError>
}

public struct GrantPermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GrantPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GrantPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GrantPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GrantPermissionsInput>
    public typealias MOutput = OperationOutput<GrantPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GrantPermissionsOutputError>
}

public struct GrantPermissionsInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>The permissions granted to the principal on the resource. AWS Lake Formation defines privileges to grant and revoke access to metadata in the Data Catalog and data organized in underlying data storage such as Amazon S3. AWS Lake Formation requires that each principal be authorized to perform a specific task on AWS Lake Formation resources. </p>
    public let permissions: [Permission]?
    /// <p>Indicates a list of the granted permissions that the principal may pass to other users. These permissions may only be a subset of the permissions granted in the <code>Privileges</code>.</p>
    public let permissionsWithGrantOption: [Permission]?
    /// <p>The principal to be granted the permissions on the resource. Supported principals are IAM users or IAM roles, and they are defined by their principal type and their ARN.</p>
    /// 	        <p>Note that if you define a resource with a particular ARN, then later delete, and recreate a resource with that same ARN, the resource maintains the permissions already granted. </p>
    public let principal: DataLakePrincipal?
    /// <p>The resource to which permissions are to be granted. Resources in AWS Lake Formation are the Data Catalog, databases, and tables.</p>
    public let resource: Resource?

    public init (
        catalogId: String? = nil,
        permissions: [Permission]? = nil,
        permissionsWithGrantOption: [Permission]? = nil,
        principal: DataLakePrincipal? = nil,
        resource: Resource? = nil
    )
    {
        self.catalogId = catalogId
        self.permissions = permissions
        self.permissionsWithGrantOption = permissionsWithGrantOption
        self.principal = principal
        self.resource = resource
    }
}

struct GrantPermissionsInputBody: Equatable {
    public let catalogId: String?
    public let principal: DataLakePrincipal?
    public let resource: Resource?
    public let permissions: [Permission]?
    public let permissionsWithGrantOption: [Permission]?
}

extension GrantPermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case permissions = "Permissions"
        case permissionsWithGrantOption = "PermissionsWithGrantOption"
        case principal = "Principal"
        case resource = "Resource"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let principalDecoded = try containerValues.decodeIfPresent(DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Resource.self, forKey: .resource)
        resource = resourceDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Permission]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
        let permissionsWithGrantOptionContainer = try containerValues.decodeIfPresent([Permission?].self, forKey: .permissionsWithGrantOption)
        var permissionsWithGrantOptionDecoded0:[Permission]? = nil
        if let permissionsWithGrantOptionContainer = permissionsWithGrantOptionContainer {
            permissionsWithGrantOptionDecoded0 = [Permission]()
            for string0 in permissionsWithGrantOptionContainer {
                if let string0 = string0 {
                    permissionsWithGrantOptionDecoded0?.append(string0)
                }
            }
        }
        permissionsWithGrantOption = permissionsWithGrantOptionDecoded0
    }
}

extension GrantPermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GrantPermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GrantPermissionsOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GrantPermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrantPermissionsOutputResponse()"}
}

extension GrantPermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct GrantPermissionsOutputResponse: Equatable {

    public init() {}
}

struct GrantPermissionsOutputResponseBody: Equatable {
}

extension GrantPermissionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension InternalServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceException(message: \(String(describing: message)))"}
}

extension InternalServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal service error occurred.</p>
public struct InternalServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInputException(message: \(String(describing: message)))"}
}

extension InvalidInputException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input provided was not valid.</p>
public struct InvalidInputException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInputExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LFTag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagKey = "TagKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKey = tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagvaluelist0 in tagValues {
                try tagValuesContainer.encode(tagvaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension LFTag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LFTag(tagKey: \(String(describing: tagKey)), tagValues: \(String(describing: tagValues)))"}
}

/// <p>A structure that allows an admin to grant user permissions on certain conditions. For example, granting a role access to all columns not tagged 'PII' of tables tagged 'Prod'.</p>
public struct LFTag: Equatable {
    /// <p>The key-name for the tag.</p>
    public let tagKey: String?
    /// <p>A list of possible values an attribute can take.</p>
    public let tagValues: [String]?

    public init (
        tagKey: String? = nil,
        tagValues: [String]? = nil
    )
    {
        self.tagKey = tagKey
        self.tagValues = tagValues
    }
}

extension LFTagError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case error = "Error"
        case lFTag = "LFTag"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let lFTag = lFTag {
            try encodeContainer.encode(lFTag, forKey: .lFTag)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lFTagDecoded = try containerValues.decodeIfPresent(LFTagPair.self, forKey: .lFTag)
        lFTag = lFTagDecoded
        let errorDecoded = try containerValues.decodeIfPresent(ErrorDetail.self, forKey: .error)
        error = errorDecoded
    }
}

extension LFTagError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LFTagError(error: \(String(describing: error)), lFTag: \(String(describing: lFTag)))"}
}

/// <p>A structure containing an error related to a <code>TagResource</code> or <code>UnTagResource</code> operation.</p>
public struct LFTagError: Equatable {
    /// <p>An error that occurred with the attachment or detachment of the tag.</p>
    public let error: ErrorDetail?
    /// <p>The key-name of the tag.</p>
    public let lFTag: LFTagPair?

    public init (
        error: ErrorDetail? = nil,
        lFTag: LFTagPair? = nil
    )
    {
        self.error = error
        self.lFTag = lFTag
    }
}

extension LFTagKeyResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let tagKey = tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagvaluelist0 in tagValues {
                try tagValuesContainer.encode(tagvaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension LFTagKeyResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LFTagKeyResource(catalogId: \(String(describing: catalogId)), tagKey: \(String(describing: tagKey)), tagValues: \(String(describing: tagValues)))"}
}

/// <p>A structure containing a tag key and values for a resource.</p>
public struct LFTagKeyResource: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>The key-name for the tag.</p>
    public let tagKey: String?
    /// <p>A list of possible values an attribute can take.</p>
    public let tagValues: [String]?

    public init (
        catalogId: String? = nil,
        tagKey: String? = nil,
        tagValues: [String]? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
        self.tagValues = tagValues
    }
}

extension LFTagPair: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let tagKey = tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagvaluelist0 in tagValues {
                try tagValuesContainer.encode(tagvaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension LFTagPair: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LFTagPair(catalogId: \(String(describing: catalogId)), tagKey: \(String(describing: tagKey)), tagValues: \(String(describing: tagValues)))"}
}

/// <p>A structure containing a tag key-value pair.</p>
public struct LFTagPair: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>The key-name for the tag.</p>
    public let tagKey: String?
    /// <p>A list of possible values an attribute can take.</p>
    public let tagValues: [String]?

    public init (
        catalogId: String? = nil,
        tagKey: String? = nil,
        tagValues: [String]? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
        self.tagValues = tagValues
    }
}

extension LFTagPolicyResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case expression = "Expression"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let expression = expression {
            var expressionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expression)
            for expression0 in expression {
                try expressionContainer.encode(expression0)
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let expressionContainer = try containerValues.decodeIfPresent([LFTag?].self, forKey: .expression)
        var expressionDecoded0:[LFTag]? = nil
        if let expressionContainer = expressionContainer {
            expressionDecoded0 = [LFTag]()
            for structure0 in expressionContainer {
                if let structure0 = structure0 {
                    expressionDecoded0?.append(structure0)
                }
            }
        }
        expression = expressionDecoded0
    }
}

extension LFTagPolicyResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LFTagPolicyResource(catalogId: \(String(describing: catalogId)), expression: \(String(describing: expression)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>A structure containing a list of tag conditions that apply to a resource's tag policy.</p>
public struct LFTagPolicyResource: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>A list of tag conditions that apply to the resource's tag policy.</p>
    public let expression: [LFTag]?
    /// <p>The resource type for which the tag policy applies.</p>
    public let resourceType: ResourceType?

    public init (
        catalogId: String? = nil,
        expression: [LFTag]? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.catalogId = catalogId
        self.expression = expression
        self.resourceType = resourceType
    }
}

public struct ListLFTagsInputBodyMiddleware: Middleware {
    public let id: String = "ListLFTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLFTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLFTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLFTagsInput>
    public typealias MOutput = OperationOutput<ListLFTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLFTagsOutputError>
}

extension ListLFTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLFTagsInput(catalogId: \(String(describing: catalogId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceShareType: \(String(describing: resourceShareType)))"}
}

extension ListLFTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceShareType = "ResourceShareType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareType = resourceShareType {
            try encodeContainer.encode(resourceShareType.rawValue, forKey: .resourceShareType)
        }
    }
}

public struct ListLFTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLFTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLFTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLFTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLFTagsInput>
    public typealias MOutput = OperationOutput<ListLFTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLFTagsOutputError>
}

public struct ListLFTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLFTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLFTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLFTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLFTagsInput>
    public typealias MOutput = OperationOutput<ListLFTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLFTagsOutputError>
}

public struct ListLFTagsInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is not the first call to retrieve this list.</p>
    public let nextToken: String?
    /// <p>If resource share type is <code>ALL</code>, returns both in-account tags and shared tags that the requester has permission to view. If resource share type is <code>FOREIGN</code>, returns all share tags that the requester can view. If no resource share type is passed, lists tags in the given catalog ID that the requester has permission to view.</p>
    public let resourceShareType: ResourceShareType?

    public init (
        catalogId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceShareType: ResourceShareType? = nil
    )
    {
        self.catalogId = catalogId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareType = resourceShareType
    }
}

struct ListLFTagsInputBody: Equatable {
    public let catalogId: String?
    public let resourceShareType: ResourceShareType?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListLFTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceShareType = "ResourceShareType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let resourceShareTypeDecoded = try containerValues.decodeIfPresent(ResourceShareType.self, forKey: .resourceShareType)
        resourceShareType = resourceShareTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLFTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLFTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLFTagsOutputError: Swift.Error, Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLFTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLFTagsOutputResponse(lFTags: \(String(describing: lFTags)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLFTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLFTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lFTags = output.lFTags
            self.nextToken = output.nextToken
        } else {
            self.lFTags = nil
            self.nextToken = nil
        }
    }
}

public struct ListLFTagsOutputResponse: Equatable {
    /// <p>A list of tags that the requested has permission to view.</p>
    public let lFTags: [LFTagPair]?
    /// <p>A continuation token, present if the current list segment is not the last.</p>
    public let nextToken: String?

    public init (
        lFTags: [LFTagPair]? = nil,
        nextToken: String? = nil
    )
    {
        self.lFTags = lFTags
        self.nextToken = nextToken
    }
}

struct ListLFTagsOutputResponseBody: Equatable {
    public let lFTags: [LFTagPair]?
    public let nextToken: String?
}

extension ListLFTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lFTags = "LFTags"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lFTagsContainer = try containerValues.decodeIfPresent([LFTagPair?].self, forKey: .lFTags)
        var lFTagsDecoded0:[LFTagPair]? = nil
        if let lFTagsContainer = lFTagsContainer {
            lFTagsDecoded0 = [LFTagPair]()
            for structure0 in lFTagsContainer {
                if let structure0 = structure0 {
                    lFTagsDecoded0?.append(structure0)
                }
            }
        }
        lFTags = lFTagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPermissionsInputBodyMiddleware: Middleware {
    public let id: String = "ListPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionsOutputError>
}

extension ListPermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPermissionsInput(catalogId: \(String(describing: catalogId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), principal: \(String(describing: principal)), resource: \(String(describing: resource)), resourceType: \(String(describing: resourceType)))"}
}

extension ListPermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case principal = "Principal"
        case resource = "Resource"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

public struct ListPermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionsOutputError>
}

public struct ListPermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPermissionsOutputError>
}

public struct ListPermissionsInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is not the first call to retrieve this list.</p>
    public let nextToken: String?
    /// <p>Specifies a principal to filter the permissions returned.</p>
    public let principal: DataLakePrincipal?
    /// <p>A resource where you will get a list of the principal permissions.</p>
    ///          <p>This operation does not support getting privileges on a table with columns. Instead, call this operation on the table, and the operation returns the table and the table w columns.</p>
    public let resource: Resource?
    /// <p>Specifies a resource type to filter the permissions returned.</p>
    public let resourceType: DataLakeResourceType?

    public init (
        catalogId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        principal: DataLakePrincipal? = nil,
        resource: Resource? = nil,
        resourceType: DataLakeResourceType? = nil
    )
    {
        self.catalogId = catalogId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct ListPermissionsInputBody: Equatable {
    public let catalogId: String?
    public let principal: DataLakePrincipal?
    public let resourceType: DataLakeResourceType?
    public let resource: Resource?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case principal = "Principal"
        case resource = "Resource"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let principalDecoded = try containerValues.decodeIfPresent(DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(DataLakeResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Resource.self, forKey: .resource)
        resource = resourceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPermissionsOutputError: Swift.Error, Equatable {
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPermissionsOutputResponse(nextToken: \(String(describing: nextToken)), principalResourcePermissions: \(String(describing: principalResourcePermissions)))"}
}

extension ListPermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.principalResourcePermissions = output.principalResourcePermissions
        } else {
            self.nextToken = nil
            self.principalResourcePermissions = nil
        }
    }
}

public struct ListPermissionsOutputResponse: Equatable {
    /// <p>A continuation token, if this is not the first call to retrieve this list.</p>
    public let nextToken: String?
    /// <p>A list of principals and their permissions on the resource for the specified principal and resource types.</p>
    public let principalResourcePermissions: [PrincipalResourcePermissions]?

    public init (
        nextToken: String? = nil,
        principalResourcePermissions: [PrincipalResourcePermissions]? = nil
    )
    {
        self.nextToken = nextToken
        self.principalResourcePermissions = principalResourcePermissions
    }
}

struct ListPermissionsOutputResponseBody: Equatable {
    public let principalResourcePermissions: [PrincipalResourcePermissions]?
    public let nextToken: String?
}

extension ListPermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case principalResourcePermissions = "PrincipalResourcePermissions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalResourcePermissionsContainer = try containerValues.decodeIfPresent([PrincipalResourcePermissions?].self, forKey: .principalResourcePermissions)
        var principalResourcePermissionsDecoded0:[PrincipalResourcePermissions]? = nil
        if let principalResourcePermissionsContainer = principalResourcePermissionsContainer {
            principalResourcePermissionsDecoded0 = [PrincipalResourcePermissions]()
            for structure0 in principalResourcePermissionsContainer {
                if let structure0 = structure0 {
                    principalResourcePermissionsDecoded0?.append(structure0)
                }
            }
        }
        principalResourcePermissions = principalResourcePermissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourcesInputBodyMiddleware: Middleware {
    public let id: String = "ListResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesInput>
    public typealias MOutput = OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesOutputError>
}

extension ListResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourcesInput(filterConditionList: \(String(describing: filterConditionList)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filterConditionList = "FilterConditionList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterConditionList = filterConditionList {
            var filterConditionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterConditionList)
            for filterconditionlist0 in filterConditionList {
                try filterConditionListContainer.encode(filterconditionlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesInput>
    public typealias MOutput = OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesOutputError>
}

public struct ListResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesInput>
    public typealias MOutput = OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesOutputError>
}

public struct ListResourcesInput: Equatable {
    /// <p>Any applicable row-level and/or column-level filtering conditions for the resources.</p>
    public let filterConditionList: [FilterCondition]?
    /// <p>The maximum number of resource results.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is not the first call to retrieve these resources.</p>
    public let nextToken: String?

    public init (
        filterConditionList: [FilterCondition]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filterConditionList = filterConditionList
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourcesInputBody: Equatable {
    public let filterConditionList: [FilterCondition]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filterConditionList = "FilterConditionList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterConditionListContainer = try containerValues.decodeIfPresent([FilterCondition?].self, forKey: .filterConditionList)
        var filterConditionListDecoded0:[FilterCondition]? = nil
        if let filterConditionListContainer = filterConditionListContainer {
            filterConditionListDecoded0 = [FilterCondition]()
            for structure0 in filterConditionListContainer {
                if let structure0 = structure0 {
                    filterConditionListDecoded0?.append(structure0)
                }
            }
        }
        filterConditionList = filterConditionListDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourcesOutputError: Swift.Error, Equatable {
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourcesOutputResponse(nextToken: \(String(describing: nextToken)), resourceInfoList: \(String(describing: resourceInfoList)))"}
}

extension ListResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceInfoList = output.resourceInfoList
        } else {
            self.nextToken = nil
            self.resourceInfoList = nil
        }
    }
}

public struct ListResourcesOutputResponse: Equatable {
    /// <p>A continuation token, if this is not the first call to retrieve these resources.</p>
    public let nextToken: String?
    /// <p>A summary of the data lake resources.</p>
    public let resourceInfoList: [ResourceInfo]?

    public init (
        nextToken: String? = nil,
        resourceInfoList: [ResourceInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceInfoList = resourceInfoList
    }
}

struct ListResourcesOutputResponseBody: Equatable {
    public let resourceInfoList: [ResourceInfo]?
    public let nextToken: String?
}

extension ListResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceInfoList = "ResourceInfoList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceInfoListContainer = try containerValues.decodeIfPresent([ResourceInfo?].self, forKey: .resourceInfoList)
        var resourceInfoListDecoded0:[ResourceInfo]? = nil
        if let resourceInfoListContainer = resourceInfoListContainer {
            resourceInfoListDecoded0 = [ResourceInfo]()
            for structure0 in resourceInfoListContainer {
                if let structure0 = structure0 {
                    resourceInfoListDecoded0?.append(structure0)
                }
            }
        }
        resourceInfoList = resourceInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension OperationTimeoutException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationTimeoutException(message: \(String(describing: message)))"}
}

extension OperationTimeoutException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OperationTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation timed out.</p>
public struct OperationTimeoutException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationTimeoutExceptionBody: Equatable {
    public let message: String?
}

extension OperationTimeoutExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Permission {
    case all
    case alter
    case alterTag
    case associateTag
    case createDatabase
    case createTable
    case createTag
    case dataLocationAccess
    case delete
    case deleteTag
    case describe
    case describeTag
    case drop
    case insert
    case select
    case sdkUnknown(String)
}

extension Permission : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Permission] {
        return [
            .all,
            .alter,
            .alterTag,
            .associateTag,
            .createDatabase,
            .createTable,
            .createTag,
            .dataLocationAccess,
            .delete,
            .deleteTag,
            .describe,
            .describeTag,
            .drop,
            .insert,
            .select,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .alter: return "ALTER"
        case .alterTag: return "ALTER_TAG"
        case .associateTag: return "ASSOCIATE_TAG"
        case .createDatabase: return "CREATE_DATABASE"
        case .createTable: return "CREATE_TABLE"
        case .createTag: return "CREATE_TAG"
        case .dataLocationAccess: return "DATA_LOCATION_ACCESS"
        case .delete: return "DELETE"
        case .deleteTag: return "DELETE_TAG"
        case .describe: return "DESCRIBE"
        case .describeTag: return "DESCRIBE_TAG"
        case .drop: return "DROP"
        case .insert: return "INSERT"
        case .select: return "SELECT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
    }
}

extension PrincipalPermissions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case permissions = "Permissions"
        case principal = "Principal"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permissionlist0 in permissions {
                try permissionsContainer.encode(permissionlist0.rawValue)
            }
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Permission]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
    }
}

extension PrincipalPermissions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PrincipalPermissions(permissions: \(String(describing: permissions)), principal: \(String(describing: principal)))"}
}

/// <p>Permissions granted to a principal.</p>
public struct PrincipalPermissions: Equatable {
    /// <p>The permissions that are granted to the principal.</p>
    public let permissions: [Permission]?
    /// <p>The principal who is granted permissions.</p>
    public let principal: DataLakePrincipal?

    public init (
        permissions: [Permission]? = nil,
        principal: DataLakePrincipal? = nil
    )
    {
        self.permissions = permissions
        self.principal = principal
    }
}

extension PrincipalResourcePermissions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalDetails = "AdditionalDetails"
        case permissions = "Permissions"
        case permissionsWithGrantOption = "PermissionsWithGrantOption"
        case principal = "Principal"
        case resource = "Resource"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalDetails = additionalDetails {
            try encodeContainer.encode(additionalDetails, forKey: .additionalDetails)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permissionlist0 in permissions {
                try permissionsContainer.encode(permissionlist0.rawValue)
            }
        }
        if let permissionsWithGrantOption = permissionsWithGrantOption {
            var permissionsWithGrantOptionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionsWithGrantOption)
            for permissionlist0 in permissionsWithGrantOption {
                try permissionsWithGrantOptionContainer.encode(permissionlist0.rawValue)
            }
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Resource.self, forKey: .resource)
        resource = resourceDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Permission]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
        let permissionsWithGrantOptionContainer = try containerValues.decodeIfPresent([Permission?].self, forKey: .permissionsWithGrantOption)
        var permissionsWithGrantOptionDecoded0:[Permission]? = nil
        if let permissionsWithGrantOptionContainer = permissionsWithGrantOptionContainer {
            permissionsWithGrantOptionDecoded0 = [Permission]()
            for string0 in permissionsWithGrantOptionContainer {
                if let string0 = string0 {
                    permissionsWithGrantOptionDecoded0?.append(string0)
                }
            }
        }
        permissionsWithGrantOption = permissionsWithGrantOptionDecoded0
        let additionalDetailsDecoded = try containerValues.decodeIfPresent(DetailsMap.self, forKey: .additionalDetails)
        additionalDetails = additionalDetailsDecoded
    }
}

extension PrincipalResourcePermissions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PrincipalResourcePermissions(additionalDetails: \(String(describing: additionalDetails)), permissions: \(String(describing: permissions)), permissionsWithGrantOption: \(String(describing: permissionsWithGrantOption)), principal: \(String(describing: principal)), resource: \(String(describing: resource)))"}
}

/// <p>The permissions granted or revoked on a resource.</p>
public struct PrincipalResourcePermissions: Equatable {
    /// <p>This attribute can be used to return any additional details of <code>PrincipalResourcePermissions</code>. Currently returns only as a RAM resource share ARN.</p>
    public let additionalDetails: DetailsMap?
    /// <p>The permissions to be granted or revoked on the resource.</p>
    public let permissions: [Permission]?
    /// <p>Indicates whether to grant the ability to grant permissions (as a subset of permissions granted).</p>
    public let permissionsWithGrantOption: [Permission]?
    /// <p>The Data Lake principal to be granted or revoked permissions.</p>
    public let principal: DataLakePrincipal?
    /// <p>The resource where permissions are to be granted or revoked.</p>
    public let resource: Resource?

    public init (
        additionalDetails: DetailsMap? = nil,
        permissions: [Permission]? = nil,
        permissionsWithGrantOption: [Permission]? = nil,
        principal: DataLakePrincipal? = nil,
        resource: Resource? = nil
    )
    {
        self.additionalDetails = additionalDetails
        self.permissions = permissions
        self.permissionsWithGrantOption = permissionsWithGrantOption
        self.principal = principal
        self.resource = resource
    }
}

public struct PutDataLakeSettingsInputBodyMiddleware: Middleware {
    public let id: String = "PutDataLakeSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDataLakeSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDataLakeSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDataLakeSettingsInput>
    public typealias MOutput = OperationOutput<PutDataLakeSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDataLakeSettingsOutputError>
}

extension PutDataLakeSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDataLakeSettingsInput(catalogId: \(String(describing: catalogId)), dataLakeSettings: \(String(describing: dataLakeSettings)))"}
}

extension PutDataLakeSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case dataLakeSettings = "DataLakeSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let dataLakeSettings = dataLakeSettings {
            try encodeContainer.encode(dataLakeSettings, forKey: .dataLakeSettings)
        }
    }
}

public struct PutDataLakeSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "PutDataLakeSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDataLakeSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDataLakeSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDataLakeSettingsInput>
    public typealias MOutput = OperationOutput<PutDataLakeSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDataLakeSettingsOutputError>
}

public struct PutDataLakeSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutDataLakeSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDataLakeSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDataLakeSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDataLakeSettingsInput>
    public typealias MOutput = OperationOutput<PutDataLakeSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDataLakeSettingsOutputError>
}

public struct PutDataLakeSettingsInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>A structure representing a list of AWS Lake Formation principals designated as data lake administrators.</p>
    public let dataLakeSettings: DataLakeSettings?

    public init (
        catalogId: String? = nil,
        dataLakeSettings: DataLakeSettings? = nil
    )
    {
        self.catalogId = catalogId
        self.dataLakeSettings = dataLakeSettings
    }
}

struct PutDataLakeSettingsInputBody: Equatable {
    public let catalogId: String?
    public let dataLakeSettings: DataLakeSettings?
}

extension PutDataLakeSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case dataLakeSettings = "DataLakeSettings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let dataLakeSettingsDecoded = try containerValues.decodeIfPresent(DataLakeSettings.self, forKey: .dataLakeSettings)
        dataLakeSettings = dataLakeSettingsDecoded
    }
}

extension PutDataLakeSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDataLakeSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDataLakeSettingsOutputError: Swift.Error, Equatable {
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDataLakeSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDataLakeSettingsOutputResponse()"}
}

extension PutDataLakeSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutDataLakeSettingsOutputResponse: Equatable {

    public init() {}
}

struct PutDataLakeSettingsOutputResponseBody: Equatable {
}

extension PutDataLakeSettingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RegisterResourceInputBodyMiddleware: Middleware {
    public let id: String = "RegisterResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterResourceInput>
    public typealias MOutput = OperationOutput<RegisterResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterResourceOutputError>
}

extension RegisterResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterResourceInput(resourceArn: \(String(describing: resourceArn)), roleArn: \(String(describing: roleArn)), useServiceLinkedRole: \(String(describing: useServiceLinkedRole)))"}
}

extension RegisterResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
        case useServiceLinkedRole = "UseServiceLinkedRole"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let useServiceLinkedRole = useServiceLinkedRole {
            try encodeContainer.encode(useServiceLinkedRole, forKey: .useServiceLinkedRole)
        }
    }
}

public struct RegisterResourceInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterResourceInput>
    public typealias MOutput = OperationOutput<RegisterResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterResourceOutputError>
}

public struct RegisterResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterResourceInput>
    public typealias MOutput = OperationOutput<RegisterResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterResourceOutputError>
}

public struct RegisterResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to register.</p>
    public let resourceArn: String?
    /// <p>The identifier for the role that registers the resource.</p>
    public let roleArn: String?
    /// <p>Designates an AWS Identity and Access Management (IAM) service-linked role by registering this role with the Data Catalog. A service-linked role is a unique type of IAM role that is linked directly to Lake Formation.</p>
    ///
    ///          <p>For more information, see <a href="https://docs-aws.amazon.com/lake-formation/latest/dg/service-linked-roles.html">Using Service-Linked Roles for Lake Formation</a>.</p>
    public let useServiceLinkedRole: Bool?

    public init (
        resourceArn: String? = nil,
        roleArn: String? = nil,
        useServiceLinkedRole: Bool? = nil
    )
    {
        self.resourceArn = resourceArn
        self.roleArn = roleArn
        self.useServiceLinkedRole = useServiceLinkedRole
    }
}

struct RegisterResourceInputBody: Equatable {
    public let resourceArn: String?
    public let useServiceLinkedRole: Bool?
    public let roleArn: String?
}

extension RegisterResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
        case useServiceLinkedRole = "UseServiceLinkedRole"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let useServiceLinkedRoleDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useServiceLinkedRole)
        useServiceLinkedRole = useServiceLinkedRoleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension RegisterResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterResourceOutputError: Swift.Error, Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterResourceOutputResponse()"}
}

extension RegisterResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RegisterResourceOutputResponse: Equatable {

    public init() {}
}

struct RegisterResourceOutputResponseBody: Equatable {
}

extension RegisterResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RemoveLFTagsFromResourceInputBodyMiddleware: Middleware {
    public let id: String = "RemoveLFTagsFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveLFTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveLFTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveLFTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveLFTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveLFTagsFromResourceOutputError>
}

extension RemoveLFTagsFromResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveLFTagsFromResourceInput(catalogId: \(String(describing: catalogId)), lFTags: \(String(describing: lFTags)), resource: \(String(describing: resource)))"}
}

extension RemoveLFTagsFromResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case lFTags = "LFTags"
        case resource = "Resource"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let lFTags = lFTags {
            var lFTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lFTags)
            for lftagslist0 in lFTags {
                try lFTagsContainer.encode(lftagslist0)
            }
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }
}

public struct RemoveLFTagsFromResourceInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveLFTagsFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveLFTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveLFTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveLFTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveLFTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveLFTagsFromResourceOutputError>
}

public struct RemoveLFTagsFromResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveLFTagsFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveLFTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveLFTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveLFTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveLFTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveLFTagsFromResourceOutputError>
}

public struct RemoveLFTagsFromResourceInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>The tags to be removed from the resource.</p>
    public let lFTags: [LFTagPair]?
    /// <p>The resource where you want to remove a tag.</p>
    public let resource: Resource?

    public init (
        catalogId: String? = nil,
        lFTags: [LFTagPair]? = nil,
        resource: Resource? = nil
    )
    {
        self.catalogId = catalogId
        self.lFTags = lFTags
        self.resource = resource
    }
}

struct RemoveLFTagsFromResourceInputBody: Equatable {
    public let catalogId: String?
    public let resource: Resource?
    public let lFTags: [LFTagPair]?
}

extension RemoveLFTagsFromResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case lFTags = "LFTags"
        case resource = "Resource"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Resource.self, forKey: .resource)
        resource = resourceDecoded
        let lFTagsContainer = try containerValues.decodeIfPresent([LFTagPair?].self, forKey: .lFTags)
        var lFTagsDecoded0:[LFTagPair]? = nil
        if let lFTagsContainer = lFTagsContainer {
            lFTagsDecoded0 = [LFTagPair]()
            for structure0 in lFTagsContainer {
                if let structure0 = structure0 {
                    lFTagsDecoded0?.append(structure0)
                }
            }
        }
        lFTags = lFTagsDecoded0
    }
}

extension RemoveLFTagsFromResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveLFTagsFromResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveLFTagsFromResourceOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveLFTagsFromResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveLFTagsFromResourceOutputResponse(failures: \(String(describing: failures)))"}
}

extension RemoveLFTagsFromResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveLFTagsFromResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
        } else {
            self.failures = nil
        }
    }
}

public struct RemoveLFTagsFromResourceOutputResponse: Equatable {
    /// <p>A list of failures to untag a resource.</p>
    public let failures: [LFTagError]?

    public init (
        failures: [LFTagError]? = nil
    )
    {
        self.failures = failures
    }
}

struct RemoveLFTagsFromResourceOutputResponseBody: Equatable {
    public let failures: [LFTagError]?
}

extension RemoveLFTagsFromResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failures = "Failures"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failuresContainer = try containerValues.decodeIfPresent([LFTagError?].self, forKey: .failures)
        var failuresDecoded0:[LFTagError]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [LFTagError]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

extension Resource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalog = "Catalog"
        case dataLocation = "DataLocation"
        case database = "Database"
        case lFTag = "LFTag"
        case lFTagPolicy = "LFTagPolicy"
        case table = "Table"
        case tableWithColumns = "TableWithColumns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let dataLocation = dataLocation {
            try encodeContainer.encode(dataLocation, forKey: .dataLocation)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let lFTag = lFTag {
            try encodeContainer.encode(lFTag, forKey: .lFTag)
        }
        if let lFTagPolicy = lFTagPolicy {
            try encodeContainer.encode(lFTagPolicy, forKey: .lFTagPolicy)
        }
        if let table = table {
            try encodeContainer.encode(table, forKey: .table)
        }
        if let tableWithColumns = tableWithColumns {
            try encodeContainer.encode(tableWithColumns, forKey: .tableWithColumns)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDecoded = try containerValues.decodeIfPresent(CatalogResource.self, forKey: .catalog)
        catalog = catalogDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(DatabaseResource.self, forKey: .database)
        database = databaseDecoded
        let tableDecoded = try containerValues.decodeIfPresent(TableResource.self, forKey: .table)
        table = tableDecoded
        let tableWithColumnsDecoded = try containerValues.decodeIfPresent(TableWithColumnsResource.self, forKey: .tableWithColumns)
        tableWithColumns = tableWithColumnsDecoded
        let dataLocationDecoded = try containerValues.decodeIfPresent(DataLocationResource.self, forKey: .dataLocation)
        dataLocation = dataLocationDecoded
        let lFTagDecoded = try containerValues.decodeIfPresent(LFTagKeyResource.self, forKey: .lFTag)
        lFTag = lFTagDecoded
        let lFTagPolicyDecoded = try containerValues.decodeIfPresent(LFTagPolicyResource.self, forKey: .lFTagPolicy)
        lFTagPolicy = lFTagPolicyDecoded
    }
}

extension Resource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Resource(catalog: \(String(describing: catalog)), dataLocation: \(String(describing: dataLocation)), database: \(String(describing: database)), lFTag: \(String(describing: lFTag)), lFTagPolicy: \(String(describing: lFTagPolicy)), table: \(String(describing: table)), tableWithColumns: \(String(describing: tableWithColumns)))"}
}

/// <p>A structure for the resource.</p>
public struct Resource: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalog: CatalogResource?
    /// <p>The location of an Amazon S3 path where permissions are granted or revoked. </p>
    public let dataLocation: DataLocationResource?
    /// <p>The database for the resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database permissions to a principal. </p>
    public let database: DatabaseResource?
    /// <p>The tag key and values attached to a resource.</p>
    public let lFTag: LFTagKeyResource?
    /// <p>A list of tag conditions that define a resource's tag policy.</p>
    public let lFTagPolicy: LFTagPolicyResource?
    /// <p>The table for the resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal. </p>
    public let table: TableResource?
    /// <p>The table with columns for the resource. A principal with permissions to this resource can select metadata from the columns of a table in the Data Catalog and the underlying data in Amazon S3.</p>
    public let tableWithColumns: TableWithColumnsResource?

    public init (
        catalog: CatalogResource? = nil,
        dataLocation: DataLocationResource? = nil,
        database: DatabaseResource? = nil,
        lFTag: LFTagKeyResource? = nil,
        lFTagPolicy: LFTagPolicyResource? = nil,
        table: TableResource? = nil,
        tableWithColumns: TableWithColumnsResource? = nil
    )
    {
        self.catalog = catalog
        self.dataLocation = dataLocation
        self.database = database
        self.lFTag = lFTag
        self.lFTagPolicy = lFTagPolicy
        self.table = table
        self.tableWithColumns = tableWithColumns
    }
}

extension ResourceInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastModified = "LastModified"
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension ResourceInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInfo(lastModified: \(String(describing: lastModified)), resourceArn: \(String(describing: resourceArn)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>A structure containing information about an AWS Lake Formation resource.</p>
public struct ResourceInfo: Equatable {
    /// <p>The date and time the resource was last modified.</p>
    public let lastModified: Date?
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>The IAM role that registered a resource.</p>
    public let roleArn: String?

    public init (
        lastModified: Date? = nil,
        resourceArn: String? = nil,
        roleArn: String? = nil
    )
    {
        self.lastModified = lastModified
        self.resourceArn = resourceArn
        self.roleArn = roleArn
    }
}

extension ResourceNumberLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNumberLimitExceededException(message: \(String(describing: message)))"}
}

extension ResourceNumberLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNumberLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource numerical limit was exceeded.</p>
public struct ResourceNumberLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message describing the problem.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNumberLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNumberLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ResourceShareType {
    case all
    case foreign
    case sdkUnknown(String)
}

extension ResourceShareType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceShareType] {
        return [
            .all,
            .foreign,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .foreign: return "FOREIGN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceShareType(rawValue: rawValue) ?? ResourceShareType.sdkUnknown(rawValue)
    }
}

public enum ResourceType {
    case database
    case table
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .database,
            .table,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .database: return "DATABASE"
        case .table: return "TABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

public struct RevokePermissionsInputBodyMiddleware: Middleware {
    public let id: String = "RevokePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokePermissionsInput>
    public typealias MOutput = OperationOutput<RevokePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokePermissionsOutputError>
}

extension RevokePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokePermissionsInput(catalogId: \(String(describing: catalogId)), permissions: \(String(describing: permissions)), permissionsWithGrantOption: \(String(describing: permissionsWithGrantOption)), principal: \(String(describing: principal)), resource: \(String(describing: resource)))"}
}

extension RevokePermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case permissions = "Permissions"
        case permissionsWithGrantOption = "PermissionsWithGrantOption"
        case principal = "Principal"
        case resource = "Resource"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permissionlist0 in permissions {
                try permissionsContainer.encode(permissionlist0.rawValue)
            }
        }
        if let permissionsWithGrantOption = permissionsWithGrantOption {
            var permissionsWithGrantOptionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionsWithGrantOption)
            for permissionlist0 in permissionsWithGrantOption {
                try permissionsWithGrantOptionContainer.encode(permissionlist0.rawValue)
            }
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }
}

public struct RevokePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "RevokePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokePermissionsInput>
    public typealias MOutput = OperationOutput<RevokePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokePermissionsOutputError>
}

public struct RevokePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "RevokePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokePermissionsInput>
    public typealias MOutput = OperationOutput<RevokePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokePermissionsOutputError>
}

public struct RevokePermissionsInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>The permissions revoked to the principal on the resource. For information about permissions, see <a href="https://docs-aws.amazon.com/lake-formation/latest/dg/security-data-access.html">Security
    ///       and Access Control to Metadata and Data</a>.</p>
    public let permissions: [Permission]?
    /// <p>Indicates a list of permissions for which to revoke the grant option allowing the principal to pass permissions to other principals.</p>
    public let permissionsWithGrantOption: [Permission]?
    /// <p>The principal to be revoked permissions on the resource.</p>
    public let principal: DataLakePrincipal?
    /// <p>The resource to which permissions are to be revoked.</p>
    public let resource: Resource?

    public init (
        catalogId: String? = nil,
        permissions: [Permission]? = nil,
        permissionsWithGrantOption: [Permission]? = nil,
        principal: DataLakePrincipal? = nil,
        resource: Resource? = nil
    )
    {
        self.catalogId = catalogId
        self.permissions = permissions
        self.permissionsWithGrantOption = permissionsWithGrantOption
        self.principal = principal
        self.resource = resource
    }
}

struct RevokePermissionsInputBody: Equatable {
    public let catalogId: String?
    public let principal: DataLakePrincipal?
    public let resource: Resource?
    public let permissions: [Permission]?
    public let permissionsWithGrantOption: [Permission]?
}

extension RevokePermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case permissions = "Permissions"
        case permissionsWithGrantOption = "PermissionsWithGrantOption"
        case principal = "Principal"
        case resource = "Resource"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let principalDecoded = try containerValues.decodeIfPresent(DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Resource.self, forKey: .resource)
        resource = resourceDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Permission]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
        let permissionsWithGrantOptionContainer = try containerValues.decodeIfPresent([Permission?].self, forKey: .permissionsWithGrantOption)
        var permissionsWithGrantOptionDecoded0:[Permission]? = nil
        if let permissionsWithGrantOptionContainer = permissionsWithGrantOptionContainer {
            permissionsWithGrantOptionDecoded0 = [Permission]()
            for string0 in permissionsWithGrantOptionContainer {
                if let string0 = string0 {
                    permissionsWithGrantOptionDecoded0?.append(string0)
                }
            }
        }
        permissionsWithGrantOption = permissionsWithGrantOptionDecoded0
    }
}

extension RevokePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokePermissionsOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokePermissionsOutputResponse()"}
}

extension RevokePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RevokePermissionsOutputResponse: Equatable {

    public init() {}
}

struct RevokePermissionsOutputResponseBody: Equatable {
}

extension RevokePermissionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SearchDatabasesByLFTagsInputBodyMiddleware: Middleware {
    public let id: String = "SearchDatabasesByLFTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchDatabasesByLFTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchDatabasesByLFTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchDatabasesByLFTagsInput>
    public typealias MOutput = OperationOutput<SearchDatabasesByLFTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchDatabasesByLFTagsOutputError>
}

extension SearchDatabasesByLFTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchDatabasesByLFTagsInput(catalogId: \(String(describing: catalogId)), expression: \(String(describing: expression)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension SearchDatabasesByLFTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let expression = expression {
            var expressionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expression)
            for expression0 in expression {
                try expressionContainer.encode(expression0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct SearchDatabasesByLFTagsInputHeadersMiddleware: Middleware {
    public let id: String = "SearchDatabasesByLFTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchDatabasesByLFTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchDatabasesByLFTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchDatabasesByLFTagsInput>
    public typealias MOutput = OperationOutput<SearchDatabasesByLFTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchDatabasesByLFTagsOutputError>
}

public struct SearchDatabasesByLFTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchDatabasesByLFTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchDatabasesByLFTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchDatabasesByLFTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchDatabasesByLFTagsInput>
    public typealias MOutput = OperationOutput<SearchDatabasesByLFTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchDatabasesByLFTagsOutputError>
}

public struct SearchDatabasesByLFTagsInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>A list of conditions (<code>LFTag</code> structures) to search for in database resources.</p>
    public let expression: [LFTag]?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is not the first call to retrieve this list.</p>
    public let nextToken: String?

    public init (
        catalogId: String? = nil,
        expression: [LFTag]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.catalogId = catalogId
        self.expression = expression
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchDatabasesByLFTagsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let catalogId: String?
    public let expression: [LFTag]?
}

extension SearchDatabasesByLFTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let expressionContainer = try containerValues.decodeIfPresent([LFTag?].self, forKey: .expression)
        var expressionDecoded0:[LFTag]? = nil
        if let expressionContainer = expressionContainer {
            expressionDecoded0 = [LFTag]()
            for structure0 in expressionContainer {
                if let structure0 = structure0 {
                    expressionDecoded0?.append(structure0)
                }
            }
        }
        expression = expressionDecoded0
    }
}

extension SearchDatabasesByLFTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchDatabasesByLFTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchDatabasesByLFTagsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchDatabasesByLFTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchDatabasesByLFTagsOutputResponse(databaseList: \(String(describing: databaseList)), nextToken: \(String(describing: nextToken)))"}
}

extension SearchDatabasesByLFTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchDatabasesByLFTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.databaseList = output.databaseList
            self.nextToken = output.nextToken
        } else {
            self.databaseList = nil
            self.nextToken = nil
        }
    }
}

public struct SearchDatabasesByLFTagsOutputResponse: Equatable {
    /// <p>A list of databases that meet the tag conditions.</p>
    public let databaseList: [TaggedDatabase]?
    /// <p>A continuation token, present if the current list segment is not the last.</p>
    public let nextToken: String?

    public init (
        databaseList: [TaggedDatabase]? = nil,
        nextToken: String? = nil
    )
    {
        self.databaseList = databaseList
        self.nextToken = nextToken
    }
}

struct SearchDatabasesByLFTagsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let databaseList: [TaggedDatabase]?
}

extension SearchDatabasesByLFTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databaseList = "DatabaseList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let databaseListContainer = try containerValues.decodeIfPresent([TaggedDatabase?].self, forKey: .databaseList)
        var databaseListDecoded0:[TaggedDatabase]? = nil
        if let databaseListContainer = databaseListContainer {
            databaseListDecoded0 = [TaggedDatabase]()
            for structure0 in databaseListContainer {
                if let structure0 = structure0 {
                    databaseListDecoded0?.append(structure0)
                }
            }
        }
        databaseList = databaseListDecoded0
    }
}

public struct SearchTablesByLFTagsInputBodyMiddleware: Middleware {
    public let id: String = "SearchTablesByLFTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchTablesByLFTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchTablesByLFTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchTablesByLFTagsInput>
    public typealias MOutput = OperationOutput<SearchTablesByLFTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchTablesByLFTagsOutputError>
}

extension SearchTablesByLFTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchTablesByLFTagsInput(catalogId: \(String(describing: catalogId)), expression: \(String(describing: expression)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension SearchTablesByLFTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let expression = expression {
            var expressionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expression)
            for expression0 in expression {
                try expressionContainer.encode(expression0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct SearchTablesByLFTagsInputHeadersMiddleware: Middleware {
    public let id: String = "SearchTablesByLFTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchTablesByLFTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchTablesByLFTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchTablesByLFTagsInput>
    public typealias MOutput = OperationOutput<SearchTablesByLFTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchTablesByLFTagsOutputError>
}

public struct SearchTablesByLFTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchTablesByLFTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchTablesByLFTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchTablesByLFTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchTablesByLFTagsInput>
    public typealias MOutput = OperationOutput<SearchTablesByLFTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchTablesByLFTagsOutputError>
}

public struct SearchTablesByLFTagsInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>A list of conditions (<code>LFTag</code> structures) to search for in table resources.</p>
    public let expression: [LFTag]?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>A continuation token, if this is not the first call to retrieve this list.</p>
    public let nextToken: String?

    public init (
        catalogId: String? = nil,
        expression: [LFTag]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.catalogId = catalogId
        self.expression = expression
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchTablesByLFTagsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let catalogId: String?
    public let expression: [LFTag]?
}

extension SearchTablesByLFTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let expressionContainer = try containerValues.decodeIfPresent([LFTag?].self, forKey: .expression)
        var expressionDecoded0:[LFTag]? = nil
        if let expressionContainer = expressionContainer {
            expressionDecoded0 = [LFTag]()
            for structure0 in expressionContainer {
                if let structure0 = structure0 {
                    expressionDecoded0?.append(structure0)
                }
            }
        }
        expression = expressionDecoded0
    }
}

extension SearchTablesByLFTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchTablesByLFTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlueEncryptionException" : self = .glueEncryptionException(try GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchTablesByLFTagsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case entityNotFoundException(EntityNotFoundException)
    case glueEncryptionException(GlueEncryptionException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchTablesByLFTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchTablesByLFTagsOutputResponse(nextToken: \(String(describing: nextToken)), tableList: \(String(describing: tableList)))"}
}

extension SearchTablesByLFTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchTablesByLFTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tableList = output.tableList
        } else {
            self.nextToken = nil
            self.tableList = nil
        }
    }
}

public struct SearchTablesByLFTagsOutputResponse: Equatable {
    /// <p>A continuation token, present if the current list segment is not the last.</p>
    public let nextToken: String?
    /// <p>A list of tables that meet the tag conditions.</p>
    public let tableList: [TaggedTable]?

    public init (
        nextToken: String? = nil,
        tableList: [TaggedTable]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableList = tableList
    }
}

struct SearchTablesByLFTagsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let tableList: [TaggedTable]?
}

extension SearchTablesByLFTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tableList = "TableList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tableListContainer = try containerValues.decodeIfPresent([TaggedTable?].self, forKey: .tableList)
        var tableListDecoded0:[TaggedTable]? = nil
        if let tableListContainer = tableListContainer {
            tableListDecoded0 = [TaggedTable]()
            for structure0 in tableListContainer {
                if let structure0 = structure0 {
                    tableListDecoded0?.append(structure0)
                }
            }
        }
        tableList = tableListDecoded0
    }
}

extension TableResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case name = "Name"
        case tableWildcard = "TableWildcard"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tableWildcard = tableWildcard {
            try encodeContainer.encode(tableWildcard, forKey: .tableWildcard)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tableWildcardDecoded = try containerValues.decodeIfPresent(TableWildcard.self, forKey: .tableWildcard)
        tableWildcard = tableWildcardDecoded
    }
}

extension TableResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableResource(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), name: \(String(describing: name)), tableWildcard: \(String(describing: tableWildcard)))"}
}

/// <p>A structure for the table object. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal. </p>
public struct TableResource: Equatable {
    /// <p>The identifier for the Data Catalog. By default, it is the account ID of the caller.</p>
    public let catalogId: String?
    /// <p>The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal. </p>
    public let databaseName: String?
    /// <p>The name of the table.</p>
    public let name: String?
    /// <p>A wildcard object representing every table under a database.</p>
    ///
    ///          <p>At least one of <code>TableResource$Name</code> or <code>TableResource$TableWildcard</code> is required.</p>
    public let tableWildcard: TableWildcard?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        name: String? = nil,
        tableWildcard: TableWildcard? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.name = name
        self.tableWildcard = tableWildcard
    }
}

extension TableWildcard: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension TableWildcard: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableWildcard()"}
}

/// <p>A wildcard object representing every table under a database.</p>
public struct TableWildcard: Equatable {

    public init() {}
}

extension TableWithColumnsResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case columnNames = "ColumnNames"
        case columnWildcard = "ColumnWildcard"
        case databaseName = "DatabaseName"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let columnNames = columnNames {
            var columnNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnNames)
            for columnnames0 in columnNames {
                try columnNamesContainer.encode(columnnames0)
            }
        }
        if let columnWildcard = columnWildcard {
            try encodeContainer.encode(columnWildcard, forKey: .columnWildcard)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let columnNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .columnNames)
        var columnNamesDecoded0:[String]? = nil
        if let columnNamesContainer = columnNamesContainer {
            columnNamesDecoded0 = [String]()
            for string0 in columnNamesContainer {
                if let string0 = string0 {
                    columnNamesDecoded0?.append(string0)
                }
            }
        }
        columnNames = columnNamesDecoded0
        let columnWildcardDecoded = try containerValues.decodeIfPresent(ColumnWildcard.self, forKey: .columnWildcard)
        columnWildcard = columnWildcardDecoded
    }
}

extension TableWithColumnsResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableWithColumnsResource(catalogId: \(String(describing: catalogId)), columnNames: \(String(describing: columnNames)), columnWildcard: \(String(describing: columnWildcard)), databaseName: \(String(describing: databaseName)), name: \(String(describing: name)))"}
}

/// <p>A structure for a table with columns object. This object is only used when granting a SELECT permission.</p>
/// 	        <p>This object must take a value for at least one of <code>ColumnsNames</code>, <code>ColumnsIndexes</code>, or <code>ColumnsWildcard</code>.</p>
public struct TableWithColumnsResource: Equatable {
    /// <p>The identifier for the Data Catalog. By default, it is the account ID of the caller.</p>
    public let catalogId: String?
    /// <p>The list of column names for the table. At least one of <code>ColumnNames</code> or <code>ColumnWildcard</code> is required.</p>
    public let columnNames: [String]?
    /// <p>A wildcard specified by a <code>ColumnWildcard</code> object. At least one of <code>ColumnNames</code> or <code>ColumnWildcard</code> is required.</p>
    public let columnWildcard: ColumnWildcard?
    /// <p>The name of the database for the table with columns resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal. </p>
    public let databaseName: String?
    /// <p>The name of the table resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal. </p>
    public let name: String?

    public init (
        catalogId: String? = nil,
        columnNames: [String]? = nil,
        columnWildcard: ColumnWildcard? = nil,
        databaseName: String? = nil,
        name: String? = nil
    )
    {
        self.catalogId = catalogId
        self.columnNames = columnNames
        self.columnWildcard = columnWildcard
        self.databaseName = databaseName
        self.name = name
    }
}

extension TaggedDatabase: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
        case lFTags = "LFTags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let lFTags = lFTags {
            var lFTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lFTags)
            for lftagslist0 in lFTags {
                try lFTagsContainer.encode(lftagslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(DatabaseResource.self, forKey: .database)
        database = databaseDecoded
        let lFTagsContainer = try containerValues.decodeIfPresent([LFTagPair?].self, forKey: .lFTags)
        var lFTagsDecoded0:[LFTagPair]? = nil
        if let lFTagsContainer = lFTagsContainer {
            lFTagsDecoded0 = [LFTagPair]()
            for structure0 in lFTagsContainer {
                if let structure0 = structure0 {
                    lFTagsDecoded0?.append(structure0)
                }
            }
        }
        lFTags = lFTagsDecoded0
    }
}

extension TaggedDatabase: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaggedDatabase(database: \(String(describing: database)), lFTags: \(String(describing: lFTags)))"}
}

/// <p>A structure describing a database resource with tags.</p>
public struct TaggedDatabase: Equatable {
    /// <p>A database that has tags attached to it.</p>
    public let database: DatabaseResource?
    /// <p>A list of tags attached to the database.</p>
    public let lFTags: [LFTagPair]?

    public init (
        database: DatabaseResource? = nil,
        lFTags: [LFTagPair]? = nil
    )
    {
        self.database = database
        self.lFTags = lFTags
    }
}

extension TaggedTable: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lFTagOnDatabase = "LFTagOnDatabase"
        case lFTagsOnColumns = "LFTagsOnColumns"
        case lFTagsOnTable = "LFTagsOnTable"
        case table = "Table"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lFTagOnDatabase = lFTagOnDatabase {
            var lFTagOnDatabaseContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lFTagOnDatabase)
            for lftagslist0 in lFTagOnDatabase {
                try lFTagOnDatabaseContainer.encode(lftagslist0)
            }
        }
        if let lFTagsOnColumns = lFTagsOnColumns {
            var lFTagsOnColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lFTagsOnColumns)
            for columnlftagslist0 in lFTagsOnColumns {
                try lFTagsOnColumnsContainer.encode(columnlftagslist0)
            }
        }
        if let lFTagsOnTable = lFTagsOnTable {
            var lFTagsOnTableContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lFTagsOnTable)
            for lftagslist0 in lFTagsOnTable {
                try lFTagsOnTableContainer.encode(lftagslist0)
            }
        }
        if let table = table {
            try encodeContainer.encode(table, forKey: .table)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableDecoded = try containerValues.decodeIfPresent(TableResource.self, forKey: .table)
        table = tableDecoded
        let lFTagOnDatabaseContainer = try containerValues.decodeIfPresent([LFTagPair?].self, forKey: .lFTagOnDatabase)
        var lFTagOnDatabaseDecoded0:[LFTagPair]? = nil
        if let lFTagOnDatabaseContainer = lFTagOnDatabaseContainer {
            lFTagOnDatabaseDecoded0 = [LFTagPair]()
            for structure0 in lFTagOnDatabaseContainer {
                if let structure0 = structure0 {
                    lFTagOnDatabaseDecoded0?.append(structure0)
                }
            }
        }
        lFTagOnDatabase = lFTagOnDatabaseDecoded0
        let lFTagsOnTableContainer = try containerValues.decodeIfPresent([LFTagPair?].self, forKey: .lFTagsOnTable)
        var lFTagsOnTableDecoded0:[LFTagPair]? = nil
        if let lFTagsOnTableContainer = lFTagsOnTableContainer {
            lFTagsOnTableDecoded0 = [LFTagPair]()
            for structure0 in lFTagsOnTableContainer {
                if let structure0 = structure0 {
                    lFTagsOnTableDecoded0?.append(structure0)
                }
            }
        }
        lFTagsOnTable = lFTagsOnTableDecoded0
        let lFTagsOnColumnsContainer = try containerValues.decodeIfPresent([ColumnLFTag?].self, forKey: .lFTagsOnColumns)
        var lFTagsOnColumnsDecoded0:[ColumnLFTag]? = nil
        if let lFTagsOnColumnsContainer = lFTagsOnColumnsContainer {
            lFTagsOnColumnsDecoded0 = [ColumnLFTag]()
            for structure0 in lFTagsOnColumnsContainer {
                if let structure0 = structure0 {
                    lFTagsOnColumnsDecoded0?.append(structure0)
                }
            }
        }
        lFTagsOnColumns = lFTagsOnColumnsDecoded0
    }
}

extension TaggedTable: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaggedTable(lFTagOnDatabase: \(String(describing: lFTagOnDatabase)), lFTagsOnColumns: \(String(describing: lFTagsOnColumns)), lFTagsOnTable: \(String(describing: lFTagsOnTable)), table: \(String(describing: table)))"}
}

/// <p>A structure describing a table resource with tags.</p>
public struct TaggedTable: Equatable {
    /// <p>A list of tags attached to the database where the table resides.</p>
    public let lFTagOnDatabase: [LFTagPair]?
    /// <p>A list of tags attached to columns in the table.</p>
    public let lFTagsOnColumns: [ColumnLFTag]?
    /// <p>A list of tags attached to the table.</p>
    public let lFTagsOnTable: [LFTagPair]?
    /// <p>A table that has tags attached to it.</p>
    public let table: TableResource?

    public init (
        lFTagOnDatabase: [LFTagPair]? = nil,
        lFTagsOnColumns: [ColumnLFTag]? = nil,
        lFTagsOnTable: [LFTagPair]? = nil,
        table: TableResource? = nil
    )
    {
        self.lFTagOnDatabase = lFTagOnDatabase
        self.lFTagsOnColumns = lFTagsOnColumns
        self.lFTagsOnTable = lFTagsOnTable
        self.table = table
    }
}

public struct UpdateLFTagInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLFTagInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLFTagInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLFTagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLFTagInput>
    public typealias MOutput = OperationOutput<UpdateLFTagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLFTagOutputError>
}

extension UpdateLFTagInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLFTagInput(catalogId: \(String(describing: catalogId)), tagKey: \(String(describing: tagKey)), tagValuesToAdd: \(String(describing: tagValuesToAdd)), tagValuesToDelete: \(String(describing: tagValuesToDelete)))"}
}

extension UpdateLFTagInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
        case tagValuesToAdd = "TagValuesToAdd"
        case tagValuesToDelete = "TagValuesToDelete"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let tagKey = tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValuesToAdd = tagValuesToAdd {
            var tagValuesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValuesToAdd)
            for tagvaluelist0 in tagValuesToAdd {
                try tagValuesToAddContainer.encode(tagvaluelist0)
            }
        }
        if let tagValuesToDelete = tagValuesToDelete {
            var tagValuesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValuesToDelete)
            for tagvaluelist0 in tagValuesToDelete {
                try tagValuesToDeleteContainer.encode(tagvaluelist0)
            }
        }
    }
}

public struct UpdateLFTagInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLFTagInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLFTagInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLFTagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLFTagInput>
    public typealias MOutput = OperationOutput<UpdateLFTagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLFTagOutputError>
}

public struct UpdateLFTagInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLFTagInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLFTagInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLFTagOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLFTagInput>
    public typealias MOutput = OperationOutput<UpdateLFTagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLFTagOutputError>
}

public struct UpdateLFTagInput: Equatable {
    /// <p>The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment. </p>
    public let catalogId: String?
    /// <p>The key-name for the tag for which to add or delete values.</p>
    public let tagKey: String?
    /// <p>A list of tag values to add from the tag.</p>
    public let tagValuesToAdd: [String]?
    /// <p>A list of tag values to delete from the tag.</p>
    public let tagValuesToDelete: [String]?

    public init (
        catalogId: String? = nil,
        tagKey: String? = nil,
        tagValuesToAdd: [String]? = nil,
        tagValuesToDelete: [String]? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
        self.tagValuesToAdd = tagValuesToAdd
        self.tagValuesToDelete = tagValuesToDelete
    }
}

struct UpdateLFTagInputBody: Equatable {
    public let catalogId: String?
    public let tagKey: String?
    public let tagValuesToDelete: [String]?
    public let tagValuesToAdd: [String]?
}

extension UpdateLFTagInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
        case tagValuesToAdd = "TagValuesToAdd"
        case tagValuesToDelete = "TagValuesToDelete"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesToDeleteContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagValuesToDelete)
        var tagValuesToDeleteDecoded0:[String]? = nil
        if let tagValuesToDeleteContainer = tagValuesToDeleteContainer {
            tagValuesToDeleteDecoded0 = [String]()
            for string0 in tagValuesToDeleteContainer {
                if let string0 = string0 {
                    tagValuesToDeleteDecoded0?.append(string0)
                }
            }
        }
        tagValuesToDelete = tagValuesToDeleteDecoded0
        let tagValuesToAddContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagValuesToAdd)
        var tagValuesToAddDecoded0:[String]? = nil
        if let tagValuesToAddContainer = tagValuesToAddContainer {
            tagValuesToAddDecoded0 = [String]()
            for string0 in tagValuesToAddContainer {
                if let string0 = string0 {
                    tagValuesToAddDecoded0?.append(string0)
                }
            }
        }
        tagValuesToAdd = tagValuesToAddDecoded0
    }
}

extension UpdateLFTagOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLFTagOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLFTagOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLFTagOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLFTagOutputResponse()"}
}

extension UpdateLFTagOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLFTagOutputResponse: Equatable {

    public init() {}
}

struct UpdateLFTagOutputResponseBody: Equatable {
}

extension UpdateLFTagOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateResourceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceInput>
    public typealias MOutput = OperationOutput<UpdateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceOutputError>
}

extension UpdateResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceInput(resourceArn: \(String(describing: resourceArn)), roleArn: \(String(describing: roleArn)))"}
}

extension UpdateResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct UpdateResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceInput>
    public typealias MOutput = OperationOutput<UpdateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceOutputError>
}

public struct UpdateResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceInput>
    public typealias MOutput = OperationOutput<UpdateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceOutputError>
}

public struct UpdateResourceInput: Equatable {
    /// <p>The resource ARN.</p>
    public let resourceArn: String?
    /// <p>The new role to use for the given resource registered in AWS Lake Formation.</p>
    public let roleArn: String?

    public init (
        resourceArn: String? = nil,
        roleArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.roleArn = roleArn
    }
}

struct UpdateResourceInputBody: Equatable {
    public let roleArn: String?
    public let resourceArn: String?
}

extension UpdateResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension UpdateResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationTimeoutException" : self = .operationTimeoutException(try OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceOutputError: Swift.Error, Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidInputException(InvalidInputException)
    case operationTimeoutException(OperationTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceOutputResponse()"}
}

extension UpdateResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateResourceOutputResponse: Equatable {

    public init() {}
}

struct UpdateResourceOutputResponseBody: Equatable {
}

extension UpdateResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
