// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BraketClientTypes.AlgorithmSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerImage
        case scriptModeConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerImage = containerImage {
            try encodeContainer.encode(containerImage, forKey: .containerImage)
        }
        if let scriptModeConfig = scriptModeConfig {
            try encodeContainer.encode(scriptModeConfig, forKey: .scriptModeConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scriptModeConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.ScriptModeConfig.self, forKey: .scriptModeConfig)
        scriptModeConfig = scriptModeConfigDecoded
        let containerImageDecoded = try containerValues.decodeIfPresent(BraketClientTypes.ContainerImage.self, forKey: .containerImage)
        containerImage = containerImageDecoded
    }
}

extension BraketClientTypes {
    /// Defines the Amazon Braket job to be created. Specifies the container image the job uses and the paths to the Python scripts used for entry and training.
    public struct AlgorithmSpecification: Swift.Equatable {
        /// The container image used to create an Amazon Braket job.
        public var containerImage: BraketClientTypes.ContainerImage?
        /// Configures the paths to the Python scripts used for entry and training.
        public var scriptModeConfig: BraketClientTypes.ScriptModeConfig?

        public init (
            containerImage: BraketClientTypes.ContainerImage? = nil,
            scriptModeConfig: BraketClientTypes.ScriptModeConfig? = nil
        )
        {
            self.containerImage = containerImage
            self.scriptModeConfig = scriptModeConfig
        }
    }

}

extension CancelJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobArn = jobArn else {
            return nil
        }
        return "/job/\(jobArn.urlPercentEncoding())/cancel"
    }
}

public struct CancelJobInput: Swift.Equatable {
    /// The ARN of the Amazon Braket job to cancel.
    /// This member is required.
    public var jobArn: Swift.String?

    public init (
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

struct CancelJobInputBody: Swift.Equatable {
}

extension CancelJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cancellationStatus = output.cancellationStatus
            self.jobArn = output.jobArn
        } else {
            self.cancellationStatus = nil
            self.jobArn = nil
        }
    }
}

public struct CancelJobOutputResponse: Swift.Equatable {
    /// The status of the job cancellation request.
    /// This member is required.
    public var cancellationStatus: BraketClientTypes.CancellationStatus?
    /// The ARN of the Amazon Braket job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init (
        cancellationStatus: BraketClientTypes.CancellationStatus? = nil,
        jobArn: Swift.String? = nil
    )
    {
        self.cancellationStatus = cancellationStatus
        self.jobArn = jobArn
    }
}

struct CancelJobOutputResponseBody: Swift.Equatable {
    let jobArn: Swift.String?
    let cancellationStatus: BraketClientTypes.CancellationStatus?
}

extension CancelJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancellationStatus
        case jobArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let cancellationStatusDecoded = try containerValues.decodeIfPresent(BraketClientTypes.CancellationStatus.self, forKey: .cancellationStatus)
        cancellationStatus = cancellationStatusDecoded
    }
}

extension CancelQuantumTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension CancelQuantumTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let quantumTaskArn = quantumTaskArn else {
            return nil
        }
        return "/quantum-task/\(quantumTaskArn.urlPercentEncoding())/cancel"
    }
}

public struct CancelQuantumTaskInput: Swift.Equatable {
    /// The client token associated with the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The ARN of the task to cancel.
    /// This member is required.
    public var quantumTaskArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        quantumTaskArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.quantumTaskArn = quantumTaskArn
    }
}

struct CancelQuantumTaskInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension CancelQuantumTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CancelQuantumTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelQuantumTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelQuantumTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelQuantumTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelQuantumTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cancellationStatus = output.cancellationStatus
            self.quantumTaskArn = output.quantumTaskArn
        } else {
            self.cancellationStatus = nil
            self.quantumTaskArn = nil
        }
    }
}

public struct CancelQuantumTaskOutputResponse: Swift.Equatable {
    /// The status of the cancellation request.
    /// This member is required.
    public var cancellationStatus: BraketClientTypes.CancellationStatus?
    /// The ARN of the task.
    /// This member is required.
    public var quantumTaskArn: Swift.String?

    public init (
        cancellationStatus: BraketClientTypes.CancellationStatus? = nil,
        quantumTaskArn: Swift.String? = nil
    )
    {
        self.cancellationStatus = cancellationStatus
        self.quantumTaskArn = quantumTaskArn
    }
}

struct CancelQuantumTaskOutputResponseBody: Swift.Equatable {
    let quantumTaskArn: Swift.String?
    let cancellationStatus: BraketClientTypes.CancellationStatus?
}

extension CancelQuantumTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancellationStatus
        case quantumTaskArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantumTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quantumTaskArn)
        quantumTaskArn = quantumTaskArnDecoded
        let cancellationStatusDecoded = try containerValues.decodeIfPresent(BraketClientTypes.CancellationStatus.self, forKey: .cancellationStatus)
        cancellationStatus = cancellationStatusDecoded
    }
}

extension BraketClientTypes {
    public enum CancellationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case sdkUnknown(Swift.String)

        public static var allCases: [CancellationStatus] {
            return [
                .cancelled,
                .cancelling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CancellationStatus(rawValue: rawValue) ?? CancellationStatus.sdkUnknown(rawValue)
        }
    }
}

extension BraketClientTypes {
    public enum CompressionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionType] {
            return [
                .gzip,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CompressionType(rawValue: rawValue) ?? CompressionType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred due to a conflict.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BraketClientTypes.ContainerImage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension BraketClientTypes {
    /// The container image used to create an Amazon Braket job.
    public struct ContainerImage: Swift.Equatable {
        /// The URI locating the container image.
        /// This member is required.
        public var uri: Swift.String?

        public init (
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }

}

extension CreateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmSpecification
        case checkpointConfig
        case clientToken
        case deviceConfig
        case hyperParameters
        case inputDataConfig
        case instanceConfig
        case jobName
        case outputDataConfig
        case roleArn
        case stoppingCondition
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmSpecification = algorithmSpecification {
            try encodeContainer.encode(algorithmSpecification, forKey: .algorithmSpecification)
        }
        if let checkpointConfig = checkpointConfig {
            try encodeContainer.encode(checkpointConfig, forKey: .checkpointConfig)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deviceConfig = deviceConfig {
            try encodeContainer.encode(deviceConfig, forKey: .deviceConfig)
        }
        if let hyperParameters = hyperParameters {
            var hyperParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .hyperParameters)
            for (dictKey0, hyperparameters0) in hyperParameters {
                try hyperParametersContainer.encode(hyperparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let inputDataConfig = inputDataConfig {
            var inputDataConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputDataConfig)
            for inputconfiglist0 in inputDataConfig {
                try inputDataConfigContainer.encode(inputconfiglist0)
            }
        }
        if let instanceConfig = instanceConfig {
            try encodeContainer.encode(instanceConfig, forKey: .instanceConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stoppingCondition = stoppingCondition {
            try encodeContainer.encode(stoppingCondition, forKey: .stoppingCondition)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/job"
    }
}

public struct CreateJobInput: Swift.Equatable {
    /// Definition of the Amazon Braket job to be created. Specifies the container image the job uses and information about the Python scripts used for entry and training.
    /// This member is required.
    public var algorithmSpecification: BraketClientTypes.AlgorithmSpecification?
    /// Information about the output locations for job checkpoint data.
    public var checkpointConfig: BraketClientTypes.JobCheckpointConfig?
    /// A unique token that guarantees that the call to this API is idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The quantum processing unit (QPU) or simulator used to create an Amazon Braket job.
    /// This member is required.
    public var deviceConfig: BraketClientTypes.DeviceConfig?
    /// Algorithm-specific parameters used by an Amazon Braket job that influence the quality of the training job. The values are set with a string of JSON key:value pairs, where the key is the name of the hyperparameter and the value is the value of th hyperparameter.
    public var hyperParameters: [Swift.String:Swift.String]?
    /// A list of parameters that specify the name and type of input data and where it is located.
    public var inputDataConfig: [BraketClientTypes.InputFileConfig]?
    /// Configuration of the resource instances to use while running the hybrid job on Amazon Braket.
    /// This member is required.
    public var instanceConfig: BraketClientTypes.InstanceConfig?
    /// The name of the Amazon Braket job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The path to the S3 location where you want to store job artifacts and the encryption key used to store them.
    /// This member is required.
    public var outputDataConfig: BraketClientTypes.JobOutputDataConfig?
    /// The Amazon Resource Name (ARN) of an IAM role that Amazon Braket can assume to perform tasks on behalf of a user. It can access user resources, run an Amazon Braket job container on behalf of user, and output resources to the users' s3 buckets.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The user-defined criteria that specifies when a job stops running.
    public var stoppingCondition: BraketClientTypes.JobStoppingCondition?
    /// A tag object that consists of a key and an optional value, used to manage metadata for Amazon Braket resources.
    public var tags: [Swift.String:Swift.String]?

    public init (
        algorithmSpecification: BraketClientTypes.AlgorithmSpecification? = nil,
        checkpointConfig: BraketClientTypes.JobCheckpointConfig? = nil,
        clientToken: Swift.String? = nil,
        deviceConfig: BraketClientTypes.DeviceConfig? = nil,
        hyperParameters: [Swift.String:Swift.String]? = nil,
        inputDataConfig: [BraketClientTypes.InputFileConfig]? = nil,
        instanceConfig: BraketClientTypes.InstanceConfig? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: BraketClientTypes.JobOutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        stoppingCondition: BraketClientTypes.JobStoppingCondition? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.algorithmSpecification = algorithmSpecification
        self.checkpointConfig = checkpointConfig
        self.clientToken = clientToken
        self.deviceConfig = deviceConfig
        self.hyperParameters = hyperParameters
        self.inputDataConfig = inputDataConfig
        self.instanceConfig = instanceConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.stoppingCondition = stoppingCondition
        self.tags = tags
    }
}

struct CreateJobInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let algorithmSpecification: BraketClientTypes.AlgorithmSpecification?
    let inputDataConfig: [BraketClientTypes.InputFileConfig]?
    let outputDataConfig: BraketClientTypes.JobOutputDataConfig?
    let checkpointConfig: BraketClientTypes.JobCheckpointConfig?
    let jobName: Swift.String?
    let roleArn: Swift.String?
    let stoppingCondition: BraketClientTypes.JobStoppingCondition?
    let instanceConfig: BraketClientTypes.InstanceConfig?
    let hyperParameters: [Swift.String:Swift.String]?
    let deviceConfig: BraketClientTypes.DeviceConfig?
    let tags: [Swift.String:Swift.String]?
}

extension CreateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmSpecification
        case checkpointConfig
        case clientToken
        case deviceConfig
        case hyperParameters
        case inputDataConfig
        case instanceConfig
        case jobName
        case outputDataConfig
        case roleArn
        case stoppingCondition
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let algorithmSpecificationDecoded = try containerValues.decodeIfPresent(BraketClientTypes.AlgorithmSpecification.self, forKey: .algorithmSpecification)
        algorithmSpecification = algorithmSpecificationDecoded
        let inputDataConfigContainer = try containerValues.decodeIfPresent([BraketClientTypes.InputFileConfig?].self, forKey: .inputDataConfig)
        var inputDataConfigDecoded0:[BraketClientTypes.InputFileConfig]? = nil
        if let inputDataConfigContainer = inputDataConfigContainer {
            inputDataConfigDecoded0 = [BraketClientTypes.InputFileConfig]()
            for structure0 in inputDataConfigContainer {
                if let structure0 = structure0 {
                    inputDataConfigDecoded0?.append(structure0)
                }
            }
        }
        inputDataConfig = inputDataConfigDecoded0
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobOutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let checkpointConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobCheckpointConfig.self, forKey: .checkpointConfig)
        checkpointConfig = checkpointConfigDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let stoppingConditionDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobStoppingCondition.self, forKey: .stoppingCondition)
        stoppingCondition = stoppingConditionDecoded
        let instanceConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.InstanceConfig.self, forKey: .instanceConfig)
        instanceConfig = instanceConfigDecoded
        let hyperParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .hyperParameters)
        var hyperParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let hyperParametersContainer = hyperParametersContainer {
            hyperParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in hyperParametersContainer {
                if let string0 = string0 {
                    hyperParametersDecoded0?[key0] = string0
                }
            }
        }
        hyperParameters = hyperParametersDecoded0
        let deviceConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.DeviceConfig.self, forKey: .deviceConfig)
        deviceConfig = deviceConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceRetiredException" : self = .deviceRetiredException(try DeviceRetiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case deviceRetiredException(DeviceRetiredException)
    case internalServiceException(InternalServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobArn = output.jobArn
        } else {
            self.jobArn = nil
        }
    }
}

public struct CreateJobOutputResponse: Swift.Equatable {
    /// The ARN of the Amazon Braket job created.
    /// This member is required.
    public var jobArn: Swift.String?

    public init (
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

struct CreateJobOutputResponseBody: Swift.Equatable {
    let jobArn: Swift.String?
}

extension CreateJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
    }
}

extension CreateQuantumTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case clientToken
        case deviceArn
        case deviceParameters
        case jobToken
        case outputS3Bucket
        case outputS3KeyPrefix
        case shots
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceParameters = deviceParameters {
            try encodeContainer.encode(deviceParameters, forKey: .deviceParameters)
        }
        if let jobToken = jobToken {
            try encodeContainer.encode(jobToken, forKey: .jobToken)
        }
        if let outputS3Bucket = outputS3Bucket {
            try encodeContainer.encode(outputS3Bucket, forKey: .outputS3Bucket)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let shots = shots {
            try encodeContainer.encode(shots, forKey: .shots)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateQuantumTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/quantum-task"
    }
}

public struct CreateQuantumTaskInput: Swift.Equatable {
    /// The action associated with the task.
    /// This member is required.
    public var action: Swift.String?
    /// The client token associated with the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The ARN of the device to run the task on.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The parameters for the device to run the task on.
    public var deviceParameters: Swift.String?
    /// The token for an Amazon Braket job that associates it with the quantum task.
    public var jobToken: Swift.String?
    /// The S3 bucket to store task result files in.
    /// This member is required.
    public var outputS3Bucket: Swift.String?
    /// The key prefix for the location in the S3 bucket to store task results in.
    /// This member is required.
    public var outputS3KeyPrefix: Swift.String?
    /// The number of shots to use for the task.
    /// This member is required.
    public var shots: Swift.Int?
    /// Tags to be added to the quantum task you're creating.
    public var tags: [Swift.String:Swift.String]?

    public init (
        action: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        deviceArn: Swift.String? = nil,
        deviceParameters: Swift.String? = nil,
        jobToken: Swift.String? = nil,
        outputS3Bucket: Swift.String? = nil,
        outputS3KeyPrefix: Swift.String? = nil,
        shots: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.deviceArn = deviceArn
        self.deviceParameters = deviceParameters
        self.jobToken = jobToken
        self.outputS3Bucket = outputS3Bucket
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.shots = shots
        self.tags = tags
    }
}

struct CreateQuantumTaskInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let deviceArn: Swift.String?
    let deviceParameters: Swift.String?
    let shots: Swift.Int?
    let outputS3Bucket: Swift.String?
    let outputS3KeyPrefix: Swift.String?
    let action: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let jobToken: Swift.String?
}

extension CreateQuantumTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case clientToken
        case deviceArn
        case deviceParameters
        case jobToken
        case outputS3Bucket
        case outputS3KeyPrefix
        case shots
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceParameters)
        deviceParameters = deviceParametersDecoded
        let shotsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shots)
        shots = shotsDecoded
        let outputS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Bucket)
        outputS3Bucket = outputS3BucketDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let jobTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobToken)
        jobToken = jobTokenDecoded
    }
}

extension CreateQuantumTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateQuantumTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceOfflineException" : self = .deviceOfflineException(try DeviceOfflineException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceRetiredException" : self = .deviceRetiredException(try DeviceRetiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateQuantumTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case deviceOfflineException(DeviceOfflineException)
    case deviceRetiredException(DeviceRetiredException)
    case internalServiceException(InternalServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateQuantumTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateQuantumTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.quantumTaskArn = output.quantumTaskArn
        } else {
            self.quantumTaskArn = nil
        }
    }
}

public struct CreateQuantumTaskOutputResponse: Swift.Equatable {
    /// The ARN of the task created by the request.
    /// This member is required.
    public var quantumTaskArn: Swift.String?

    public init (
        quantumTaskArn: Swift.String? = nil
    )
    {
        self.quantumTaskArn = quantumTaskArn
    }
}

struct CreateQuantumTaskOutputResponseBody: Swift.Equatable {
    let quantumTaskArn: Swift.String?
}

extension CreateQuantumTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quantumTaskArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantumTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quantumTaskArn)
        quantumTaskArn = quantumTaskArnDecoded
    }
}

extension BraketClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3DataSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataSource = s3DataSource {
            try encodeContainer.encode(s3DataSource, forKey: .s3DataSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataSourceDecoded = try containerValues.decodeIfPresent(BraketClientTypes.S3DataSource.self, forKey: .s3DataSource)
        s3DataSource = s3DataSourceDecoded
    }
}

extension BraketClientTypes {
    /// Information about the source of the data used by the Amazon Braket job.
    public struct DataSource: Swift.Equatable {
        /// Information about the data stored in Amazon S3 used by the Amazon Braket job.
        /// This member is required.
        public var s3DataSource: BraketClientTypes.S3DataSource?

        public init (
            s3DataSource: BraketClientTypes.S3DataSource? = nil
        )
        {
            self.s3DataSource = s3DataSource
        }
    }

}

extension BraketClientTypes.DeviceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let device = device {
            try encodeContainer.encode(device, forKey: .device)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .device)
        device = deviceDecoded
    }
}

extension BraketClientTypes {
    /// Configures the quantum processing units (QPUs) or simulator used to create and run an Amazon Braket job.
    public struct DeviceConfig: Swift.Equatable {
        /// The primary quantum processing unit (QPU) or simulator used to create and run an Amazon Braket job.
        /// This member is required.
        public var device: Swift.String?

        public init (
            device: Swift.String? = nil
        )
        {
            self.device = device
        }
    }

}

extension DeviceOfflineException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeviceOfflineExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified device is currently offline.
public struct DeviceOfflineException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeviceOfflineExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeviceOfflineExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeviceRetiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeviceRetiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified device has been retired.
public struct DeviceRetiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeviceRetiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeviceRetiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BraketClientTypes {
    public enum DeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case offline
        case online
        case retired
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatus] {
            return [
                .offline,
                .online,
                .retired,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .retired: return "RETIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceStatus(rawValue: rawValue) ?? DeviceStatus.sdkUnknown(rawValue)
        }
    }
}

extension BraketClientTypes.DeviceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn
        case deviceName
        case deviceStatus
        case deviceType
        case providerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let deviceStatus = deviceStatus {
            try encodeContainer.encode(deviceStatus.rawValue, forKey: .deviceStatus)
        }
        if let deviceType = deviceType {
            try encodeContainer.encode(deviceType.rawValue, forKey: .deviceType)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(BraketClientTypes.DeviceType.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let deviceStatusDecoded = try containerValues.decodeIfPresent(BraketClientTypes.DeviceStatus.self, forKey: .deviceStatus)
        deviceStatus = deviceStatusDecoded
    }
}

extension BraketClientTypes {
    /// Includes information about the device.
    public struct DeviceSummary: Swift.Equatable {
        /// The ARN of the device.
        /// This member is required.
        public var deviceArn: Swift.String?
        /// The name of the device.
        /// This member is required.
        public var deviceName: Swift.String?
        /// The status of the device.
        /// This member is required.
        public var deviceStatus: BraketClientTypes.DeviceStatus?
        /// The type of the device.
        /// This member is required.
        public var deviceType: BraketClientTypes.DeviceType?
        /// The provider of the device.
        /// This member is required.
        public var providerName: Swift.String?

        public init (
            deviceArn: Swift.String? = nil,
            deviceName: Swift.String? = nil,
            deviceStatus: BraketClientTypes.DeviceStatus? = nil,
            deviceType: BraketClientTypes.DeviceType? = nil,
            providerName: Swift.String? = nil
        )
        {
            self.deviceArn = deviceArn
            self.deviceName = deviceName
            self.deviceStatus = deviceStatus
            self.deviceType = deviceType
            self.providerName = providerName
        }
    }

}

extension BraketClientTypes {
    public enum DeviceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case qpu
        case simulator
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceType] {
            return [
                .qpu,
                .simulator,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .qpu: return "QPU"
            case .simulator: return "SIMULATOR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceType(rawValue: rawValue) ?? DeviceType.sdkUnknown(rawValue)
        }
    }
}

extension GetDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceArn = deviceArn else {
            return nil
        }
        return "/device/\(deviceArn.urlPercentEncoding())"
    }
}

public struct GetDeviceInput: Swift.Equatable {
    /// The ARN of the device to retrieve.
    /// This member is required.
    public var deviceArn: Swift.String?

    public init (
        deviceArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

struct GetDeviceInputBody: Swift.Equatable {
}

extension GetDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceArn = output.deviceArn
            self.deviceCapabilities = output.deviceCapabilities
            self.deviceName = output.deviceName
            self.deviceStatus = output.deviceStatus
            self.deviceType = output.deviceType
            self.providerName = output.providerName
        } else {
            self.deviceArn = nil
            self.deviceCapabilities = nil
            self.deviceName = nil
            self.deviceStatus = nil
            self.deviceType = nil
            self.providerName = nil
        }
    }
}

public struct GetDeviceOutputResponse: Swift.Equatable {
    /// The ARN of the device.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// Details about the capabilities of the device.
    /// This member is required.
    public var deviceCapabilities: Swift.String?
    /// The name of the device.
    /// This member is required.
    public var deviceName: Swift.String?
    /// The status of the device.
    /// This member is required.
    public var deviceStatus: BraketClientTypes.DeviceStatus?
    /// The type of the device.
    /// This member is required.
    public var deviceType: BraketClientTypes.DeviceType?
    /// The name of the partner company for the device.
    /// This member is required.
    public var providerName: Swift.String?

    public init (
        deviceArn: Swift.String? = nil,
        deviceCapabilities: Swift.String? = nil,
        deviceName: Swift.String? = nil,
        deviceStatus: BraketClientTypes.DeviceStatus? = nil,
        deviceType: BraketClientTypes.DeviceType? = nil,
        providerName: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.deviceCapabilities = deviceCapabilities
        self.deviceName = deviceName
        self.deviceStatus = deviceStatus
        self.deviceType = deviceType
        self.providerName = providerName
    }
}

struct GetDeviceOutputResponseBody: Swift.Equatable {
    let deviceArn: Swift.String?
    let deviceName: Swift.String?
    let providerName: Swift.String?
    let deviceType: BraketClientTypes.DeviceType?
    let deviceStatus: BraketClientTypes.DeviceStatus?
    let deviceCapabilities: Swift.String?
}

extension GetDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn
        case deviceCapabilities
        case deviceName
        case deviceStatus
        case deviceType
        case providerName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(BraketClientTypes.DeviceType.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let deviceStatusDecoded = try containerValues.decodeIfPresent(BraketClientTypes.DeviceStatus.self, forKey: .deviceStatus)
        deviceStatus = deviceStatusDecoded
        let deviceCapabilitiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCapabilities)
        deviceCapabilities = deviceCapabilitiesDecoded
    }
}

extension GetJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobArn = jobArn else {
            return nil
        }
        return "/job/\(jobArn.urlPercentEncoding())"
    }
}

public struct GetJobInput: Swift.Equatable {
    /// The ARN of the job to retrieve.
    /// This member is required.
    public var jobArn: Swift.String?

    public init (
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

struct GetJobInputBody: Swift.Equatable {
}

extension GetJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.algorithmSpecification = output.algorithmSpecification
            self.billableDuration = output.billableDuration
            self.checkpointConfig = output.checkpointConfig
            self.createdAt = output.createdAt
            self.deviceConfig = output.deviceConfig
            self.endedAt = output.endedAt
            self.events = output.events
            self.failureReason = output.failureReason
            self.hyperParameters = output.hyperParameters
            self.inputDataConfig = output.inputDataConfig
            self.instanceConfig = output.instanceConfig
            self.jobArn = output.jobArn
            self.jobName = output.jobName
            self.outputDataConfig = output.outputDataConfig
            self.roleArn = output.roleArn
            self.startedAt = output.startedAt
            self.status = output.status
            self.stoppingCondition = output.stoppingCondition
            self.tags = output.tags
        } else {
            self.algorithmSpecification = nil
            self.billableDuration = nil
            self.checkpointConfig = nil
            self.createdAt = nil
            self.deviceConfig = nil
            self.endedAt = nil
            self.events = nil
            self.failureReason = nil
            self.hyperParameters = nil
            self.inputDataConfig = nil
            self.instanceConfig = nil
            self.jobArn = nil
            self.jobName = nil
            self.outputDataConfig = nil
            self.roleArn = nil
            self.startedAt = nil
            self.status = nil
            self.stoppingCondition = nil
            self.tags = nil
        }
    }
}

public struct GetJobOutputResponse: Swift.Equatable {
    /// Definition of the Amazon Braket job created. Specifies the container image the job uses, information about the Python scripts used for entry and training, and the user-defined metrics used to evaluation the job.
    /// This member is required.
    public var algorithmSpecification: BraketClientTypes.AlgorithmSpecification?
    /// The billable time the Amazon Braket job used to complete.
    public var billableDuration: Swift.Int?
    /// Information about the output locations for job checkpoint data.
    public var checkpointConfig: BraketClientTypes.JobCheckpointConfig?
    /// The date and time that the Amazon Braket job was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The quantum processing unit (QPU) or simulator used to run the Amazon Braket job.
    public var deviceConfig: BraketClientTypes.DeviceConfig?
    /// The date and time that the Amazon Braket job ended.
    public var endedAt: ClientRuntime.Date?
    /// Details about the type and time events occurred related to the Amazon Braket job.
    public var events: [BraketClientTypes.JobEventDetails]?
    /// A description of the reason why an Amazon Braket job failed, if it failed.
    public var failureReason: Swift.String?
    /// Algorithm-specific parameters used by an Amazon Braket job that influence the quality of the traiing job. The values are set with a string of JSON key:value pairs, where the key is the name of the hyperparameter and the value is the value of th hyperparameter.
    public var hyperParameters: [Swift.String:Swift.String]?
    /// A list of parameters that specify the name and type of input data and where it is located.
    public var inputDataConfig: [BraketClientTypes.InputFileConfig]?
    /// The resource instances to use while running the hybrid job on Amazon Braket.
    /// This member is required.
    public var instanceConfig: BraketClientTypes.InstanceConfig?
    /// The ARN of the Amazon Braket job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The name of the Amazon Braket job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The path to the S3 location where job artifacts are stored and the encryption key used to store them there.
    /// This member is required.
    public var outputDataConfig: BraketClientTypes.JobOutputDataConfig?
    /// The Amazon Resource Name (ARN) of an IAM role that Amazon Braket can assume to perform tasks on behalf of a user. It can access user resources, run an Amazon Braket job container on behalf of user, and output resources to the s3 buckets of a user.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The date and time that the Amazon Braket job was started.
    public var startedAt: ClientRuntime.Date?
    /// The status of the Amazon Braket job.
    /// This member is required.
    public var status: BraketClientTypes.JobPrimaryStatus?
    /// The user-defined criteria that specifies when to stop a job running.
    public var stoppingCondition: BraketClientTypes.JobStoppingCondition?
    /// A tag object that consists of a key and an optional value, used to manage metadata for Amazon Braket resources.
    public var tags: [Swift.String:Swift.String]?

    public init (
        algorithmSpecification: BraketClientTypes.AlgorithmSpecification? = nil,
        billableDuration: Swift.Int? = nil,
        checkpointConfig: BraketClientTypes.JobCheckpointConfig? = nil,
        createdAt: ClientRuntime.Date? = nil,
        deviceConfig: BraketClientTypes.DeviceConfig? = nil,
        endedAt: ClientRuntime.Date? = nil,
        events: [BraketClientTypes.JobEventDetails]? = nil,
        failureReason: Swift.String? = nil,
        hyperParameters: [Swift.String:Swift.String]? = nil,
        inputDataConfig: [BraketClientTypes.InputFileConfig]? = nil,
        instanceConfig: BraketClientTypes.InstanceConfig? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: BraketClientTypes.JobOutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        startedAt: ClientRuntime.Date? = nil,
        status: BraketClientTypes.JobPrimaryStatus? = nil,
        stoppingCondition: BraketClientTypes.JobStoppingCondition? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.algorithmSpecification = algorithmSpecification
        self.billableDuration = billableDuration
        self.checkpointConfig = checkpointConfig
        self.createdAt = createdAt
        self.deviceConfig = deviceConfig
        self.endedAt = endedAt
        self.events = events
        self.failureReason = failureReason
        self.hyperParameters = hyperParameters
        self.inputDataConfig = inputDataConfig
        self.instanceConfig = instanceConfig
        self.jobArn = jobArn
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.startedAt = startedAt
        self.status = status
        self.stoppingCondition = stoppingCondition
        self.tags = tags
    }
}

struct GetJobOutputResponseBody: Swift.Equatable {
    let status: BraketClientTypes.JobPrimaryStatus?
    let jobArn: Swift.String?
    let roleArn: Swift.String?
    let failureReason: Swift.String?
    let jobName: Swift.String?
    let hyperParameters: [Swift.String:Swift.String]?
    let inputDataConfig: [BraketClientTypes.InputFileConfig]?
    let outputDataConfig: BraketClientTypes.JobOutputDataConfig?
    let stoppingCondition: BraketClientTypes.JobStoppingCondition?
    let checkpointConfig: BraketClientTypes.JobCheckpointConfig?
    let algorithmSpecification: BraketClientTypes.AlgorithmSpecification?
    let instanceConfig: BraketClientTypes.InstanceConfig?
    let createdAt: ClientRuntime.Date?
    let startedAt: ClientRuntime.Date?
    let endedAt: ClientRuntime.Date?
    let billableDuration: Swift.Int?
    let deviceConfig: BraketClientTypes.DeviceConfig?
    let events: [BraketClientTypes.JobEventDetails]?
    let tags: [Swift.String:Swift.String]?
}

extension GetJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmSpecification
        case billableDuration
        case checkpointConfig
        case createdAt
        case deviceConfig
        case endedAt
        case events
        case failureReason
        case hyperParameters
        case inputDataConfig
        case instanceConfig
        case jobArn
        case jobName
        case outputDataConfig
        case roleArn
        case startedAt
        case status
        case stoppingCondition
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobPrimaryStatus.self, forKey: .status)
        status = statusDecoded
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let hyperParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .hyperParameters)
        var hyperParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let hyperParametersContainer = hyperParametersContainer {
            hyperParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in hyperParametersContainer {
                if let string0 = string0 {
                    hyperParametersDecoded0?[key0] = string0
                }
            }
        }
        hyperParameters = hyperParametersDecoded0
        let inputDataConfigContainer = try containerValues.decodeIfPresent([BraketClientTypes.InputFileConfig?].self, forKey: .inputDataConfig)
        var inputDataConfigDecoded0:[BraketClientTypes.InputFileConfig]? = nil
        if let inputDataConfigContainer = inputDataConfigContainer {
            inputDataConfigDecoded0 = [BraketClientTypes.InputFileConfig]()
            for structure0 in inputDataConfigContainer {
                if let structure0 = structure0 {
                    inputDataConfigDecoded0?.append(structure0)
                }
            }
        }
        inputDataConfig = inputDataConfigDecoded0
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobOutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let stoppingConditionDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobStoppingCondition.self, forKey: .stoppingCondition)
        stoppingCondition = stoppingConditionDecoded
        let checkpointConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobCheckpointConfig.self, forKey: .checkpointConfig)
        checkpointConfig = checkpointConfigDecoded
        let algorithmSpecificationDecoded = try containerValues.decodeIfPresent(BraketClientTypes.AlgorithmSpecification.self, forKey: .algorithmSpecification)
        algorithmSpecification = algorithmSpecificationDecoded
        let instanceConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.InstanceConfig.self, forKey: .instanceConfig)
        instanceConfig = instanceConfigDecoded
        let createdAtDateString = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        var createdAtDecoded: ClientRuntime.Date? = nil
        if let createdAtDateString = createdAtDateString {
            let createdAtFormatter = ClientRuntime.DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            createdAtDecoded = createdAtFormatter.date(from: createdAtDateString)
        }
        createdAt = createdAtDecoded
        let startedAtDateString = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startedAt)
        var startedAtDecoded: ClientRuntime.Date? = nil
        if let startedAtDateString = startedAtDateString {
            let startedAtFormatter = ClientRuntime.DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            startedAtDecoded = startedAtFormatter.date(from: startedAtDateString)
        }
        startedAt = startedAtDecoded
        let endedAtDateString = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endedAt)
        var endedAtDecoded: ClientRuntime.Date? = nil
        if let endedAtDateString = endedAtDateString {
            let endedAtFormatter = ClientRuntime.DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            endedAtDecoded = endedAtFormatter.date(from: endedAtDateString)
        }
        endedAt = endedAtDecoded
        let billableDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .billableDuration)
        billableDuration = billableDurationDecoded
        let deviceConfigDecoded = try containerValues.decodeIfPresent(BraketClientTypes.DeviceConfig.self, forKey: .deviceConfig)
        deviceConfig = deviceConfigDecoded
        let eventsContainer = try containerValues.decodeIfPresent([BraketClientTypes.JobEventDetails?].self, forKey: .events)
        var eventsDecoded0:[BraketClientTypes.JobEventDetails]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [BraketClientTypes.JobEventDetails]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetQuantumTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let quantumTaskArn = quantumTaskArn else {
            return nil
        }
        return "/quantum-task/\(quantumTaskArn.urlPercentEncoding())"
    }
}

public struct GetQuantumTaskInput: Swift.Equatable {
    /// the ARN of the task to retrieve.
    /// This member is required.
    public var quantumTaskArn: Swift.String?

    public init (
        quantumTaskArn: Swift.String? = nil
    )
    {
        self.quantumTaskArn = quantumTaskArn
    }
}

struct GetQuantumTaskInputBody: Swift.Equatable {
}

extension GetQuantumTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetQuantumTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetQuantumTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetQuantumTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetQuantumTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetQuantumTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.deviceArn = output.deviceArn
            self.deviceParameters = output.deviceParameters
            self.endedAt = output.endedAt
            self.failureReason = output.failureReason
            self.jobArn = output.jobArn
            self.outputS3Bucket = output.outputS3Bucket
            self.outputS3Directory = output.outputS3Directory
            self.quantumTaskArn = output.quantumTaskArn
            self.shots = output.shots
            self.status = output.status
            self.tags = output.tags
        } else {
            self.createdAt = nil
            self.deviceArn = nil
            self.deviceParameters = nil
            self.endedAt = nil
            self.failureReason = nil
            self.jobArn = nil
            self.outputS3Bucket = nil
            self.outputS3Directory = nil
            self.quantumTaskArn = nil
            self.shots = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetQuantumTaskOutputResponse: Swift.Equatable {
    /// The time at which the task was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The ARN of the device the task was run on.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The parameters for the device on which the task ran.
    /// This member is required.
    public var deviceParameters: Swift.String?
    /// The time at which the task ended.
    public var endedAt: ClientRuntime.Date?
    /// The reason that a task failed.
    public var failureReason: Swift.String?
    /// The ARN of the Amazon Braket job associated with the quantum task.
    public var jobArn: Swift.String?
    /// The S3 bucket where task results are stored.
    /// This member is required.
    public var outputS3Bucket: Swift.String?
    /// The folder in the S3 bucket where task results are stored.
    /// This member is required.
    public var outputS3Directory: Swift.String?
    /// The ARN of the task.
    /// This member is required.
    public var quantumTaskArn: Swift.String?
    /// The number of shots used in the task.
    /// This member is required.
    public var shots: Swift.Int?
    /// The status of the task.
    /// This member is required.
    public var status: BraketClientTypes.QuantumTaskStatus?
    /// The tags that belong to this task.
    public var tags: [Swift.String:Swift.String]?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        deviceArn: Swift.String? = nil,
        deviceParameters: Swift.String? = nil,
        endedAt: ClientRuntime.Date? = nil,
        failureReason: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        outputS3Bucket: Swift.String? = nil,
        outputS3Directory: Swift.String? = nil,
        quantumTaskArn: Swift.String? = nil,
        shots: Swift.Int? = nil,
        status: BraketClientTypes.QuantumTaskStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.createdAt = createdAt
        self.deviceArn = deviceArn
        self.deviceParameters = deviceParameters
        self.endedAt = endedAt
        self.failureReason = failureReason
        self.jobArn = jobArn
        self.outputS3Bucket = outputS3Bucket
        self.outputS3Directory = outputS3Directory
        self.quantumTaskArn = quantumTaskArn
        self.shots = shots
        self.status = status
        self.tags = tags
    }
}

struct GetQuantumTaskOutputResponseBody: Swift.Equatable {
    let quantumTaskArn: Swift.String?
    let status: BraketClientTypes.QuantumTaskStatus?
    let failureReason: Swift.String?
    let deviceArn: Swift.String?
    let deviceParameters: Swift.String?
    let shots: Swift.Int?
    let outputS3Bucket: Swift.String?
    let outputS3Directory: Swift.String?
    let createdAt: ClientRuntime.Date?
    let endedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let jobArn: Swift.String?
}

extension GetQuantumTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case deviceArn
        case deviceParameters
        case endedAt
        case failureReason
        case jobArn
        case outputS3Bucket
        case outputS3Directory
        case quantumTaskArn
        case shots
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantumTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quantumTaskArn)
        quantumTaskArn = quantumTaskArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BraketClientTypes.QuantumTaskStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceParameters)
        deviceParameters = deviceParametersDecoded
        let shotsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shots)
        shots = shotsDecoded
        let outputS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Bucket)
        outputS3Bucket = outputS3BucketDecoded
        let outputS3DirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Directory)
        outputS3Directory = outputS3DirectoryDecoded
        let createdAtDateString = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        var createdAtDecoded: ClientRuntime.Date? = nil
        if let createdAtDateString = createdAtDateString {
            let createdAtFormatter = ClientRuntime.DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            createdAtDecoded = createdAtFormatter.date(from: createdAtDateString)
        }
        createdAt = createdAtDecoded
        let endedAtDateString = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endedAt)
        var endedAtDecoded: ClientRuntime.Date? = nil
        if let endedAtDateString = endedAtDateString {
            let endedAtFormatter = ClientRuntime.DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            endedAtDecoded = endedAtFormatter.date(from: endedAtDateString)
        }
        endedAt = endedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
    }
}

extension BraketClientTypes.InputFileConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName
        case contentType
        case dataSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(BraketClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

extension BraketClientTypes {
    /// A list of parameters that specify the input channels, type of input data, and where it is located.
    public struct InputFileConfig: Swift.Equatable {
        /// A named input source that an Amazon Braket job can consume.
        /// This member is required.
        public var channelName: Swift.String?
        /// The MIME type of the data.
        public var contentType: Swift.String?
        /// The location of the channel data.
        /// This member is required.
        public var dataSource: BraketClientTypes.DataSource?

        public init (
            channelName: Swift.String? = nil,
            contentType: Swift.String? = nil,
            dataSource: BraketClientTypes.DataSource? = nil
        )
        {
            self.channelName = channelName
            self.contentType = contentType
            self.dataSource = dataSource
        }
    }

}

extension BraketClientTypes.InstanceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceType
        case volumeSizeInGb
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType.rawValue, forKey: .instanceType)
        }
        if let volumeSizeInGb = volumeSizeInGb {
            try encodeContainer.encode(volumeSizeInGb, forKey: .volumeSizeInGb)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceTypeDecoded = try containerValues.decodeIfPresent(BraketClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let volumeSizeInGbDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSizeInGb)
        volumeSizeInGb = volumeSizeInGbDecoded
    }
}

extension BraketClientTypes {
    /// Configures the resource instances to use while running the Amazon Braket hybrid job on Amazon Braket.
    public struct InstanceConfig: Swift.Equatable {
        /// Configures the type resource instances to use while running an Amazon Braket hybrid job.
        /// This member is required.
        public var instanceType: BraketClientTypes.InstanceType?
        /// The size of the storage volume, in GB, that user wants to provision.
        /// This member is required.
        public var volumeSizeInGb: Swift.Int?

        public init (
            instanceType: BraketClientTypes.InstanceType? = nil,
            volumeSizeInGb: Swift.Int? = nil
        )
        {
            self.instanceType = instanceType
            self.volumeSizeInGb = volumeSizeInGb
        }
    }

}

extension BraketClientTypes {
    public enum InstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mlC42xlarge
        case mlC44xlarge
        case mlC48xlarge
        case mlC4Xlarge
        case mlC5n18xlarge
        case mlC5n2xlarge
        case mlC5n4xlarge
        case mlC5n9xlarge
        case mlC5nXlarge
        case mlC518xlarge
        case mlC52xlarge
        case mlC54xlarge
        case mlC59xlarge
        case mlC5Xlarge
        case mlG4dn12xlarge
        case mlG4dn16xlarge
        case mlG4dn2xlarge
        case mlG4dn4xlarge
        case mlG4dn8xlarge
        case mlG4dnXlarge
        case mlM410xlarge
        case mlM416xlarge
        case mlM42xlarge
        case mlM44xlarge
        case mlM4Xlarge
        case mlM512xlarge
        case mlM524xlarge
        case mlM52xlarge
        case mlM54xlarge
        case mlM5Large
        case mlM5Xlarge
        case mlP216xlarge
        case mlP28xlarge
        case mlP2Xlarge
        case mlP3dn24xlarge
        case mlP316xlarge
        case mlP32xlarge
        case mlP38xlarge
        case mlP4d24xlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceType] {
            return [
                .mlC42xlarge,
                .mlC44xlarge,
                .mlC48xlarge,
                .mlC4Xlarge,
                .mlC5n18xlarge,
                .mlC5n2xlarge,
                .mlC5n4xlarge,
                .mlC5n9xlarge,
                .mlC5nXlarge,
                .mlC518xlarge,
                .mlC52xlarge,
                .mlC54xlarge,
                .mlC59xlarge,
                .mlC5Xlarge,
                .mlG4dn12xlarge,
                .mlG4dn16xlarge,
                .mlG4dn2xlarge,
                .mlG4dn4xlarge,
                .mlG4dn8xlarge,
                .mlG4dnXlarge,
                .mlM410xlarge,
                .mlM416xlarge,
                .mlM42xlarge,
                .mlM44xlarge,
                .mlM4Xlarge,
                .mlM512xlarge,
                .mlM524xlarge,
                .mlM52xlarge,
                .mlM54xlarge,
                .mlM5Large,
                .mlM5Xlarge,
                .mlP216xlarge,
                .mlP28xlarge,
                .mlP2Xlarge,
                .mlP3dn24xlarge,
                .mlP316xlarge,
                .mlP32xlarge,
                .mlP38xlarge,
                .mlP4d24xlarge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mlC42xlarge: return "ml.c4.2xlarge"
            case .mlC44xlarge: return "ml.c4.4xlarge"
            case .mlC48xlarge: return "ml.c4.8xlarge"
            case .mlC4Xlarge: return "ml.c4.xlarge"
            case .mlC5n18xlarge: return "ml.c5n.18xlarge"
            case .mlC5n2xlarge: return "ml.c5n.2xlarge"
            case .mlC5n4xlarge: return "ml.c5n.4xlarge"
            case .mlC5n9xlarge: return "ml.c5n.9xlarge"
            case .mlC5nXlarge: return "ml.c5n.xlarge"
            case .mlC518xlarge: return "ml.c5.18xlarge"
            case .mlC52xlarge: return "ml.c5.2xlarge"
            case .mlC54xlarge: return "ml.c5.4xlarge"
            case .mlC59xlarge: return "ml.c5.9xlarge"
            case .mlC5Xlarge: return "ml.c5.xlarge"
            case .mlG4dn12xlarge: return "ml.g4dn.12xlarge"
            case .mlG4dn16xlarge: return "ml.g4dn.16xlarge"
            case .mlG4dn2xlarge: return "ml.g4dn.2xlarge"
            case .mlG4dn4xlarge: return "ml.g4dn.4xlarge"
            case .mlG4dn8xlarge: return "ml.g4dn.8xlarge"
            case .mlG4dnXlarge: return "ml.g4dn.xlarge"
            case .mlM410xlarge: return "ml.m4.10xlarge"
            case .mlM416xlarge: return "ml.m4.16xlarge"
            case .mlM42xlarge: return "ml.m4.2xlarge"
            case .mlM44xlarge: return "ml.m4.4xlarge"
            case .mlM4Xlarge: return "ml.m4.xlarge"
            case .mlM512xlarge: return "ml.m5.12xlarge"
            case .mlM524xlarge: return "ml.m5.24xlarge"
            case .mlM52xlarge: return "ml.m5.2xlarge"
            case .mlM54xlarge: return "ml.m5.4xlarge"
            case .mlM5Large: return "ml.m5.large"
            case .mlM5Xlarge: return "ml.m5.xlarge"
            case .mlP216xlarge: return "ml.p2.16xlarge"
            case .mlP28xlarge: return "ml.p2.8xlarge"
            case .mlP2Xlarge: return "ml.p2.xlarge"
            case .mlP3dn24xlarge: return "ml.p3dn.24xlarge"
            case .mlP316xlarge: return "ml.p3.16xlarge"
            case .mlP32xlarge: return "ml.p3.2xlarge"
            case .mlP38xlarge: return "ml.p3.8xlarge"
            case .mlP4d24xlarge: return "ml.p4d.24xlarge"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceType(rawValue: rawValue) ?? InstanceType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServiceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request processing has failed because of an unknown error, exception, or failure.
public struct InternalServiceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BraketClientTypes.JobCheckpointConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case localPath
        case s3Uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let localPath = localPath {
            try encodeContainer.encode(localPath, forKey: .localPath)
        }
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localPath)
        localPath = localPathDecoded
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension BraketClientTypes {
    /// Contains information about the output locations for job checkpoint data.
    public struct JobCheckpointConfig: Swift.Equatable {
        /// (Optional) The local directory where checkpoints are written. The default directory is /opt/braket/checkpoints/.
        public var localPath: Swift.String?
        /// Identifies the S3 path where you want Amazon Braket to store checkpoints. For example, s3://bucket-name/key-name-prefix.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init (
            localPath: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.localPath = localPath
            self.s3Uri = s3Uri
        }
    }

}

extension BraketClientTypes.JobEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType
        case message
        case timeOfEvent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventType = eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let timeOfEvent = timeOfEvent {
            try encodeContainer.encode(timeOfEvent.iso8601WithoutFractionalSeconds(), forKey: .timeOfEvent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobEventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let timeOfEventDateString = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeOfEvent)
        var timeOfEventDecoded: ClientRuntime.Date? = nil
        if let timeOfEventDateString = timeOfEventDateString {
            let timeOfEventFormatter = ClientRuntime.DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            timeOfEventDecoded = timeOfEventFormatter.date(from: timeOfEventDateString)
        }
        timeOfEvent = timeOfEventDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BraketClientTypes {
    /// Details about the type and time events occurred related to the Amazon Braket job.
    public struct JobEventDetails: Swift.Equatable {
        /// The type of event that occurred related to the Amazon Braket job.
        public var eventType: BraketClientTypes.JobEventType?
        /// A message describing the event that occurred related to the Amazon Braket job.
        public var message: Swift.String?
        /// TThe type of event that occurred related to the Amazon Braket job.
        public var timeOfEvent: ClientRuntime.Date?

        public init (
            eventType: BraketClientTypes.JobEventType? = nil,
            message: Swift.String? = nil,
            timeOfEvent: ClientRuntime.Date? = nil
        )
        {
            self.eventType = eventType
            self.message = message
            self.timeOfEvent = timeOfEvent
        }
    }

}

extension BraketClientTypes {
    public enum JobEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case deprioritizedDueToInactivity
        case downloadingData
        case failed
        case maxRuntimeExceeded
        case queuedForExecution
        case running
        case startingInstance
        case uploadingResults
        case waitingForPriority
        case sdkUnknown(Swift.String)

        public static var allCases: [JobEventType] {
            return [
                .cancelled,
                .completed,
                .deprioritizedDueToInactivity,
                .downloadingData,
                .failed,
                .maxRuntimeExceeded,
                .queuedForExecution,
                .running,
                .startingInstance,
                .uploadingResults,
                .waitingForPriority,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .deprioritizedDueToInactivity: return "DEPRIORITIZED_DUE_TO_INACTIVITY"
            case .downloadingData: return "DOWNLOADING_DATA"
            case .failed: return "FAILED"
            case .maxRuntimeExceeded: return "MAX_RUNTIME_EXCEEDED"
            case .queuedForExecution: return "QUEUED_FOR_EXECUTION"
            case .running: return "RUNNING"
            case .startingInstance: return "STARTING_INSTANCE"
            case .uploadingResults: return "UPLOADING_RESULTS"
            case .waitingForPriority: return "WAITING_FOR_PRIORITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobEventType(rawValue: rawValue) ?? JobEventType.sdkUnknown(rawValue)
        }
    }
}

extension BraketClientTypes.JobOutputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId
        case s3Path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3Path = s3Path {
            try encodeContainer.encode(s3Path, forKey: .s3Path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
    }
}

extension BraketClientTypes {
    /// Specifies the path to the S3 location where you want to store job artifacts and the encryption key used to store them.
    public struct JobOutputDataConfig: Swift.Equatable {
        /// The AWS Key Management Service (AWS KMS) key that Amazon Braket uses to encrypt the job training artifacts at rest using Amazon S3 server-side encryption.
        public var kmsKeyId: Swift.String?
        /// Identifies the S3 path where you want Amazon Braket to store the job training artifacts. For example, s3://bucket-name/key-name-prefix.
        /// This member is required.
        public var s3Path: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil,
            s3Path: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.s3Path = s3Path
        }
    }

}

extension BraketClientTypes {
    public enum JobPrimaryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case failed
        case queued
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [JobPrimaryStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .failed,
                .queued,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobPrimaryStatus(rawValue: rawValue) ?? JobPrimaryStatus.sdkUnknown(rawValue)
        }
    }
}

extension BraketClientTypes.JobStoppingCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxRuntimeInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxRuntimeInSeconds = maxRuntimeInSeconds {
            try encodeContainer.encode(maxRuntimeInSeconds, forKey: .maxRuntimeInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRuntimeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRuntimeInSeconds)
        maxRuntimeInSeconds = maxRuntimeInSecondsDecoded
    }
}

extension BraketClientTypes {
    /// Specifies limits for how long an Amazon Braket job can run.
    public struct JobStoppingCondition: Swift.Equatable {
        /// The maximum length of time, in seconds, that an Amazon Braket job can run.
        public var maxRuntimeInSeconds: Swift.Int?

        public init (
            maxRuntimeInSeconds: Swift.Int? = nil
        )
        {
            self.maxRuntimeInSeconds = maxRuntimeInSeconds
        }
    }

}

extension BraketClientTypes.JobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case device
        case endedAt
        case jobArn
        case jobName
        case startedAt
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.iso8601WithoutFractionalSeconds(), forKey: .createdAt)
        }
        if let device = device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let endedAt = endedAt {
            try encodeContainer.encode(endedAt.iso8601WithoutFractionalSeconds(), forKey: .endedAt)
        }
        if let jobArn = jobArn {
            try encodeContainer.encode(jobArn, forKey: .jobArn)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.iso8601WithoutFractionalSeconds(), forKey: .startedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(BraketClientTypes.JobPrimaryStatus.self, forKey: .status)
        status = statusDecoded
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .device)
        device = deviceDecoded
        let createdAtDateString = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        var createdAtDecoded: ClientRuntime.Date? = nil
        if let createdAtDateString = createdAtDateString {
            let createdAtFormatter = ClientRuntime.DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            createdAtDecoded = createdAtFormatter.date(from: createdAtDateString)
        }
        createdAt = createdAtDecoded
        let startedAtDateString = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startedAt)
        var startedAtDecoded: ClientRuntime.Date? = nil
        if let startedAtDateString = startedAtDateString {
            let startedAtFormatter = ClientRuntime.DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            startedAtDecoded = startedAtFormatter.date(from: startedAtDateString)
        }
        startedAt = startedAtDecoded
        let endedAtDateString = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endedAt)
        var endedAtDecoded: ClientRuntime.Date? = nil
        if let endedAtDateString = endedAtDateString {
            let endedAtFormatter = ClientRuntime.DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            endedAtDecoded = endedAtFormatter.date(from: endedAtDateString)
        }
        endedAt = endedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension BraketClientTypes {
    /// Provides summary information about an Amazon Braket job.
    public struct JobSummary: Swift.Equatable {
        /// The date and time that the Amazon Braket job was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Provides summary information about the primary device used by an Amazon Braket job.
        /// This member is required.
        public var device: Swift.String?
        /// The date and time that the Amazon Braket job ended.
        public var endedAt: ClientRuntime.Date?
        /// The ARN of the Amazon Braket job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The name of the Amazon Braket job.
        /// This member is required.
        public var jobName: Swift.String?
        /// The date and time that the Amazon Braket job was started.
        public var startedAt: ClientRuntime.Date?
        /// The status of the Amazon Braket job.
        /// This member is required.
        public var status: BraketClientTypes.JobPrimaryStatus?
        /// A tag object that consists of a key and an optional value, used to manage metadata for Amazon Braket resources.
        public var tags: [Swift.String:Swift.String]?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            device: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            jobArn: Swift.String? = nil,
            jobName: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            status: BraketClientTypes.JobPrimaryStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.createdAt = createdAt
            self.device = device
            self.endedAt = endedAt
            self.jobArn = jobArn
            self.jobName = jobName
            self.startedAt = startedAt
            self.status = status
            self.tags = tags
        }
    }

}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// Specify the resourceArn for the resource whose tags to display.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Displays the key, value pairs of tags associated with this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension BraketClientTypes {
    public enum QuantumTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case created
        case failed
        case queued
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [QuantumTaskStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .created,
                .failed,
                .queued,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuantumTaskStatus(rawValue: rawValue) ?? QuantumTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension BraketClientTypes.QuantumTaskSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case deviceArn
        case endedAt
        case outputS3Bucket
        case outputS3Directory
        case quantumTaskArn
        case shots
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.iso8601WithoutFractionalSeconds(), forKey: .createdAt)
        }
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let endedAt = endedAt {
            try encodeContainer.encode(endedAt.iso8601WithoutFractionalSeconds(), forKey: .endedAt)
        }
        if let outputS3Bucket = outputS3Bucket {
            try encodeContainer.encode(outputS3Bucket, forKey: .outputS3Bucket)
        }
        if let outputS3Directory = outputS3Directory {
            try encodeContainer.encode(outputS3Directory, forKey: .outputS3Directory)
        }
        if let quantumTaskArn = quantumTaskArn {
            try encodeContainer.encode(quantumTaskArn, forKey: .quantumTaskArn)
        }
        if let shots = shots {
            try encodeContainer.encode(shots, forKey: .shots)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantumTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quantumTaskArn)
        quantumTaskArn = quantumTaskArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BraketClientTypes.QuantumTaskStatus.self, forKey: .status)
        status = statusDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let shotsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shots)
        shots = shotsDecoded
        let outputS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Bucket)
        outputS3Bucket = outputS3BucketDecoded
        let outputS3DirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Directory)
        outputS3Directory = outputS3DirectoryDecoded
        let createdAtDateString = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        var createdAtDecoded: ClientRuntime.Date? = nil
        if let createdAtDateString = createdAtDateString {
            let createdAtFormatter = ClientRuntime.DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            createdAtDecoded = createdAtFormatter.date(from: createdAtDateString)
        }
        createdAt = createdAtDecoded
        let endedAtDateString = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endedAt)
        var endedAtDecoded: ClientRuntime.Date? = nil
        if let endedAtDateString = endedAtDateString {
            let endedAtFormatter = ClientRuntime.DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            endedAtDecoded = endedAtFormatter.date(from: endedAtDateString)
        }
        endedAt = endedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension BraketClientTypes {
    /// Includes information about a quantum task.
    public struct QuantumTaskSummary: Swift.Equatable {
        /// The time at which the task was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The ARN of the device the task ran on.
        /// This member is required.
        public var deviceArn: Swift.String?
        /// The time at which the task finished.
        public var endedAt: ClientRuntime.Date?
        /// The S3 bucket where the task result file is stored..
        /// This member is required.
        public var outputS3Bucket: Swift.String?
        /// The folder in the S3 bucket where the task result file is stored.
        /// This member is required.
        public var outputS3Directory: Swift.String?
        /// The ARN of the task.
        /// This member is required.
        public var quantumTaskArn: Swift.String?
        /// The shots used for the task.
        /// This member is required.
        public var shots: Swift.Int?
        /// The status of the task.
        /// This member is required.
        public var status: BraketClientTypes.QuantumTaskStatus?
        /// Displays the key, value pairs of tags associated with this quantum task.
        public var tags: [Swift.String:Swift.String]?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            deviceArn: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            outputS3Bucket: Swift.String? = nil,
            outputS3Directory: Swift.String? = nil,
            quantumTaskArn: Swift.String? = nil,
            shots: Swift.Int? = nil,
            status: BraketClientTypes.QuantumTaskStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.createdAt = createdAt
            self.deviceArn = deviceArn
            self.endedAt = endedAt
            self.outputS3Bucket = outputS3Bucket
            self.outputS3Directory = outputS3Directory
            self.quantumTaskArn = quantumTaskArn
            self.shots = shots
            self.status = status
            self.tags = tags
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BraketClientTypes.S3DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension BraketClientTypes {
    /// Information about the data stored in Amazon S3 used by the Amazon Braket job.
    public struct S3DataSource: Swift.Equatable {
        /// Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest that locates the S3 data source.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init (
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension BraketClientTypes.ScriptModeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compressionType
        case entryPoint
        case s3Uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compressionType = compressionType {
            try encodeContainer.encode(compressionType.rawValue, forKey: .compressionType)
        }
        if let entryPoint = entryPoint {
            try encodeContainer.encode(entryPoint, forKey: .entryPoint)
        }
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryPoint)
        entryPoint = entryPointDecoded
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let compressionTypeDecoded = try containerValues.decodeIfPresent(BraketClientTypes.CompressionType.self, forKey: .compressionType)
        compressionType = compressionTypeDecoded
    }
}

extension BraketClientTypes {
    /// Contains information about the Python scripts used for entry and by an Amazon Braket job.
    public struct ScriptModeConfig: Swift.Equatable {
        /// The type of compression used by the Python scripts for an Amazon Braket job.
        public var compressionType: BraketClientTypes.CompressionType?
        /// The path to the Python script that serves as the entry point for an Amazon Braket job.
        /// This member is required.
        public var entryPoint: Swift.String?
        /// The URI that specifies the S3 path to the Python script module that contains the training script used by an Amazon Braket job.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init (
            compressionType: BraketClientTypes.CompressionType? = nil,
            entryPoint: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.compressionType = compressionType
            self.entryPoint = entryPoint
            self.s3Uri = s3Uri
        }
    }

}

extension BraketClientTypes.SearchDevicesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string256list0 in values {
                try valuesContainer.encode(string256list0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension BraketClientTypes {
    /// The filter to use for searching devices.
    public struct SearchDevicesFilter: Swift.Equatable {
        /// The name to use to filter results.
        /// This member is required.
        public var name: Swift.String?
        /// The values to use to filter results.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension SearchDevicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for searchdevicesfilterlist0 in filters {
                try filtersContainer.encode(searchdevicesfilterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/devices"
    }
}

public struct SearchDevicesInput: Swift.Equatable {
    /// The filter values to use to search for a device.
    /// This member is required.
    public var filters: [BraketClientTypes.SearchDevicesFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned in the response. Use the token returned from the previous request continue results where the previous request ended.
    public var nextToken: Swift.String?

    public init (
        filters: [BraketClientTypes.SearchDevicesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchDevicesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [BraketClientTypes.SearchDevicesFilter]?
}

extension SearchDevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([BraketClientTypes.SearchDevicesFilter?].self, forKey: .filters)
        var filtersDecoded0:[BraketClientTypes.SearchDevicesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [BraketClientTypes.SearchDevicesFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension SearchDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchDevicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

public struct SearchDevicesOutputResponse: Swift.Equatable {
    /// An array of DeviceSummary objects for devices that match the specified filter values.
    /// This member is required.
    public var devices: [BraketClientTypes.DeviceSummary]?
    /// A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue results where the previous request ended.
    public var nextToken: Swift.String?

    public init (
        devices: [BraketClientTypes.DeviceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct SearchDevicesOutputResponseBody: Swift.Equatable {
    let devices: [BraketClientTypes.DeviceSummary]?
    let nextToken: Swift.String?
}

extension SearchDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([BraketClientTypes.DeviceSummary?].self, forKey: .devices)
        var devicesDecoded0:[BraketClientTypes.DeviceSummary]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [BraketClientTypes.DeviceSummary]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BraketClientTypes.SearchJobsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string256list0 in values {
                try valuesContainer.encode(string256list0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(BraketClientTypes.SearchJobsFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension BraketClientTypes {
    /// A filter used to search for Amazon Braket jobs.
    public struct SearchJobsFilter: Swift.Equatable {
        /// The name to use for the jobs filter.
        /// This member is required.
        public var name: Swift.String?
        /// An operator to use for the jobs filter.
        /// This member is required.
        public var `operator`: BraketClientTypes.SearchJobsFilterOperator?
        /// The values to use for the jobs filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            `operator`: BraketClientTypes.SearchJobsFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension BraketClientTypes {
    public enum SearchJobsFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case contains
        case equal
        case gt
        case gte
        case lt
        case lte
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchJobsFilterOperator] {
            return [
                .between,
                .contains,
                .equal,
                .gt,
                .gte,
                .lt,
                .lte,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .equal: return "EQUAL"
            case .gt: return "GT"
            case .gte: return "GTE"
            case .lt: return "LT"
            case .lte: return "LTE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SearchJobsFilterOperator(rawValue: rawValue) ?? SearchJobsFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension SearchJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for searchjobsfilterlist0 in filters {
                try filtersContainer.encode(searchjobsfilterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/jobs"
    }
}

public struct SearchJobsInput: Swift.Equatable {
    /// The filter values to use when searching for a job.
    /// This member is required.
    public var filters: [BraketClientTypes.SearchJobsFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned in the response. Use the token returned from the previous request to continue results where the previous request ended.
    public var nextToken: Swift.String?

    public init (
        filters: [BraketClientTypes.SearchJobsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [BraketClientTypes.SearchJobsFilter]?
}

extension SearchJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([BraketClientTypes.SearchJobsFilter?].self, forKey: .filters)
        var filtersDecoded0:[BraketClientTypes.SearchJobsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [BraketClientTypes.SearchJobsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension SearchJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct SearchJobsOutputResponse: Swift.Equatable {
    /// An array of JobSummary objects for devices that match the specified filter values.
    /// This member is required.
    public var jobs: [BraketClientTypes.JobSummary]?
    /// A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue results where the previous request ended.
    public var nextToken: Swift.String?

    public init (
        jobs: [BraketClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct SearchJobsOutputResponseBody: Swift.Equatable {
    let jobs: [BraketClientTypes.JobSummary]?
    let nextToken: Swift.String?
}

extension SearchJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([BraketClientTypes.JobSummary?].self, forKey: .jobs)
        var jobsDecoded0:[BraketClientTypes.JobSummary]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [BraketClientTypes.JobSummary]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BraketClientTypes.SearchQuantumTasksFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string256list0 in values {
                try valuesContainer.encode(string256list0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(BraketClientTypes.SearchQuantumTasksFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension BraketClientTypes {
    /// A filter to use to search for tasks.
    public struct SearchQuantumTasksFilter: Swift.Equatable {
        /// The name of the device used for the task.
        /// This member is required.
        public var name: Swift.String?
        /// An operator to use in the filter.
        /// This member is required.
        public var `operator`: BraketClientTypes.SearchQuantumTasksFilterOperator?
        /// The values to use for the filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            `operator`: BraketClientTypes.SearchQuantumTasksFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension BraketClientTypes {
    public enum SearchQuantumTasksFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case equal
        case gt
        case gte
        case lt
        case lte
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchQuantumTasksFilterOperator] {
            return [
                .between,
                .equal,
                .gt,
                .gte,
                .lt,
                .lte,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .equal: return "EQUAL"
            case .gt: return "GT"
            case .gte: return "GTE"
            case .lt: return "LT"
            case .lte: return "LTE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SearchQuantumTasksFilterOperator(rawValue: rawValue) ?? SearchQuantumTasksFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension SearchQuantumTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for searchquantumtasksfilterlist0 in filters {
                try filtersContainer.encode(searchquantumtasksfilterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchQuantumTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/quantum-tasks"
    }
}

public struct SearchQuantumTasksInput: Swift.Equatable {
    /// Array of SearchQuantumTasksFilter objects.
    /// This member is required.
    public var filters: [BraketClientTypes.SearchQuantumTasksFilter]?
    /// Maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned in the response. Use the token returned from the previous request continue results where the previous request ended.
    public var nextToken: Swift.String?

    public init (
        filters: [BraketClientTypes.SearchQuantumTasksFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchQuantumTasksInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [BraketClientTypes.SearchQuantumTasksFilter]?
}

extension SearchQuantumTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([BraketClientTypes.SearchQuantumTasksFilter?].self, forKey: .filters)
        var filtersDecoded0:[BraketClientTypes.SearchQuantumTasksFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [BraketClientTypes.SearchQuantumTasksFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension SearchQuantumTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchQuantumTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchQuantumTasksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchQuantumTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchQuantumTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.quantumTasks = output.quantumTasks
        } else {
            self.nextToken = nil
            self.quantumTasks = nil
        }
    }
}

public struct SearchQuantumTasksOutputResponse: Swift.Equatable {
    /// A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue results where the previous request ended.
    public var nextToken: Swift.String?
    /// An array of QuantumTaskSummary objects for tasks that match the specified filters.
    /// This member is required.
    public var quantumTasks: [BraketClientTypes.QuantumTaskSummary]?

    public init (
        nextToken: Swift.String? = nil,
        quantumTasks: [BraketClientTypes.QuantumTaskSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.quantumTasks = quantumTasks
    }
}

struct SearchQuantumTasksOutputResponseBody: Swift.Equatable {
    let quantumTasks: [BraketClientTypes.QuantumTaskSummary]?
    let nextToken: Swift.String?
}

extension SearchQuantumTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case quantumTasks
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantumTasksContainer = try containerValues.decodeIfPresent([BraketClientTypes.QuantumTaskSummary?].self, forKey: .quantumTasks)
        var quantumTasksDecoded0:[BraketClientTypes.QuantumTaskSummary]? = nil
        if let quantumTasksContainer = quantumTasksContainer {
            quantumTasksDecoded0 = [BraketClientTypes.QuantumTaskSummary]()
            for structure0 in quantumTasksContainer {
                if let structure0 = structure0 {
                    quantumTasksDecoded0?.append(structure0)
                }
            }
        }
        quantumTasks = quantumTasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed because a service quota is exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Specify the resourceArn of the resource to which a tag will be added.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Specify the tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The throttling rate limit is met.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Specify the resourceArn for the resource from which to remove the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Specify the keys for the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
