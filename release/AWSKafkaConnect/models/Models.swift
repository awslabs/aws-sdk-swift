// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension KafkaConnectClientTypes.ApacheKafkaCluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bootstrapServers
        case vpc
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bootstrapServers = bootstrapServers {
            try encodeContainer.encode(bootstrapServers, forKey: .bootstrapServers)
        }
        if let vpc = vpc {
            try encodeContainer.encode(vpc, forKey: .vpc)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bootstrapServersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapServers)
        bootstrapServers = bootstrapServersDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.Vpc.self, forKey: .vpc)
        vpc = vpcDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The details of the Apache Kafka cluster to which the connector is connected.
    public struct ApacheKafkaCluster: Swift.Equatable {
        /// The bootstrap servers of the cluster.
        /// This member is required.
        public var bootstrapServers: Swift.String?
        /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        /// This member is required.
        public var vpc: KafkaConnectClientTypes.Vpc?

        public init (
            bootstrapServers: Swift.String? = nil,
            vpc: KafkaConnectClientTypes.Vpc? = nil
        )
        {
            self.bootstrapServers = bootstrapServers
            self.vpc = vpc
        }
    }

}

extension KafkaConnectClientTypes.ApacheKafkaClusterDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bootstrapServers
        case vpc
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bootstrapServers = bootstrapServers {
            try encodeContainer.encode(bootstrapServers, forKey: .bootstrapServers)
        }
        if let vpc = vpc {
            try encodeContainer.encode(vpc, forKey: .vpc)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bootstrapServersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapServers)
        bootstrapServers = bootstrapServersDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.VpcDescription.self, forKey: .vpc)
        vpc = vpcDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The description of the Apache Kafka cluster to which the connector is connected.
    public struct ApacheKafkaClusterDescription: Swift.Equatable {
        /// The bootstrap servers of the cluster.
        public var bootstrapServers: Swift.String?
        /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        public var vpc: KafkaConnectClientTypes.VpcDescription?

        public init (
            bootstrapServers: Swift.String? = nil,
            vpc: KafkaConnectClientTypes.VpcDescription? = nil
        )
        {
            self.bootstrapServers = bootstrapServers
            self.vpc = vpc
        }
    }

}

extension KafkaConnectClientTypes.AutoScaling: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxWorkerCount
        case mcuCount
        case minWorkerCount
        case scaleInPolicy
        case scaleOutPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxWorkerCount != 0 {
            try encodeContainer.encode(maxWorkerCount, forKey: .maxWorkerCount)
        }
        if mcuCount != 0 {
            try encodeContainer.encode(mcuCount, forKey: .mcuCount)
        }
        if minWorkerCount != 0 {
            try encodeContainer.encode(minWorkerCount, forKey: .minWorkerCount)
        }
        if let scaleInPolicy = scaleInPolicy {
            try encodeContainer.encode(scaleInPolicy, forKey: .scaleInPolicy)
        }
        if let scaleOutPolicy = scaleOutPolicy {
            try encodeContainer.encode(scaleOutPolicy, forKey: .scaleOutPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxWorkerCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxWorkerCount)
        maxWorkerCount = maxWorkerCountDecoded
        let mcuCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .mcuCount)
        mcuCount = mcuCountDecoded
        let minWorkerCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .minWorkerCount)
        minWorkerCount = minWorkerCountDecoded
        let scaleInPolicyDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.ScaleInPolicy.self, forKey: .scaleInPolicy)
        scaleInPolicy = scaleInPolicyDecoded
        let scaleOutPolicyDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.ScaleOutPolicy.self, forKey: .scaleOutPolicy)
        scaleOutPolicy = scaleOutPolicyDecoded
    }
}

extension KafkaConnectClientTypes {
    /// Specifies how the connector scales.
    public struct AutoScaling: Swift.Equatable {
        /// The maximum number of workers allocated to the connector.
        /// This member is required.
        public var maxWorkerCount: Swift.Int
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        /// This member is required.
        public var mcuCount: Swift.Int
        /// The minimum number of workers allocated to the connector.
        /// This member is required.
        public var minWorkerCount: Swift.Int
        /// The sacle-in policy for the connector.
        public var scaleInPolicy: KafkaConnectClientTypes.ScaleInPolicy?
        /// The sacle-out policy for the connector.
        public var scaleOutPolicy: KafkaConnectClientTypes.ScaleOutPolicy?

        public init (
            maxWorkerCount: Swift.Int = 0,
            mcuCount: Swift.Int = 0,
            minWorkerCount: Swift.Int = 0,
            scaleInPolicy: KafkaConnectClientTypes.ScaleInPolicy? = nil,
            scaleOutPolicy: KafkaConnectClientTypes.ScaleOutPolicy? = nil
        )
        {
            self.maxWorkerCount = maxWorkerCount
            self.mcuCount = mcuCount
            self.minWorkerCount = minWorkerCount
            self.scaleInPolicy = scaleInPolicy
            self.scaleOutPolicy = scaleOutPolicy
        }
    }

}

extension KafkaConnectClientTypes.AutoScalingDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxWorkerCount
        case mcuCount
        case minWorkerCount
        case scaleInPolicy
        case scaleOutPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxWorkerCount != 0 {
            try encodeContainer.encode(maxWorkerCount, forKey: .maxWorkerCount)
        }
        if mcuCount != 0 {
            try encodeContainer.encode(mcuCount, forKey: .mcuCount)
        }
        if minWorkerCount != 0 {
            try encodeContainer.encode(minWorkerCount, forKey: .minWorkerCount)
        }
        if let scaleInPolicy = scaleInPolicy {
            try encodeContainer.encode(scaleInPolicy, forKey: .scaleInPolicy)
        }
        if let scaleOutPolicy = scaleOutPolicy {
            try encodeContainer.encode(scaleOutPolicy, forKey: .scaleOutPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxWorkerCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxWorkerCount)
        maxWorkerCount = maxWorkerCountDecoded
        let mcuCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .mcuCount)
        mcuCount = mcuCountDecoded
        let minWorkerCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .minWorkerCount)
        minWorkerCount = minWorkerCountDecoded
        let scaleInPolicyDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.ScaleInPolicyDescription.self, forKey: .scaleInPolicy)
        scaleInPolicy = scaleInPolicyDecoded
        let scaleOutPolicyDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.ScaleOutPolicyDescription.self, forKey: .scaleOutPolicy)
        scaleOutPolicy = scaleOutPolicyDecoded
    }
}

extension KafkaConnectClientTypes {
    /// Information about the auto scaling parameters for the connector.
    public struct AutoScalingDescription: Swift.Equatable {
        /// The maximum number of workers allocated to the connector.
        public var maxWorkerCount: Swift.Int
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        public var mcuCount: Swift.Int
        /// The minimum number of workers allocated to the connector.
        public var minWorkerCount: Swift.Int
        /// The sacle-in policy for the connector.
        public var scaleInPolicy: KafkaConnectClientTypes.ScaleInPolicyDescription?
        /// The sacle-out policy for the connector.>
        public var scaleOutPolicy: KafkaConnectClientTypes.ScaleOutPolicyDescription?

        public init (
            maxWorkerCount: Swift.Int = 0,
            mcuCount: Swift.Int = 0,
            minWorkerCount: Swift.Int = 0,
            scaleInPolicy: KafkaConnectClientTypes.ScaleInPolicyDescription? = nil,
            scaleOutPolicy: KafkaConnectClientTypes.ScaleOutPolicyDescription? = nil
        )
        {
            self.maxWorkerCount = maxWorkerCount
            self.mcuCount = mcuCount
            self.minWorkerCount = minWorkerCount
            self.scaleInPolicy = scaleInPolicy
            self.scaleOutPolicy = scaleOutPolicy
        }
    }

}

extension KafkaConnectClientTypes.AutoScalingUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxWorkerCount
        case mcuCount
        case minWorkerCount
        case scaleInPolicy
        case scaleOutPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxWorkerCount != 0 {
            try encodeContainer.encode(maxWorkerCount, forKey: .maxWorkerCount)
        }
        if mcuCount != 0 {
            try encodeContainer.encode(mcuCount, forKey: .mcuCount)
        }
        if minWorkerCount != 0 {
            try encodeContainer.encode(minWorkerCount, forKey: .minWorkerCount)
        }
        if let scaleInPolicy = scaleInPolicy {
            try encodeContainer.encode(scaleInPolicy, forKey: .scaleInPolicy)
        }
        if let scaleOutPolicy = scaleOutPolicy {
            try encodeContainer.encode(scaleOutPolicy, forKey: .scaleOutPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxWorkerCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxWorkerCount)
        maxWorkerCount = maxWorkerCountDecoded
        let mcuCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .mcuCount)
        mcuCount = mcuCountDecoded
        let minWorkerCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .minWorkerCount)
        minWorkerCount = minWorkerCountDecoded
        let scaleInPolicyDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.ScaleInPolicyUpdate.self, forKey: .scaleInPolicy)
        scaleInPolicy = scaleInPolicyDecoded
        let scaleOutPolicyDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.ScaleOutPolicyUpdate.self, forKey: .scaleOutPolicy)
        scaleOutPolicy = scaleOutPolicyDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The updates to the auto scaling parameters for the connector.
    public struct AutoScalingUpdate: Swift.Equatable {
        /// The target maximum number of workers allocated to the connector.
        /// This member is required.
        public var maxWorkerCount: Swift.Int
        /// The target number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        /// This member is required.
        public var mcuCount: Swift.Int
        /// The target minimum number of workers allocated to the connector.
        /// This member is required.
        public var minWorkerCount: Swift.Int
        /// The target sacle-in policy for the connector.
        /// This member is required.
        public var scaleInPolicy: KafkaConnectClientTypes.ScaleInPolicyUpdate?
        /// The target sacle-out policy for the connector.
        /// This member is required.
        public var scaleOutPolicy: KafkaConnectClientTypes.ScaleOutPolicyUpdate?

        public init (
            maxWorkerCount: Swift.Int = 0,
            mcuCount: Swift.Int = 0,
            minWorkerCount: Swift.Int = 0,
            scaleInPolicy: KafkaConnectClientTypes.ScaleInPolicyUpdate? = nil,
            scaleOutPolicy: KafkaConnectClientTypes.ScaleOutPolicyUpdate? = nil
        )
        {
            self.maxWorkerCount = maxWorkerCount
            self.mcuCount = mcuCount
            self.minWorkerCount = minWorkerCount
            self.scaleInPolicy = scaleInPolicy
            self.scaleOutPolicy = scaleOutPolicy
        }
    }

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// HTTP Status Code 400: Bad request due to incorrect input. Correct your request and then retry it.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaConnectClientTypes.Capacity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScaling
        case provisionedCapacity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScaling = autoScaling {
            try encodeContainer.encode(autoScaling, forKey: .autoScaling)
        }
        if let provisionedCapacity = provisionedCapacity {
            try encodeContainer.encode(provisionedCapacity, forKey: .provisionedCapacity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.AutoScaling.self, forKey: .autoScaling)
        autoScaling = autoScalingDecoded
        let provisionedCapacityDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.ProvisionedCapacity.self, forKey: .provisionedCapacity)
        provisionedCapacity = provisionedCapacityDecoded
    }
}

extension KafkaConnectClientTypes {
    /// Information about the capacity of the connector, whether it is auto scaled or provisioned.
    public struct Capacity: Swift.Equatable {
        /// Information about the auto scaling parameters for the connector.
        public var autoScaling: KafkaConnectClientTypes.AutoScaling?
        /// Details about a fixed capacity allocated to a connector.
        public var provisionedCapacity: KafkaConnectClientTypes.ProvisionedCapacity?

        public init (
            autoScaling: KafkaConnectClientTypes.AutoScaling? = nil,
            provisionedCapacity: KafkaConnectClientTypes.ProvisionedCapacity? = nil
        )
        {
            self.autoScaling = autoScaling
            self.provisionedCapacity = provisionedCapacity
        }
    }

}

extension KafkaConnectClientTypes.CapacityDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScaling
        case provisionedCapacity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScaling = autoScaling {
            try encodeContainer.encode(autoScaling, forKey: .autoScaling)
        }
        if let provisionedCapacity = provisionedCapacity {
            try encodeContainer.encode(provisionedCapacity, forKey: .provisionedCapacity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.AutoScalingDescription.self, forKey: .autoScaling)
        autoScaling = autoScalingDecoded
        let provisionedCapacityDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.ProvisionedCapacityDescription.self, forKey: .provisionedCapacity)
        provisionedCapacity = provisionedCapacityDecoded
    }
}

extension KafkaConnectClientTypes {
    /// A description of the connector's capacity.
    public struct CapacityDescription: Swift.Equatable {
        /// Describes the connector's auto scaling capacity.
        public var autoScaling: KafkaConnectClientTypes.AutoScalingDescription?
        /// Describes a connector's provisioned capacity.
        public var provisionedCapacity: KafkaConnectClientTypes.ProvisionedCapacityDescription?

        public init (
            autoScaling: KafkaConnectClientTypes.AutoScalingDescription? = nil,
            provisionedCapacity: KafkaConnectClientTypes.ProvisionedCapacityDescription? = nil
        )
        {
            self.autoScaling = autoScaling
            self.provisionedCapacity = provisionedCapacity
        }
    }

}

extension KafkaConnectClientTypes.CapacityUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScaling
        case provisionedCapacity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScaling = autoScaling {
            try encodeContainer.encode(autoScaling, forKey: .autoScaling)
        }
        if let provisionedCapacity = provisionedCapacity {
            try encodeContainer.encode(provisionedCapacity, forKey: .provisionedCapacity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.AutoScalingUpdate.self, forKey: .autoScaling)
        autoScaling = autoScalingDecoded
        let provisionedCapacityDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.ProvisionedCapacityUpdate.self, forKey: .provisionedCapacity)
        provisionedCapacity = provisionedCapacityDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The target capacity for the connector. The capacity can be auto scaled or provisioned.
    public struct CapacityUpdate: Swift.Equatable {
        /// The target auto scaling setting.
        public var autoScaling: KafkaConnectClientTypes.AutoScalingUpdate?
        /// The target settings for provisioned capacity.
        public var provisionedCapacity: KafkaConnectClientTypes.ProvisionedCapacityUpdate?

        public init (
            autoScaling: KafkaConnectClientTypes.AutoScalingUpdate? = nil,
            provisionedCapacity: KafkaConnectClientTypes.ProvisionedCapacityUpdate? = nil
        )
        {
            self.autoScaling = autoScaling
            self.provisionedCapacity = provisionedCapacity
        }
    }

}

extension KafkaConnectClientTypes.CloudWatchLogsLogDelivery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case logGroup
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let logGroup = logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let logGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The settings for delivering connector logs to Amazon CloudWatch Logs.
    public struct CloudWatchLogsLogDelivery: Swift.Equatable {
        /// Whether log delivery to Amazon CloudWatch Logs is enabled.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The name of the CloudWatch log group that is the destination for log delivery.
        public var logGroup: Swift.String?

        public init (
            enabled: Swift.Bool = false,
            logGroup: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.logGroup = logGroup
        }
    }

}

extension KafkaConnectClientTypes.CloudWatchLogsLogDeliveryDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case logGroup
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let logGroup = logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let logGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
    }
}

extension KafkaConnectClientTypes {
    /// A description of the log delivery settings.
    public struct CloudWatchLogsLogDeliveryDescription: Swift.Equatable {
        /// Whether log delivery to Amazon CloudWatch Logs is enabled.
        public var enabled: Swift.Bool
        /// The name of the CloudWatch log group that is the destination for log delivery.
        public var logGroup: Swift.String?

        public init (
            enabled: Swift.Bool = false,
            logGroup: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.logGroup = logGroup
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// HTTP Status Code 409: Conflict. A resource with this name already exists. Retry your request with another name.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaConnectClientTypes {
    public enum ConnectorState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case running
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectorState] {
            return [
                .creating,
                .deleting,
                .failed,
                .running,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectorState(rawValue: rawValue) ?? ConnectorState.sdkUnknown(rawValue)
        }
    }
}

extension KafkaConnectClientTypes.ConnectorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacity
        case connectorArn
        case connectorDescription
        case connectorName
        case connectorState
        case creationTime
        case currentVersion
        case kafkaCluster
        case kafkaClusterClientAuthentication
        case kafkaClusterEncryptionInTransit
        case kafkaConnectVersion
        case logDelivery
        case plugins
        case serviceExecutionRoleArn
        case workerConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacity = capacity {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
        if let connectorArn = connectorArn {
            try encodeContainer.encode(connectorArn, forKey: .connectorArn)
        }
        if let connectorDescription = connectorDescription {
            try encodeContainer.encode(connectorDescription, forKey: .connectorDescription)
        }
        if let connectorName = connectorName {
            try encodeContainer.encode(connectorName, forKey: .connectorName)
        }
        if let connectorState = connectorState {
            try encodeContainer.encode(connectorState.rawValue, forKey: .connectorState)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let kafkaCluster = kafkaCluster {
            try encodeContainer.encode(kafkaCluster, forKey: .kafkaCluster)
        }
        if let kafkaClusterClientAuthentication = kafkaClusterClientAuthentication {
            try encodeContainer.encode(kafkaClusterClientAuthentication, forKey: .kafkaClusterClientAuthentication)
        }
        if let kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransit {
            try encodeContainer.encode(kafkaClusterEncryptionInTransit, forKey: .kafkaClusterEncryptionInTransit)
        }
        if let kafkaConnectVersion = kafkaConnectVersion {
            try encodeContainer.encode(kafkaConnectVersion, forKey: .kafkaConnectVersion)
        }
        if let logDelivery = logDelivery {
            try encodeContainer.encode(logDelivery, forKey: .logDelivery)
        }
        if let plugins = plugins {
            var pluginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .plugins)
            for __listofplugindescription0 in plugins {
                try pluginsContainer.encode(__listofplugindescription0)
            }
        }
        if let serviceExecutionRoleArn = serviceExecutionRoleArn {
            try encodeContainer.encode(serviceExecutionRoleArn, forKey: .serviceExecutionRoleArn)
        }
        if let workerConfiguration = workerConfiguration {
            try encodeContainer.encode(workerConfiguration, forKey: .workerConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CapacityDescription.self, forKey: .capacity)
        capacity = capacityDecoded
        let connectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorArn)
        connectorArn = connectorArnDecoded
        let connectorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorDescription)
        connectorDescription = connectorDescriptionDecoded
        let connectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorName)
        connectorName = connectorNameDecoded
        let connectorStateDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.ConnectorState.self, forKey: .connectorState)
        connectorState = connectorStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let kafkaClusterDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.KafkaClusterDescription.self, forKey: .kafkaCluster)
        kafkaCluster = kafkaClusterDecoded
        let kafkaClusterClientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription.self, forKey: .kafkaClusterClientAuthentication)
        kafkaClusterClientAuthentication = kafkaClusterClientAuthenticationDecoded
        let kafkaClusterEncryptionInTransitDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription.self, forKey: .kafkaClusterEncryptionInTransit)
        kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransitDecoded
        let kafkaConnectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kafkaConnectVersion)
        kafkaConnectVersion = kafkaConnectVersionDecoded
        let logDeliveryDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.LogDeliveryDescription.self, forKey: .logDelivery)
        logDelivery = logDeliveryDecoded
        let pluginsContainer = try containerValues.decodeIfPresent([KafkaConnectClientTypes.PluginDescription?].self, forKey: .plugins)
        var pluginsDecoded0:[KafkaConnectClientTypes.PluginDescription]? = nil
        if let pluginsContainer = pluginsContainer {
            pluginsDecoded0 = [KafkaConnectClientTypes.PluginDescription]()
            for structure0 in pluginsContainer {
                if let structure0 = structure0 {
                    pluginsDecoded0?.append(structure0)
                }
            }
        }
        plugins = pluginsDecoded0
        let serviceExecutionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceExecutionRoleArn)
        serviceExecutionRoleArn = serviceExecutionRoleArnDecoded
        let workerConfigurationDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.WorkerConfigurationDescription.self, forKey: .workerConfiguration)
        workerConfiguration = workerConfigurationDecoded
    }
}

extension KafkaConnectClientTypes {
    /// Summary of a connector.
    public struct ConnectorSummary: Swift.Equatable {
        /// The connector's compute capacity settings.
        public var capacity: KafkaConnectClientTypes.CapacityDescription?
        /// The Amazon Resource Name (ARN) of the connector.
        public var connectorArn: Swift.String?
        /// The description of the connector.
        public var connectorDescription: Swift.String?
        /// The name of the connector.
        public var connectorName: Swift.String?
        /// The state of the connector.
        public var connectorState: KafkaConnectClientTypes.ConnectorState?
        /// The time that the connector was created.
        public var creationTime: ClientRuntime.Date?
        /// The current version of the connector.
        public var currentVersion: Swift.String?
        /// The details of the Apache Kafka cluster to which the connector is connected.
        public var kafkaCluster: KafkaConnectClientTypes.KafkaClusterDescription?
        /// The type of client authentication used to connect to the Apache Kafka cluster. The value is NONE when no client authentication is used.
        public var kafkaClusterClientAuthentication: KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription?
        /// Details of encryption in transit to the Apache Kafka cluster.
        public var kafkaClusterEncryptionInTransit: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription?
        /// The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins.
        public var kafkaConnectVersion: Swift.String?
        /// The settings for delivering connector logs to Amazon CloudWatch Logs.
        public var logDelivery: KafkaConnectClientTypes.LogDeliveryDescription?
        /// Specifies which plugins were used for this connector.
        public var plugins: [KafkaConnectClientTypes.PluginDescription]?
        /// The Amazon Resource Name (ARN) of the IAM role used by the connector to access Amazon Web Services resources.
        public var serviceExecutionRoleArn: Swift.String?
        /// The worker configurations that are in use with the connector.
        public var workerConfiguration: KafkaConnectClientTypes.WorkerConfigurationDescription?

        public init (
            capacity: KafkaConnectClientTypes.CapacityDescription? = nil,
            connectorArn: Swift.String? = nil,
            connectorDescription: Swift.String? = nil,
            connectorName: Swift.String? = nil,
            connectorState: KafkaConnectClientTypes.ConnectorState? = nil,
            creationTime: ClientRuntime.Date? = nil,
            currentVersion: Swift.String? = nil,
            kafkaCluster: KafkaConnectClientTypes.KafkaClusterDescription? = nil,
            kafkaClusterClientAuthentication: KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription? = nil,
            kafkaClusterEncryptionInTransit: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription? = nil,
            kafkaConnectVersion: Swift.String? = nil,
            logDelivery: KafkaConnectClientTypes.LogDeliveryDescription? = nil,
            plugins: [KafkaConnectClientTypes.PluginDescription]? = nil,
            serviceExecutionRoleArn: Swift.String? = nil,
            workerConfiguration: KafkaConnectClientTypes.WorkerConfigurationDescription? = nil
        )
        {
            self.capacity = capacity
            self.connectorArn = connectorArn
            self.connectorDescription = connectorDescription
            self.connectorName = connectorName
            self.connectorState = connectorState
            self.creationTime = creationTime
            self.currentVersion = currentVersion
            self.kafkaCluster = kafkaCluster
            self.kafkaClusterClientAuthentication = kafkaClusterClientAuthentication
            self.kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransit
            self.kafkaConnectVersion = kafkaConnectVersion
            self.logDelivery = logDelivery
            self.plugins = plugins
            self.serviceExecutionRoleArn = serviceExecutionRoleArn
            self.workerConfiguration = workerConfiguration
        }
    }

}

extension CreateConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacity
        case connectorConfiguration
        case connectorDescription
        case connectorName
        case kafkaCluster
        case kafkaClusterClientAuthentication
        case kafkaClusterEncryptionInTransit
        case kafkaConnectVersion
        case logDelivery
        case plugins
        case serviceExecutionRoleArn
        case workerConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacity = capacity {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
        if let connectorConfiguration = connectorConfiguration {
            var connectorConfigurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .connectorConfiguration)
            for (dictKey0, __mapof__string0) in connectorConfiguration {
                try connectorConfigurationContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let connectorDescription = connectorDescription {
            try encodeContainer.encode(connectorDescription, forKey: .connectorDescription)
        }
        if let connectorName = connectorName {
            try encodeContainer.encode(connectorName, forKey: .connectorName)
        }
        if let kafkaCluster = kafkaCluster {
            try encodeContainer.encode(kafkaCluster, forKey: .kafkaCluster)
        }
        if let kafkaClusterClientAuthentication = kafkaClusterClientAuthentication {
            try encodeContainer.encode(kafkaClusterClientAuthentication, forKey: .kafkaClusterClientAuthentication)
        }
        if let kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransit {
            try encodeContainer.encode(kafkaClusterEncryptionInTransit, forKey: .kafkaClusterEncryptionInTransit)
        }
        if let kafkaConnectVersion = kafkaConnectVersion {
            try encodeContainer.encode(kafkaConnectVersion, forKey: .kafkaConnectVersion)
        }
        if let logDelivery = logDelivery {
            try encodeContainer.encode(logDelivery, forKey: .logDelivery)
        }
        if let plugins = plugins {
            var pluginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .plugins)
            for __listofplugin0 in plugins {
                try pluginsContainer.encode(__listofplugin0)
            }
        }
        if let serviceExecutionRoleArn = serviceExecutionRoleArn {
            try encodeContainer.encode(serviceExecutionRoleArn, forKey: .serviceExecutionRoleArn)
        }
        if let workerConfiguration = workerConfiguration {
            try encodeContainer.encode(workerConfiguration, forKey: .workerConfiguration)
        }
    }
}

extension CreateConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/connectors"
    }
}

public struct CreateConnectorInput: Swift.Equatable {
    /// Information about the capacity allocated to the connector. Exactly one of the two properties must be specified.
    /// This member is required.
    public var capacity: KafkaConnectClientTypes.Capacity?
    /// A map of keys to values that represent the configuration for the connector.
    /// This member is required.
    public var connectorConfiguration: [Swift.String:Swift.String]?
    /// A summary description of the connector.
    public var connectorDescription: Swift.String?
    /// The name of the connector.
    /// This member is required.
    public var connectorName: Swift.String?
    /// Specifies which Apache Kafka cluster to connect to.
    /// This member is required.
    public var kafkaCluster: KafkaConnectClientTypes.KafkaCluster?
    /// Details of the client authentication used by the Apache Kafka cluster.
    /// This member is required.
    public var kafkaClusterClientAuthentication: KafkaConnectClientTypes.KafkaClusterClientAuthentication?
    /// Details of encryption in transit to the Apache Kafka cluster.
    /// This member is required.
    public var kafkaClusterEncryptionInTransit: KafkaConnectClientTypes.KafkaClusterEncryptionInTransit?
    /// The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins.
    /// This member is required.
    public var kafkaConnectVersion: Swift.String?
    /// Details about log delivery.
    public var logDelivery: KafkaConnectClientTypes.LogDelivery?
    /// Specifies which plugins to use for the connector.
    /// This member is required.
    public var plugins: [KafkaConnectClientTypes.Plugin]?
    /// The Amazon Resource Name (ARN) of the IAM role used by the connector to access the Amazon Web Services resources that it needs. The types of resources depends on the logic of the connector. For example, a connector that has Amazon S3 as a destination must have permissions that allow it to write to the S3 destination bucket.
    /// This member is required.
    public var serviceExecutionRoleArn: Swift.String?
    /// Specifies which worker configuration to use with the connector.
    public var workerConfiguration: KafkaConnectClientTypes.WorkerConfiguration?

    public init (
        capacity: KafkaConnectClientTypes.Capacity? = nil,
        connectorConfiguration: [Swift.String:Swift.String]? = nil,
        connectorDescription: Swift.String? = nil,
        connectorName: Swift.String? = nil,
        kafkaCluster: KafkaConnectClientTypes.KafkaCluster? = nil,
        kafkaClusterClientAuthentication: KafkaConnectClientTypes.KafkaClusterClientAuthentication? = nil,
        kafkaClusterEncryptionInTransit: KafkaConnectClientTypes.KafkaClusterEncryptionInTransit? = nil,
        kafkaConnectVersion: Swift.String? = nil,
        logDelivery: KafkaConnectClientTypes.LogDelivery? = nil,
        plugins: [KafkaConnectClientTypes.Plugin]? = nil,
        serviceExecutionRoleArn: Swift.String? = nil,
        workerConfiguration: KafkaConnectClientTypes.WorkerConfiguration? = nil
    )
    {
        self.capacity = capacity
        self.connectorConfiguration = connectorConfiguration
        self.connectorDescription = connectorDescription
        self.connectorName = connectorName
        self.kafkaCluster = kafkaCluster
        self.kafkaClusterClientAuthentication = kafkaClusterClientAuthentication
        self.kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransit
        self.kafkaConnectVersion = kafkaConnectVersion
        self.logDelivery = logDelivery
        self.plugins = plugins
        self.serviceExecutionRoleArn = serviceExecutionRoleArn
        self.workerConfiguration = workerConfiguration
    }
}

struct CreateConnectorInputBody: Swift.Equatable {
    let capacity: KafkaConnectClientTypes.Capacity?
    let connectorConfiguration: [Swift.String:Swift.String]?
    let connectorDescription: Swift.String?
    let connectorName: Swift.String?
    let kafkaCluster: KafkaConnectClientTypes.KafkaCluster?
    let kafkaClusterClientAuthentication: KafkaConnectClientTypes.KafkaClusterClientAuthentication?
    let kafkaClusterEncryptionInTransit: KafkaConnectClientTypes.KafkaClusterEncryptionInTransit?
    let kafkaConnectVersion: Swift.String?
    let logDelivery: KafkaConnectClientTypes.LogDelivery?
    let plugins: [KafkaConnectClientTypes.Plugin]?
    let serviceExecutionRoleArn: Swift.String?
    let workerConfiguration: KafkaConnectClientTypes.WorkerConfiguration?
}

extension CreateConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacity
        case connectorConfiguration
        case connectorDescription
        case connectorName
        case kafkaCluster
        case kafkaClusterClientAuthentication
        case kafkaClusterEncryptionInTransit
        case kafkaConnectVersion
        case logDelivery
        case plugins
        case serviceExecutionRoleArn
        case workerConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.Capacity.self, forKey: .capacity)
        capacity = capacityDecoded
        let connectorConfigurationContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .connectorConfiguration)
        var connectorConfigurationDecoded0: [Swift.String:Swift.String]? = nil
        if let connectorConfigurationContainer = connectorConfigurationContainer {
            connectorConfigurationDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in connectorConfigurationContainer {
                if let __string0 = __string0 {
                    connectorConfigurationDecoded0?[key0] = __string0
                }
            }
        }
        connectorConfiguration = connectorConfigurationDecoded0
        let connectorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorDescription)
        connectorDescription = connectorDescriptionDecoded
        let connectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorName)
        connectorName = connectorNameDecoded
        let kafkaClusterDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.KafkaCluster.self, forKey: .kafkaCluster)
        kafkaCluster = kafkaClusterDecoded
        let kafkaClusterClientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.KafkaClusterClientAuthentication.self, forKey: .kafkaClusterClientAuthentication)
        kafkaClusterClientAuthentication = kafkaClusterClientAuthenticationDecoded
        let kafkaClusterEncryptionInTransitDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.KafkaClusterEncryptionInTransit.self, forKey: .kafkaClusterEncryptionInTransit)
        kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransitDecoded
        let kafkaConnectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kafkaConnectVersion)
        kafkaConnectVersion = kafkaConnectVersionDecoded
        let logDeliveryDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.LogDelivery.self, forKey: .logDelivery)
        logDelivery = logDeliveryDecoded
        let pluginsContainer = try containerValues.decodeIfPresent([KafkaConnectClientTypes.Plugin?].self, forKey: .plugins)
        var pluginsDecoded0:[KafkaConnectClientTypes.Plugin]? = nil
        if let pluginsContainer = pluginsContainer {
            pluginsDecoded0 = [KafkaConnectClientTypes.Plugin]()
            for structure0 in pluginsContainer {
                if let structure0 = structure0 {
                    pluginsDecoded0?.append(structure0)
                }
            }
        }
        plugins = pluginsDecoded0
        let serviceExecutionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceExecutionRoleArn)
        serviceExecutionRoleArn = serviceExecutionRoleArnDecoded
        let workerConfigurationDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.WorkerConfiguration.self, forKey: .workerConfiguration)
        workerConfiguration = workerConfigurationDecoded
    }
}

extension CreateConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorArn = output.connectorArn
            self.connectorName = output.connectorName
            self.connectorState = output.connectorState
        } else {
            self.connectorArn = nil
            self.connectorName = nil
            self.connectorState = nil
        }
    }
}

public struct CreateConnectorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that Amazon assigned to the connector.
    public var connectorArn: Swift.String?
    /// The name of the connector.
    public var connectorName: Swift.String?
    /// The state of the connector.
    public var connectorState: KafkaConnectClientTypes.ConnectorState?

    public init (
        connectorArn: Swift.String? = nil,
        connectorName: Swift.String? = nil,
        connectorState: KafkaConnectClientTypes.ConnectorState? = nil
    )
    {
        self.connectorArn = connectorArn
        self.connectorName = connectorName
        self.connectorState = connectorState
    }
}

struct CreateConnectorOutputResponseBody: Swift.Equatable {
    let connectorArn: Swift.String?
    let connectorName: Swift.String?
    let connectorState: KafkaConnectClientTypes.ConnectorState?
}

extension CreateConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorArn
        case connectorName
        case connectorState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorArn)
        connectorArn = connectorArnDecoded
        let connectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorName)
        connectorName = connectorNameDecoded
        let connectorStateDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.ConnectorState.self, forKey: .connectorState)
        connectorState = connectorStateDecoded
    }
}

extension CreateCustomPluginInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case description
        case location
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateCustomPluginInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/custom-plugins"
    }
}

public struct CreateCustomPluginInput: Swift.Equatable {
    /// The type of the plugin file.
    /// This member is required.
    public var contentType: KafkaConnectClientTypes.CustomPluginContentType?
    /// A summary description of the custom plugin.
    public var description: Swift.String?
    /// Information about the location of a custom plugin.
    /// This member is required.
    public var location: KafkaConnectClientTypes.CustomPluginLocation?
    /// The name of the custom plugin.
    /// This member is required.
    public var name: Swift.String?

    public init (
        contentType: KafkaConnectClientTypes.CustomPluginContentType? = nil,
        description: Swift.String? = nil,
        location: KafkaConnectClientTypes.CustomPluginLocation? = nil,
        name: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.location = location
        self.name = name
    }
}

struct CreateCustomPluginInputBody: Swift.Equatable {
    let contentType: KafkaConnectClientTypes.CustomPluginContentType?
    let description: Swift.String?
    let location: KafkaConnectClientTypes.CustomPluginLocation?
    let name: Swift.String?
}

extension CreateCustomPluginInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case description
        case location
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CustomPluginContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CustomPluginLocation.self, forKey: .location)
        location = locationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateCustomPluginOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomPluginOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomPluginOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomPluginOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCustomPluginOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customPluginArn = output.customPluginArn
            self.customPluginState = output.customPluginState
            self.name = output.name
            self.revision = output.revision
        } else {
            self.customPluginArn = nil
            self.customPluginState = nil
            self.name = nil
            self.revision = 0
        }
    }
}

public struct CreateCustomPluginOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that Amazon assigned to the custom plugin.
    public var customPluginArn: Swift.String?
    /// The state of the custom plugin.
    public var customPluginState: KafkaConnectClientTypes.CustomPluginState?
    /// The name of the custom plugin.
    public var name: Swift.String?
    /// The revision of the custom plugin.
    public var revision: Swift.Int

    public init (
        customPluginArn: Swift.String? = nil,
        customPluginState: KafkaConnectClientTypes.CustomPluginState? = nil,
        name: Swift.String? = nil,
        revision: Swift.Int = 0
    )
    {
        self.customPluginArn = customPluginArn
        self.customPluginState = customPluginState
        self.name = name
        self.revision = revision
    }
}

struct CreateCustomPluginOutputResponseBody: Swift.Equatable {
    let customPluginArn: Swift.String?
    let customPluginState: KafkaConnectClientTypes.CustomPluginState?
    let name: Swift.String?
    let revision: Swift.Int
}

extension CreateCustomPluginOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customPluginArn
        case customPluginState
        case name
        case revision
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customPluginArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customPluginArn)
        customPluginArn = customPluginArnDecoded
        let customPluginStateDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CustomPluginState.self, forKey: .customPluginState)
        customPluginState = customPluginStateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionDecoded = try containerValues.decode(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension CreateWorkerConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case propertiesFileContent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let propertiesFileContent = propertiesFileContent {
            try encodeContainer.encode(propertiesFileContent, forKey: .propertiesFileContent)
        }
    }
}

extension CreateWorkerConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/worker-configurations"
    }
}

public struct CreateWorkerConfigurationInput: Swift.Equatable {
    /// A summary description of the worker configuration.
    public var description: Swift.String?
    /// The name of the worker configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Base64 encoded contents of connect-distributed.properties file.
    /// This member is required.
    public var propertiesFileContent: Swift.String?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        propertiesFileContent: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.propertiesFileContent = propertiesFileContent
    }
}

struct CreateWorkerConfigurationInputBody: Swift.Equatable {
    let description: Swift.String?
    let name: Swift.String?
    let propertiesFileContent: Swift.String?
}

extension CreateWorkerConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case propertiesFileContent
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let propertiesFileContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertiesFileContent)
        propertiesFileContent = propertiesFileContentDecoded
    }
}

extension CreateWorkerConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkerConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkerConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkerConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWorkerConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.latestRevision = output.latestRevision
            self.name = output.name
            self.workerConfigurationArn = output.workerConfigurationArn
        } else {
            self.creationTime = nil
            self.latestRevision = nil
            self.name = nil
            self.workerConfigurationArn = nil
        }
    }
}

public struct CreateWorkerConfigurationOutputResponse: Swift.Equatable {
    /// The time that the worker configuration was created.
    public var creationTime: ClientRuntime.Date?
    /// The latest revision of the worker configuration.
    public var latestRevision: KafkaConnectClientTypes.WorkerConfigurationRevisionSummary?
    /// The name of the worker configuration.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that Amazon assigned to the worker configuration.
    public var workerConfigurationArn: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        latestRevision: KafkaConnectClientTypes.WorkerConfigurationRevisionSummary? = nil,
        name: Swift.String? = nil,
        workerConfigurationArn: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.latestRevision = latestRevision
        self.name = name
        self.workerConfigurationArn = workerConfigurationArn
    }
}

struct CreateWorkerConfigurationOutputResponseBody: Swift.Equatable {
    let creationTime: ClientRuntime.Date?
    let latestRevision: KafkaConnectClientTypes.WorkerConfigurationRevisionSummary?
    let name: Swift.String?
    let workerConfigurationArn: Swift.String?
}

extension CreateWorkerConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case latestRevision
        case name
        case workerConfigurationArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.WorkerConfigurationRevisionSummary.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let workerConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerConfigurationArn)
        workerConfigurationArn = workerConfigurationArnDecoded
    }
}

extension KafkaConnectClientTypes.CustomPlugin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customPluginArn
        case revision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customPluginArn = customPluginArn {
            try encodeContainer.encode(customPluginArn, forKey: .customPluginArn)
        }
        if revision != 0 {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customPluginArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customPluginArn)
        customPluginArn = customPluginArnDecoded
        let revisionDecoded = try containerValues.decode(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension KafkaConnectClientTypes {
    /// A plugin is an AWS resource that contains the code that defines a connector's logic.
    public struct CustomPlugin: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the custom plugin.
        /// This member is required.
        public var customPluginArn: Swift.String?
        /// The revision of the custom plugin.
        /// This member is required.
        public var revision: Swift.Int

        public init (
            customPluginArn: Swift.String? = nil,
            revision: Swift.Int = 0
        )
        {
            self.customPluginArn = customPluginArn
            self.revision = revision
        }
    }

}

extension KafkaConnectClientTypes {
    public enum CustomPluginContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jar
        case zip
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomPluginContentType] {
            return [
                .jar,
                .zip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jar: return "JAR"
            case .zip: return "ZIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomPluginContentType(rawValue: rawValue) ?? CustomPluginContentType.sdkUnknown(rawValue)
        }
    }
}

extension KafkaConnectClientTypes.CustomPluginDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customPluginArn
        case revision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customPluginArn = customPluginArn {
            try encodeContainer.encode(customPluginArn, forKey: .customPluginArn)
        }
        if revision != 0 {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customPluginArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customPluginArn)
        customPluginArn = customPluginArnDecoded
        let revisionDecoded = try containerValues.decode(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension KafkaConnectClientTypes {
    /// Details about a custom plugin.
    public struct CustomPluginDescription: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the custom plugin.
        public var customPluginArn: Swift.String?
        /// The revision of the custom plugin.
        public var revision: Swift.Int

        public init (
            customPluginArn: Swift.String? = nil,
            revision: Swift.Int = 0
        )
        {
            self.customPluginArn = customPluginArn
            self.revision = revision
        }
    }

}

extension KafkaConnectClientTypes.CustomPluginFileDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileMd5
        case fileSize
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileMd5 = fileMd5 {
            try encodeContainer.encode(fileMd5, forKey: .fileMd5)
        }
        if fileSize != 0 {
            try encodeContainer.encode(fileSize, forKey: .fileSize)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileMd5Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileMd5)
        fileMd5 = fileMd5Decoded
        let fileSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .fileSize)
        fileSize = fileSizeDecoded
    }
}

extension KafkaConnectClientTypes {
    /// Details about a custom plugin file.
    public struct CustomPluginFileDescription: Swift.Equatable {
        /// The hex-encoded MD5 checksum of the custom plugin file. You can use it to validate the file.
        public var fileMd5: Swift.String?
        /// The size in bytes of the custom plugin file. You can use it to validate the file.
        public var fileSize: Swift.Int

        public init (
            fileMd5: Swift.String? = nil,
            fileSize: Swift.Int = 0
        )
        {
            self.fileMd5 = fileMd5
            self.fileSize = fileSize
        }
    }

}

extension KafkaConnectClientTypes.CustomPluginLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension KafkaConnectClientTypes {
    /// Information about the location of a custom plugin.
    public struct CustomPluginLocation: Swift.Equatable {
        /// The S3 bucket Amazon Resource Name (ARN), file key, and object version of the plugin file stored in Amazon S3.
        /// This member is required.
        public var s3Location: KafkaConnectClientTypes.S3Location?

        public init (
            s3Location: KafkaConnectClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }

}

extension KafkaConnectClientTypes.CustomPluginLocationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.S3LocationDescription.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension KafkaConnectClientTypes {
    /// Information about the location of a custom plugin.
    public struct CustomPluginLocationDescription: Swift.Equatable {
        /// The S3 bucket Amazon Resource Name (ARN), file key, and object version of the plugin file stored in Amazon S3.
        public var s3Location: KafkaConnectClientTypes.S3LocationDescription?

        public init (
            s3Location: KafkaConnectClientTypes.S3LocationDescription? = nil
        )
        {
            self.s3Location = s3Location
        }
    }

}

extension KafkaConnectClientTypes.CustomPluginRevisionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case creationTime
        case description
        case fileDescription
        case location
        case revision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fileDescription = fileDescription {
            try encodeContainer.encode(fileDescription, forKey: .fileDescription)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if revision != 0 {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CustomPluginContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let fileDescriptionDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CustomPluginFileDescription.self, forKey: .fileDescription)
        fileDescription = fileDescriptionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CustomPluginLocationDescription.self, forKey: .location)
        location = locationDecoded
        let revisionDecoded = try containerValues.decode(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension KafkaConnectClientTypes {
    /// Details about the revision of a custom plugin.
    public struct CustomPluginRevisionSummary: Swift.Equatable {
        /// The format of the plugin file.
        public var contentType: KafkaConnectClientTypes.CustomPluginContentType?
        /// The time that the custom plugin was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the custom plugin.
        public var description: Swift.String?
        /// Details about the custom plugin file.
        public var fileDescription: KafkaConnectClientTypes.CustomPluginFileDescription?
        /// Information about the location of the custom plugin.
        public var location: KafkaConnectClientTypes.CustomPluginLocationDescription?
        /// The revision of the custom plugin.
        public var revision: Swift.Int

        public init (
            contentType: KafkaConnectClientTypes.CustomPluginContentType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            fileDescription: KafkaConnectClientTypes.CustomPluginFileDescription? = nil,
            location: KafkaConnectClientTypes.CustomPluginLocationDescription? = nil,
            revision: Swift.Int = 0
        )
        {
            self.contentType = contentType
            self.creationTime = creationTime
            self.description = description
            self.fileDescription = fileDescription
            self.location = location
            self.revision = revision
        }
    }

}

extension KafkaConnectClientTypes {
    public enum CustomPluginState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleting
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomPluginState] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleting,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomPluginState(rawValue: rawValue) ?? CustomPluginState.sdkUnknown(rawValue)
        }
    }
}

extension KafkaConnectClientTypes.CustomPluginSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case customPluginArn
        case customPluginState
        case description
        case latestRevision
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let customPluginArn = customPluginArn {
            try encodeContainer.encode(customPluginArn, forKey: .customPluginArn)
        }
        if let customPluginState = customPluginState {
            try encodeContainer.encode(customPluginState.rawValue, forKey: .customPluginState)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let latestRevision = latestRevision {
            try encodeContainer.encode(latestRevision, forKey: .latestRevision)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let customPluginArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customPluginArn)
        customPluginArn = customPluginArnDecoded
        let customPluginStateDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CustomPluginState.self, forKey: .customPluginState)
        customPluginState = customPluginStateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CustomPluginRevisionSummary.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension KafkaConnectClientTypes {
    /// A summary of the custom plugin.
    public struct CustomPluginSummary: Swift.Equatable {
        /// The time that the custom plugin was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the custom plugin.
        public var customPluginArn: Swift.String?
        /// The state of the custom plugin.
        public var customPluginState: KafkaConnectClientTypes.CustomPluginState?
        /// A description of the custom plugin.
        public var description: Swift.String?
        /// The latest revision of the custom plugin.
        public var latestRevision: KafkaConnectClientTypes.CustomPluginRevisionSummary?
        /// The name of the custom plugin.
        public var name: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            customPluginArn: Swift.String? = nil,
            customPluginState: KafkaConnectClientTypes.CustomPluginState? = nil,
            description: Swift.String? = nil,
            latestRevision: KafkaConnectClientTypes.CustomPluginRevisionSummary? = nil,
            name: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.customPluginArn = customPluginArn
            self.customPluginState = customPluginState
            self.description = description
            self.latestRevision = latestRevision
            self.name = name
        }
    }

}

extension DeleteConnectorInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let currentVersion = currentVersion {
            let currentVersionQueryItem = ClientRuntime.URLQueryItem(name: "currentVersion".urlPercentEncoding(), value: Swift.String(currentVersion).urlPercentEncoding())
            items.append(currentVersionQueryItem)
        }
        return items
    }
}

extension DeleteConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectorArn = connectorArn else {
            return nil
        }
        return "/v1/connectors/\(connectorArn.urlPercentEncoding())"
    }
}

public struct DeleteConnectorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the connector that you want to delete.
    /// This member is required.
    public var connectorArn: Swift.String?
    /// The current version of the connector that you want to delete.
    public var currentVersion: Swift.String?

    public init (
        connectorArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.connectorArn = connectorArn
        self.currentVersion = currentVersion
    }
}

struct DeleteConnectorInputBody: Swift.Equatable {
}

extension DeleteConnectorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorArn = output.connectorArn
            self.connectorState = output.connectorState
        } else {
            self.connectorArn = nil
            self.connectorState = nil
        }
    }
}

public struct DeleteConnectorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the connector that you requested to delete.
    public var connectorArn: Swift.String?
    /// The state of the connector that you requested to delete.
    public var connectorState: KafkaConnectClientTypes.ConnectorState?

    public init (
        connectorArn: Swift.String? = nil,
        connectorState: KafkaConnectClientTypes.ConnectorState? = nil
    )
    {
        self.connectorArn = connectorArn
        self.connectorState = connectorState
    }
}

struct DeleteConnectorOutputResponseBody: Swift.Equatable {
    let connectorArn: Swift.String?
    let connectorState: KafkaConnectClientTypes.ConnectorState?
}

extension DeleteConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorArn
        case connectorState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorArn)
        connectorArn = connectorArnDecoded
        let connectorStateDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.ConnectorState.self, forKey: .connectorState)
        connectorState = connectorStateDecoded
    }
}

extension DescribeConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectorArn = connectorArn else {
            return nil
        }
        return "/v1/connectors/\(connectorArn.urlPercentEncoding())"
    }
}

public struct DescribeConnectorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the connector that you want to describe.
    /// This member is required.
    public var connectorArn: Swift.String?

    public init (
        connectorArn: Swift.String? = nil
    )
    {
        self.connectorArn = connectorArn
    }
}

struct DescribeConnectorInputBody: Swift.Equatable {
}

extension DescribeConnectorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.capacity = output.capacity
            self.connectorArn = output.connectorArn
            self.connectorConfiguration = output.connectorConfiguration
            self.connectorDescription = output.connectorDescription
            self.connectorName = output.connectorName
            self.connectorState = output.connectorState
            self.creationTime = output.creationTime
            self.currentVersion = output.currentVersion
            self.kafkaCluster = output.kafkaCluster
            self.kafkaClusterClientAuthentication = output.kafkaClusterClientAuthentication
            self.kafkaClusterEncryptionInTransit = output.kafkaClusterEncryptionInTransit
            self.kafkaConnectVersion = output.kafkaConnectVersion
            self.logDelivery = output.logDelivery
            self.plugins = output.plugins
            self.serviceExecutionRoleArn = output.serviceExecutionRoleArn
            self.workerConfiguration = output.workerConfiguration
        } else {
            self.capacity = nil
            self.connectorArn = nil
            self.connectorConfiguration = nil
            self.connectorDescription = nil
            self.connectorName = nil
            self.connectorState = nil
            self.creationTime = nil
            self.currentVersion = nil
            self.kafkaCluster = nil
            self.kafkaClusterClientAuthentication = nil
            self.kafkaClusterEncryptionInTransit = nil
            self.kafkaConnectVersion = nil
            self.logDelivery = nil
            self.plugins = nil
            self.serviceExecutionRoleArn = nil
            self.workerConfiguration = nil
        }
    }
}

public struct DescribeConnectorOutputResponse: Swift.Equatable {
    /// Information about the capacity of the connector, whether it is auto scaled or provisioned.
    public var capacity: KafkaConnectClientTypes.CapacityDescription?
    /// The Amazon Resource Name (ARN) of the connector.
    public var connectorArn: Swift.String?
    /// A map of keys to values that represent the configuration for the connector.
    public var connectorConfiguration: [Swift.String:Swift.String]?
    /// A summary description of the connector.
    public var connectorDescription: Swift.String?
    /// The name of the connector.
    public var connectorName: Swift.String?
    /// The state of the connector.
    public var connectorState: KafkaConnectClientTypes.ConnectorState?
    /// The time the connector was created.
    public var creationTime: ClientRuntime.Date?
    /// The current version of the connector.
    public var currentVersion: Swift.String?
    /// The Apache Kafka cluster that the connector is connected to.
    public var kafkaCluster: KafkaConnectClientTypes.KafkaClusterDescription?
    /// The type of client authentication used to connect to the Apache Kafka cluster. The value is NONE when no client authentication is used.
    public var kafkaClusterClientAuthentication: KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription?
    /// Details of encryption in transit to the Apache Kafka cluster.
    public var kafkaClusterEncryptionInTransit: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription?
    /// The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins.
    public var kafkaConnectVersion: Swift.String?
    /// Details about delivering logs to Amazon CloudWatch Logs.
    public var logDelivery: KafkaConnectClientTypes.LogDeliveryDescription?
    /// Specifies which plugins were used for this connector.
    public var plugins: [KafkaConnectClientTypes.PluginDescription]?
    /// The Amazon Resource Name (ARN) of the IAM role used by the connector to access Amazon Web Services resources.
    public var serviceExecutionRoleArn: Swift.String?
    /// Specifies which worker configuration was used for the connector.
    public var workerConfiguration: KafkaConnectClientTypes.WorkerConfigurationDescription?

    public init (
        capacity: KafkaConnectClientTypes.CapacityDescription? = nil,
        connectorArn: Swift.String? = nil,
        connectorConfiguration: [Swift.String:Swift.String]? = nil,
        connectorDescription: Swift.String? = nil,
        connectorName: Swift.String? = nil,
        connectorState: KafkaConnectClientTypes.ConnectorState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        currentVersion: Swift.String? = nil,
        kafkaCluster: KafkaConnectClientTypes.KafkaClusterDescription? = nil,
        kafkaClusterClientAuthentication: KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription? = nil,
        kafkaClusterEncryptionInTransit: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription? = nil,
        kafkaConnectVersion: Swift.String? = nil,
        logDelivery: KafkaConnectClientTypes.LogDeliveryDescription? = nil,
        plugins: [KafkaConnectClientTypes.PluginDescription]? = nil,
        serviceExecutionRoleArn: Swift.String? = nil,
        workerConfiguration: KafkaConnectClientTypes.WorkerConfigurationDescription? = nil
    )
    {
        self.capacity = capacity
        self.connectorArn = connectorArn
        self.connectorConfiguration = connectorConfiguration
        self.connectorDescription = connectorDescription
        self.connectorName = connectorName
        self.connectorState = connectorState
        self.creationTime = creationTime
        self.currentVersion = currentVersion
        self.kafkaCluster = kafkaCluster
        self.kafkaClusterClientAuthentication = kafkaClusterClientAuthentication
        self.kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransit
        self.kafkaConnectVersion = kafkaConnectVersion
        self.logDelivery = logDelivery
        self.plugins = plugins
        self.serviceExecutionRoleArn = serviceExecutionRoleArn
        self.workerConfiguration = workerConfiguration
    }
}

struct DescribeConnectorOutputResponseBody: Swift.Equatable {
    let capacity: KafkaConnectClientTypes.CapacityDescription?
    let connectorArn: Swift.String?
    let connectorConfiguration: [Swift.String:Swift.String]?
    let connectorDescription: Swift.String?
    let connectorName: Swift.String?
    let connectorState: KafkaConnectClientTypes.ConnectorState?
    let creationTime: ClientRuntime.Date?
    let currentVersion: Swift.String?
    let kafkaCluster: KafkaConnectClientTypes.KafkaClusterDescription?
    let kafkaClusterClientAuthentication: KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription?
    let kafkaClusterEncryptionInTransit: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription?
    let kafkaConnectVersion: Swift.String?
    let logDelivery: KafkaConnectClientTypes.LogDeliveryDescription?
    let plugins: [KafkaConnectClientTypes.PluginDescription]?
    let serviceExecutionRoleArn: Swift.String?
    let workerConfiguration: KafkaConnectClientTypes.WorkerConfigurationDescription?
}

extension DescribeConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacity
        case connectorArn
        case connectorConfiguration
        case connectorDescription
        case connectorName
        case connectorState
        case creationTime
        case currentVersion
        case kafkaCluster
        case kafkaClusterClientAuthentication
        case kafkaClusterEncryptionInTransit
        case kafkaConnectVersion
        case logDelivery
        case plugins
        case serviceExecutionRoleArn
        case workerConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CapacityDescription.self, forKey: .capacity)
        capacity = capacityDecoded
        let connectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorArn)
        connectorArn = connectorArnDecoded
        let connectorConfigurationContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .connectorConfiguration)
        var connectorConfigurationDecoded0: [Swift.String:Swift.String]? = nil
        if let connectorConfigurationContainer = connectorConfigurationContainer {
            connectorConfigurationDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in connectorConfigurationContainer {
                if let __string0 = __string0 {
                    connectorConfigurationDecoded0?[key0] = __string0
                }
            }
        }
        connectorConfiguration = connectorConfigurationDecoded0
        let connectorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorDescription)
        connectorDescription = connectorDescriptionDecoded
        let connectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorName)
        connectorName = connectorNameDecoded
        let connectorStateDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.ConnectorState.self, forKey: .connectorState)
        connectorState = connectorStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let kafkaClusterDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.KafkaClusterDescription.self, forKey: .kafkaCluster)
        kafkaCluster = kafkaClusterDecoded
        let kafkaClusterClientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription.self, forKey: .kafkaClusterClientAuthentication)
        kafkaClusterClientAuthentication = kafkaClusterClientAuthenticationDecoded
        let kafkaClusterEncryptionInTransitDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription.self, forKey: .kafkaClusterEncryptionInTransit)
        kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransitDecoded
        let kafkaConnectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kafkaConnectVersion)
        kafkaConnectVersion = kafkaConnectVersionDecoded
        let logDeliveryDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.LogDeliveryDescription.self, forKey: .logDelivery)
        logDelivery = logDeliveryDecoded
        let pluginsContainer = try containerValues.decodeIfPresent([KafkaConnectClientTypes.PluginDescription?].self, forKey: .plugins)
        var pluginsDecoded0:[KafkaConnectClientTypes.PluginDescription]? = nil
        if let pluginsContainer = pluginsContainer {
            pluginsDecoded0 = [KafkaConnectClientTypes.PluginDescription]()
            for structure0 in pluginsContainer {
                if let structure0 = structure0 {
                    pluginsDecoded0?.append(structure0)
                }
            }
        }
        plugins = pluginsDecoded0
        let serviceExecutionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceExecutionRoleArn)
        serviceExecutionRoleArn = serviceExecutionRoleArnDecoded
        let workerConfigurationDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.WorkerConfigurationDescription.self, forKey: .workerConfiguration)
        workerConfiguration = workerConfigurationDecoded
    }
}

extension DescribeCustomPluginInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let customPluginArn = customPluginArn else {
            return nil
        }
        return "/v1/custom-plugins/\(customPluginArn.urlPercentEncoding())"
    }
}

public struct DescribeCustomPluginInput: Swift.Equatable {
    /// Returns information about a custom plugin.
    /// This member is required.
    public var customPluginArn: Swift.String?

    public init (
        customPluginArn: Swift.String? = nil
    )
    {
        self.customPluginArn = customPluginArn
    }
}

struct DescribeCustomPluginInputBody: Swift.Equatable {
}

extension DescribeCustomPluginInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeCustomPluginOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomPluginOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomPluginOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomPluginOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCustomPluginOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.customPluginArn = output.customPluginArn
            self.customPluginState = output.customPluginState
            self.description = output.description
            self.latestRevision = output.latestRevision
            self.name = output.name
        } else {
            self.creationTime = nil
            self.customPluginArn = nil
            self.customPluginState = nil
            self.description = nil
            self.latestRevision = nil
            self.name = nil
        }
    }
}

public struct DescribeCustomPluginOutputResponse: Swift.Equatable {
    /// The time that the custom plugin was created.
    public var creationTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the custom plugin.
    public var customPluginArn: Swift.String?
    /// The state of the custom plugin.
    public var customPluginState: KafkaConnectClientTypes.CustomPluginState?
    /// The description of the custom plugin.
    public var description: Swift.String?
    /// The latest successfully created revision of the custom plugin. If there are no successfully created revisions, this field will be absent.
    public var latestRevision: KafkaConnectClientTypes.CustomPluginRevisionSummary?
    /// The name of the custom plugin.
    public var name: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        customPluginArn: Swift.String? = nil,
        customPluginState: KafkaConnectClientTypes.CustomPluginState? = nil,
        description: Swift.String? = nil,
        latestRevision: KafkaConnectClientTypes.CustomPluginRevisionSummary? = nil,
        name: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.customPluginArn = customPluginArn
        self.customPluginState = customPluginState
        self.description = description
        self.latestRevision = latestRevision
        self.name = name
    }
}

struct DescribeCustomPluginOutputResponseBody: Swift.Equatable {
    let creationTime: ClientRuntime.Date?
    let customPluginArn: Swift.String?
    let customPluginState: KafkaConnectClientTypes.CustomPluginState?
    let description: Swift.String?
    let latestRevision: KafkaConnectClientTypes.CustomPluginRevisionSummary?
    let name: Swift.String?
}

extension DescribeCustomPluginOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case customPluginArn
        case customPluginState
        case description
        case latestRevision
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let customPluginArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customPluginArn)
        customPluginArn = customPluginArnDecoded
        let customPluginStateDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CustomPluginState.self, forKey: .customPluginState)
        customPluginState = customPluginStateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CustomPluginRevisionSummary.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeWorkerConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workerConfigurationArn = workerConfigurationArn else {
            return nil
        }
        return "/v1/worker-configurations/\(workerConfigurationArn.urlPercentEncoding())"
    }
}

public struct DescribeWorkerConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the worker configuration that you want to get information about.
    /// This member is required.
    public var workerConfigurationArn: Swift.String?

    public init (
        workerConfigurationArn: Swift.String? = nil
    )
    {
        self.workerConfigurationArn = workerConfigurationArn
    }
}

struct DescribeWorkerConfigurationInputBody: Swift.Equatable {
}

extension DescribeWorkerConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeWorkerConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkerConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkerConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkerConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorkerConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.latestRevision = output.latestRevision
            self.name = output.name
            self.workerConfigurationArn = output.workerConfigurationArn
        } else {
            self.creationTime = nil
            self.description = nil
            self.latestRevision = nil
            self.name = nil
            self.workerConfigurationArn = nil
        }
    }
}

public struct DescribeWorkerConfigurationOutputResponse: Swift.Equatable {
    /// The time that the worker configuration was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the worker configuration.
    public var description: Swift.String?
    /// The latest revision of the custom configuration.
    public var latestRevision: KafkaConnectClientTypes.WorkerConfigurationRevisionDescription?
    /// The name of the worker configuration.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the custom configuration.
    public var workerConfigurationArn: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        latestRevision: KafkaConnectClientTypes.WorkerConfigurationRevisionDescription? = nil,
        name: Swift.String? = nil,
        workerConfigurationArn: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.latestRevision = latestRevision
        self.name = name
        self.workerConfigurationArn = workerConfigurationArn
    }
}

struct DescribeWorkerConfigurationOutputResponseBody: Swift.Equatable {
    let creationTime: ClientRuntime.Date?
    let description: Swift.String?
    let latestRevision: KafkaConnectClientTypes.WorkerConfigurationRevisionDescription?
    let name: Swift.String?
    let workerConfigurationArn: Swift.String?
}

extension DescribeWorkerConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case latestRevision
        case name
        case workerConfigurationArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.WorkerConfigurationRevisionDescription.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let workerConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerConfigurationArn)
        workerConfigurationArn = workerConfigurationArnDecoded
    }
}

extension KafkaConnectClientTypes.FirehoseLogDelivery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryStream
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStream = deliveryStream {
            try encodeContainer.encode(deliveryStream, forKey: .deliveryStream)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryStream)
        deliveryStream = deliveryStreamDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The settings for delivering logs to Amazon Kinesis Data Firehose.
    public struct FirehoseLogDelivery: Swift.Equatable {
        /// The name of the Kinesis Data Firehose delivery stream that is the destination for log delivery.
        public var deliveryStream: Swift.String?
        /// Specifies whether connector logs get delivered to Amazon Kinesis Data Firehose.
        /// This member is required.
        public var enabled: Swift.Bool

        public init (
            deliveryStream: Swift.String? = nil,
            enabled: Swift.Bool = false
        )
        {
            self.deliveryStream = deliveryStream
            self.enabled = enabled
        }
    }

}

extension KafkaConnectClientTypes.FirehoseLogDeliveryDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryStream
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStream = deliveryStream {
            try encodeContainer.encode(deliveryStream, forKey: .deliveryStream)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryStream)
        deliveryStream = deliveryStreamDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension KafkaConnectClientTypes {
    /// A description of the settings for delivering logs to Amazon Kinesis Data Firehose.
    public struct FirehoseLogDeliveryDescription: Swift.Equatable {
        /// The name of the Kinesis Data Firehose delivery stream that is the destination for log delivery.
        public var deliveryStream: Swift.String?
        /// Specifies whether connector logs get delivered to Amazon Kinesis Data Firehose.
        public var enabled: Swift.Bool

        public init (
            deliveryStream: Swift.String? = nil,
            enabled: Swift.Bool = false
        )
        {
            self.deliveryStream = deliveryStream
            self.enabled = enabled
        }
    }

}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// HTTP Status Code 403: Access forbidden. Correct your credentials and then retry your request.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// HTTP Status Code 500: Unexpected internal server error. Retrying your request might resolve the issue.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaConnectClientTypes.KafkaCluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apacheKafkaCluster
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apacheKafkaCluster = apacheKafkaCluster {
            try encodeContainer.encode(apacheKafkaCluster, forKey: .apacheKafkaCluster)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apacheKafkaClusterDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.ApacheKafkaCluster.self, forKey: .apacheKafkaCluster)
        apacheKafkaCluster = apacheKafkaClusterDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The details of the Apache Kafka cluster to which the connector is connected.
    public struct KafkaCluster: Swift.Equatable {
        /// The Apache Kafka cluster to which the connector is connected.
        /// This member is required.
        public var apacheKafkaCluster: KafkaConnectClientTypes.ApacheKafkaCluster?

        public init (
            apacheKafkaCluster: KafkaConnectClientTypes.ApacheKafkaCluster? = nil
        )
        {
            self.apacheKafkaCluster = apacheKafkaCluster
        }
    }

}

extension KafkaConnectClientTypes.KafkaClusterClientAuthentication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.KafkaClusterClientAuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The client authentication information used in order to authenticate with the Apache Kafka cluster.
    public struct KafkaClusterClientAuthentication: Swift.Equatable {
        /// The type of client authentication used to connect to the Apache Kafka cluster. Value NONE means that no client authentication is used.
        /// This member is required.
        public var authenticationType: KafkaConnectClientTypes.KafkaClusterClientAuthenticationType?

        public init (
            authenticationType: KafkaConnectClientTypes.KafkaClusterClientAuthenticationType? = nil
        )
        {
            self.authenticationType = authenticationType
        }
    }

}

extension KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.KafkaClusterClientAuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The client authentication information used in order to authenticate with the Apache Kafka cluster.
    public struct KafkaClusterClientAuthenticationDescription: Swift.Equatable {
        /// The type of client authentication used to connect to the Apache Kafka cluster. Value NONE means that no client authentication is used.
        public var authenticationType: KafkaConnectClientTypes.KafkaClusterClientAuthenticationType?

        public init (
            authenticationType: KafkaConnectClientTypes.KafkaClusterClientAuthenticationType? = nil
        )
        {
            self.authenticationType = authenticationType
        }
    }

}

extension KafkaConnectClientTypes {
    public enum KafkaClusterClientAuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iam
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaClusterClientAuthenticationType] {
            return [
                .iam,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KafkaClusterClientAuthenticationType(rawValue: rawValue) ?? KafkaClusterClientAuthenticationType.sdkUnknown(rawValue)
        }
    }
}

extension KafkaConnectClientTypes.KafkaClusterDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apacheKafkaCluster
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apacheKafkaCluster = apacheKafkaCluster {
            try encodeContainer.encode(apacheKafkaCluster, forKey: .apacheKafkaCluster)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apacheKafkaClusterDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.ApacheKafkaClusterDescription.self, forKey: .apacheKafkaCluster)
        apacheKafkaCluster = apacheKafkaClusterDecoded
    }
}

extension KafkaConnectClientTypes {
    /// Details of how to connect to the Apache Kafka cluster.
    public struct KafkaClusterDescription: Swift.Equatable {
        /// The Apache Kafka cluster to which the connector is connected.
        public var apacheKafkaCluster: KafkaConnectClientTypes.ApacheKafkaClusterDescription?

        public init (
            apacheKafkaCluster: KafkaConnectClientTypes.ApacheKafkaClusterDescription? = nil
        )
        {
            self.apacheKafkaCluster = apacheKafkaCluster
        }
    }

}

extension KafkaConnectClientTypes.KafkaClusterEncryptionInTransit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.KafkaClusterEncryptionInTransitType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
    }
}

extension KafkaConnectClientTypes {
    /// Details of encryption in transit to the Apache Kafka cluster.
    public struct KafkaClusterEncryptionInTransit: Swift.Equatable {
        /// The type of encryption in transit to the Apache Kafka cluster.
        /// This member is required.
        public var encryptionType: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitType?

        public init (
            encryptionType: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitType? = nil
        )
        {
            self.encryptionType = encryptionType
        }
    }

}

extension KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.KafkaClusterEncryptionInTransitType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The description of the encryption in transit to the Apache Kafka cluster.
    public struct KafkaClusterEncryptionInTransitDescription: Swift.Equatable {
        /// The type of encryption in transit to the Apache Kafka cluster.
        public var encryptionType: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitType?

        public init (
            encryptionType: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitType? = nil
        )
        {
            self.encryptionType = encryptionType
        }
    }

}

extension KafkaConnectClientTypes {
    public enum KafkaClusterEncryptionInTransitType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plaintext
        case tls
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaClusterEncryptionInTransitType] {
            return [
                .plaintext,
                .tls,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "PLAINTEXT"
            case .tls: return "TLS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KafkaClusterEncryptionInTransitType(rawValue: rawValue) ?? KafkaClusterEncryptionInTransitType.sdkUnknown(rawValue)
        }
    }
}

extension ListConnectorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let connectorNamePrefix = connectorNamePrefix {
            let connectorNamePrefixQueryItem = ClientRuntime.URLQueryItem(name: "connectorNamePrefix".urlPercentEncoding(), value: Swift.String(connectorNamePrefix).urlPercentEncoding())
            items.append(connectorNamePrefixQueryItem)
        }
        return items
    }
}

extension ListConnectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/connectors"
    }
}

public struct ListConnectorsInput: Swift.Equatable {
    /// The name prefix that you want to use to search for and list connectors.
    public var connectorNamePrefix: Swift.String?
    /// The maximum number of connectors to list in one response.
    public var maxResults: Swift.Int
    /// If the response of a ListConnectors operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
    public var nextToken: Swift.String?

    public init (
        connectorNamePrefix: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorNamePrefix = connectorNamePrefix
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectorsInputBody: Swift.Equatable {
}

extension ListConnectorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConnectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConnectorsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConnectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectors = output.connectors
            self.nextToken = output.nextToken
        } else {
            self.connectors = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectorsOutputResponse: Swift.Equatable {
    /// An array of connector descriptions.
    public var connectors: [KafkaConnectClientTypes.ConnectorSummary]?
    /// If the response of a ListConnectors operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where it left off.
    public var nextToken: Swift.String?

    public init (
        connectors: [KafkaConnectClientTypes.ConnectorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectors = connectors
        self.nextToken = nextToken
    }
}

struct ListConnectorsOutputResponseBody: Swift.Equatable {
    let connectors: [KafkaConnectClientTypes.ConnectorSummary]?
    let nextToken: Swift.String?
}

extension ListConnectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectors
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorsContainer = try containerValues.decodeIfPresent([KafkaConnectClientTypes.ConnectorSummary?].self, forKey: .connectors)
        var connectorsDecoded0:[KafkaConnectClientTypes.ConnectorSummary]? = nil
        if let connectorsContainer = connectorsContainer {
            connectorsDecoded0 = [KafkaConnectClientTypes.ConnectorSummary]()
            for structure0 in connectorsContainer {
                if let structure0 = structure0 {
                    connectorsDecoded0?.append(structure0)
                }
            }
        }
        connectors = connectorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomPluginsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListCustomPluginsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/custom-plugins"
    }
}

public struct ListCustomPluginsInput: Swift.Equatable {
    /// The maximum number of custom plugins to list in one response.
    public var maxResults: Swift.Int
    /// If the response of a ListCustomPlugins operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomPluginsInputBody: Swift.Equatable {
}

extension ListCustomPluginsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCustomPluginsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomPluginsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCustomPluginsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomPluginsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCustomPluginsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customPlugins = output.customPlugins
            self.nextToken = output.nextToken
        } else {
            self.customPlugins = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomPluginsOutputResponse: Swift.Equatable {
    /// An array of custom plugin descriptions.
    public var customPlugins: [KafkaConnectClientTypes.CustomPluginSummary]?
    /// If the response of a ListCustomPlugins operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
    public var nextToken: Swift.String?

    public init (
        customPlugins: [KafkaConnectClientTypes.CustomPluginSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customPlugins = customPlugins
        self.nextToken = nextToken
    }
}

struct ListCustomPluginsOutputResponseBody: Swift.Equatable {
    let customPlugins: [KafkaConnectClientTypes.CustomPluginSummary]?
    let nextToken: Swift.String?
}

extension ListCustomPluginsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customPlugins
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customPluginsContainer = try containerValues.decodeIfPresent([KafkaConnectClientTypes.CustomPluginSummary?].self, forKey: .customPlugins)
        var customPluginsDecoded0:[KafkaConnectClientTypes.CustomPluginSummary]? = nil
        if let customPluginsContainer = customPluginsContainer {
            customPluginsDecoded0 = [KafkaConnectClientTypes.CustomPluginSummary]()
            for structure0 in customPluginsContainer {
                if let structure0 = structure0 {
                    customPluginsDecoded0?.append(structure0)
                }
            }
        }
        customPlugins = customPluginsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorkerConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListWorkerConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/worker-configurations"
    }
}

public struct ListWorkerConfigurationsInput: Swift.Equatable {
    /// The maximum number of worker configurations to list in one response.
    public var maxResults: Swift.Int
    /// If the response of a ListWorkerConfigurations operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkerConfigurationsInputBody: Swift.Equatable {
}

extension ListWorkerConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkerConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkerConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkerConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkerConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorkerConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workerConfigurations = output.workerConfigurations
        } else {
            self.nextToken = nil
            self.workerConfigurations = nil
        }
    }
}

public struct ListWorkerConfigurationsOutputResponse: Swift.Equatable {
    /// If the response of a ListWorkerConfigurations operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
    public var nextToken: Swift.String?
    /// An array of worker configuration descriptions.
    public var workerConfigurations: [KafkaConnectClientTypes.WorkerConfigurationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        workerConfigurations: [KafkaConnectClientTypes.WorkerConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workerConfigurations = workerConfigurations
    }
}

struct ListWorkerConfigurationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workerConfigurations: [KafkaConnectClientTypes.WorkerConfigurationSummary]?
}

extension ListWorkerConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workerConfigurations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workerConfigurationsContainer = try containerValues.decodeIfPresent([KafkaConnectClientTypes.WorkerConfigurationSummary?].self, forKey: .workerConfigurations)
        var workerConfigurationsDecoded0:[KafkaConnectClientTypes.WorkerConfigurationSummary]? = nil
        if let workerConfigurationsContainer = workerConfigurationsContainer {
            workerConfigurationsDecoded0 = [KafkaConnectClientTypes.WorkerConfigurationSummary]()
            for structure0 in workerConfigurationsContainer {
                if let structure0 = structure0 {
                    workerConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        workerConfigurations = workerConfigurationsDecoded0
    }
}

extension KafkaConnectClientTypes.LogDelivery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workerLogDelivery
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workerLogDelivery = workerLogDelivery {
            try encodeContainer.encode(workerLogDelivery, forKey: .workerLogDelivery)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerLogDeliveryDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.WorkerLogDelivery.self, forKey: .workerLogDelivery)
        workerLogDelivery = workerLogDeliveryDecoded
    }
}

extension KafkaConnectClientTypes {
    /// Details about log delivery.
    public struct LogDelivery: Swift.Equatable {
        /// The workers can send worker logs to different destination types. This configuration specifies the details of these destinations.
        /// This member is required.
        public var workerLogDelivery: KafkaConnectClientTypes.WorkerLogDelivery?

        public init (
            workerLogDelivery: KafkaConnectClientTypes.WorkerLogDelivery? = nil
        )
        {
            self.workerLogDelivery = workerLogDelivery
        }
    }

}

extension KafkaConnectClientTypes.LogDeliveryDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workerLogDelivery
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workerLogDelivery = workerLogDelivery {
            try encodeContainer.encode(workerLogDelivery, forKey: .workerLogDelivery)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerLogDeliveryDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.WorkerLogDeliveryDescription.self, forKey: .workerLogDelivery)
        workerLogDelivery = workerLogDeliveryDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The description of the log delivery settings.
    public struct LogDeliveryDescription: Swift.Equatable {
        /// The workers can send worker logs to different destination types. This configuration specifies the details of these destinations.
        public var workerLogDelivery: KafkaConnectClientTypes.WorkerLogDeliveryDescription?

        public init (
            workerLogDelivery: KafkaConnectClientTypes.WorkerLogDeliveryDescription? = nil
        )
        {
            self.workerLogDelivery = workerLogDelivery
        }
    }

}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// HTTP Status Code 404: Resource not found due to incorrect input. Correct your request and then retry it.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaConnectClientTypes.Plugin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customPlugin
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customPlugin = customPlugin {
            try encodeContainer.encode(customPlugin, forKey: .customPlugin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customPluginDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CustomPlugin.self, forKey: .customPlugin)
        customPlugin = customPluginDecoded
    }
}

extension KafkaConnectClientTypes {
    /// A plugin is an AWS resource that contains the code that defines your connector logic.
    public struct Plugin: Swift.Equatable {
        /// Details about a custom plugin.
        /// This member is required.
        public var customPlugin: KafkaConnectClientTypes.CustomPlugin?

        public init (
            customPlugin: KafkaConnectClientTypes.CustomPlugin? = nil
        )
        {
            self.customPlugin = customPlugin
        }
    }

}

extension KafkaConnectClientTypes.PluginDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customPlugin
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customPlugin = customPlugin {
            try encodeContainer.encode(customPlugin, forKey: .customPlugin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customPluginDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CustomPluginDescription.self, forKey: .customPlugin)
        customPlugin = customPluginDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The description of the plugin.
    public struct PluginDescription: Swift.Equatable {
        /// Details about a custom plugin.
        public var customPlugin: KafkaConnectClientTypes.CustomPluginDescription?

        public init (
            customPlugin: KafkaConnectClientTypes.CustomPluginDescription? = nil
        )
        {
            self.customPlugin = customPlugin
        }
    }

}

extension KafkaConnectClientTypes.ProvisionedCapacity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mcuCount
        case workerCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if mcuCount != 0 {
            try encodeContainer.encode(mcuCount, forKey: .mcuCount)
        }
        if workerCount != 0 {
            try encodeContainer.encode(workerCount, forKey: .workerCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mcuCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .mcuCount)
        mcuCount = mcuCountDecoded
        let workerCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .workerCount)
        workerCount = workerCountDecoded
    }
}

extension KafkaConnectClientTypes {
    /// Details about a connector's provisioned capacity.
    public struct ProvisionedCapacity: Swift.Equatable {
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        /// This member is required.
        public var mcuCount: Swift.Int
        /// The number of workers that are allocated to the connector.
        /// This member is required.
        public var workerCount: Swift.Int

        public init (
            mcuCount: Swift.Int = 0,
            workerCount: Swift.Int = 0
        )
        {
            self.mcuCount = mcuCount
            self.workerCount = workerCount
        }
    }

}

extension KafkaConnectClientTypes.ProvisionedCapacityDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mcuCount
        case workerCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if mcuCount != 0 {
            try encodeContainer.encode(mcuCount, forKey: .mcuCount)
        }
        if workerCount != 0 {
            try encodeContainer.encode(workerCount, forKey: .workerCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mcuCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .mcuCount)
        mcuCount = mcuCountDecoded
        let workerCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .workerCount)
        workerCount = workerCountDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The description of a connector's provisioned capacity.
    public struct ProvisionedCapacityDescription: Swift.Equatable {
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        public var mcuCount: Swift.Int
        /// The number of workers that are allocated to the connector.
        public var workerCount: Swift.Int

        public init (
            mcuCount: Swift.Int = 0,
            workerCount: Swift.Int = 0
        )
        {
            self.mcuCount = mcuCount
            self.workerCount = workerCount
        }
    }

}

extension KafkaConnectClientTypes.ProvisionedCapacityUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mcuCount
        case workerCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if mcuCount != 0 {
            try encodeContainer.encode(mcuCount, forKey: .mcuCount)
        }
        if workerCount != 0 {
            try encodeContainer.encode(workerCount, forKey: .workerCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mcuCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .mcuCount)
        mcuCount = mcuCountDecoded
        let workerCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .workerCount)
        workerCount = workerCountDecoded
    }
}

extension KafkaConnectClientTypes {
    /// An update to a connector's fixed capacity.
    public struct ProvisionedCapacityUpdate: Swift.Equatable {
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        /// This member is required.
        public var mcuCount: Swift.Int
        /// The number of workers that are allocated to the connector.
        /// This member is required.
        public var workerCount: Swift.Int

        public init (
            mcuCount: Swift.Int = 0,
            workerCount: Swift.Int = 0
        )
        {
            self.mcuCount = mcuCount
            self.workerCount = workerCount
        }
    }

}

extension KafkaConnectClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn
        case fileKey
        case objectVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let fileKey = fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
        if let objectVersion = objectVersion {
            try encodeContainer.encode(objectVersion, forKey: .objectVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
        let objectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectVersion)
        objectVersion = objectVersionDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The location of an object in Amazon S3.
    public struct S3Location: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an S3 bucket.
        /// This member is required.
        public var bucketArn: Swift.String?
        /// The file key for an object in an S3 bucket.
        /// This member is required.
        public var fileKey: Swift.String?
        /// The version of an object in an S3 bucket.
        public var objectVersion: Swift.String?

        public init (
            bucketArn: Swift.String? = nil,
            fileKey: Swift.String? = nil,
            objectVersion: Swift.String? = nil
        )
        {
            self.bucketArn = bucketArn
            self.fileKey = fileKey
            self.objectVersion = objectVersion
        }
    }

}

extension KafkaConnectClientTypes.S3LocationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn
        case fileKey
        case objectVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let fileKey = fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
        if let objectVersion = objectVersion {
            try encodeContainer.encode(objectVersion, forKey: .objectVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
        let objectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectVersion)
        objectVersion = objectVersionDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The description of the location of an object in Amazon S3.
    public struct S3LocationDescription: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an S3 bucket.
        public var bucketArn: Swift.String?
        /// The file key for an object in an S3 bucket.
        public var fileKey: Swift.String?
        /// The version of an object in an S3 bucket.
        public var objectVersion: Swift.String?

        public init (
            bucketArn: Swift.String? = nil,
            fileKey: Swift.String? = nil,
            objectVersion: Swift.String? = nil
        )
        {
            self.bucketArn = bucketArn
            self.fileKey = fileKey
            self.objectVersion = objectVersion
        }
    }

}

extension KafkaConnectClientTypes.S3LogDelivery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case enabled
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let `prefix` = `prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension KafkaConnectClientTypes {
    /// Details about delivering logs to Amazon S3.
    public struct S3LogDelivery: Swift.Equatable {
        /// The name of the S3 bucket that is the destination for log delivery.
        public var bucket: Swift.String?
        /// Specifies whether connector logs get sent to the specified Amazon S3 destination.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The S3 prefix that is the destination for log delivery.
        public var `prefix`: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            enabled: Swift.Bool = false,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.`prefix` = `prefix`
        }
    }

}

extension KafkaConnectClientTypes.S3LogDeliveryDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case enabled
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let `prefix` = `prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The description of the details about delivering logs to Amazon S3.
    public struct S3LogDeliveryDescription: Swift.Equatable {
        /// The name of the S3 bucket that is the destination for log delivery.
        public var bucket: Swift.String?
        /// Specifies whether connector logs get sent to the specified Amazon S3 destination.
        public var enabled: Swift.Bool
        /// The S3 prefix that is the destination for log delivery.
        public var `prefix`: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            enabled: Swift.Bool = false,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.`prefix` = `prefix`
        }
    }

}

extension KafkaConnectClientTypes.ScaleInPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpuUtilizationPercentage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cpuUtilizationPercentage != 0 {
            try encodeContainer.encode(cpuUtilizationPercentage, forKey: .cpuUtilizationPercentage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpuUtilizationPercentageDecoded = try containerValues.decode(Swift.Int.self, forKey: .cpuUtilizationPercentage)
        cpuUtilizationPercentage = cpuUtilizationPercentageDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The scale-in policy for the connector.
    public struct ScaleInPolicy: Swift.Equatable {
        /// Specifies the CPU utilization percentage threshold at which you want connector scale in to be triggered.
        /// This member is required.
        public var cpuUtilizationPercentage: Swift.Int

        public init (
            cpuUtilizationPercentage: Swift.Int = 0
        )
        {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }
    }

}

extension KafkaConnectClientTypes.ScaleInPolicyDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpuUtilizationPercentage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cpuUtilizationPercentage != 0 {
            try encodeContainer.encode(cpuUtilizationPercentage, forKey: .cpuUtilizationPercentage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpuUtilizationPercentageDecoded = try containerValues.decode(Swift.Int.self, forKey: .cpuUtilizationPercentage)
        cpuUtilizationPercentage = cpuUtilizationPercentageDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The description of the scale-in policy for the connector.
    public struct ScaleInPolicyDescription: Swift.Equatable {
        /// Specifies the CPU utilization percentage threshold at which you want connector scale in to be triggered.
        public var cpuUtilizationPercentage: Swift.Int

        public init (
            cpuUtilizationPercentage: Swift.Int = 0
        )
        {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }
    }

}

extension KafkaConnectClientTypes.ScaleInPolicyUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpuUtilizationPercentage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cpuUtilizationPercentage != 0 {
            try encodeContainer.encode(cpuUtilizationPercentage, forKey: .cpuUtilizationPercentage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpuUtilizationPercentageDecoded = try containerValues.decode(Swift.Int.self, forKey: .cpuUtilizationPercentage)
        cpuUtilizationPercentage = cpuUtilizationPercentageDecoded
    }
}

extension KafkaConnectClientTypes {
    /// An update to the connector's scale-in policy.
    public struct ScaleInPolicyUpdate: Swift.Equatable {
        /// The target CPU utilization percentage threshold at which you want connector scale in to be triggered.
        /// This member is required.
        public var cpuUtilizationPercentage: Swift.Int

        public init (
            cpuUtilizationPercentage: Swift.Int = 0
        )
        {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }
    }

}

extension KafkaConnectClientTypes.ScaleOutPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpuUtilizationPercentage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cpuUtilizationPercentage != 0 {
            try encodeContainer.encode(cpuUtilizationPercentage, forKey: .cpuUtilizationPercentage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpuUtilizationPercentageDecoded = try containerValues.decode(Swift.Int.self, forKey: .cpuUtilizationPercentage)
        cpuUtilizationPercentage = cpuUtilizationPercentageDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The scale-out policy for the connector.
    public struct ScaleOutPolicy: Swift.Equatable {
        /// The CPU utilization percentage threshold at which you want connector scale out to be triggered.
        /// This member is required.
        public var cpuUtilizationPercentage: Swift.Int

        public init (
            cpuUtilizationPercentage: Swift.Int = 0
        )
        {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }
    }

}

extension KafkaConnectClientTypes.ScaleOutPolicyDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpuUtilizationPercentage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cpuUtilizationPercentage != 0 {
            try encodeContainer.encode(cpuUtilizationPercentage, forKey: .cpuUtilizationPercentage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpuUtilizationPercentageDecoded = try containerValues.decode(Swift.Int.self, forKey: .cpuUtilizationPercentage)
        cpuUtilizationPercentage = cpuUtilizationPercentageDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The description of the scale-out policy for the connector.
    public struct ScaleOutPolicyDescription: Swift.Equatable {
        /// The CPU utilization percentage threshold at which you want connector scale out to be triggered.
        public var cpuUtilizationPercentage: Swift.Int

        public init (
            cpuUtilizationPercentage: Swift.Int = 0
        )
        {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }
    }

}

extension KafkaConnectClientTypes.ScaleOutPolicyUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpuUtilizationPercentage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cpuUtilizationPercentage != 0 {
            try encodeContainer.encode(cpuUtilizationPercentage, forKey: .cpuUtilizationPercentage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpuUtilizationPercentageDecoded = try containerValues.decode(Swift.Int.self, forKey: .cpuUtilizationPercentage)
        cpuUtilizationPercentage = cpuUtilizationPercentageDecoded
    }
}

extension KafkaConnectClientTypes {
    /// An update to the connector's scale-out policy.
    public struct ScaleOutPolicyUpdate: Swift.Equatable {
        /// The target CPU utilization percentage threshold at which you want connector scale out to be triggered.
        /// This member is required.
        public var cpuUtilizationPercentage: Swift.Int

        public init (
            cpuUtilizationPercentage: Swift.Int = 0
        )
        {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }
    }

}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// HTTP Status Code 503: Service Unavailable. Retrying your request in some time might resolve the issue.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// HTTP Status Code 429: Limit exceeded. Resource limit reached.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// HTTP Status Code 401: Unauthorized request. The provided credentials couldn't be validated.
public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacity = capacity {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
    }
}

extension UpdateConnectorInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let currentVersion = currentVersion {
            let currentVersionQueryItem = ClientRuntime.URLQueryItem(name: "currentVersion".urlPercentEncoding(), value: Swift.String(currentVersion).urlPercentEncoding())
            items.append(currentVersionQueryItem)
        }
        return items
    }
}

extension UpdateConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectorArn = connectorArn else {
            return nil
        }
        return "/v1/connectors/\(connectorArn.urlPercentEncoding())"
    }
}

public struct UpdateConnectorInput: Swift.Equatable {
    /// The target capacity.
    /// This member is required.
    public var capacity: KafkaConnectClientTypes.CapacityUpdate?
    /// The Amazon Resource Name (ARN) of the connector that you want to update.
    /// This member is required.
    public var connectorArn: Swift.String?
    /// The current version of the connector that you want to update.
    /// This member is required.
    public var currentVersion: Swift.String?

    public init (
        capacity: KafkaConnectClientTypes.CapacityUpdate? = nil,
        connectorArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.capacity = capacity
        self.connectorArn = connectorArn
        self.currentVersion = currentVersion
    }
}

struct UpdateConnectorInputBody: Swift.Equatable {
    let capacity: KafkaConnectClientTypes.CapacityUpdate?
}

extension UpdateConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CapacityUpdate.self, forKey: .capacity)
        capacity = capacityDecoded
    }
}

extension UpdateConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConnectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectorArn = output.connectorArn
            self.connectorState = output.connectorState
        } else {
            self.connectorArn = nil
            self.connectorState = nil
        }
    }
}

public struct UpdateConnectorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the connector.
    public var connectorArn: Swift.String?
    /// The state of the connector.
    public var connectorState: KafkaConnectClientTypes.ConnectorState?

    public init (
        connectorArn: Swift.String? = nil,
        connectorState: KafkaConnectClientTypes.ConnectorState? = nil
    )
    {
        self.connectorArn = connectorArn
        self.connectorState = connectorState
    }
}

struct UpdateConnectorOutputResponseBody: Swift.Equatable {
    let connectorArn: Swift.String?
    let connectorState: KafkaConnectClientTypes.ConnectorState?
}

extension UpdateConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorArn
        case connectorState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorArn)
        connectorArn = connectorArnDecoded
        let connectorStateDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.ConnectorState.self, forKey: .connectorState)
        connectorState = connectorStateDecoded
    }
}

extension KafkaConnectClientTypes.Vpc: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroups
        case subnets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for __listof__string0 in securityGroups {
                try securityGroupsContainer.encode(__listof__string0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for __listof__string0 in subnets {
                try subnetsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
    }
}

extension KafkaConnectClientTypes {
    /// Information about the VPC in which the connector resides.
    public struct Vpc: Swift.Equatable {
        /// The security groups for the connector.
        public var securityGroups: [Swift.String]?
        /// The subnets for the connector.
        /// This member is required.
        public var subnets: [Swift.String]?

        public init (
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil
        )
        {
            self.securityGroups = securityGroups
            self.subnets = subnets
        }
    }

}

extension KafkaConnectClientTypes.VpcDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroups
        case subnets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for __listof__string0 in securityGroups {
                try securityGroupsContainer.encode(__listof__string0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for __listof__string0 in subnets {
                try subnetsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
    }
}

extension KafkaConnectClientTypes {
    /// The description of the VPC in which the connector resides.
    public struct VpcDescription: Swift.Equatable {
        /// The security groups for the connector.
        public var securityGroups: [Swift.String]?
        /// The subnets for the connector.
        public var subnets: [Swift.String]?

        public init (
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil
        )
        {
            self.securityGroups = securityGroups
            self.subnets = subnets
        }
    }

}

extension KafkaConnectClientTypes.WorkerConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revision
        case workerConfigurationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if revision != 0 {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let workerConfigurationArn = workerConfigurationArn {
            try encodeContainer.encode(workerConfigurationArn, forKey: .workerConfigurationArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionDecoded = try containerValues.decode(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
        let workerConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerConfigurationArn)
        workerConfigurationArn = workerConfigurationArnDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The configuration of the workers, which are the processes that run the connector logic.
    public struct WorkerConfiguration: Swift.Equatable {
        /// The revision of the worker configuration.
        /// This member is required.
        public var revision: Swift.Int
        /// The Amazon Resource Name (ARN) of the worker configuration.
        /// This member is required.
        public var workerConfigurationArn: Swift.String?

        public init (
            revision: Swift.Int = 0,
            workerConfigurationArn: Swift.String? = nil
        )
        {
            self.revision = revision
            self.workerConfigurationArn = workerConfigurationArn
        }
    }

}

extension KafkaConnectClientTypes.WorkerConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revision
        case workerConfigurationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if revision != 0 {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let workerConfigurationArn = workerConfigurationArn {
            try encodeContainer.encode(workerConfigurationArn, forKey: .workerConfigurationArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionDecoded = try containerValues.decode(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
        let workerConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerConfigurationArn)
        workerConfigurationArn = workerConfigurationArnDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The description of the worker configuration.
    public struct WorkerConfigurationDescription: Swift.Equatable {
        /// The revision of the worker configuration.
        public var revision: Swift.Int
        /// The Amazon Resource Name (ARN) of the worker configuration.
        public var workerConfigurationArn: Swift.String?

        public init (
            revision: Swift.Int = 0,
            workerConfigurationArn: Swift.String? = nil
        )
        {
            self.revision = revision
            self.workerConfigurationArn = workerConfigurationArn
        }
    }

}

extension KafkaConnectClientTypes.WorkerConfigurationRevisionDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case propertiesFileContent
        case revision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let propertiesFileContent = propertiesFileContent {
            try encodeContainer.encode(propertiesFileContent, forKey: .propertiesFileContent)
        }
        if revision != 0 {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertiesFileContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertiesFileContent)
        propertiesFileContent = propertiesFileContentDecoded
        let revisionDecoded = try containerValues.decode(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The description of the worker configuration revision.
    public struct WorkerConfigurationRevisionDescription: Swift.Equatable {
        /// The time that the worker configuration was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the worker configuration revision.
        public var description: Swift.String?
        /// Base64 encoded contents of the connect-distributed.properties file.
        public var propertiesFileContent: Swift.String?
        /// The description of a revision of the worker configuration.
        public var revision: Swift.Int

        public init (
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            propertiesFileContent: Swift.String? = nil,
            revision: Swift.Int = 0
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.propertiesFileContent = propertiesFileContent
            self.revision = revision
        }
    }

}

extension KafkaConnectClientTypes.WorkerConfigurationRevisionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case revision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if revision != 0 {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let revisionDecoded = try containerValues.decode(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The summary of a worker configuration revision.
    public struct WorkerConfigurationRevisionSummary: Swift.Equatable {
        /// The time that a worker configuration revision was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of a worker configuration revision.
        public var description: Swift.String?
        /// The revision of a worker configuration.
        public var revision: Swift.Int

        public init (
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            revision: Swift.Int = 0
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.revision = revision
        }
    }

}

extension KafkaConnectClientTypes.WorkerConfigurationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case latestRevision
        case name
        case workerConfigurationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let latestRevision = latestRevision {
            try encodeContainer.encode(latestRevision, forKey: .latestRevision)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let workerConfigurationArn = workerConfigurationArn {
            try encodeContainer.encode(workerConfigurationArn, forKey: .workerConfigurationArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.WorkerConfigurationRevisionSummary.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let workerConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerConfigurationArn)
        workerConfigurationArn = workerConfigurationArnDecoded
    }
}

extension KafkaConnectClientTypes {
    /// The summary of a worker configuration.
    public struct WorkerConfigurationSummary: Swift.Equatable {
        /// The time that a worker configuration was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of a worker configuration.
        public var description: Swift.String?
        /// The latest revision of a worker configuration.
        public var latestRevision: KafkaConnectClientTypes.WorkerConfigurationRevisionSummary?
        /// The name of the worker configuration.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the worker configuration.
        public var workerConfigurationArn: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            latestRevision: KafkaConnectClientTypes.WorkerConfigurationRevisionSummary? = nil,
            name: Swift.String? = nil,
            workerConfigurationArn: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.latestRevision = latestRevision
            self.name = name
            self.workerConfigurationArn = workerConfigurationArn
        }
    }

}

extension KafkaConnectClientTypes.WorkerLogDelivery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogs
        case firehose
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogs = cloudWatchLogs {
            try encodeContainer.encode(cloudWatchLogs, forKey: .cloudWatchLogs)
        }
        if let firehose = firehose {
            try encodeContainer.encode(firehose, forKey: .firehose)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CloudWatchLogsLogDelivery.self, forKey: .cloudWatchLogs)
        cloudWatchLogs = cloudWatchLogsDecoded
        let firehoseDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.FirehoseLogDelivery.self, forKey: .firehose)
        firehose = firehoseDecoded
        let s3Decoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.S3LogDelivery.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension KafkaConnectClientTypes {
    /// Workers can send worker logs to different destination types. This configuration specifies the details of these destinations.
    public struct WorkerLogDelivery: Swift.Equatable {
        /// Details about delivering logs to Amazon CloudWatch Logs.
        public var cloudWatchLogs: KafkaConnectClientTypes.CloudWatchLogsLogDelivery?
        /// Details about delivering logs to Amazon Kinesis Data Firehose.
        public var firehose: KafkaConnectClientTypes.FirehoseLogDelivery?
        /// Details about delivering logs to Amazon S3.
        public var s3: KafkaConnectClientTypes.S3LogDelivery?

        public init (
            cloudWatchLogs: KafkaConnectClientTypes.CloudWatchLogsLogDelivery? = nil,
            firehose: KafkaConnectClientTypes.FirehoseLogDelivery? = nil,
            s3: KafkaConnectClientTypes.S3LogDelivery? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.firehose = firehose
            self.s3 = s3
        }
    }

}

extension KafkaConnectClientTypes.WorkerLogDeliveryDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogs
        case firehose
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogs = cloudWatchLogs {
            try encodeContainer.encode(cloudWatchLogs, forKey: .cloudWatchLogs)
        }
        if let firehose = firehose {
            try encodeContainer.encode(firehose, forKey: .firehose)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.CloudWatchLogsLogDeliveryDescription.self, forKey: .cloudWatchLogs)
        cloudWatchLogs = cloudWatchLogsDecoded
        let firehoseDecoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.FirehoseLogDeliveryDescription.self, forKey: .firehose)
        firehose = firehoseDecoded
        let s3Decoded = try containerValues.decodeIfPresent(KafkaConnectClientTypes.S3LogDeliveryDescription.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension KafkaConnectClientTypes {
    /// Workers can send worker logs to different destination types. This configuration specifies the details of these destinations.
    public struct WorkerLogDeliveryDescription: Swift.Equatable {
        /// Details about delivering logs to Amazon CloudWatch Logs.
        public var cloudWatchLogs: KafkaConnectClientTypes.CloudWatchLogsLogDeliveryDescription?
        /// Details about delivering logs to Amazon Kinesis Data Firehose.
        public var firehose: KafkaConnectClientTypes.FirehoseLogDeliveryDescription?
        /// Details about delivering logs to Amazon S3.
        public var s3: KafkaConnectClientTypes.S3LogDeliveryDescription?

        public init (
            cloudWatchLogs: KafkaConnectClientTypes.CloudWatchLogsLogDeliveryDescription? = nil,
            firehose: KafkaConnectClientTypes.FirehoseLogDeliveryDescription? = nil,
            s3: KafkaConnectClientTypes.S3LogDeliveryDescription? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.firehose = firehose
            self.s3 = s3
        }
    }

}
