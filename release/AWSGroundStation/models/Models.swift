// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension GroundStationClientTypes {
    public enum AngleUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case degreeAngle
        case radian
        case sdkUnknown(Swift.String)

        public static var allCases: [AngleUnits] {
            return [
                .degreeAngle,
                .radian,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .degreeAngle: return "DEGREE_ANGLE"
            case .radian: return "RADIAN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AngleUnits(rawValue: rawValue) ?? AngleUnits.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.AntennaDemodDecodeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputNode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputNode = outputNode {
            try encodeContainer.encode(outputNode, forKey: .outputNode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputNodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputNode)
        outputNode = outputNodeDecoded
    }
}

extension GroundStationClientTypes {
    /// Details about an antenna demod decode Config used in a contact.
    public struct AntennaDemodDecodeDetails: Swift.Equatable {
        /// Name of an antenna demod decode output node used in a contact.
        public var outputNode: Swift.String?

        public init (
            outputNode: Swift.String? = nil
        )
        {
            self.outputNode = outputNode
        }
    }

}

extension GroundStationClientTypes.AntennaDownlinkConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case spectrumConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spectrumConfig = spectrumConfig {
            try encodeContainer.encode(spectrumConfig, forKey: .spectrumConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spectrumConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SpectrumConfig.self, forKey: .spectrumConfig)
        spectrumConfig = spectrumConfigDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about how AWS Ground Station should configure an antenna for downlink during a contact.
    public struct AntennaDownlinkConfig: Swift.Equatable {
        /// Object that describes a spectral Config.
        /// This member is required.
        public var spectrumConfig: GroundStationClientTypes.SpectrumConfig?

        public init (
            spectrumConfig: GroundStationClientTypes.SpectrumConfig? = nil
        )
        {
            self.spectrumConfig = spectrumConfig
        }
    }

}

extension GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decodeConfig
        case demodulationConfig
        case spectrumConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decodeConfig = decodeConfig {
            try encodeContainer.encode(decodeConfig, forKey: .decodeConfig)
        }
        if let demodulationConfig = demodulationConfig {
            try encodeContainer.encode(demodulationConfig, forKey: .demodulationConfig)
        }
        if let spectrumConfig = spectrumConfig {
            try encodeContainer.encode(spectrumConfig, forKey: .spectrumConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spectrumConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SpectrumConfig.self, forKey: .spectrumConfig)
        spectrumConfig = spectrumConfigDecoded
        let demodulationConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.DemodulationConfig.self, forKey: .demodulationConfig)
        demodulationConfig = demodulationConfigDecoded
        let decodeConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.DecodeConfig.self, forKey: .decodeConfig)
        decodeConfig = decodeConfigDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about how AWS Ground Station should conﬁgure an antenna for downlink demod decode during a contact.
    public struct AntennaDownlinkDemodDecodeConfig: Swift.Equatable {
        /// Information about the decode Config.
        /// This member is required.
        public var decodeConfig: GroundStationClientTypes.DecodeConfig?
        /// Information about the demodulation Config.
        /// This member is required.
        public var demodulationConfig: GroundStationClientTypes.DemodulationConfig?
        /// Information about the spectral Config.
        /// This member is required.
        public var spectrumConfig: GroundStationClientTypes.SpectrumConfig?

        public init (
            decodeConfig: GroundStationClientTypes.DecodeConfig? = nil,
            demodulationConfig: GroundStationClientTypes.DemodulationConfig? = nil,
            spectrumConfig: GroundStationClientTypes.SpectrumConfig? = nil
        )
        {
            self.decodeConfig = decodeConfig
            self.demodulationConfig = demodulationConfig
            self.spectrumConfig = spectrumConfig
        }
    }

}

extension GroundStationClientTypes.AntennaUplinkConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case spectrumConfig
        case targetEirp
        case transmitDisabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spectrumConfig = spectrumConfig {
            try encodeContainer.encode(spectrumConfig, forKey: .spectrumConfig)
        }
        if let targetEirp = targetEirp {
            try encodeContainer.encode(targetEirp, forKey: .targetEirp)
        }
        if let transmitDisabled = transmitDisabled {
            try encodeContainer.encode(transmitDisabled, forKey: .transmitDisabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transmitDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .transmitDisabled)
        transmitDisabled = transmitDisabledDecoded
        let spectrumConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.UplinkSpectrumConfig.self, forKey: .spectrumConfig)
        spectrumConfig = spectrumConfigDecoded
        let targetEirpDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Eirp.self, forKey: .targetEirp)
        targetEirp = targetEirpDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the uplink Config of an antenna.
    public struct AntennaUplinkConfig: Swift.Equatable {
        /// Information about the uplink spectral Config.
        /// This member is required.
        public var spectrumConfig: GroundStationClientTypes.UplinkSpectrumConfig?
        /// EIRP of the target.
        /// This member is required.
        public var targetEirp: GroundStationClientTypes.Eirp?
        /// Whether or not uplink transmit is disabled.
        public var transmitDisabled: Swift.Bool?

        public init (
            spectrumConfig: GroundStationClientTypes.UplinkSpectrumConfig? = nil,
            targetEirp: GroundStationClientTypes.Eirp? = nil,
            transmitDisabled: Swift.Bool? = nil
        )
        {
            self.spectrumConfig = spectrumConfig
            self.targetEirp = targetEirp
            self.transmitDisabled = transmitDisabled
        }
    }

}

extension GroundStationClientTypes {
    public enum BandwidthUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ghz
        case khz
        case mhz
        case sdkUnknown(Swift.String)

        public static var allCases: [BandwidthUnits] {
            return [
                .ghz,
                .khz,
                .mhz,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ghz: return "GHz"
            case .khz: return "kHz"
            case .mhz: return "MHz"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BandwidthUnits(rawValue: rawValue) ?? BandwidthUnits.sdkUnknown(rawValue)
        }
    }
}

extension CancelContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let contactId = contactId else {
            return nil
        }
        return "/contact/\(contactId.urlPercentEncoding())"
    }
}

///
public struct CancelContactInput: Swift.Equatable {
    /// UUID of a contact.
    /// This member is required.
    public var contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct CancelContactInputBody: Swift.Equatable {
}

extension CancelContactInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelContactOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
        } else {
            self.contactId = nil
        }
    }
}

///
public struct CancelContactOutputResponse: Swift.Equatable {
    /// UUID of a contact.
    public var contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct CancelContactOutputResponseBody: Swift.Equatable {
    let contactId: Swift.String?
}

extension CancelContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension GroundStationClientTypes {
    public enum ConfigCapabilityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case antennaDownlink
        case antennaDownlinkDemodDecode
        case antennaUplink
        case dataflowEndpoint
        case s3Recording
        case tracking
        case uplinkEcho
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigCapabilityType] {
            return [
                .antennaDownlink,
                .antennaDownlinkDemodDecode,
                .antennaUplink,
                .dataflowEndpoint,
                .s3Recording,
                .tracking,
                .uplinkEcho,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .antennaDownlink: return "antenna-downlink"
            case .antennaDownlinkDemodDecode: return "antenna-downlink-demod-decode"
            case .antennaUplink: return "antenna-uplink"
            case .dataflowEndpoint: return "dataflow-endpoint"
            case .s3Recording: return "s3-recording"
            case .tracking: return "tracking"
            case .uplinkEcho: return "uplink-echo"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigCapabilityType(rawValue: rawValue) ?? ConfigCapabilityType.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.ConfigDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case antennademoddecodedetails = "antennaDemodDecodeDetails"
        case endpointdetails = "endpointDetails"
        case s3recordingdetails = "s3RecordingDetails"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .antennademoddecodedetails(antennademoddecodedetails):
                try container.encode(antennademoddecodedetails, forKey: .antennademoddecodedetails)
            case let .endpointdetails(endpointdetails):
                try container.encode(endpointdetails, forKey: .endpointdetails)
            case let .s3recordingdetails(s3recordingdetails):
                try container.encode(s3recordingdetails, forKey: .s3recordingdetails)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let endpointdetailsDecoded = try values.decodeIfPresent(GroundStationClientTypes.EndpointDetails.self, forKey: .endpointdetails)
        if let endpointdetails = endpointdetailsDecoded {
            self = .endpointdetails(endpointdetails)
            return
        }
        let antennademoddecodedetailsDecoded = try values.decodeIfPresent(GroundStationClientTypes.AntennaDemodDecodeDetails.self, forKey: .antennademoddecodedetails)
        if let antennademoddecodedetails = antennademoddecodedetailsDecoded {
            self = .antennademoddecodedetails(antennademoddecodedetails)
            return
        }
        let s3recordingdetailsDecoded = try values.decodeIfPresent(GroundStationClientTypes.S3RecordingDetails.self, forKey: .s3recordingdetails)
        if let s3recordingdetails = s3recordingdetailsDecoded {
            self = .s3recordingdetails(s3recordingdetails)
            return
        }
        self = .sdkUnknown("")
    }
}

extension GroundStationClientTypes {
    /// Details for certain Config object types in a contact.
    public enum ConfigDetails: Swift.Equatable {
        /// Information about the endpoint details.
        case endpointdetails(GroundStationClientTypes.EndpointDetails)
        /// Details for antenna demod decode Config in a contact.
        case antennademoddecodedetails(GroundStationClientTypes.AntennaDemodDecodeDetails)
        /// Details for an S3 recording Config in a contact.
        case s3recordingdetails(GroundStationClientTypes.S3RecordingDetails)
        case sdkUnknown(Swift.String)
    }

}

extension GroundStationClientTypes.ConfigListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configId
        case configType
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configArn = configArn {
            try encodeContainer.encode(configArn, forKey: .configArn)
        }
        if let configId = configId {
            try encodeContainer.encode(configId, forKey: .configId)
        }
        if let configType = configType {
            try encodeContainer.encode(configType.rawValue, forKey: .configType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GroundStationClientTypes {
    /// An item in a list of Config objects.
    public struct ConfigListItem: Swift.Equatable {
        /// ARN of a Config.
        public var configArn: Swift.String?
        /// UUID of a Config.
        public var configId: Swift.String?
        /// Type of a Config.
        public var configType: GroundStationClientTypes.ConfigCapabilityType?
        /// Name of a Config.
        public var name: Swift.String?

        public init (
            configArn: Swift.String? = nil,
            configId: Swift.String? = nil,
            configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
            name: Swift.String? = nil
        )
        {
            self.configArn = configArn
            self.configId = configId
            self.configType = configType
            self.name = name
        }
    }

}

extension GroundStationClientTypes.ConfigTypeData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case antennadownlinkconfig = "antennaDownlinkConfig"
        case antennadownlinkdemoddecodeconfig = "antennaDownlinkDemodDecodeConfig"
        case antennauplinkconfig = "antennaUplinkConfig"
        case dataflowendpointconfig = "dataflowEndpointConfig"
        case s3recordingconfig = "s3RecordingConfig"
        case sdkUnknown
        case trackingconfig = "trackingConfig"
        case uplinkechoconfig = "uplinkEchoConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .antennadownlinkconfig(antennadownlinkconfig):
                try container.encode(antennadownlinkconfig, forKey: .antennadownlinkconfig)
            case let .antennadownlinkdemoddecodeconfig(antennadownlinkdemoddecodeconfig):
                try container.encode(antennadownlinkdemoddecodeconfig, forKey: .antennadownlinkdemoddecodeconfig)
            case let .antennauplinkconfig(antennauplinkconfig):
                try container.encode(antennauplinkconfig, forKey: .antennauplinkconfig)
            case let .dataflowendpointconfig(dataflowendpointconfig):
                try container.encode(dataflowendpointconfig, forKey: .dataflowendpointconfig)
            case let .s3recordingconfig(s3recordingconfig):
                try container.encode(s3recordingconfig, forKey: .s3recordingconfig)
            case let .trackingconfig(trackingconfig):
                try container.encode(trackingconfig, forKey: .trackingconfig)
            case let .uplinkechoconfig(uplinkechoconfig):
                try container.encode(uplinkechoconfig, forKey: .uplinkechoconfig)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let antennadownlinkconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.AntennaDownlinkConfig.self, forKey: .antennadownlinkconfig)
        if let antennadownlinkconfig = antennadownlinkconfigDecoded {
            self = .antennadownlinkconfig(antennadownlinkconfig)
            return
        }
        let trackingconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.TrackingConfig.self, forKey: .trackingconfig)
        if let trackingconfig = trackingconfigDecoded {
            self = .trackingconfig(trackingconfig)
            return
        }
        let dataflowendpointconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.DataflowEndpointConfig.self, forKey: .dataflowendpointconfig)
        if let dataflowendpointconfig = dataflowendpointconfigDecoded {
            self = .dataflowendpointconfig(dataflowendpointconfig)
            return
        }
        let antennadownlinkdemoddecodeconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig.self, forKey: .antennadownlinkdemoddecodeconfig)
        if let antennadownlinkdemoddecodeconfig = antennadownlinkdemoddecodeconfigDecoded {
            self = .antennadownlinkdemoddecodeconfig(antennadownlinkdemoddecodeconfig)
            return
        }
        let antennauplinkconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.AntennaUplinkConfig.self, forKey: .antennauplinkconfig)
        if let antennauplinkconfig = antennauplinkconfigDecoded {
            self = .antennauplinkconfig(antennauplinkconfig)
            return
        }
        let uplinkechoconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.UplinkEchoConfig.self, forKey: .uplinkechoconfig)
        if let uplinkechoconfig = uplinkechoconfigDecoded {
            self = .uplinkechoconfig(uplinkechoconfig)
            return
        }
        let s3recordingconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.S3RecordingConfig.self, forKey: .s3recordingconfig)
        if let s3recordingconfig = s3recordingconfigDecoded {
            self = .s3recordingconfig(s3recordingconfig)
            return
        }
        self = .sdkUnknown("")
    }
}

extension GroundStationClientTypes {
    /// Object containing the parameters of a Config. See the subtype definitions for what each type of Config contains.
    public enum ConfigTypeData: Swift.Equatable {
        /// Information about how AWS Ground Station should configure an antenna for downlink during a contact.
        case antennadownlinkconfig(GroundStationClientTypes.AntennaDownlinkConfig)
        /// Object that determines whether tracking should be used during a contact executed with this Config in the mission profile.
        case trackingconfig(GroundStationClientTypes.TrackingConfig)
        /// Information about the dataflow endpoint Config.
        case dataflowendpointconfig(GroundStationClientTypes.DataflowEndpointConfig)
        /// Information about how AWS Ground Station should conﬁgure an antenna for downlink demod decode during a contact.
        case antennadownlinkdemoddecodeconfig(GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig)
        /// Information about how AWS Ground Station should conﬁgure an antenna for uplink during a contact.
        case antennauplinkconfig(GroundStationClientTypes.AntennaUplinkConfig)
        /// Information about an uplink echo Config. Parameters from the AntennaUplinkConfig, corresponding to the specified AntennaUplinkConfigArn, are used when this UplinkEchoConfig is used in a contact.
        case uplinkechoconfig(GroundStationClientTypes.UplinkEchoConfig)
        /// Information about an S3 recording Config.
        case s3recordingconfig(GroundStationClientTypes.S3RecordingConfig)
        case sdkUnknown(Swift.String)
    }

}

extension GroundStationClientTypes.ContactData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId
        case contactStatus
        case endTime
        case errorMessage
        case groundStation
        case maximumElevation
        case missionProfileArn
        case postPassEndTime
        case prePassStartTime
        case region
        case satelliteArn
        case startTime
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let contactStatus = contactStatus {
            try encodeContainer.encode(contactStatus.rawValue, forKey: .contactStatus)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let groundStation = groundStation {
            try encodeContainer.encode(groundStation, forKey: .groundStation)
        }
        if let maximumElevation = maximumElevation {
            try encodeContainer.encode(maximumElevation, forKey: .maximumElevation)
        }
        if let missionProfileArn = missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let postPassEndTime = postPassEndTime {
            try encodeContainer.encode(postPassEndTime.timeIntervalSince1970, forKey: .postPassEndTime)
        }
        if let prePassStartTime = prePassStartTime {
            try encodeContainer.encode(prePassStartTime.timeIntervalSince1970, forKey: .prePassStartTime)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let satelliteArn = satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let prePassStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .prePassStartTime)
        prePassStartTime = prePassStartTimeDecoded
        let postPassEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .postPassEndTime)
        postPassEndTime = postPassEndTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let contactStatusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ContactStatus.self, forKey: .contactStatus)
        contactStatus = contactStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let maximumElevationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Elevation.self, forKey: .maximumElevation)
        maximumElevation = maximumElevationDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GroundStationClientTypes {
    /// Data describing a contact.
    public struct ContactData: Swift.Equatable {
        /// UUID of a contact.
        public var contactId: Swift.String?
        /// Status of a contact.
        public var contactStatus: GroundStationClientTypes.ContactStatus?
        /// End time of a contact.
        public var endTime: ClientRuntime.Date?
        /// Error message of a contact.
        public var errorMessage: Swift.String?
        /// Name of a ground station.
        public var groundStation: Swift.String?
        /// Maximum elevation angle of a contact.
        public var maximumElevation: GroundStationClientTypes.Elevation?
        /// ARN of a mission profile.
        public var missionProfileArn: Swift.String?
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public var postPassEndTime: ClientRuntime.Date?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public var prePassStartTime: ClientRuntime.Date?
        /// Region of a contact.
        public var region: Swift.String?
        /// ARN of a satellite.
        public var satelliteArn: Swift.String?
        /// Start time of a contact.
        public var startTime: ClientRuntime.Date?
        /// Tags assigned to a contact.
        public var tags: [Swift.String:Swift.String]?

        public init (
            contactId: Swift.String? = nil,
            contactStatus: GroundStationClientTypes.ContactStatus? = nil,
            endTime: ClientRuntime.Date? = nil,
            errorMessage: Swift.String? = nil,
            groundStation: Swift.String? = nil,
            maximumElevation: GroundStationClientTypes.Elevation? = nil,
            missionProfileArn: Swift.String? = nil,
            postPassEndTime: ClientRuntime.Date? = nil,
            prePassStartTime: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            satelliteArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.contactId = contactId
            self.contactStatus = contactStatus
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.groundStation = groundStation
            self.maximumElevation = maximumElevation
            self.missionProfileArn = missionProfileArn
            self.postPassEndTime = postPassEndTime
            self.prePassStartTime = prePassStartTime
            self.region = region
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
        }
    }

}

extension GroundStationClientTypes {
    public enum ContactStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case awsCancelled
        case awsFailed
        case cancelled
        case cancelling
        case completed
        case failed
        case failedToSchedule
        case pass
        case postpass
        case prepass
        case scheduled
        case scheduling
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactStatus] {
            return [
                .available,
                .awsCancelled,
                .awsFailed,
                .cancelled,
                .cancelling,
                .completed,
                .failed,
                .failedToSchedule,
                .pass,
                .postpass,
                .prepass,
                .scheduled,
                .scheduling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .awsCancelled: return "AWS_CANCELLED"
            case .awsFailed: return "AWS_FAILED"
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .failedToSchedule: return "FAILED_TO_SCHEDULE"
            case .pass: return "PASS"
            case .postpass: return "POSTPASS"
            case .prepass: return "PREPASS"
            case .scheduled: return "SCHEDULED"
            case .scheduling: return "SCHEDULING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactStatus(rawValue: rawValue) ?? ContactStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configData
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configData = configData {
            try encodeContainer.encode(configData, forKey: .configData)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/config"
    }
}

///
public struct CreateConfigInput: Swift.Equatable {
    /// Parameters of a Config.
    /// This member is required.
    public var configData: GroundStationClientTypes.ConfigTypeData?
    /// Name of a Config.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to a Config.
    public var tags: [Swift.String:Swift.String]?

    public init (
        configData: GroundStationClientTypes.ConfigTypeData? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.configData = configData
        self.name = name
        self.tags = tags
    }
}

struct CreateConfigInputBody: Swift.Equatable {
    let name: Swift.String?
    let configData: GroundStationClientTypes.ConfigTypeData?
    let tags: [Swift.String:Swift.String]?
}

extension CreateConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configData
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configDataDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigTypeData.self, forKey: .configData)
        configData = configDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configArn = output.configArn
            self.configId = output.configId
            self.configType = output.configType
        } else {
            self.configArn = nil
            self.configId = nil
            self.configType = nil
        }
    }
}

///
public struct CreateConfigOutputResponse: Swift.Equatable {
    /// ARN of a Config.
    public var configArn: Swift.String?
    /// UUID of a Config.
    public var configId: Swift.String?
    /// Type of a Config.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init (
        configArn: Swift.String? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

struct CreateConfigOutputResponseBody: Swift.Equatable {
    let configId: Swift.String?
    let configType: GroundStationClientTypes.ConfigCapabilityType?
    let configArn: Swift.String?
}

extension CreateConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configId
        case configType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
    }
}

extension CreateDataflowEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointDetails
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointDetails = endpointDetails {
            var endpointDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointDetails)
            for endpointdetailslist0 in endpointDetails {
                try endpointDetailsContainer.encode(endpointdetailslist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDataflowEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/dataflowEndpointGroup"
    }
}

///
public struct CreateDataflowEndpointGroupInput: Swift.Equatable {
    /// Endpoint details of each endpoint in the dataflow endpoint group.
    /// This member is required.
    public var endpointDetails: [GroundStationClientTypes.EndpointDetails]?
    /// Tags of a dataflow endpoint group.
    public var tags: [Swift.String:Swift.String]?

    public init (
        endpointDetails: [GroundStationClientTypes.EndpointDetails]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.endpointDetails = endpointDetails
        self.tags = tags
    }
}

struct CreateDataflowEndpointGroupInputBody: Swift.Equatable {
    let endpointDetails: [GroundStationClientTypes.EndpointDetails]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDataflowEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointDetails
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDetailsContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.EndpointDetails?].self, forKey: .endpointDetails)
        var endpointDetailsDecoded0:[GroundStationClientTypes.EndpointDetails]? = nil
        if let endpointDetailsContainer = endpointDetailsContainer {
            endpointDetailsDecoded0 = [GroundStationClientTypes.EndpointDetails]()
            for structure0 in endpointDetailsContainer {
                if let structure0 = structure0 {
                    endpointDetailsDecoded0?.append(structure0)
                }
            }
        }
        endpointDetails = endpointDetailsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataflowEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataflowEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataflowEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataflowEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDataflowEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataflowEndpointGroupId = output.dataflowEndpointGroupId
        } else {
            self.dataflowEndpointGroupId = nil
        }
    }
}

///
public struct CreateDataflowEndpointGroupOutputResponse: Swift.Equatable {
    /// UUID of a dataflow endpoint group.
    public var dataflowEndpointGroupId: Swift.String?

    public init (
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct CreateDataflowEndpointGroupOutputResponseBody: Swift.Equatable {
    let dataflowEndpointGroupId: Swift.String?
}

extension CreateDataflowEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
    }
}

extension CreateMissionProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case tags
        case trackingConfigArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactPostPassDurationSeconds = contactPostPassDurationSeconds {
            try encodeContainer.encode(contactPostPassDurationSeconds, forKey: .contactPostPassDurationSeconds)
        }
        if let contactPrePassDurationSeconds = contactPrePassDurationSeconds {
            try encodeContainer.encode(contactPrePassDurationSeconds, forKey: .contactPrePassDurationSeconds)
        }
        if let dataflowEdges = dataflowEdges {
            var dataflowEdgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataflowEdges)
            for dataflowedgelist0 in dataflowEdges {
                var dataflowedgelist0Container = dataflowEdgesContainer.nestedUnkeyedContainer()
                for dataflowedge1 in dataflowedgelist0 {
                    try dataflowedgelist0Container.encode(dataflowedge1)
                }
            }
        }
        if let minimumViableContactDurationSeconds = minimumViableContactDurationSeconds {
            try encodeContainer.encode(minimumViableContactDurationSeconds, forKey: .minimumViableContactDurationSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let trackingConfigArn = trackingConfigArn {
            try encodeContainer.encode(trackingConfigArn, forKey: .trackingConfigArn)
        }
    }
}

extension CreateMissionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/missionprofile"
    }
}

///
public struct CreateMissionProfileInput: Swift.Equatable {
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var contactPostPassDurationSeconds: Swift.Int?
    /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
    public var contactPrePassDurationSeconds: Swift.Int?
    /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
    /// This member is required.
    public var dataflowEdges: [[Swift.String]]?
    /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
    /// This member is required.
    public var minimumViableContactDurationSeconds: Swift.Int?
    /// Name of a mission profile.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to a mission profile.
    public var tags: [Swift.String:Swift.String]?
    /// ARN of a tracking Config.
    /// This member is required.
    public var trackingConfigArn: Swift.String?

    public init (
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEdges: [[Swift.String]]? = nil,
        minimumViableContactDurationSeconds: Swift.Int? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trackingConfigArn: Swift.String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.name = name
        self.tags = tags
        self.trackingConfigArn = trackingConfigArn
    }
}

struct CreateMissionProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let contactPrePassDurationSeconds: Swift.Int?
    let contactPostPassDurationSeconds: Swift.Int?
    let minimumViableContactDurationSeconds: Swift.Int?
    let dataflowEdges: [[Swift.String]]?
    let trackingConfigArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateMissionProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case tags
        case trackingConfigArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
        let minimumViableContactDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumViableContactDurationSeconds)
        minimumViableContactDurationSeconds = minimumViableContactDurationSecondsDecoded
        let dataflowEdgesContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .dataflowEdges)
        var dataflowEdgesDecoded0:[[Swift.String]]? = nil
        if let dataflowEdgesContainer = dataflowEdgesContainer {
            dataflowEdgesDecoded0 = [[Swift.String]]()
            for list0 in dataflowEdgesContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    dataflowEdgesDecoded0?.append(list0Decoded0)
                }
            }
        }
        dataflowEdges = dataflowEdgesDecoded0
        let trackingConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingConfigArn)
        trackingConfigArn = trackingConfigArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMissionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMissionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMissionProfileOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMissionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMissionProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.missionProfileId = output.missionProfileId
        } else {
            self.missionProfileId = nil
        }
    }
}

///
public struct CreateMissionProfileOutputResponse: Swift.Equatable {
    /// UUID of a mission profile.
    public var missionProfileId: Swift.String?

    public init (
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct CreateMissionProfileOutputResponseBody: Swift.Equatable {
    let missionProfileId: Swift.String?
}

extension CreateMissionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
    }
}

extension GroundStationClientTypes {
    public enum Criticality: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case preferred
        case removed
        case `required`
        case sdkUnknown(Swift.String)

        public static var allCases: [Criticality] {
            return [
                .preferred,
                .removed,
                .required,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .preferred: return "PREFERRED"
            case .removed: return "REMOVED"
            case .required: return "REQUIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Criticality(rawValue: rawValue) ?? Criticality.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.DataflowDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case errorMessage
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about a dataflow edge used in a contact.
    public struct DataflowDetail: Swift.Equatable {
        /// Dataflow details for the destination side.
        public var destination: GroundStationClientTypes.Destination?
        /// Error message for a dataflow.
        public var errorMessage: Swift.String?
        /// Dataflow details for the source side.
        public var source: GroundStationClientTypes.Source?

        public init (
            destination: GroundStationClientTypes.Destination? = nil,
            errorMessage: Swift.String? = nil,
            source: GroundStationClientTypes.Source? = nil
        )
        {
            self.destination = destination
            self.errorMessage = errorMessage
            self.source = source
        }
    }

}

extension GroundStationClientTypes.DataflowEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address
        case mtu
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let mtu = mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let addressDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SocketAddress.self, forKey: .address)
        address = addressDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EndpointStatus.self, forKey: .status)
        status = statusDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about a dataflow endpoint.
    public struct DataflowEndpoint: Swift.Equatable {
        /// Socket address of a dataflow endpoint.
        public var address: GroundStationClientTypes.SocketAddress?
        /// Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.
        public var mtu: Swift.Int?
        /// Name of a dataflow endpoint.
        public var name: Swift.String?
        /// Status of a dataflow endpoint.
        public var status: GroundStationClientTypes.EndpointStatus?

        public init (
            address: GroundStationClientTypes.SocketAddress? = nil,
            mtu: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: GroundStationClientTypes.EndpointStatus? = nil
        )
        {
            self.address = address
            self.mtu = mtu
            self.name = name
            self.status = status
        }
    }

}

extension GroundStationClientTypes.DataflowEndpointConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointName
        case dataflowEndpointRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataflowEndpointName = dataflowEndpointName {
            try encodeContainer.encode(dataflowEndpointName, forKey: .dataflowEndpointName)
        }
        if let dataflowEndpointRegion = dataflowEndpointRegion {
            try encodeContainer.encode(dataflowEndpointRegion, forKey: .dataflowEndpointRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointName)
        dataflowEndpointName = dataflowEndpointNameDecoded
        let dataflowEndpointRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointRegion)
        dataflowEndpointRegion = dataflowEndpointRegionDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the dataflow endpoint Config.
    public struct DataflowEndpointConfig: Swift.Equatable {
        /// Name of a dataflow endpoint.
        /// This member is required.
        public var dataflowEndpointName: Swift.String?
        /// Region of a dataflow endpoint.
        public var dataflowEndpointRegion: Swift.String?

        public init (
            dataflowEndpointName: Swift.String? = nil,
            dataflowEndpointRegion: Swift.String? = nil
        )
        {
            self.dataflowEndpointName = dataflowEndpointName
            self.dataflowEndpointRegion = dataflowEndpointRegion
        }
    }

}

extension GroundStationClientTypes.DataflowEndpointListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupArn
        case dataflowEndpointGroupId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataflowEndpointGroupArn = dataflowEndpointGroupArn {
            try encodeContainer.encode(dataflowEndpointGroupArn, forKey: .dataflowEndpointGroupArn)
        }
        if let dataflowEndpointGroupId = dataflowEndpointGroupId {
            try encodeContainer.encode(dataflowEndpointGroupId, forKey: .dataflowEndpointGroupId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
        let dataflowEndpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupArn)
        dataflowEndpointGroupArn = dataflowEndpointGroupArnDecoded
    }
}

extension GroundStationClientTypes {
    /// Item in a list of DataflowEndpoint groups.
    public struct DataflowEndpointListItem: Swift.Equatable {
        /// ARN of a dataflow endpoint group.
        public var dataflowEndpointGroupArn: Swift.String?
        /// UUID of a dataflow endpoint group.
        public var dataflowEndpointGroupId: Swift.String?

        public init (
            dataflowEndpointGroupArn: Swift.String? = nil,
            dataflowEndpointGroupId: Swift.String? = nil
        )
        {
            self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }
    }

}

extension GroundStationClientTypes.DecodeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unvalidatedJSON
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unvalidatedJSON = unvalidatedJSON {
            try encodeContainer.encode(unvalidatedJSON, forKey: .unvalidatedJSON)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unvalidatedJSONDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unvalidatedJSON)
        unvalidatedJSON = unvalidatedJSONDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the decode Config.
    public struct DecodeConfig: Swift.Equatable {
        /// Unvalidated JSON of a decode Config.
        /// This member is required.
        public var unvalidatedJSON: Swift.String?

        public init (
            unvalidatedJSON: Swift.String? = nil
        )
        {
            self.unvalidatedJSON = unvalidatedJSON
        }
    }

}

extension DeleteConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configType = configType else {
            return nil
        }
        guard let configId = configId else {
            return nil
        }
        return "/config/\(configType.rawValue.urlPercentEncoding())/\(configId.urlPercentEncoding())"
    }
}

///
public struct DeleteConfigInput: Swift.Equatable {
    /// UUID of a Config.
    /// This member is required.
    public var configId: Swift.String?
    /// Type of a Config.
    /// This member is required.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init (
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configId = configId
        self.configType = configType
    }
}

struct DeleteConfigInputBody: Swift.Equatable {
}

extension DeleteConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configArn = output.configArn
            self.configId = output.configId
            self.configType = output.configType
        } else {
            self.configArn = nil
            self.configId = nil
            self.configType = nil
        }
    }
}

///
public struct DeleteConfigOutputResponse: Swift.Equatable {
    /// ARN of a Config.
    public var configArn: Swift.String?
    /// UUID of a Config.
    public var configId: Swift.String?
    /// Type of a Config.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init (
        configArn: Swift.String? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

struct DeleteConfigOutputResponseBody: Swift.Equatable {
    let configId: Swift.String?
    let configType: GroundStationClientTypes.ConfigCapabilityType?
    let configArn: Swift.String?
}

extension DeleteConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configId
        case configType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
    }
}

extension DeleteDataflowEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let dataflowEndpointGroupId = dataflowEndpointGroupId else {
            return nil
        }
        return "/dataflowEndpointGroup/\(dataflowEndpointGroupId.urlPercentEncoding())"
    }
}

///
public struct DeleteDataflowEndpointGroupInput: Swift.Equatable {
    /// UUID of a dataflow endpoint group.
    /// This member is required.
    public var dataflowEndpointGroupId: Swift.String?

    public init (
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct DeleteDataflowEndpointGroupInputBody: Swift.Equatable {
}

extension DeleteDataflowEndpointGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataflowEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataflowEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDataflowEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataflowEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDataflowEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataflowEndpointGroupId = output.dataflowEndpointGroupId
        } else {
            self.dataflowEndpointGroupId = nil
        }
    }
}

///
public struct DeleteDataflowEndpointGroupOutputResponse: Swift.Equatable {
    /// UUID of a dataflow endpoint group.
    public var dataflowEndpointGroupId: Swift.String?

    public init (
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct DeleteDataflowEndpointGroupOutputResponseBody: Swift.Equatable {
    let dataflowEndpointGroupId: Swift.String?
}

extension DeleteDataflowEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
    }
}

extension DeleteMissionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let missionProfileId = missionProfileId else {
            return nil
        }
        return "/missionprofile/\(missionProfileId.urlPercentEncoding())"
    }
}

///
public struct DeleteMissionProfileInput: Swift.Equatable {
    /// UUID of a mission profile.
    /// This member is required.
    public var missionProfileId: Swift.String?

    public init (
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct DeleteMissionProfileInputBody: Swift.Equatable {
}

extension DeleteMissionProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMissionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMissionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMissionProfileOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMissionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteMissionProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.missionProfileId = output.missionProfileId
        } else {
            self.missionProfileId = nil
        }
    }
}

///
public struct DeleteMissionProfileOutputResponse: Swift.Equatable {
    /// UUID of a mission profile.
    public var missionProfileId: Swift.String?

    public init (
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct DeleteMissionProfileOutputResponseBody: Swift.Equatable {
    let missionProfileId: Swift.String?
}

extension DeleteMissionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
    }
}

extension GroundStationClientTypes.DemodulationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unvalidatedJSON
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unvalidatedJSON = unvalidatedJSON {
            try encodeContainer.encode(unvalidatedJSON, forKey: .unvalidatedJSON)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unvalidatedJSONDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unvalidatedJSON)
        unvalidatedJSON = unvalidatedJSONDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the demodulation Config.
    public struct DemodulationConfig: Swift.Equatable {
        /// Unvalidated JSON of a demodulation Config.
        /// This member is required.
        public var unvalidatedJSON: Swift.String?

        public init (
            unvalidatedJSON: Swift.String? = nil
        )
        {
            self.unvalidatedJSON = unvalidatedJSON
        }
    }

}

extension DependencyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DependencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.parameterName = output.parameterName
        } else {
            self.message = nil
            self.parameterName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Dependency encountered an error.
public struct DependencyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    ///
    public var parameterName: Swift.String?

    public init (
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.message = message
        self.parameterName = parameterName
    }
}

struct DependencyExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let parameterName: Swift.String?
}

extension DependencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case parameterName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension DescribeContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let contactId = contactId else {
            return nil
        }
        return "/contact/\(contactId.urlPercentEncoding())"
    }
}

///
public struct DescribeContactInput: Swift.Equatable {
    /// UUID of a contact.
    /// This member is required.
    public var contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct DescribeContactInputBody: Swift.Equatable {
}

extension DescribeContactInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeContactOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
            self.contactStatus = output.contactStatus
            self.dataflowList = output.dataflowList
            self.endTime = output.endTime
            self.errorMessage = output.errorMessage
            self.groundStation = output.groundStation
            self.maximumElevation = output.maximumElevation
            self.missionProfileArn = output.missionProfileArn
            self.postPassEndTime = output.postPassEndTime
            self.prePassStartTime = output.prePassStartTime
            self.region = output.region
            self.satelliteArn = output.satelliteArn
            self.startTime = output.startTime
            self.tags = output.tags
        } else {
            self.contactId = nil
            self.contactStatus = nil
            self.dataflowList = nil
            self.endTime = nil
            self.errorMessage = nil
            self.groundStation = nil
            self.maximumElevation = nil
            self.missionProfileArn = nil
            self.postPassEndTime = nil
            self.prePassStartTime = nil
            self.region = nil
            self.satelliteArn = nil
            self.startTime = nil
            self.tags = nil
        }
    }
}

///
public struct DescribeContactOutputResponse: Swift.Equatable {
    /// UUID of a contact.
    public var contactId: Swift.String?
    /// Status of a contact.
    public var contactStatus: GroundStationClientTypes.ContactStatus?
    /// List describing source and destination details for each dataflow edge.
    public var dataflowList: [GroundStationClientTypes.DataflowDetail]?
    /// End time of a contact.
    public var endTime: ClientRuntime.Date?
    /// Error message for a contact.
    public var errorMessage: Swift.String?
    /// Ground station for a contact.
    public var groundStation: Swift.String?
    /// Maximum elevation angle of a contact.
    public var maximumElevation: GroundStationClientTypes.Elevation?
    /// ARN of a mission profile.
    public var missionProfileArn: Swift.String?
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var postPassEndTime: ClientRuntime.Date?
    /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
    public var prePassStartTime: ClientRuntime.Date?
    /// Region of a contact.
    public var region: Swift.String?
    /// ARN of a satellite.
    public var satelliteArn: Swift.String?
    /// Start time of a contact.
    public var startTime: ClientRuntime.Date?
    /// Tags assigned to a contact.
    public var tags: [Swift.String:Swift.String]?

    public init (
        contactId: Swift.String? = nil,
        contactStatus: GroundStationClientTypes.ContactStatus? = nil,
        dataflowList: [GroundStationClientTypes.DataflowDetail]? = nil,
        endTime: ClientRuntime.Date? = nil,
        errorMessage: Swift.String? = nil,
        groundStation: Swift.String? = nil,
        maximumElevation: GroundStationClientTypes.Elevation? = nil,
        missionProfileArn: Swift.String? = nil,
        postPassEndTime: ClientRuntime.Date? = nil,
        prePassStartTime: ClientRuntime.Date? = nil,
        region: Swift.String? = nil,
        satelliteArn: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.contactId = contactId
        self.contactStatus = contactStatus
        self.dataflowList = dataflowList
        self.endTime = endTime
        self.errorMessage = errorMessage
        self.groundStation = groundStation
        self.maximumElevation = maximumElevation
        self.missionProfileArn = missionProfileArn
        self.postPassEndTime = postPassEndTime
        self.prePassStartTime = prePassStartTime
        self.region = region
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.tags = tags
    }
}

struct DescribeContactOutputResponseBody: Swift.Equatable {
    let contactId: Swift.String?
    let missionProfileArn: Swift.String?
    let satelliteArn: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let prePassStartTime: ClientRuntime.Date?
    let postPassEndTime: ClientRuntime.Date?
    let groundStation: Swift.String?
    let contactStatus: GroundStationClientTypes.ContactStatus?
    let errorMessage: Swift.String?
    let maximumElevation: GroundStationClientTypes.Elevation?
    let tags: [Swift.String:Swift.String]?
    let region: Swift.String?
    let dataflowList: [GroundStationClientTypes.DataflowDetail]?
}

extension DescribeContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId
        case contactStatus
        case dataflowList
        case endTime
        case errorMessage
        case groundStation
        case maximumElevation
        case missionProfileArn
        case postPassEndTime
        case prePassStartTime
        case region
        case satelliteArn
        case startTime
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let prePassStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .prePassStartTime)
        prePassStartTime = prePassStartTimeDecoded
        let postPassEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .postPassEndTime)
        postPassEndTime = postPassEndTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let contactStatusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ContactStatus.self, forKey: .contactStatus)
        contactStatus = contactStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let maximumElevationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Elevation.self, forKey: .maximumElevation)
        maximumElevation = maximumElevationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let dataflowListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.DataflowDetail?].self, forKey: .dataflowList)
        var dataflowListDecoded0:[GroundStationClientTypes.DataflowDetail]? = nil
        if let dataflowListContainer = dataflowListContainer {
            dataflowListDecoded0 = [GroundStationClientTypes.DataflowDetail]()
            for structure0 in dataflowListContainer {
                if let structure0 = structure0 {
                    dataflowListDecoded0?.append(structure0)
                }
            }
        }
        dataflowList = dataflowListDecoded0
    }
}

extension GroundStationClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configDetails
        case configId
        case configType
        case dataflowDestinationRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configDetails = configDetails {
            try encodeContainer.encode(configDetails, forKey: .configDetails)
        }
        if let configId = configId {
            try encodeContainer.encode(configId, forKey: .configId)
        }
        if let configType = configType {
            try encodeContainer.encode(configType.rawValue, forKey: .configType)
        }
        if let dataflowDestinationRegion = dataflowDestinationRegion {
            try encodeContainer.encode(dataflowDestinationRegion, forKey: .dataflowDestinationRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configDetailsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigDetails.self, forKey: .configDetails)
        configDetails = configDetailsDecoded
        let dataflowDestinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowDestinationRegion)
        dataflowDestinationRegion = dataflowDestinationRegionDecoded
    }
}

extension GroundStationClientTypes {
    /// Dataflow details for the destination side.
    public struct Destination: Swift.Equatable {
        /// Additional details for a Config, if type is dataflow endpoint or antenna demod decode.
        public var configDetails: GroundStationClientTypes.ConfigDetails?
        /// UUID of a Config.
        public var configId: Swift.String?
        /// Type of a Config.
        public var configType: GroundStationClientTypes.ConfigCapabilityType?
        /// Region of a dataflow destination.
        public var dataflowDestinationRegion: Swift.String?

        public init (
            configDetails: GroundStationClientTypes.ConfigDetails? = nil,
            configId: Swift.String? = nil,
            configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
            dataflowDestinationRegion: Swift.String? = nil
        )
        {
            self.configDetails = configDetails
            self.configId = configId
            self.configType = configType
            self.dataflowDestinationRegion = dataflowDestinationRegion
        }
    }

}

extension GroundStationClientTypes.Eirp: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case units
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let units = units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EirpUnits.self, forKey: .units)
        units = unitsDecoded
    }
}

extension GroundStationClientTypes {
    /// Object that represents EIRP.
    public struct Eirp: Swift.Equatable {
        /// Units of an EIRP.
        /// This member is required.
        public var units: GroundStationClientTypes.EirpUnits?
        /// Value of an EIRP. Valid values are between 20.0 to 50.0 dBW.
        /// This member is required.
        public var value: Swift.Double?

        public init (
            units: GroundStationClientTypes.EirpUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.units = units
            self.value = value
        }
    }

}

extension GroundStationClientTypes {
    public enum EirpUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dbw
        case sdkUnknown(Swift.String)

        public static var allCases: [EirpUnits] {
            return [
                .dbw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dbw: return "dBW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EirpUnits(rawValue: rawValue) ?? EirpUnits.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.Elevation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unit
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.AngleUnits.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension GroundStationClientTypes {
    /// Elevation angle of the satellite in the sky during a contact.
    public struct Elevation: Swift.Equatable {
        /// Elevation angle units.
        /// This member is required.
        public var unit: GroundStationClientTypes.AngleUnits?
        /// Elevation angle value.
        /// This member is required.
        public var value: Swift.Double?

        public init (
            unit: GroundStationClientTypes.AngleUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension GroundStationClientTypes.EndpointDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
        case securityDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let securityDetails = securityDetails {
            try encodeContainer.encode(securityDetails, forKey: .securityDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityDetailsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SecurityDetails.self, forKey: .securityDetails)
        securityDetails = securityDetailsDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.DataflowEndpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the endpoint details.
    public struct EndpointDetails: Swift.Equatable {
        /// A dataflow endpoint.
        public var endpoint: GroundStationClientTypes.DataflowEndpoint?
        /// Endpoint security details.
        public var securityDetails: GroundStationClientTypes.SecurityDetails?

        public init (
            endpoint: GroundStationClientTypes.DataflowEndpoint? = nil,
            securityDetails: GroundStationClientTypes.SecurityDetails? = nil
        )
        {
            self.endpoint = endpoint
            self.securityDetails = securityDetails
        }
    }

}

extension GroundStationClientTypes {
    public enum EndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case deleted
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointStatus] {
            return [
                .created,
                .creating,
                .deleted,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "created"
            case .creating: return "creating"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .failed: return "failed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointStatus(rawValue: rawValue) ?? EndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.Frequency: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case units
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let units = units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.FrequencyUnits.self, forKey: .units)
        units = unitsDecoded
    }
}

extension GroundStationClientTypes {
    /// Object that describes the frequency.
    public struct Frequency: Swift.Equatable {
        /// Frequency units.
        /// This member is required.
        public var units: GroundStationClientTypes.FrequencyUnits?
        /// Frequency value. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.
        /// This member is required.
        public var value: Swift.Double?

        public init (
            units: GroundStationClientTypes.FrequencyUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.units = units
            self.value = value
        }
    }

}

extension GroundStationClientTypes.FrequencyBandwidth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case units
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let units = units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.BandwidthUnits.self, forKey: .units)
        units = unitsDecoded
    }
}

extension GroundStationClientTypes {
    /// Object that describes the frequency bandwidth.
    public struct FrequencyBandwidth: Swift.Equatable {
        /// Frequency bandwidth units.
        /// This member is required.
        public var units: GroundStationClientTypes.BandwidthUnits?
        /// Frequency bandwidth value. AWS Ground Station currently has the following bandwidth limitations:
        ///
        /// * For AntennaDownlinkDemodDecodeconfig, valid values are between 125 kHz to 650 MHz.
        ///
        /// * For AntennaDownlinkconfig, valid values are between 10 kHz to 54 MHz.
        ///
        /// * For AntennaUplinkConfig, valid values are between 10 kHz to 54 MHz.
        /// This member is required.
        public var value: Swift.Double?

        public init (
            units: GroundStationClientTypes.BandwidthUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.units = units
            self.value = value
        }
    }

}

extension GroundStationClientTypes {
    public enum FrequencyUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ghz
        case khz
        case mhz
        case sdkUnknown(Swift.String)

        public static var allCases: [FrequencyUnits] {
            return [
                .ghz,
                .khz,
                .mhz,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ghz: return "GHz"
            case .khz: return "kHz"
            case .mhz: return "MHz"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FrequencyUnits(rawValue: rawValue) ?? FrequencyUnits.sdkUnknown(rawValue)
        }
    }
}

extension GetConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configType = configType else {
            return nil
        }
        guard let configId = configId else {
            return nil
        }
        return "/config/\(configType.rawValue.urlPercentEncoding())/\(configId.urlPercentEncoding())"
    }
}

///
public struct GetConfigInput: Swift.Equatable {
    /// UUID of a Config.
    /// This member is required.
    public var configId: Swift.String?
    /// Type of a Config.
    /// This member is required.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init (
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configId = configId
        self.configType = configType
    }
}

struct GetConfigInputBody: Swift.Equatable {
}

extension GetConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configArn = output.configArn
            self.configData = output.configData
            self.configId = output.configId
            self.configType = output.configType
            self.name = output.name
            self.tags = output.tags
        } else {
            self.configArn = nil
            self.configData = nil
            self.configId = nil
            self.configType = nil
            self.name = nil
            self.tags = nil
        }
    }
}

///
public struct GetConfigOutputResponse: Swift.Equatable {
    /// ARN of a Config
    /// This member is required.
    public var configArn: Swift.String?
    /// Data elements in a Config.
    /// This member is required.
    public var configData: GroundStationClientTypes.ConfigTypeData?
    /// UUID of a Config.
    /// This member is required.
    public var configId: Swift.String?
    /// Type of a Config.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?
    /// Name of a Config.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to a Config.
    public var tags: [Swift.String:Swift.String]?

    public init (
        configArn: Swift.String? = nil,
        configData: GroundStationClientTypes.ConfigTypeData? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.configArn = configArn
        self.configData = configData
        self.configId = configId
        self.configType = configType
        self.name = name
        self.tags = tags
    }
}

struct GetConfigOutputResponseBody: Swift.Equatable {
    let configId: Swift.String?
    let configArn: Swift.String?
    let name: Swift.String?
    let configType: GroundStationClientTypes.ConfigCapabilityType?
    let configData: GroundStationClientTypes.ConfigTypeData?
    let tags: [Swift.String:Swift.String]?
}

extension GetConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configData
        case configId
        case configType
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configDataDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigTypeData.self, forKey: .configData)
        configData = configDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetDataflowEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let dataflowEndpointGroupId = dataflowEndpointGroupId else {
            return nil
        }
        return "/dataflowEndpointGroup/\(dataflowEndpointGroupId.urlPercentEncoding())"
    }
}

///
public struct GetDataflowEndpointGroupInput: Swift.Equatable {
    /// UUID of a dataflow endpoint group.
    /// This member is required.
    public var dataflowEndpointGroupId: Swift.String?

    public init (
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct GetDataflowEndpointGroupInputBody: Swift.Equatable {
}

extension GetDataflowEndpointGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDataflowEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataflowEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataflowEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataflowEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDataflowEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataflowEndpointGroupArn = output.dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = output.dataflowEndpointGroupId
            self.endpointsDetails = output.endpointsDetails
            self.tags = output.tags
        } else {
            self.dataflowEndpointGroupArn = nil
            self.dataflowEndpointGroupId = nil
            self.endpointsDetails = nil
            self.tags = nil
        }
    }
}

///
public struct GetDataflowEndpointGroupOutputResponse: Swift.Equatable {
    /// ARN of a dataflow endpoint group.
    public var dataflowEndpointGroupArn: Swift.String?
    /// UUID of a dataflow endpoint group.
    public var dataflowEndpointGroupId: Swift.String?
    /// Details of a dataflow endpoint.
    public var endpointsDetails: [GroundStationClientTypes.EndpointDetails]?
    /// Tags assigned to a dataflow endpoint group.
    public var tags: [Swift.String:Swift.String]?

    public init (
        dataflowEndpointGroupArn: Swift.String? = nil,
        dataflowEndpointGroupId: Swift.String? = nil,
        endpointsDetails: [GroundStationClientTypes.EndpointDetails]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
        self.endpointsDetails = endpointsDetails
        self.tags = tags
    }
}

struct GetDataflowEndpointGroupOutputResponseBody: Swift.Equatable {
    let dataflowEndpointGroupId: Swift.String?
    let dataflowEndpointGroupArn: Swift.String?
    let endpointsDetails: [GroundStationClientTypes.EndpointDetails]?
    let tags: [Swift.String:Swift.String]?
}

extension GetDataflowEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupArn
        case dataflowEndpointGroupId
        case endpointsDetails
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
        let dataflowEndpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupArn)
        dataflowEndpointGroupArn = dataflowEndpointGroupArnDecoded
        let endpointsDetailsContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.EndpointDetails?].self, forKey: .endpointsDetails)
        var endpointsDetailsDecoded0:[GroundStationClientTypes.EndpointDetails]? = nil
        if let endpointsDetailsContainer = endpointsDetailsContainer {
            endpointsDetailsDecoded0 = [GroundStationClientTypes.EndpointDetails]()
            for structure0 in endpointsDetailsContainer {
                if let structure0 = structure0 {
                    endpointsDetailsDecoded0?.append(structure0)
                }
            }
        }
        endpointsDetails = endpointsDetailsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetMinuteUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case month
        case year
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let month = month {
            try encodeContainer.encode(month, forKey: .month)
        }
        if let year = year {
            try encodeContainer.encode(year, forKey: .year)
        }
    }
}

extension GetMinuteUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/minute-usage"
    }
}

///
public struct GetMinuteUsageInput: Swift.Equatable {
    /// The month being requested, with a value of 1-12.
    /// This member is required.
    public var month: Swift.Int?
    /// The year being requested, in the format of YYYY.
    /// This member is required.
    public var year: Swift.Int?

    public init (
        month: Swift.Int? = nil,
        year: Swift.Int? = nil
    )
    {
        self.month = month
        self.year = year
    }
}

struct GetMinuteUsageInputBody: Swift.Equatable {
    let month: Swift.Int?
    let year: Swift.Int?
}

extension GetMinuteUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case month
        case year
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .month)
        month = monthDecoded
        let yearDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .year)
        year = yearDecoded
    }
}

extension GetMinuteUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMinuteUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMinuteUsageOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMinuteUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMinuteUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.estimatedMinutesRemaining = output.estimatedMinutesRemaining
            self.isReservedMinutesCustomer = output.isReservedMinutesCustomer
            self.totalReservedMinuteAllocation = output.totalReservedMinuteAllocation
            self.totalScheduledMinutes = output.totalScheduledMinutes
            self.upcomingMinutesScheduled = output.upcomingMinutesScheduled
        } else {
            self.estimatedMinutesRemaining = nil
            self.isReservedMinutesCustomer = nil
            self.totalReservedMinuteAllocation = nil
            self.totalScheduledMinutes = nil
            self.upcomingMinutesScheduled = nil
        }
    }
}

///
public struct GetMinuteUsageOutputResponse: Swift.Equatable {
    /// Estimated number of minutes remaining for an account, specific to the month being requested.
    public var estimatedMinutesRemaining: Swift.Int?
    /// Returns whether or not an account has signed up for the reserved minutes pricing plan, specific to the month being requested.
    public var isReservedMinutesCustomer: Swift.Bool?
    /// Total number of reserved minutes allocated, specific to the month being requested.
    public var totalReservedMinuteAllocation: Swift.Int?
    /// Total scheduled minutes for an account, specific to the month being requested.
    public var totalScheduledMinutes: Swift.Int?
    /// Upcoming minutes scheduled for an account, specific to the month being requested.
    public var upcomingMinutesScheduled: Swift.Int?

    public init (
        estimatedMinutesRemaining: Swift.Int? = nil,
        isReservedMinutesCustomer: Swift.Bool? = nil,
        totalReservedMinuteAllocation: Swift.Int? = nil,
        totalScheduledMinutes: Swift.Int? = nil,
        upcomingMinutesScheduled: Swift.Int? = nil
    )
    {
        self.estimatedMinutesRemaining = estimatedMinutesRemaining
        self.isReservedMinutesCustomer = isReservedMinutesCustomer
        self.totalReservedMinuteAllocation = totalReservedMinuteAllocation
        self.totalScheduledMinutes = totalScheduledMinutes
        self.upcomingMinutesScheduled = upcomingMinutesScheduled
    }
}

struct GetMinuteUsageOutputResponseBody: Swift.Equatable {
    let isReservedMinutesCustomer: Swift.Bool?
    let totalReservedMinuteAllocation: Swift.Int?
    let upcomingMinutesScheduled: Swift.Int?
    let totalScheduledMinutes: Swift.Int?
    let estimatedMinutesRemaining: Swift.Int?
}

extension GetMinuteUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedMinutesRemaining
        case isReservedMinutesCustomer
        case totalReservedMinuteAllocation
        case totalScheduledMinutes
        case upcomingMinutesScheduled
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isReservedMinutesCustomerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isReservedMinutesCustomer)
        isReservedMinutesCustomer = isReservedMinutesCustomerDecoded
        let totalReservedMinuteAllocationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalReservedMinuteAllocation)
        totalReservedMinuteAllocation = totalReservedMinuteAllocationDecoded
        let upcomingMinutesScheduledDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .upcomingMinutesScheduled)
        upcomingMinutesScheduled = upcomingMinutesScheduledDecoded
        let totalScheduledMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalScheduledMinutes)
        totalScheduledMinutes = totalScheduledMinutesDecoded
        let estimatedMinutesRemainingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedMinutesRemaining)
        estimatedMinutesRemaining = estimatedMinutesRemainingDecoded
    }
}

extension GetMissionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let missionProfileId = missionProfileId else {
            return nil
        }
        return "/missionprofile/\(missionProfileId.urlPercentEncoding())"
    }
}

///
public struct GetMissionProfileInput: Swift.Equatable {
    /// UUID of a mission profile.
    /// This member is required.
    public var missionProfileId: Swift.String?

    public init (
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct GetMissionProfileInputBody: Swift.Equatable {
}

extension GetMissionProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMissionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMissionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMissionProfileOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMissionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMissionProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactPostPassDurationSeconds = output.contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = output.contactPrePassDurationSeconds
            self.dataflowEdges = output.dataflowEdges
            self.minimumViableContactDurationSeconds = output.minimumViableContactDurationSeconds
            self.missionProfileArn = output.missionProfileArn
            self.missionProfileId = output.missionProfileId
            self.name = output.name
            self.region = output.region
            self.tags = output.tags
            self.trackingConfigArn = output.trackingConfigArn
        } else {
            self.contactPostPassDurationSeconds = nil
            self.contactPrePassDurationSeconds = nil
            self.dataflowEdges = nil
            self.minimumViableContactDurationSeconds = nil
            self.missionProfileArn = nil
            self.missionProfileId = nil
            self.name = nil
            self.region = nil
            self.tags = nil
            self.trackingConfigArn = nil
        }
    }
}

///
public struct GetMissionProfileOutputResponse: Swift.Equatable {
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var contactPostPassDurationSeconds: Swift.Int?
    /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
    public var contactPrePassDurationSeconds: Swift.Int?
    /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
    public var dataflowEdges: [[Swift.String]]?
    /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
    public var minimumViableContactDurationSeconds: Swift.Int?
    /// ARN of a mission profile.
    public var missionProfileArn: Swift.String?
    /// UUID of a mission profile.
    public var missionProfileId: Swift.String?
    /// Name of a mission profile.
    public var name: Swift.String?
    /// Region of a mission profile.
    public var region: Swift.String?
    /// Tags assigned to a mission profile.
    public var tags: [Swift.String:Swift.String]?
    /// ARN of a tracking Config.
    public var trackingConfigArn: Swift.String?

    public init (
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEdges: [[Swift.String]]? = nil,
        minimumViableContactDurationSeconds: Swift.Int? = nil,
        missionProfileArn: Swift.String? = nil,
        missionProfileId: Swift.String? = nil,
        name: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trackingConfigArn: Swift.String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.missionProfileArn = missionProfileArn
        self.missionProfileId = missionProfileId
        self.name = name
        self.region = region
        self.tags = tags
        self.trackingConfigArn = trackingConfigArn
    }
}

struct GetMissionProfileOutputResponseBody: Swift.Equatable {
    let missionProfileId: Swift.String?
    let missionProfileArn: Swift.String?
    let name: Swift.String?
    let region: Swift.String?
    let contactPrePassDurationSeconds: Swift.Int?
    let contactPostPassDurationSeconds: Swift.Int?
    let minimumViableContactDurationSeconds: Swift.Int?
    let dataflowEdges: [[Swift.String]]?
    let trackingConfigArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetMissionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case missionProfileArn
        case missionProfileId
        case name
        case region
        case tags
        case trackingConfigArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
        let minimumViableContactDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumViableContactDurationSeconds)
        minimumViableContactDurationSeconds = minimumViableContactDurationSecondsDecoded
        let dataflowEdgesContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .dataflowEdges)
        var dataflowEdgesDecoded0:[[Swift.String]]? = nil
        if let dataflowEdgesContainer = dataflowEdgesContainer {
            dataflowEdgesDecoded0 = [[Swift.String]]()
            for list0 in dataflowEdgesContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    dataflowEdgesDecoded0?.append(list0Decoded0)
                }
            }
        }
        dataflowEdges = dataflowEdgesDecoded0
        let trackingConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingConfigArn)
        trackingConfigArn = trackingConfigArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetSatelliteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let satelliteId = satelliteId else {
            return nil
        }
        return "/satellite/\(satelliteId.urlPercentEncoding())"
    }
}

///
public struct GetSatelliteInput: Swift.Equatable {
    /// UUID of a satellite.
    /// This member is required.
    public var satelliteId: Swift.String?

    public init (
        satelliteId: Swift.String? = nil
    )
    {
        self.satelliteId = satelliteId
    }
}

struct GetSatelliteInputBody: Swift.Equatable {
}

extension GetSatelliteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSatelliteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSatelliteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSatelliteOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSatelliteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSatelliteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groundStations = output.groundStations
            self.noradSatelliteID = output.noradSatelliteID
            self.satelliteArn = output.satelliteArn
            self.satelliteId = output.satelliteId
        } else {
            self.groundStations = nil
            self.noradSatelliteID = 0
            self.satelliteArn = nil
            self.satelliteId = nil
        }
    }
}

///
public struct GetSatelliteOutputResponse: Swift.Equatable {
    /// A list of ground stations to which the satellite is on-boarded.
    public var groundStations: [Swift.String]?
    /// NORAD satellite ID number.
    public var noradSatelliteID: Swift.Int
    /// ARN of a satellite.
    public var satelliteArn: Swift.String?
    /// UUID of a satellite.
    public var satelliteId: Swift.String?

    public init (
        groundStations: [Swift.String]? = nil,
        noradSatelliteID: Swift.Int = 0,
        satelliteArn: Swift.String? = nil,
        satelliteId: Swift.String? = nil
    )
    {
        self.groundStations = groundStations
        self.noradSatelliteID = noradSatelliteID
        self.satelliteArn = satelliteArn
        self.satelliteId = satelliteId
    }
}

struct GetSatelliteOutputResponseBody: Swift.Equatable {
    let satelliteId: Swift.String?
    let satelliteArn: Swift.String?
    let noradSatelliteID: Swift.Int
    let groundStations: [Swift.String]?
}

extension GetSatelliteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groundStations
        case noradSatelliteID
        case satelliteArn
        case satelliteId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let satelliteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteId)
        satelliteId = satelliteIdDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let noradSatelliteIDDecoded = try containerValues.decode(Swift.Int.self, forKey: .noradSatelliteID)
        noradSatelliteID = noradSatelliteIDDecoded
        let groundStationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groundStations)
        var groundStationsDecoded0:[Swift.String]? = nil
        if let groundStationsContainer = groundStationsContainer {
            groundStationsDecoded0 = [Swift.String]()
            for string0 in groundStationsContainer {
                if let string0 = string0 {
                    groundStationsDecoded0?.append(string0)
                }
            }
        }
        groundStations = groundStationsDecoded0
    }
}

extension GroundStationClientTypes.GroundStationData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groundStationId
        case groundStationName
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groundStationId = groundStationId {
            try encodeContainer.encode(groundStationId, forKey: .groundStationId)
        }
        if let groundStationName = groundStationName {
            try encodeContainer.encode(groundStationName, forKey: .groundStationName)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groundStationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStationId)
        groundStationId = groundStationIdDecoded
        let groundStationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStationName)
        groundStationName = groundStationNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the ground station data.
    public struct GroundStationData: Swift.Equatable {
        /// UUID of a ground station.
        public var groundStationId: Swift.String?
        /// Name of a ground station.
        public var groundStationName: Swift.String?
        /// Ground station Region.
        public var region: Swift.String?

        public init (
            groundStationId: Swift.String? = nil,
            groundStationName: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.groundStationId = groundStationId
            self.groundStationName = groundStationName
            self.region = region
        }
    }

}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.parameterName = output.parameterName
        } else {
            self.message = nil
            self.parameterName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more parameters are not valid.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    ///
    public var parameterName: Swift.String?

    public init (
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.message = message
        self.parameterName = parameterName
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let parameterName: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case parameterName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension ListConfigsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/config"
    }
}

///
public struct ListConfigsInput: Swift.Equatable {
    /// Maximum number of Configs returned.
    public var maxResults: Swift.Int?
    /// Next token returned in the request of a previous ListConfigs call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigsInputBody: Swift.Equatable {
}

extension ListConfigsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigsOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configList = output.configList
            self.nextToken = output.nextToken
        } else {
            self.configList = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListConfigsOutputResponse: Swift.Equatable {
    /// List of Config items.
    public var configList: [GroundStationClientTypes.ConfigListItem]?
    /// Next token returned in the response of a previous ListConfigs call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        configList: [GroundStationClientTypes.ConfigListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configList = configList
        self.nextToken = nextToken
    }
}

struct ListConfigsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let configList: [GroundStationClientTypes.ConfigListItem]?
}

extension ListConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let configListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.ConfigListItem?].self, forKey: .configList)
        var configListDecoded0:[GroundStationClientTypes.ConfigListItem]? = nil
        if let configListContainer = configListContainer {
            configListDecoded0 = [GroundStationClientTypes.ConfigListItem]()
            for structure0 in configListContainer {
                if let structure0 = structure0 {
                    configListDecoded0?.append(structure0)
                }
            }
        }
        configList = configListDecoded0
    }
}

extension ListContactsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groundStation
        case maxResults
        case missionProfileArn
        case nextToken
        case satelliteArn
        case startTime
        case statusList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let groundStation = groundStation {
            try encodeContainer.encode(groundStation, forKey: .groundStation)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let missionProfileArn = missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let satelliteArn = satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let statusList = statusList {
            var statusListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statusList)
            for statuslist0 in statusList {
                try statusListContainer.encode(statuslist0.rawValue)
            }
        }
    }
}

extension ListContactsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contacts"
    }
}

///
public struct ListContactsInput: Swift.Equatable {
    /// End time of a contact.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// Name of a ground station.
    public var groundStation: Swift.String?
    /// Maximum number of contacts returned.
    public var maxResults: Swift.Int?
    /// ARN of a mission profile.
    public var missionProfileArn: Swift.String?
    /// Next token returned in the request of a previous ListContacts call. Used to get the next page of results.
    public var nextToken: Swift.String?
    /// ARN of a satellite.
    public var satelliteArn: Swift.String?
    /// Start time of a contact.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// Status of a contact reservation.
    /// This member is required.
    public var statusList: [GroundStationClientTypes.ContactStatus]?

    public init (
        endTime: ClientRuntime.Date? = nil,
        groundStation: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        missionProfileArn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        satelliteArn: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        statusList: [GroundStationClientTypes.ContactStatus]? = nil
    )
    {
        self.endTime = endTime
        self.groundStation = groundStation
        self.maxResults = maxResults
        self.missionProfileArn = missionProfileArn
        self.nextToken = nextToken
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.statusList = statusList
    }
}

struct ListContactsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let statusList: [GroundStationClientTypes.ContactStatus]?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let groundStation: Swift.String?
    let satelliteArn: Swift.String?
    let missionProfileArn: Swift.String?
}

extension ListContactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groundStation
        case maxResults
        case missionProfileArn
        case nextToken
        case satelliteArn
        case startTime
        case statusList
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.ContactStatus?].self, forKey: .statusList)
        var statusListDecoded0:[GroundStationClientTypes.ContactStatus]? = nil
        if let statusListContainer = statusListContainer {
            statusListDecoded0 = [GroundStationClientTypes.ContactStatus]()
            for string0 in statusListContainer {
                if let string0 = string0 {
                    statusListDecoded0?.append(string0)
                }
            }
        }
        statusList = statusListDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
    }
}

extension ListContactsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContactsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContactsOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContactsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListContactsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactList = output.contactList
            self.nextToken = output.nextToken
        } else {
            self.contactList = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListContactsOutputResponse: Swift.Equatable {
    /// List of contacts.
    public var contactList: [GroundStationClientTypes.ContactData]?
    /// Next token returned in the response of a previous ListContacts call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        contactList: [GroundStationClientTypes.ContactData]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactList = contactList
        self.nextToken = nextToken
    }
}

struct ListContactsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let contactList: [GroundStationClientTypes.ContactData]?
}

extension ListContactsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let contactListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.ContactData?].self, forKey: .contactList)
        var contactListDecoded0:[GroundStationClientTypes.ContactData]? = nil
        if let contactListContainer = contactListContainer {
            contactListDecoded0 = [GroundStationClientTypes.ContactData]()
            for structure0 in contactListContainer {
                if let structure0 = structure0 {
                    contactListDecoded0?.append(structure0)
                }
            }
        }
        contactList = contactListDecoded0
    }
}

extension ListDataflowEndpointGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListDataflowEndpointGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/dataflowEndpointGroup"
    }
}

///
public struct ListDataflowEndpointGroupsInput: Swift.Equatable {
    /// Maximum number of dataflow endpoint groups returned.
    public var maxResults: Swift.Int?
    /// Next token returned in the request of a previous ListDataflowEndpointGroups call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataflowEndpointGroupsInputBody: Swift.Equatable {
}

extension ListDataflowEndpointGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDataflowEndpointGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataflowEndpointGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataflowEndpointGroupsOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataflowEndpointGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDataflowEndpointGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataflowEndpointGroupList = output.dataflowEndpointGroupList
            self.nextToken = output.nextToken
        } else {
            self.dataflowEndpointGroupList = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListDataflowEndpointGroupsOutputResponse: Swift.Equatable {
    /// A list of dataflow endpoint groups.
    public var dataflowEndpointGroupList: [GroundStationClientTypes.DataflowEndpointListItem]?
    /// Next token returned in the response of a previous ListDataflowEndpointGroups call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        dataflowEndpointGroupList: [GroundStationClientTypes.DataflowEndpointListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupList = dataflowEndpointGroupList
        self.nextToken = nextToken
    }
}

struct ListDataflowEndpointGroupsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let dataflowEndpointGroupList: [GroundStationClientTypes.DataflowEndpointListItem]?
}

extension ListDataflowEndpointGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let dataflowEndpointGroupListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.DataflowEndpointListItem?].self, forKey: .dataflowEndpointGroupList)
        var dataflowEndpointGroupListDecoded0:[GroundStationClientTypes.DataflowEndpointListItem]? = nil
        if let dataflowEndpointGroupListContainer = dataflowEndpointGroupListContainer {
            dataflowEndpointGroupListDecoded0 = [GroundStationClientTypes.DataflowEndpointListItem]()
            for structure0 in dataflowEndpointGroupListContainer {
                if let structure0 = structure0 {
                    dataflowEndpointGroupListDecoded0?.append(structure0)
                }
            }
        }
        dataflowEndpointGroupList = dataflowEndpointGroupListDecoded0
    }
}

extension ListGroundStationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let satelliteId = satelliteId {
            let satelliteIdQueryItem = ClientRuntime.URLQueryItem(name: "satelliteId".urlPercentEncoding(), value: Swift.String(satelliteId).urlPercentEncoding())
            items.append(satelliteIdQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListGroundStationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/groundstation"
    }
}

///
public struct ListGroundStationsInput: Swift.Equatable {
    /// Maximum number of ground stations returned.
    public var maxResults: Swift.Int?
    /// Next token that can be supplied in the next call to get the next page of ground stations.
    public var nextToken: Swift.String?
    /// Satellite ID to retrieve on-boarded ground stations.
    public var satelliteId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        satelliteId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.satelliteId = satelliteId
    }
}

struct ListGroundStationsInputBody: Swift.Equatable {
}

extension ListGroundStationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGroundStationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroundStationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroundStationsOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroundStationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListGroundStationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groundStationList = output.groundStationList
            self.nextToken = output.nextToken
        } else {
            self.groundStationList = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListGroundStationsOutputResponse: Swift.Equatable {
    /// List of ground stations.
    public var groundStationList: [GroundStationClientTypes.GroundStationData]?
    /// Next token that can be supplied in the next call to get the next page of ground stations.
    public var nextToken: Swift.String?

    public init (
        groundStationList: [GroundStationClientTypes.GroundStationData]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groundStationList = groundStationList
        self.nextToken = nextToken
    }
}

struct ListGroundStationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let groundStationList: [GroundStationClientTypes.GroundStationData]?
}

extension ListGroundStationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groundStationList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let groundStationListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.GroundStationData?].self, forKey: .groundStationList)
        var groundStationListDecoded0:[GroundStationClientTypes.GroundStationData]? = nil
        if let groundStationListContainer = groundStationListContainer {
            groundStationListDecoded0 = [GroundStationClientTypes.GroundStationData]()
            for structure0 in groundStationListContainer {
                if let structure0 = structure0 {
                    groundStationListDecoded0?.append(structure0)
                }
            }
        }
        groundStationList = groundStationListDecoded0
    }
}

extension ListMissionProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListMissionProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/missionprofile"
    }
}

///
public struct ListMissionProfilesInput: Swift.Equatable {
    /// Maximum number of mission profiles returned.
    public var maxResults: Swift.Int?
    /// Next token returned in the request of a previous ListMissionProfiles call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMissionProfilesInputBody: Swift.Equatable {
}

extension ListMissionProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMissionProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMissionProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMissionProfilesOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMissionProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMissionProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.missionProfileList = output.missionProfileList
            self.nextToken = output.nextToken
        } else {
            self.missionProfileList = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListMissionProfilesOutputResponse: Swift.Equatable {
    /// List of mission profiles.
    public var missionProfileList: [GroundStationClientTypes.MissionProfileListItem]?
    /// Next token returned in the response of a previous ListMissionProfiles call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        missionProfileList: [GroundStationClientTypes.MissionProfileListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.missionProfileList = missionProfileList
        self.nextToken = nextToken
    }
}

struct ListMissionProfilesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let missionProfileList: [GroundStationClientTypes.MissionProfileListItem]?
}

extension ListMissionProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let missionProfileListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.MissionProfileListItem?].self, forKey: .missionProfileList)
        var missionProfileListDecoded0:[GroundStationClientTypes.MissionProfileListItem]? = nil
        if let missionProfileListContainer = missionProfileListContainer {
            missionProfileListDecoded0 = [GroundStationClientTypes.MissionProfileListItem]()
            for structure0 in missionProfileListContainer {
                if let structure0 = structure0 {
                    missionProfileListDecoded0?.append(structure0)
                }
            }
        }
        missionProfileList = missionProfileListDecoded0
    }
}

extension ListSatellitesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListSatellitesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/satellite"
    }
}

///
public struct ListSatellitesInput: Swift.Equatable {
    /// Maximum number of satellites returned.
    public var maxResults: Swift.Int?
    /// Next token that can be supplied in the next call to get the next page of satellites.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSatellitesInputBody: Swift.Equatable {
}

extension ListSatellitesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSatellitesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSatellitesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSatellitesOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSatellitesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSatellitesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.satellites = output.satellites
        } else {
            self.nextToken = nil
            self.satellites = nil
        }
    }
}

///
public struct ListSatellitesOutputResponse: Swift.Equatable {
    /// Next token that can be supplied in the next call to get the next page of satellites.
    public var nextToken: Swift.String?
    /// List of satellites.
    public var satellites: [GroundStationClientTypes.SatelliteListItem]?

    public init (
        nextToken: Swift.String? = nil,
        satellites: [GroundStationClientTypes.SatelliteListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.satellites = satellites
    }
}

struct ListSatellitesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let satellites: [GroundStationClientTypes.SatelliteListItem]?
}

extension ListSatellitesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case satellites
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let satellitesContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.SatelliteListItem?].self, forKey: .satellites)
        var satellitesDecoded0:[GroundStationClientTypes.SatelliteListItem]? = nil
        if let satellitesContainer = satellitesContainer {
            satellitesDecoded0 = [GroundStationClientTypes.SatelliteListItem]()
            for structure0 in satellitesContainer {
                if let structure0 = structure0 {
                    satellitesDecoded0?.append(structure0)
                }
            }
        }
        satellites = satellitesDecoded0
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

///
public struct ListTagsForResourceInput: Swift.Equatable {
    /// ARN of a resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

///
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Tags assigned to a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GroundStationClientTypes.MissionProfileListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileArn
        case missionProfileId
        case name
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let missionProfileArn = missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let missionProfileId = missionProfileId {
            try encodeContainer.encode(missionProfileId, forKey: .missionProfileId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GroundStationClientTypes {
    /// Item in a list of mission profiles.
    public struct MissionProfileListItem: Swift.Equatable {
        /// ARN of a mission profile.
        public var missionProfileArn: Swift.String?
        /// UUID of a mission profile.
        public var missionProfileId: Swift.String?
        /// Name of a mission profile.
        public var name: Swift.String?
        /// Region of a mission profile.
        public var region: Swift.String?

        public init (
            missionProfileArn: Swift.String? = nil,
            missionProfileId: Swift.String? = nil,
            name: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.missionProfileArn = missionProfileArn
            self.missionProfileId = missionProfileId
            self.name = name
            self.region = region
        }
    }

}

extension GroundStationClientTypes {
    public enum Polarization: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case leftHand
        case `none`
        case rightHand
        case sdkUnknown(Swift.String)

        public static var allCases: [Polarization] {
            return [
                .leftHand,
                .none,
                .rightHand,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .leftHand: return "LEFT_HAND"
            case .none: return "NONE"
            case .rightHand: return "RIGHT_HAND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Polarization(rawValue: rawValue) ?? Polarization.sdkUnknown(rawValue)
        }
    }
}

extension ReserveContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groundStation
        case missionProfileArn
        case satelliteArn
        case startTime
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let groundStation = groundStation {
            try encodeContainer.encode(groundStation, forKey: .groundStation)
        }
        if let missionProfileArn = missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let satelliteArn = satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension ReserveContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact"
    }
}

///
public struct ReserveContactInput: Swift.Equatable {
    /// End time of a contact.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// Name of a ground station.
    /// This member is required.
    public var groundStation: Swift.String?
    /// ARN of a mission profile.
    /// This member is required.
    public var missionProfileArn: Swift.String?
    /// ARN of a satellite
    /// This member is required.
    public var satelliteArn: Swift.String?
    /// Start time of a contact.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// Tags assigned to a contact.
    public var tags: [Swift.String:Swift.String]?

    public init (
        endTime: ClientRuntime.Date? = nil,
        groundStation: Swift.String? = nil,
        missionProfileArn: Swift.String? = nil,
        satelliteArn: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.endTime = endTime
        self.groundStation = groundStation
        self.missionProfileArn = missionProfileArn
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.tags = tags
    }
}

struct ReserveContactInputBody: Swift.Equatable {
    let missionProfileArn: Swift.String?
    let satelliteArn: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let groundStation: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ReserveContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groundStation
        case missionProfileArn
        case satelliteArn
        case startTime
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ReserveContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReserveContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReserveContactOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReserveContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReserveContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
        } else {
            self.contactId = nil
        }
    }
}

///
public struct ReserveContactOutputResponse: Swift.Equatable {
    /// UUID of a contact.
    public var contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct ReserveContactOutputResponseBody: Swift.Equatable {
    let contactId: Swift.String?
}

extension ReserveContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension ResourceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.parameterName = output.parameterName
        } else {
            self.message = nil
            self.parameterName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Account limits for this resource have been exceeded.
public struct ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    ///
    public var parameterName: Swift.String?

    public init (
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.message = message
        self.parameterName = parameterName
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let parameterName: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case parameterName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GroundStationClientTypes.S3RecordingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn
        case `prefix` = "prefix"
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let `prefix` = `prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about an S3 recording Config.
    public struct S3RecordingConfig: Swift.Equatable {
        /// ARN of the bucket to record to.
        /// This member is required.
        public var bucketArn: Swift.String?
        /// S3 Key prefix to prefice data files.
        public var `prefix`: Swift.String?
        /// ARN of the role Ground Station assumes to write data to the bucket.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            bucketArn: Swift.String? = nil,
            `prefix`: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucketArn = bucketArn
            self.`prefix` = `prefix`
            self.roleArn = roleArn
        }
    }

}

extension GroundStationClientTypes.S3RecordingDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn
        case keyTemplate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let keyTemplate = keyTemplate {
            try encodeContainer.encode(keyTemplate, forKey: .keyTemplate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let keyTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyTemplate)
        keyTemplate = keyTemplateDecoded
    }
}

extension GroundStationClientTypes {
    /// Details about an S3 recording Config used in a contact.
    public struct S3RecordingDetails: Swift.Equatable {
        /// ARN of the bucket used.
        public var bucketArn: Swift.String?
        /// Template of the S3 key used.
        public var keyTemplate: Swift.String?

        public init (
            bucketArn: Swift.String? = nil,
            keyTemplate: Swift.String? = nil
        )
        {
            self.bucketArn = bucketArn
            self.keyTemplate = keyTemplate
        }
    }

}

extension GroundStationClientTypes.SatelliteListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groundStations
        case noradSatelliteID
        case satelliteArn
        case satelliteId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groundStations = groundStations {
            var groundStationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groundStations)
            for groundstationidlist0 in groundStations {
                try groundStationsContainer.encode(groundstationidlist0)
            }
        }
        if noradSatelliteID != 0 {
            try encodeContainer.encode(noradSatelliteID, forKey: .noradSatelliteID)
        }
        if let satelliteArn = satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let satelliteId = satelliteId {
            try encodeContainer.encode(satelliteId, forKey: .satelliteId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let satelliteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteId)
        satelliteId = satelliteIdDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let noradSatelliteIDDecoded = try containerValues.decode(Swift.Int.self, forKey: .noradSatelliteID)
        noradSatelliteID = noradSatelliteIDDecoded
        let groundStationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groundStations)
        var groundStationsDecoded0:[Swift.String]? = nil
        if let groundStationsContainer = groundStationsContainer {
            groundStationsDecoded0 = [Swift.String]()
            for string0 in groundStationsContainer {
                if let string0 = string0 {
                    groundStationsDecoded0?.append(string0)
                }
            }
        }
        groundStations = groundStationsDecoded0
    }
}

extension GroundStationClientTypes {
    /// Item in a list of satellites.
    public struct SatelliteListItem: Swift.Equatable {
        /// A list of ground stations to which the satellite is on-boarded.
        public var groundStations: [Swift.String]?
        /// NORAD satellite ID number.
        public var noradSatelliteID: Swift.Int
        /// ARN of a satellite.
        public var satelliteArn: Swift.String?
        /// UUID of a satellite.
        public var satelliteId: Swift.String?

        public init (
            groundStations: [Swift.String]? = nil,
            noradSatelliteID: Swift.Int = 0,
            satelliteArn: Swift.String? = nil,
            satelliteId: Swift.String? = nil
        )
        {
            self.groundStations = groundStations
            self.noradSatelliteID = noradSatelliteID
            self.satelliteArn = satelliteArn
            self.satelliteId = satelliteId
        }
    }

}

extension GroundStationClientTypes.SecurityDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case securityGroupIds
        case subnetIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about endpoints.
    public struct SecurityDetails: Swift.Equatable {
        /// ARN to a role needed for connecting streams to your instances.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The security groups to attach to the elastic network interfaces.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnets where AWS Ground Station places elastic network interfaces to send streams to your instances.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init (
            roleArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension GroundStationClientTypes.SocketAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case port
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the socket address.
    public struct SocketAddress: Swift.Equatable {
        /// Name of a socket address.
        /// This member is required.
        public var name: Swift.String?
        /// Port of a socket address.
        /// This member is required.
        public var port: Swift.Int?

        public init (
            name: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.name = name
            self.port = port
        }
    }

}

extension GroundStationClientTypes.Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configDetails
        case configId
        case configType
        case dataflowSourceRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configDetails = configDetails {
            try encodeContainer.encode(configDetails, forKey: .configDetails)
        }
        if let configId = configId {
            try encodeContainer.encode(configId, forKey: .configId)
        }
        if let configType = configType {
            try encodeContainer.encode(configType.rawValue, forKey: .configType)
        }
        if let dataflowSourceRegion = dataflowSourceRegion {
            try encodeContainer.encode(dataflowSourceRegion, forKey: .dataflowSourceRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configDetailsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigDetails.self, forKey: .configDetails)
        configDetails = configDetailsDecoded
        let dataflowSourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowSourceRegion)
        dataflowSourceRegion = dataflowSourceRegionDecoded
    }
}

extension GroundStationClientTypes {
    /// Dataflow details for the source side.
    public struct Source: Swift.Equatable {
        /// Additional details for a Config, if type is dataflow endpoint or antenna demod decode.
        public var configDetails: GroundStationClientTypes.ConfigDetails?
        /// UUID of a Config.
        public var configId: Swift.String?
        /// Type of a Config.
        public var configType: GroundStationClientTypes.ConfigCapabilityType?
        /// Region of a dataflow source.
        public var dataflowSourceRegion: Swift.String?

        public init (
            configDetails: GroundStationClientTypes.ConfigDetails? = nil,
            configId: Swift.String? = nil,
            configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
            dataflowSourceRegion: Swift.String? = nil
        )
        {
            self.configDetails = configDetails
            self.configId = configId
            self.configType = configType
            self.dataflowSourceRegion = dataflowSourceRegion
        }
    }

}

extension GroundStationClientTypes.SpectrumConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth
        case centerFrequency
        case polarization
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let centerFrequency = centerFrequency {
            try encodeContainer.encode(centerFrequency, forKey: .centerFrequency)
        }
        if let polarization = polarization {
            try encodeContainer.encode(polarization.rawValue, forKey: .polarization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let centerFrequencyDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Frequency.self, forKey: .centerFrequency)
        centerFrequency = centerFrequencyDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.FrequencyBandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let polarizationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Polarization.self, forKey: .polarization)
        polarization = polarizationDecoded
    }
}

extension GroundStationClientTypes {
    /// Object that describes a spectral Config.
    public struct SpectrumConfig: Swift.Equatable {
        /// Bandwidth of a spectral Config. AWS Ground Station currently has the following bandwidth limitations:
        ///
        /// * For AntennaDownlinkDemodDecodeconfig, valid values are between 125 kHz to 650 MHz.
        ///
        /// * For AntennaDownlinkconfig valid values are between 10 kHz to 54 MHz.
        ///
        /// * For AntennaUplinkConfig, valid values are between 10 kHz to 54 MHz.
        /// This member is required.
        public var bandwidth: GroundStationClientTypes.FrequencyBandwidth?
        /// Center frequency of a spectral Config. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.
        /// This member is required.
        public var centerFrequency: GroundStationClientTypes.Frequency?
        /// Polarization of a spectral Config. Capturing both "RIGHT_HAND" and "LEFT_HAND" polarization requires two separate configs.
        public var polarization: GroundStationClientTypes.Polarization?

        public init (
            bandwidth: GroundStationClientTypes.FrequencyBandwidth? = nil,
            centerFrequency: GroundStationClientTypes.Frequency? = nil,
            polarization: GroundStationClientTypes.Polarization? = nil
        )
        {
            self.bandwidth = bandwidth
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

///
public struct TagResourceInput: Swift.Equatable {
    /// ARN of a resource tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags assigned to a resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct TagResourceOutputResponse: Swift.Equatable {

}

extension GroundStationClientTypes.TrackingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autotrack
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autotrack = autotrack {
            try encodeContainer.encode(autotrack.rawValue, forKey: .autotrack)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autotrackDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Criticality.self, forKey: .autotrack)
        autotrack = autotrackDecoded
    }
}

extension GroundStationClientTypes {
    /// Object that determines whether tracking should be used during a contact executed with this Config in the mission profile.
    public struct TrackingConfig: Swift.Equatable {
        /// Current setting for autotrack.
        /// This member is required.
        public var autotrack: GroundStationClientTypes.Criticality?

        public init (
            autotrack: GroundStationClientTypes.Criticality? = nil
        )
        {
            self.autotrack = autotrack
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

///
public struct UntagResourceInput: Swift.Equatable {
    /// ARN of a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys of a resource tag.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configData
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configData = configData {
            try encodeContainer.encode(configData, forKey: .configData)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configType = configType else {
            return nil
        }
        guard let configId = configId else {
            return nil
        }
        return "/config/\(configType.rawValue.urlPercentEncoding())/\(configId.urlPercentEncoding())"
    }
}

///
public struct UpdateConfigInput: Swift.Equatable {
    /// Parameters of a Config.
    /// This member is required.
    public var configData: GroundStationClientTypes.ConfigTypeData?
    /// UUID of a Config.
    /// This member is required.
    public var configId: Swift.String?
    /// Type of a Config.
    /// This member is required.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?
    /// Name of a Config.
    /// This member is required.
    public var name: Swift.String?

    public init (
        configData: GroundStationClientTypes.ConfigTypeData? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
        name: Swift.String? = nil
    )
    {
        self.configData = configData
        self.configId = configId
        self.configType = configType
        self.name = name
    }
}

struct UpdateConfigInputBody: Swift.Equatable {
    let name: Swift.String?
    let configData: GroundStationClientTypes.ConfigTypeData?
}

extension UpdateConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configData
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configDataDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigTypeData.self, forKey: .configData)
        configData = configDataDecoded
    }
}

extension UpdateConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configArn = output.configArn
            self.configId = output.configId
            self.configType = output.configType
        } else {
            self.configArn = nil
            self.configId = nil
            self.configType = nil
        }
    }
}

///
public struct UpdateConfigOutputResponse: Swift.Equatable {
    /// ARN of a Config.
    public var configArn: Swift.String?
    /// UUID of a Config.
    public var configId: Swift.String?
    /// Type of a Config.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init (
        configArn: Swift.String? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

struct UpdateConfigOutputResponseBody: Swift.Equatable {
    let configId: Swift.String?
    let configType: GroundStationClientTypes.ConfigCapabilityType?
    let configArn: Swift.String?
}

extension UpdateConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configId
        case configType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
    }
}

extension UpdateMissionProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case trackingConfigArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactPostPassDurationSeconds = contactPostPassDurationSeconds {
            try encodeContainer.encode(contactPostPassDurationSeconds, forKey: .contactPostPassDurationSeconds)
        }
        if let contactPrePassDurationSeconds = contactPrePassDurationSeconds {
            try encodeContainer.encode(contactPrePassDurationSeconds, forKey: .contactPrePassDurationSeconds)
        }
        if let dataflowEdges = dataflowEdges {
            var dataflowEdgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataflowEdges)
            for dataflowedgelist0 in dataflowEdges {
                var dataflowedgelist0Container = dataflowEdgesContainer.nestedUnkeyedContainer()
                for dataflowedge1 in dataflowedgelist0 {
                    try dataflowedgelist0Container.encode(dataflowedge1)
                }
            }
        }
        if let minimumViableContactDurationSeconds = minimumViableContactDurationSeconds {
            try encodeContainer.encode(minimumViableContactDurationSeconds, forKey: .minimumViableContactDurationSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let trackingConfigArn = trackingConfigArn {
            try encodeContainer.encode(trackingConfigArn, forKey: .trackingConfigArn)
        }
    }
}

extension UpdateMissionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let missionProfileId = missionProfileId else {
            return nil
        }
        return "/missionprofile/\(missionProfileId.urlPercentEncoding())"
    }
}

///
public struct UpdateMissionProfileInput: Swift.Equatable {
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var contactPostPassDurationSeconds: Swift.Int?
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var contactPrePassDurationSeconds: Swift.Int?
    /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
    public var dataflowEdges: [[Swift.String]]?
    /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
    public var minimumViableContactDurationSeconds: Swift.Int?
    /// UUID of a mission profile.
    /// This member is required.
    public var missionProfileId: Swift.String?
    /// Name of a mission profile.
    public var name: Swift.String?
    /// ARN of a tracking Config.
    public var trackingConfigArn: Swift.String?

    public init (
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEdges: [[Swift.String]]? = nil,
        minimumViableContactDurationSeconds: Swift.Int? = nil,
        missionProfileId: Swift.String? = nil,
        name: Swift.String? = nil,
        trackingConfigArn: Swift.String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.missionProfileId = missionProfileId
        self.name = name
        self.trackingConfigArn = trackingConfigArn
    }
}

struct UpdateMissionProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let contactPrePassDurationSeconds: Swift.Int?
    let contactPostPassDurationSeconds: Swift.Int?
    let minimumViableContactDurationSeconds: Swift.Int?
    let dataflowEdges: [[Swift.String]]?
    let trackingConfigArn: Swift.String?
}

extension UpdateMissionProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case trackingConfigArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
        let minimumViableContactDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumViableContactDurationSeconds)
        minimumViableContactDurationSeconds = minimumViableContactDurationSecondsDecoded
        let dataflowEdgesContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .dataflowEdges)
        var dataflowEdgesDecoded0:[[Swift.String]]? = nil
        if let dataflowEdgesContainer = dataflowEdgesContainer {
            dataflowEdgesDecoded0 = [[Swift.String]]()
            for list0 in dataflowEdgesContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    dataflowEdgesDecoded0?.append(list0Decoded0)
                }
            }
        }
        dataflowEdges = dataflowEdgesDecoded0
        let trackingConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingConfigArn)
        trackingConfigArn = trackingConfigArnDecoded
    }
}

extension UpdateMissionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMissionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMissionProfileOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMissionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateMissionProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.missionProfileId = output.missionProfileId
        } else {
            self.missionProfileId = nil
        }
    }
}

///
public struct UpdateMissionProfileOutputResponse: Swift.Equatable {
    /// UUID of a mission profile.
    public var missionProfileId: Swift.String?

    public init (
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct UpdateMissionProfileOutputResponseBody: Swift.Equatable {
    let missionProfileId: Swift.String?
}

extension UpdateMissionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
    }
}

extension GroundStationClientTypes.UplinkEchoConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case antennaUplinkConfigArn
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let antennaUplinkConfigArn = antennaUplinkConfigArn {
            try encodeContainer.encode(antennaUplinkConfigArn, forKey: .antennaUplinkConfigArn)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let antennaUplinkConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .antennaUplinkConfigArn)
        antennaUplinkConfigArn = antennaUplinkConfigArnDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about an uplink echo Config. Parameters from the AntennaUplinkConfig, corresponding to the specified AntennaUplinkConfigArn, are used when this UplinkEchoConfig is used in a contact.
    public struct UplinkEchoConfig: Swift.Equatable {
        /// ARN of an uplink Config.
        /// This member is required.
        public var antennaUplinkConfigArn: Swift.String?
        /// Whether or not an uplink Config is enabled.
        /// This member is required.
        public var enabled: Swift.Bool?

        public init (
            antennaUplinkConfigArn: Swift.String? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.antennaUplinkConfigArn = antennaUplinkConfigArn
            self.enabled = enabled
        }
    }

}

extension GroundStationClientTypes.UplinkSpectrumConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case centerFrequency
        case polarization
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let centerFrequency = centerFrequency {
            try encodeContainer.encode(centerFrequency, forKey: .centerFrequency)
        }
        if let polarization = polarization {
            try encodeContainer.encode(polarization.rawValue, forKey: .polarization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let centerFrequencyDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Frequency.self, forKey: .centerFrequency)
        centerFrequency = centerFrequencyDecoded
        let polarizationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Polarization.self, forKey: .polarization)
        polarization = polarizationDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the uplink spectral Config.
    public struct UplinkSpectrumConfig: Swift.Equatable {
        /// Center frequency of an uplink spectral Config. Valid values are between 2025 to 2120 MHz.
        /// This member is required.
        public var centerFrequency: GroundStationClientTypes.Frequency?
        /// Polarization of an uplink spectral Config. Capturing both "RIGHT_HAND" and "LEFT_HAND" polarization requires two separate configs.
        public var polarization: GroundStationClientTypes.Polarization?

        public init (
            centerFrequency: GroundStationClientTypes.Frequency? = nil,
            polarization: GroundStationClientTypes.Polarization? = nil
        )
        {
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }
    }

}
