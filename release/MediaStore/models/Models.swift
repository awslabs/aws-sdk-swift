// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Container: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case accessLoggingEnabled = "AccessLoggingEnabled"
        case creationTime = "CreationTime"
        case endpoint = "Endpoint"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let accessLoggingEnabled = accessLoggingEnabled {
            try encodeContainer.encode(accessLoggingEnabled, forKey: .accessLoggingEnabled)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ContainerStatus.self, forKey: .status)
        status = statusDecoded
        let accessLoggingEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .accessLoggingEnabled)
        accessLoggingEnabled = accessLoggingEnabledDecoded
    }
}

extension Container: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Container(aRN: \(String(describing: aRN)), accessLoggingEnabled: \(String(describing: accessLoggingEnabled)), creationTime: \(String(describing: creationTime)), endpoint: \(String(describing: endpoint)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>This section describes operations that you can perform on an AWS Elemental MediaStore
///          container.</p>
public struct Container: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the container. The ARN has the following
    ///          format:</p>
    ///          <p>arn:aws:<region>:<account that owns this container>:container/<name of
    ///          container> </p>
    ///          <p>For example: arn:aws:mediastore:us-west-2:111122223333:container/movies </p>
    public let aRN: String?
    /// <p>The state of access logging on the container. This value is <code>false</code> by default, indicating that AWS Elemental MediaStore does not send access logs to Amazon CloudWatch Logs. When you enable access logging on the container, MediaStore changes this value to <code>true</code>, indicating that the service delivers access logs for objects stored in that container to CloudWatch Logs.</p>
    public let accessLoggingEnabled: Bool?
    /// <p>Unix timestamp.</p>
    public let creationTime: Date?
    /// <p>The DNS endpoint of the container. Use the endpoint to identify the specific
    ///          container when sending requests to the data plane. The service assigns this value when the
    ///          container is created. Once the value has been assigned, it does not change.</p>
    public let endpoint: String?
    /// <p>The name of the container.</p>
    public let name: String?
    /// <p>The status of container creation or deletion. The status is one of the following:
    ///             <code>CREATING</code>, <code>ACTIVE</code>, or <code>DELETING</code>. While the service
    ///          is creating the container, the status is <code>CREATING</code>. When the endpoint is
    ///          available, the status changes to <code>ACTIVE</code>.</p>
    public let status: ContainerStatus?

    public init (
        aRN: String? = nil,
        accessLoggingEnabled: Bool? = nil,
        creationTime: Date? = nil,
        endpoint: String? = nil,
        name: String? = nil,
        status: ContainerStatus? = nil
    )
    {
        self.aRN = aRN
        self.accessLoggingEnabled = accessLoggingEnabled
        self.creationTime = creationTime
        self.endpoint = endpoint
        self.name = name
        self.status = status
    }
}

extension ContainerInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContainerInUseException(message: \(String(describing: message)))"}
}

extension ContainerInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ContainerInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The container that you specified in the request already exists or is being
///          updated.</p>
public struct ContainerInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ContainerInUseExceptionBody: Equatable {
    public let message: String?
}

extension ContainerInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ContainerLevelMetrics {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension ContainerLevelMetrics : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContainerLevelMetrics] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContainerLevelMetrics(rawValue: rawValue) ?? ContainerLevelMetrics.sdkUnknown(rawValue)
    }
}

extension ContainerNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContainerNotFoundException(message: \(String(describing: message)))"}
}

extension ContainerNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ContainerNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The container that you specified in the request does not exist.</p>
public struct ContainerNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ContainerNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ContainerNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ContainerStatus {
    case active
    case creating
    case deleting
    case sdkUnknown(String)
}

extension ContainerStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContainerStatus] {
        return [
            .active,
            .creating,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContainerStatus(rawValue: rawValue) ?? ContainerStatus.sdkUnknown(rawValue)
    }
}

extension CorsPolicyNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CorsPolicyNotFoundException(message: \(String(describing: message)))"}
}

extension CorsPolicyNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CorsPolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The CORS policy that you specified in the request does not exist.</p>
public struct CorsPolicyNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CorsPolicyNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension CorsPolicyNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CorsRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedHeaders = "AllowedHeaders"
        case allowedMethods = "AllowedMethods"
        case allowedOrigins = "AllowedOrigins"
        case exposeHeaders = "ExposeHeaders"
        case maxAgeSeconds = "MaxAgeSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedHeaders = allowedHeaders {
            var allowedHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedHeaders)
            for allowedheaders0 in allowedHeaders {
                try allowedHeadersContainer.encode(allowedheaders0)
            }
        }
        if let allowedMethods = allowedMethods {
            var allowedMethodsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedMethods)
            for allowedmethods0 in allowedMethods {
                try allowedMethodsContainer.encode(allowedmethods0.rawValue)
            }
        }
        if let allowedOrigins = allowedOrigins {
            var allowedOriginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOrigins)
            for allowedorigins0 in allowedOrigins {
                try allowedOriginsContainer.encode(allowedorigins0)
            }
        }
        if let exposeHeaders = exposeHeaders {
            var exposeHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exposeHeaders)
            for exposeheaders0 in exposeHeaders {
                try exposeHeadersContainer.encode(exposeheaders0)
            }
        }
        if maxAgeSeconds != 0 {
            try encodeContainer.encode(maxAgeSeconds, forKey: .maxAgeSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedOriginsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .allowedOrigins)
        var allowedOriginsDecoded0:[String]? = nil
        if let allowedOriginsContainer = allowedOriginsContainer {
            allowedOriginsDecoded0 = [String]()
            for string0 in allowedOriginsContainer {
                if let string0 = string0 {
                    allowedOriginsDecoded0?.append(string0)
                }
            }
        }
        allowedOrigins = allowedOriginsDecoded0
        let allowedMethodsContainer = try containerValues.decodeIfPresent([MethodName?].self, forKey: .allowedMethods)
        var allowedMethodsDecoded0:[MethodName]? = nil
        if let allowedMethodsContainer = allowedMethodsContainer {
            allowedMethodsDecoded0 = [MethodName]()
            for string0 in allowedMethodsContainer {
                if let string0 = string0 {
                    allowedMethodsDecoded0?.append(string0)
                }
            }
        }
        allowedMethods = allowedMethodsDecoded0
        let allowedHeadersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .allowedHeaders)
        var allowedHeadersDecoded0:[String]? = nil
        if let allowedHeadersContainer = allowedHeadersContainer {
            allowedHeadersDecoded0 = [String]()
            for string0 in allowedHeadersContainer {
                if let string0 = string0 {
                    allowedHeadersDecoded0?.append(string0)
                }
            }
        }
        allowedHeaders = allowedHeadersDecoded0
        let maxAgeSecondsDecoded = try containerValues.decode(Int.self, forKey: .maxAgeSeconds)
        maxAgeSeconds = maxAgeSecondsDecoded
        let exposeHeadersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exposeHeaders)
        var exposeHeadersDecoded0:[String]? = nil
        if let exposeHeadersContainer = exposeHeadersContainer {
            exposeHeadersDecoded0 = [String]()
            for string0 in exposeHeadersContainer {
                if let string0 = string0 {
                    exposeHeadersDecoded0?.append(string0)
                }
            }
        }
        exposeHeaders = exposeHeadersDecoded0
    }
}

extension CorsRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CorsRule(allowedHeaders: \(String(describing: allowedHeaders)), allowedMethods: \(String(describing: allowedMethods)), allowedOrigins: \(String(describing: allowedOrigins)), exposeHeaders: \(String(describing: exposeHeaders)), maxAgeSeconds: \(String(describing: maxAgeSeconds)))"}
}

/// <p>A rule for a CORS policy. You can add up to 100 rules to a CORS policy. If more than
///          one rule applies, the service uses the first applicable rule listed.</p>
public struct CorsRule: Equatable {
    /// <p>Specifies which headers are allowed in a preflight <code>OPTIONS</code> request
    ///          through the <code>Access-Control-Request-Headers</code> header. Each header name that is
    ///          specified in <code>Access-Control-Request-Headers</code> must have a corresponding entry in
    ///          the rule. Only the headers that were requested are sent back. </p>
    ///          <p>This element can contain only one wildcard character (*).</p>
    public let allowedHeaders: [String]?
    /// <p>Identifies an HTTP method that the origin that is specified in the rule is allowed to
    ///          execute.</p>
    ///          <p>Each CORS rule must contain at least one <code>AllowedMethods</code> and one
    ///             <code>AllowedOrigins</code> element.</p>
    public let allowedMethods: [MethodName]?
    /// <p>One or more response headers that you want users to be able to access from their
    ///          applications (for example, from a JavaScript <code>XMLHttpRequest</code> object).</p>
    ///          <p>Each CORS rule must have at least one <code>AllowedOrigins</code> element. The string
    ///          value can include only one wildcard character (*), for example, http://*.example.com.
    ///          Additionally, you can specify only one wildcard character to allow cross-origin access for
    ///          all origins.</p>
    public let allowedOrigins: [String]?
    /// <p>One or more headers in the response that you want users to be able to access from
    ///          their applications (for example, from a JavaScript <code>XMLHttpRequest</code>
    ///          object).</p>
    ///          <p>This element is optional for each rule.</p>
    public let exposeHeaders: [String]?
    /// <p>The time in seconds that your browser caches the preflight response for the specified
    ///          resource.</p>
    ///          <p>A CORS rule can have only one <code>MaxAgeSeconds</code> element.</p>
    public let maxAgeSeconds: Int

    public init (
        allowedHeaders: [String]? = nil,
        allowedMethods: [MethodName]? = nil,
        allowedOrigins: [String]? = nil,
        exposeHeaders: [String]? = nil,
        maxAgeSeconds: Int = 0
    )
    {
        self.allowedHeaders = allowedHeaders
        self.allowedMethods = allowedMethods
        self.allowedOrigins = allowedOrigins
        self.exposeHeaders = exposeHeaders
        self.maxAgeSeconds = maxAgeSeconds
    }
}

public struct CreateContainerInputBodyMiddleware: Middleware {
    public let id: String = "CreateContainerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContainerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContainerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContainerInput>
    public typealias MOutput = OperationOutput<CreateContainerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContainerOutputError>
}

extension CreateContainerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateContainerInput(containerName: \(String(describing: containerName)), tags: \(String(describing: tags)))"}
}

extension CreateContainerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateContainerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateContainerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContainerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContainerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContainerInput>
    public typealias MOutput = OperationOutput<CreateContainerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContainerOutputError>
}

public struct CreateContainerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateContainerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContainerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContainerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContainerInput>
    public typealias MOutput = OperationOutput<CreateContainerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContainerOutputError>
}

public struct CreateContainerInput: Equatable {
    /// <p>The name for the container. The name must be from 1 to 255 characters. Container
    ///          names must be unique to your AWS account within a specific region. As an example, you could
    ///          create a container named <code>movies</code> in every region, as long as you don’t have an
    ///          existing container with that name.</p>
    public let containerName: String?
    /// <p>An array of key:value pairs that you define. These values can be anything that you want. Typically, the tag key represents a category (such as
    ///            "environment") and the tag value represents a specific value within that category (such as "test," "development," or "production"). You can add up to 50
    ///            tags to each container. For more information about tagging, including naming and usage conventions, see <a href="https://docs.aws.amazon.com/mediastore/latest/ug/tagging.html">Tagging Resources in MediaStore</a>.</p>
    public let tags: [Tag]?

    public init (
        containerName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.containerName = containerName
        self.tags = tags
    }
}

struct CreateContainerInputBody: Equatable {
    public let containerName: String?
    public let tags: [Tag]?
}

extension CreateContainerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateContainerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContainerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContainerOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case internalServerError(InternalServerError)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContainerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateContainerOutputResponse(container: \(String(describing: container)))"}
}

extension CreateContainerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateContainerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.container = output.container
        } else {
            self.container = nil
        }
    }
}

public struct CreateContainerOutputResponse: Equatable {
    /// <p>ContainerARN: The Amazon Resource Name (ARN) of the newly created container. The ARN
    ///          has the following format: arn:aws:<region>:<account that owns this
    ///          container>:container/<name of container>. For example:
    ///          arn:aws:mediastore:us-west-2:111122223333:container/movies </p>
    ///          <p>ContainerName: The container name as specified in the request.</p>
    ///          <p>CreationTime: Unix time stamp.</p>
    ///          <p>Status: The status of container creation or deletion. The status is one of the
    ///          following: <code>CREATING</code>, <code>ACTIVE</code>, or <code>DELETING</code>. While the
    ///          service is creating the container, the status is <code>CREATING</code>. When an endpoint is
    ///          available, the status changes to <code>ACTIVE</code>.</p>
    ///          <p>The return value does not include the container's endpoint. To make downstream
    ///          requests, you must obtain this value by using <a>DescribeContainer</a> or <a>ListContainers</a>.</p>
    public let container: Container?

    public init (
        container: Container? = nil
    )
    {
        self.container = container
    }
}

struct CreateContainerOutputResponseBody: Equatable {
    public let container: Container?
}

extension CreateContainerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case container = "Container"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerDecoded = try containerValues.decodeIfPresent(Container.self, forKey: .container)
        container = containerDecoded
    }
}

public struct DeleteContainerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteContainerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContainerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContainerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContainerInput>
    public typealias MOutput = OperationOutput<DeleteContainerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContainerOutputError>
}

extension DeleteContainerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteContainerInput(containerName: \(String(describing: containerName)))"}
}

extension DeleteContainerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

public struct DeleteContainerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteContainerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContainerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContainerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContainerInput>
    public typealias MOutput = OperationOutput<DeleteContainerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContainerOutputError>
}

public struct DeleteContainerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteContainerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContainerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContainerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContainerInput>
    public typealias MOutput = OperationOutput<DeleteContainerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContainerOutputError>
}

public struct DeleteContainerInput: Equatable {
    /// <p>The name of the container to delete. </p>
    public let containerName: String?

    public init (
        containerName: String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DeleteContainerInputBody: Equatable {
    public let containerName: String?
}

extension DeleteContainerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DeleteContainerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContainerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContainerOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContainerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteContainerOutputResponse()"}
}

extension DeleteContainerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContainerOutputResponse: Equatable {

    public init() {}
}

struct DeleteContainerOutputResponseBody: Equatable {
}

extension DeleteContainerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteContainerPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteContainerPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContainerPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContainerPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContainerPolicyInput>
    public typealias MOutput = OperationOutput<DeleteContainerPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContainerPolicyOutputError>
}

extension DeleteContainerPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteContainerPolicyInput(containerName: \(String(describing: containerName)))"}
}

extension DeleteContainerPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

public struct DeleteContainerPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteContainerPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContainerPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContainerPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContainerPolicyInput>
    public typealias MOutput = OperationOutput<DeleteContainerPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContainerPolicyOutputError>
}

public struct DeleteContainerPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteContainerPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContainerPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContainerPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContainerPolicyInput>
    public typealias MOutput = OperationOutput<DeleteContainerPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContainerPolicyOutputError>
}

public struct DeleteContainerPolicyInput: Equatable {
    /// <p>The name of the container that holds the policy.</p>
    public let containerName: String?

    public init (
        containerName: String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DeleteContainerPolicyInputBody: Equatable {
    public let containerName: String?
}

extension DeleteContainerPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DeleteContainerPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContainerPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFoundException" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContainerPolicyOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContainerPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteContainerPolicyOutputResponse()"}
}

extension DeleteContainerPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContainerPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteContainerPolicyOutputResponseBody: Equatable {
}

extension DeleteContainerPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteCorsPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteCorsPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCorsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCorsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCorsPolicyInput>
    public typealias MOutput = OperationOutput<DeleteCorsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCorsPolicyOutputError>
}

extension DeleteCorsPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCorsPolicyInput(containerName: \(String(describing: containerName)))"}
}

extension DeleteCorsPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

public struct DeleteCorsPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCorsPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCorsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCorsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCorsPolicyInput>
    public typealias MOutput = OperationOutput<DeleteCorsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCorsPolicyOutputError>
}

public struct DeleteCorsPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCorsPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCorsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCorsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCorsPolicyInput>
    public typealias MOutput = OperationOutput<DeleteCorsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCorsPolicyOutputError>
}

public struct DeleteCorsPolicyInput: Equatable {
    /// <p>The name of the container to remove the policy from.</p>
    public let containerName: String?

    public init (
        containerName: String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DeleteCorsPolicyInputBody: Equatable {
    public let containerName: String?
}

extension DeleteCorsPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DeleteCorsPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCorsPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CorsPolicyNotFoundException" : self = .corsPolicyNotFoundException(try CorsPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCorsPolicyOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case corsPolicyNotFoundException(CorsPolicyNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCorsPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCorsPolicyOutputResponse()"}
}

extension DeleteCorsPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCorsPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteCorsPolicyOutputResponseBody: Equatable {
}

extension DeleteCorsPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteLifecyclePolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLifecyclePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<DeleteLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLifecyclePolicyOutputError>
}

extension DeleteLifecyclePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLifecyclePolicyInput(containerName: \(String(describing: containerName)))"}
}

extension DeleteLifecyclePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

public struct DeleteLifecyclePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<DeleteLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLifecyclePolicyOutputError>
}

public struct DeleteLifecyclePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<DeleteLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLifecyclePolicyOutputError>
}

public struct DeleteLifecyclePolicyInput: Equatable {
    /// <p>The name of the container that holds the object lifecycle policy.</p>
    public let containerName: String?

    public init (
        containerName: String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DeleteLifecyclePolicyInputBody: Equatable {
    public let containerName: String?
}

extension DeleteLifecyclePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DeleteLifecyclePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLifecyclePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFoundException" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLifecyclePolicyOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLifecyclePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLifecyclePolicyOutputResponse()"}
}

extension DeleteLifecyclePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLifecyclePolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteLifecyclePolicyOutputResponseBody: Equatable {
}

extension DeleteLifecyclePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteMetricPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteMetricPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMetricPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMetricPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMetricPolicyInput>
    public typealias MOutput = OperationOutput<DeleteMetricPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMetricPolicyOutputError>
}

extension DeleteMetricPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMetricPolicyInput(containerName: \(String(describing: containerName)))"}
}

extension DeleteMetricPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

public struct DeleteMetricPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteMetricPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMetricPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMetricPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMetricPolicyInput>
    public typealias MOutput = OperationOutput<DeleteMetricPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMetricPolicyOutputError>
}

public struct DeleteMetricPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteMetricPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMetricPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMetricPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMetricPolicyInput>
    public typealias MOutput = OperationOutput<DeleteMetricPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMetricPolicyOutputError>
}

public struct DeleteMetricPolicyInput: Equatable {
    /// <p>The name of the container that is associated with the metric policy that you want to delete.</p>
    public let containerName: String?

    public init (
        containerName: String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DeleteMetricPolicyInputBody: Equatable {
    public let containerName: String?
}

extension DeleteMetricPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DeleteMetricPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMetricPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFoundException" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMetricPolicyOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMetricPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMetricPolicyOutputResponse()"}
}

extension DeleteMetricPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMetricPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteMetricPolicyOutputResponseBody: Equatable {
}

extension DeleteMetricPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeContainerInputBodyMiddleware: Middleware {
    public let id: String = "DescribeContainerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeContainerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeContainerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeContainerInput>
    public typealias MOutput = OperationOutput<DescribeContainerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeContainerOutputError>
}

extension DescribeContainerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeContainerInput(containerName: \(String(describing: containerName)))"}
}

extension DescribeContainerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

public struct DescribeContainerInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeContainerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeContainerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeContainerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeContainerInput>
    public typealias MOutput = OperationOutput<DescribeContainerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeContainerOutputError>
}

public struct DescribeContainerInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeContainerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeContainerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeContainerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeContainerInput>
    public typealias MOutput = OperationOutput<DescribeContainerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeContainerOutputError>
}

public struct DescribeContainerInput: Equatable {
    /// <p>The name of the container to query.</p>
    public let containerName: String?

    public init (
        containerName: String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DescribeContainerInputBody: Equatable {
    public let containerName: String?
}

extension DescribeContainerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DescribeContainerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeContainerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeContainerOutputError: Equatable {
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeContainerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeContainerOutputResponse(container: \(String(describing: container)))"}
}

extension DescribeContainerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeContainerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.container = output.container
        } else {
            self.container = nil
        }
    }
}

public struct DescribeContainerOutputResponse: Equatable {
    /// <p>The name of the queried container.</p>
    public let container: Container?

    public init (
        container: Container? = nil
    )
    {
        self.container = container
    }
}

struct DescribeContainerOutputResponseBody: Equatable {
    public let container: Container?
}

extension DescribeContainerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case container = "Container"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerDecoded = try containerValues.decodeIfPresent(Container.self, forKey: .container)
        container = containerDecoded
    }
}

public struct GetContainerPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetContainerPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContainerPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContainerPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContainerPolicyInput>
    public typealias MOutput = OperationOutput<GetContainerPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContainerPolicyOutputError>
}

extension GetContainerPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContainerPolicyInput(containerName: \(String(describing: containerName)))"}
}

extension GetContainerPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

public struct GetContainerPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetContainerPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContainerPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContainerPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContainerPolicyInput>
    public typealias MOutput = OperationOutput<GetContainerPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContainerPolicyOutputError>
}

public struct GetContainerPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetContainerPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContainerPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContainerPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContainerPolicyInput>
    public typealias MOutput = OperationOutput<GetContainerPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContainerPolicyOutputError>
}

public struct GetContainerPolicyInput: Equatable {
    /// <p>The name of the container. </p>
    public let containerName: String?

    public init (
        containerName: String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct GetContainerPolicyInputBody: Equatable {
    public let containerName: String?
}

extension GetContainerPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension GetContainerPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContainerPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFoundException" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContainerPolicyOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContainerPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContainerPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetContainerPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetContainerPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetContainerPolicyOutputResponse: Equatable {
    /// <p>The contents of the access policy.</p>
    public let policy: String?

    public init (
        policy: String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetContainerPolicyOutputResponseBody: Equatable {
    public let policy: String?
}

extension GetContainerPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct GetCorsPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetCorsPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCorsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCorsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCorsPolicyInput>
    public typealias MOutput = OperationOutput<GetCorsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCorsPolicyOutputError>
}

extension GetCorsPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCorsPolicyInput(containerName: \(String(describing: containerName)))"}
}

extension GetCorsPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

public struct GetCorsPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetCorsPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCorsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCorsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCorsPolicyInput>
    public typealias MOutput = OperationOutput<GetCorsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCorsPolicyOutputError>
}

public struct GetCorsPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCorsPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCorsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCorsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCorsPolicyInput>
    public typealias MOutput = OperationOutput<GetCorsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCorsPolicyOutputError>
}

public struct GetCorsPolicyInput: Equatable {
    /// <p>The name of the container that the policy is assigned to.</p>
    public let containerName: String?

    public init (
        containerName: String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct GetCorsPolicyInputBody: Equatable {
    public let containerName: String?
}

extension GetCorsPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension GetCorsPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCorsPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CorsPolicyNotFoundException" : self = .corsPolicyNotFoundException(try CorsPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCorsPolicyOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case corsPolicyNotFoundException(CorsPolicyNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCorsPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCorsPolicyOutputResponse(corsPolicy: \(String(describing: corsPolicy)))"}
}

extension GetCorsPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCorsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.corsPolicy = output.corsPolicy
        } else {
            self.corsPolicy = nil
        }
    }
}

public struct GetCorsPolicyOutputResponse: Equatable {
    /// <p>The CORS policy assigned to the container.</p>
    public let corsPolicy: [CorsRule]?

    public init (
        corsPolicy: [CorsRule]? = nil
    )
    {
        self.corsPolicy = corsPolicy
    }
}

struct GetCorsPolicyOutputResponseBody: Equatable {
    public let corsPolicy: [CorsRule]?
}

extension GetCorsPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case corsPolicy = "CorsPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let corsPolicyContainer = try containerValues.decodeIfPresent([CorsRule?].self, forKey: .corsPolicy)
        var corsPolicyDecoded0:[CorsRule]? = nil
        if let corsPolicyContainer = corsPolicyContainer {
            corsPolicyDecoded0 = [CorsRule]()
            for structure0 in corsPolicyContainer {
                if let structure0 = structure0 {
                    corsPolicyDecoded0?.append(structure0)
                }
            }
        }
        corsPolicy = corsPolicyDecoded0
    }
}

public struct GetLifecyclePolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetLifecyclePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<GetLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLifecyclePolicyOutputError>
}

extension GetLifecyclePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLifecyclePolicyInput(containerName: \(String(describing: containerName)))"}
}

extension GetLifecyclePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

public struct GetLifecyclePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<GetLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLifecyclePolicyOutputError>
}

public struct GetLifecyclePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<GetLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLifecyclePolicyOutputError>
}

public struct GetLifecyclePolicyInput: Equatable {
    /// <p>The name of the container that the object lifecycle policy is assigned to.</p>
    public let containerName: String?

    public init (
        containerName: String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct GetLifecyclePolicyInputBody: Equatable {
    public let containerName: String?
}

extension GetLifecyclePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension GetLifecyclePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLifecyclePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFoundException" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLifecyclePolicyOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLifecyclePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLifecyclePolicyOutputResponse(lifecyclePolicy: \(String(describing: lifecyclePolicy)))"}
}

extension GetLifecyclePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLifecyclePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lifecyclePolicy = output.lifecyclePolicy
        } else {
            self.lifecyclePolicy = nil
        }
    }
}

public struct GetLifecyclePolicyOutputResponse: Equatable {
    /// <p>The object lifecycle policy that is assigned to the container.</p>
    public let lifecyclePolicy: String?

    public init (
        lifecyclePolicy: String? = nil
    )
    {
        self.lifecyclePolicy = lifecyclePolicy
    }
}

struct GetLifecyclePolicyOutputResponseBody: Equatable {
    public let lifecyclePolicy: String?
}

extension GetLifecyclePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lifecyclePolicy = "LifecyclePolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lifecyclePolicy)
        lifecyclePolicy = lifecyclePolicyDecoded
    }
}

public struct GetMetricPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetMetricPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMetricPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMetricPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMetricPolicyInput>
    public typealias MOutput = OperationOutput<GetMetricPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMetricPolicyOutputError>
}

extension GetMetricPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMetricPolicyInput(containerName: \(String(describing: containerName)))"}
}

extension GetMetricPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

public struct GetMetricPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetMetricPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMetricPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMetricPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMetricPolicyInput>
    public typealias MOutput = OperationOutput<GetMetricPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMetricPolicyOutputError>
}

public struct GetMetricPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMetricPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMetricPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMetricPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMetricPolicyInput>
    public typealias MOutput = OperationOutput<GetMetricPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMetricPolicyOutputError>
}

public struct GetMetricPolicyInput: Equatable {
    /// <p>The name of the container that is associated with the metric policy.</p>
    public let containerName: String?

    public init (
        containerName: String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct GetMetricPolicyInputBody: Equatable {
    public let containerName: String?
}

extension GetMetricPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension GetMetricPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMetricPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFoundException" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMetricPolicyOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMetricPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMetricPolicyOutputResponse(metricPolicy: \(String(describing: metricPolicy)))"}
}

extension GetMetricPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMetricPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metricPolicy = output.metricPolicy
        } else {
            self.metricPolicy = nil
        }
    }
}

public struct GetMetricPolicyOutputResponse: Equatable {
    /// <p>The metric policy that is associated with the specific container.</p>
    public let metricPolicy: MetricPolicy?

    public init (
        metricPolicy: MetricPolicy? = nil
    )
    {
        self.metricPolicy = metricPolicy
    }
}

struct GetMetricPolicyOutputResponseBody: Equatable {
    public let metricPolicy: MetricPolicy?
}

extension GetMetricPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metricPolicy = "MetricPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricPolicyDecoded = try containerValues.decodeIfPresent(MetricPolicy.self, forKey: .metricPolicy)
        metricPolicy = metricPolicyDecoded
    }
}

extension InternalServerError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerError(message: \(String(describing: message)))"}
}

extension InternalServerError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is temporarily unavailable.</p>
public struct InternalServerError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Equatable {
    public let message: String?
}

extension InternalServerErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A service limit has been exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListContainersInputBodyMiddleware: Middleware {
    public let id: String = "ListContainersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContainersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContainersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContainersInput>
    public typealias MOutput = OperationOutput<ListContainersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContainersOutputError>
}

extension ListContainersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContainersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListContainersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListContainersInputHeadersMiddleware: Middleware {
    public let id: String = "ListContainersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContainersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContainersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContainersInput>
    public typealias MOutput = OperationOutput<ListContainersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContainersOutputError>
}

public struct ListContainersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListContainersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContainersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContainersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContainersInput>
    public typealias MOutput = OperationOutput<ListContainersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContainersOutputError>
}

public struct ListContainersInput: Equatable {
    /// <p>Enter the maximum number of containers in the response. Use from 1 to 255 characters.
    ///       </p>
    public let maxResults: Int?
    /// <p>Only if you used <code>MaxResults</code> in the first command, enter the token (which
    ///          was included in the previous response) to obtain the next set of containers. This token is
    ///          included in a response only if there actually are more containers to list.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListContainersInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListContainersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListContainersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContainersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContainersOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContainersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContainersOutputResponse(containers: \(String(describing: containers)), nextToken: \(String(describing: nextToken)))"}
}

extension ListContainersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListContainersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.containers = output.containers
            self.nextToken = output.nextToken
        } else {
            self.containers = nil
            self.nextToken = nil
        }
    }
}

public struct ListContainersOutputResponse: Equatable {
    /// <p>The names of the containers.</p>
    public let containers: [Container]?
    /// <p>
    ///             <code>NextToken</code> is the token to use in the next call to <code>ListContainers</code>.
    ///          This token is returned only if you included the <code>MaxResults</code> tag in the original
    ///          command, and only if there are still containers to return. </p>
    public let nextToken: String?

    public init (
        containers: [Container]? = nil,
        nextToken: String? = nil
    )
    {
        self.containers = containers
        self.nextToken = nextToken
    }
}

struct ListContainersOutputResponseBody: Equatable {
    public let containers: [Container]?
    public let nextToken: String?
}

extension ListContainersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containers = "Containers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containersContainer = try containerValues.decodeIfPresent([Container?].self, forKey: .containers)
        var containersDecoded0:[Container]? = nil
        if let containersContainer = containersContainer {
            containersDecoded0 = [Container]()
            for structure0 in containersContainer {
                if let structure0 = structure0 {
                    containersDecoded0?.append(structure0)
                }
            }
        }
        containers = containersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resource: \(String(describing: resource)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resource = "Resource"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the container.</p>
    public let resource: String?

    public init (
        resource: String? = nil
    )
    {
        self.resource = resource
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resource: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resource = "Resource"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>An array of key:value pairs that are assigned to the container.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum MethodName {
    case delete
    case `get`
    case head
    case put
    case sdkUnknown(String)
}

extension MethodName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MethodName] {
        return [
            .delete,
            .get,
            .head,
            .put,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .delete: return "DELETE"
        case .get: return "GET"
        case .head: return "HEAD"
        case .put: return "PUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MethodName(rawValue: rawValue) ?? MethodName.sdkUnknown(rawValue)
    }
}

extension MetricPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerLevelMetrics = "ContainerLevelMetrics"
        case metricPolicyRules = "MetricPolicyRules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerLevelMetrics = containerLevelMetrics {
            try encodeContainer.encode(containerLevelMetrics.rawValue, forKey: .containerLevelMetrics)
        }
        if let metricPolicyRules = metricPolicyRules {
            var metricPolicyRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricPolicyRules)
            for metricpolicyrules0 in metricPolicyRules {
                try metricPolicyRulesContainer.encode(metricpolicyrules0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerLevelMetricsDecoded = try containerValues.decodeIfPresent(ContainerLevelMetrics.self, forKey: .containerLevelMetrics)
        containerLevelMetrics = containerLevelMetricsDecoded
        let metricPolicyRulesContainer = try containerValues.decodeIfPresent([MetricPolicyRule?].self, forKey: .metricPolicyRules)
        var metricPolicyRulesDecoded0:[MetricPolicyRule]? = nil
        if let metricPolicyRulesContainer = metricPolicyRulesContainer {
            metricPolicyRulesDecoded0 = [MetricPolicyRule]()
            for structure0 in metricPolicyRulesContainer {
                if let structure0 = structure0 {
                    metricPolicyRulesDecoded0?.append(structure0)
                }
            }
        }
        metricPolicyRules = metricPolicyRulesDecoded0
    }
}

extension MetricPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricPolicy(containerLevelMetrics: \(String(describing: containerLevelMetrics)), metricPolicyRules: \(String(describing: metricPolicyRules)))"}
}

/// <p>The metric policy that is associated with the container. A metric policy allows AWS Elemental MediaStore to send metrics to Amazon CloudWatch. In the policy, you must indicate whether you want MediaStore to send container-level metrics. You can also include rules to define groups of objects that you want MediaStore to send object-level metrics for.</p>
///          <p>To view examples of how to construct a metric policy for your use case, see <a href="https://docs.aws.amazon.com/mediastore/latest/ug/policies-metric-examples.html">Example Metric Policies</a>.</p>
public struct MetricPolicy: Equatable {
    /// <p>A setting to enable or disable metrics at the container level.</p>
    public let containerLevelMetrics: ContainerLevelMetrics?
    /// <p>A parameter that holds an array of rules that enable metrics at the object level. This parameter is optional, but if you choose to include it, you must also include at least one rule. By default, you can include up to five rules. You can also <a href="https://console.aws.amazon.com/servicequotas/home?region=us-east-1#!/services/mediastore/quotas">request a quota increase</a> to allow up to 300 rules per policy.</p>
    public let metricPolicyRules: [MetricPolicyRule]?

    public init (
        containerLevelMetrics: ContainerLevelMetrics? = nil,
        metricPolicyRules: [MetricPolicyRule]? = nil
    )
    {
        self.containerLevelMetrics = containerLevelMetrics
        self.metricPolicyRules = metricPolicyRules
    }
}

extension MetricPolicyRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectGroup = "ObjectGroup"
        case objectGroupName = "ObjectGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectGroup = objectGroup {
            try encodeContainer.encode(objectGroup, forKey: .objectGroup)
        }
        if let objectGroupName = objectGroupName {
            try encodeContainer.encode(objectGroupName, forKey: .objectGroupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectGroup)
        objectGroup = objectGroupDecoded
        let objectGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectGroupName)
        objectGroupName = objectGroupNameDecoded
    }
}

extension MetricPolicyRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricPolicyRule(objectGroup: \(String(describing: objectGroup)), objectGroupName: \(String(describing: objectGroupName)))"}
}

/// <p>A setting that enables metrics at the object level. Each rule contains an object group and an object group name. If the policy includes the MetricPolicyRules parameter, you must include at least one rule. Each metric policy can include up to five rules by default. You can also <a href="https://console.aws.amazon.com/servicequotas/home?region=us-east-1#!/services/mediastore/quotas">request a quota increase</a> to allow up to 300 rules per policy.</p>
public struct MetricPolicyRule: Equatable {
    /// <p>A path or file name that defines which objects to include in the group. Wildcards (*) are acceptable.</p>
    public let objectGroup: String?
    /// <p>A name that allows you to refer to the object group.</p>
    public let objectGroupName: String?

    public init (
        objectGroup: String? = nil,
        objectGroupName: String? = nil
    )
    {
        self.objectGroup = objectGroup
        self.objectGroupName = objectGroupName
    }
}

extension PolicyNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyNotFoundException(message: \(String(describing: message)))"}
}

extension PolicyNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The policy that you specified in the request does not exist.</p>
public struct PolicyNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PolicyNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension PolicyNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutContainerPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutContainerPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutContainerPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutContainerPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutContainerPolicyInput>
    public typealias MOutput = OperationOutput<PutContainerPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutContainerPolicyOutputError>
}

extension PutContainerPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutContainerPolicyInput(containerName: \(String(describing: containerName)), policy: \(String(describing: policy)))"}
}

extension PutContainerPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
        case policy = "Policy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutContainerPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutContainerPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutContainerPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutContainerPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutContainerPolicyInput>
    public typealias MOutput = OperationOutput<PutContainerPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutContainerPolicyOutputError>
}

public struct PutContainerPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutContainerPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutContainerPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutContainerPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutContainerPolicyInput>
    public typealias MOutput = OperationOutput<PutContainerPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutContainerPolicyOutputError>
}

public struct PutContainerPolicyInput: Equatable {
    /// <p>The name of the container.</p>
    public let containerName: String?
    /// <p>The contents of the policy, which includes the following: </p>
    ///          <ul>
    ///             <li>
    ///                <p>One <code>Version</code> tag</p>
    ///             </li>
    ///             <li>
    ///                <p>One <code>Statement</code> tag that contains the standard tags for the
    ///                policy.</p>
    ///             </li>
    ///          </ul>
    public let policy: String?

    public init (
        containerName: String? = nil,
        policy: String? = nil
    )
    {
        self.containerName = containerName
        self.policy = policy
    }
}

struct PutContainerPolicyInputBody: Equatable {
    public let containerName: String?
    public let policy: String?
}

extension PutContainerPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutContainerPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutContainerPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutContainerPolicyOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutContainerPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutContainerPolicyOutputResponse()"}
}

extension PutContainerPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutContainerPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutContainerPolicyOutputResponseBody: Equatable {
}

extension PutContainerPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutCorsPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutCorsPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutCorsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutCorsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutCorsPolicyInput>
    public typealias MOutput = OperationOutput<PutCorsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutCorsPolicyOutputError>
}

extension PutCorsPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutCorsPolicyInput(containerName: \(String(describing: containerName)), corsPolicy: \(String(describing: corsPolicy)))"}
}

extension PutCorsPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
        case corsPolicy = "CorsPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if let corsPolicy = corsPolicy {
            var corsPolicyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .corsPolicy)
            for corspolicy0 in corsPolicy {
                try corsPolicyContainer.encode(corspolicy0)
            }
        }
    }
}

public struct PutCorsPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutCorsPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutCorsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutCorsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutCorsPolicyInput>
    public typealias MOutput = OperationOutput<PutCorsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutCorsPolicyOutputError>
}

public struct PutCorsPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutCorsPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutCorsPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutCorsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutCorsPolicyInput>
    public typealias MOutput = OperationOutput<PutCorsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutCorsPolicyOutputError>
}

public struct PutCorsPolicyInput: Equatable {
    /// <p>The name of the container that you want to assign the CORS policy to.</p>
    public let containerName: String?
    /// <p>The CORS policy to apply to the container.  </p>
    public let corsPolicy: [CorsRule]?

    public init (
        containerName: String? = nil,
        corsPolicy: [CorsRule]? = nil
    )
    {
        self.containerName = containerName
        self.corsPolicy = corsPolicy
    }
}

struct PutCorsPolicyInputBody: Equatable {
    public let containerName: String?
    public let corsPolicy: [CorsRule]?
}

extension PutCorsPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
        case corsPolicy = "CorsPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let corsPolicyContainer = try containerValues.decodeIfPresent([CorsRule?].self, forKey: .corsPolicy)
        var corsPolicyDecoded0:[CorsRule]? = nil
        if let corsPolicyContainer = corsPolicyContainer {
            corsPolicyDecoded0 = [CorsRule]()
            for structure0 in corsPolicyContainer {
                if let structure0 = structure0 {
                    corsPolicyDecoded0?.append(structure0)
                }
            }
        }
        corsPolicy = corsPolicyDecoded0
    }
}

extension PutCorsPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutCorsPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutCorsPolicyOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutCorsPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutCorsPolicyOutputResponse()"}
}

extension PutCorsPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutCorsPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutCorsPolicyOutputResponseBody: Equatable {
}

extension PutCorsPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutLifecyclePolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutLifecyclePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<PutLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLifecyclePolicyOutputError>
}

extension PutLifecyclePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLifecyclePolicyInput(containerName: \(String(describing: containerName)), lifecyclePolicy: \(String(describing: lifecyclePolicy)))"}
}

extension PutLifecyclePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
        case lifecyclePolicy = "LifecyclePolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if let lifecyclePolicy = lifecyclePolicy {
            try encodeContainer.encode(lifecyclePolicy, forKey: .lifecyclePolicy)
        }
    }
}

public struct PutLifecyclePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<PutLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLifecyclePolicyOutputError>
}

public struct PutLifecyclePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<PutLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLifecyclePolicyOutputError>
}

public struct PutLifecyclePolicyInput: Equatable {
    /// <p>The name of the container that you want to assign the object lifecycle policy to.</p>
    public let containerName: String?
    /// <p>The object lifecycle policy to apply to the container.</p>
    public let lifecyclePolicy: String?

    public init (
        containerName: String? = nil,
        lifecyclePolicy: String? = nil
    )
    {
        self.containerName = containerName
        self.lifecyclePolicy = lifecyclePolicy
    }
}

struct PutLifecyclePolicyInputBody: Equatable {
    public let containerName: String?
    public let lifecyclePolicy: String?
}

extension PutLifecyclePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
        case lifecyclePolicy = "LifecyclePolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let lifecyclePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lifecyclePolicy)
        lifecyclePolicy = lifecyclePolicyDecoded
    }
}

extension PutLifecyclePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLifecyclePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLifecyclePolicyOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLifecyclePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLifecyclePolicyOutputResponse()"}
}

extension PutLifecyclePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutLifecyclePolicyOutputResponse: Equatable {

    public init() {}
}

struct PutLifecyclePolicyOutputResponseBody: Equatable {
}

extension PutLifecyclePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutMetricPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutMetricPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutMetricPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutMetricPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutMetricPolicyInput>
    public typealias MOutput = OperationOutput<PutMetricPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutMetricPolicyOutputError>
}

extension PutMetricPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutMetricPolicyInput(containerName: \(String(describing: containerName)), metricPolicy: \(String(describing: metricPolicy)))"}
}

extension PutMetricPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
        case metricPolicy = "MetricPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if let metricPolicy = metricPolicy {
            try encodeContainer.encode(metricPolicy, forKey: .metricPolicy)
        }
    }
}

public struct PutMetricPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutMetricPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutMetricPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutMetricPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutMetricPolicyInput>
    public typealias MOutput = OperationOutput<PutMetricPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutMetricPolicyOutputError>
}

public struct PutMetricPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutMetricPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutMetricPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutMetricPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutMetricPolicyInput>
    public typealias MOutput = OperationOutput<PutMetricPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutMetricPolicyOutputError>
}

public struct PutMetricPolicyInput: Equatable {
    /// <p>The name of the container that you want to add the metric policy to.</p>
    public let containerName: String?
    /// <p>The metric policy that you want to associate with the container. In the policy, you must indicate whether you want MediaStore to send container-level metrics. You can also include up to five rules to define groups of objects that you want MediaStore to send object-level metrics for.  If you include rules in the policy, construct each rule with both of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>An object group that defines which objects to include in the group. The definition can be a path or a file name, but it can't have more than 900 characters. Valid characters are: a-z, A-Z, 0-9, _ (underscore), = (equal), : (colon), . (period), - (hyphen), ~ (tilde), / (forward slash), and * (asterisk). Wildcards (*) are acceptable.</p>
    ///             </li>
    ///             <li>
    ///                <p>An object group name that allows you to refer to the object group. The name can't have more than 30 characters. Valid characters are: a-z, A-Z, 0-9, and _ (underscore).</p>
    ///             </li>
    ///          </ul>
    public let metricPolicy: MetricPolicy?

    public init (
        containerName: String? = nil,
        metricPolicy: MetricPolicy? = nil
    )
    {
        self.containerName = containerName
        self.metricPolicy = metricPolicy
    }
}

struct PutMetricPolicyInputBody: Equatable {
    public let containerName: String?
    public let metricPolicy: MetricPolicy?
}

extension PutMetricPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
        case metricPolicy = "MetricPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let metricPolicyDecoded = try containerValues.decodeIfPresent(MetricPolicy.self, forKey: .metricPolicy)
        metricPolicy = metricPolicyDecoded
    }
}

extension PutMetricPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutMetricPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutMetricPolicyOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutMetricPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutMetricPolicyOutputResponse()"}
}

extension PutMetricPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutMetricPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutMetricPolicyOutputResponseBody: Equatable {
}

extension PutMetricPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StartAccessLoggingInputBodyMiddleware: Middleware {
    public let id: String = "StartAccessLoggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAccessLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAccessLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAccessLoggingInput>
    public typealias MOutput = OperationOutput<StartAccessLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAccessLoggingOutputError>
}

extension StartAccessLoggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartAccessLoggingInput(containerName: \(String(describing: containerName)))"}
}

extension StartAccessLoggingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

public struct StartAccessLoggingInputHeadersMiddleware: Middleware {
    public let id: String = "StartAccessLoggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAccessLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAccessLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAccessLoggingInput>
    public typealias MOutput = OperationOutput<StartAccessLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAccessLoggingOutputError>
}

public struct StartAccessLoggingInputQueryItemMiddleware: Middleware {
    public let id: String = "StartAccessLoggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAccessLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAccessLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAccessLoggingInput>
    public typealias MOutput = OperationOutput<StartAccessLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAccessLoggingOutputError>
}

public struct StartAccessLoggingInput: Equatable {
    /// <p>The name of the container that you want to start access logging on.</p>
    public let containerName: String?

    public init (
        containerName: String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct StartAccessLoggingInputBody: Equatable {
    public let containerName: String?
}

extension StartAccessLoggingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension StartAccessLoggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAccessLoggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAccessLoggingOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAccessLoggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartAccessLoggingOutputResponse()"}
}

extension StartAccessLoggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartAccessLoggingOutputResponse: Equatable {

    public init() {}
}

struct StartAccessLoggingOutputResponseBody: Equatable {
}

extension StartAccessLoggingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StopAccessLoggingInputBodyMiddleware: Middleware {
    public let id: String = "StopAccessLoggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopAccessLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<StopAccessLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopAccessLoggingInput>
    public typealias MOutput = OperationOutput<StopAccessLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopAccessLoggingOutputError>
}

extension StopAccessLoggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopAccessLoggingInput(containerName: \(String(describing: containerName)))"}
}

extension StopAccessLoggingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

public struct StopAccessLoggingInputHeadersMiddleware: Middleware {
    public let id: String = "StopAccessLoggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopAccessLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<StopAccessLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopAccessLoggingInput>
    public typealias MOutput = OperationOutput<StopAccessLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopAccessLoggingOutputError>
}

public struct StopAccessLoggingInputQueryItemMiddleware: Middleware {
    public let id: String = "StopAccessLoggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopAccessLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<StopAccessLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopAccessLoggingInput>
    public typealias MOutput = OperationOutput<StopAccessLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopAccessLoggingOutputError>
}

public struct StopAccessLoggingInput: Equatable {
    /// <p>The name of the container that you want to stop access logging on.</p>
    public let containerName: String?

    public init (
        containerName: String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct StopAccessLoggingInputBody: Equatable {
    public let containerName: String?
}

extension StopAccessLoggingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension StopAccessLoggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopAccessLoggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopAccessLoggingOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopAccessLoggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopAccessLoggingOutputResponse()"}
}

extension StopAccessLoggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopAccessLoggingOutputResponse: Equatable {

    public init() {}
}

struct StopAccessLoggingOutputResponseBody: Equatable {
}

extension StopAccessLoggingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A collection of tags associated with a container. Each tag consists of a key:value pair, which can be anything you define. Typically, the tag key
///             represents a category (such as "environment") and the tag value represents a specific value within that category (such as "test," "development," or
///             "production"). You can add up to 50
///             tags to each container. For more information about tagging, including naming and usage conventions, see <a href="https://docs.aws.amazon.com/mediastore/latest/ug/tagging.html">Tagging Resources in MediaStore</a>.</p>
public struct Tag: Equatable {
    /// <p>Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are
    ///             case-sensitive.</p>
    public let key: String?
    /// <p>Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or
    ///             "companyB." Tag values are case-sensitive.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resource: \(String(describing: resource)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resource = "Resource"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the container. </p>
    public let resource: String?
    /// <p>An array of key:value pairs that you want to add to the container. You need to specify only the tags that you want to add or update. For example,
    ///             suppose a container already has two tags (customer:CompanyA and priority:High). You want to change the priority tag and also add a third tag
    ///             (type:Contract). For TagResource, you specify the following tags: priority:Medium, type:Contract. The result is that your container has three tags:
    ///             customer:CompanyA, priority:Medium, and type:Contract.</p>
    public let tags: [Tag]?

    public init (
        resource: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resource = resource
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resource: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resource = "Resource"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resource: \(String(describing: resource)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resource = "Resource"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the container.</p>
    public let resource: String?
    /// <p>A comma-separated list of keys for tags that you want to remove from the container. For example, if your container has two tags (customer:CompanyA
    ///             and priority:High) and you want to remove one of the tags (priority:High), you specify the key for the tag that you want to remove
    ///             (priority).</p>
    public let tagKeys: [String]?

    public init (
        resource: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resource: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resource = "Resource"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
