// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessEndpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointType = "EndpointType"
        case vpceId = "VpceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let vpceId = vpceId {
            try encodeContainer.encode(vpceId, forKey: .vpceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointTypeDecoded = try containerValues.decodeIfPresent(AccessEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let vpceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpceId)
        vpceId = vpceIdDecoded
    }
}

extension AccessEndpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessEndpoint(endpointType: \(String(describing: endpointType)), vpceId: \(String(describing: vpceId)))"}
}

/// <p>Describes an interface VPC endpoint (interface endpoint) that lets you create a private connection between the virtual private cloud (VPC) that you specify and AppStream 2.0. When you specify an interface endpoint for a stack, users of the stack can connect to AppStream 2.0 only through that endpoint. When you specify an interface endpoint for an image builder, administrators can connect to the image builder only through that endpoint.</p>
public struct AccessEndpoint: Equatable {
    /// <p>The type of interface endpoint.</p>
    public let endpointType: AccessEndpointType?
    /// <p>The identifier (ID) of the VPC in which the interface endpoint is used.</p>
    public let vpceId: String?

    public init (
        endpointType: AccessEndpointType? = nil,
        vpceId: String? = nil
    )
    {
        self.endpointType = endpointType
        self.vpceId = vpceId
    }
}

public enum AccessEndpointType {
    case streaming
    case sdkUnknown(String)
}

extension AccessEndpointType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccessEndpointType] {
        return [
            .streaming,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .streaming: return "STREAMING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccessEndpointType(rawValue: rawValue) ?? AccessEndpointType.sdkUnknown(rawValue)
    }
}

public enum Action {
    case clipboardCopyFromLocalDevice
    case clipboardCopyToLocalDevice
    case domainPasswordSignin
    case domainSmartCardSignin
    case fileDownload
    case fileUpload
    case printingToLocalDevice
    case sdkUnknown(String)
}

extension Action : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Action] {
        return [
            .clipboardCopyFromLocalDevice,
            .clipboardCopyToLocalDevice,
            .domainPasswordSignin,
            .domainSmartCardSignin,
            .fileDownload,
            .fileUpload,
            .printingToLocalDevice,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .clipboardCopyFromLocalDevice: return "CLIPBOARD_COPY_FROM_LOCAL_DEVICE"
        case .clipboardCopyToLocalDevice: return "CLIPBOARD_COPY_TO_LOCAL_DEVICE"
        case .domainPasswordSignin: return "DOMAIN_PASSWORD_SIGNIN"
        case .domainSmartCardSignin: return "DOMAIN_SMART_CARD_SIGNIN"
        case .fileDownload: return "FILE_DOWNLOAD"
        case .fileUpload: return "FILE_UPLOAD"
        case .printingToLocalDevice: return "PRINTING_TO_LOCAL_DEVICE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Action(rawValue: rawValue) ?? Action.sdkUnknown(rawValue)
    }
}

extension Application: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName = "DisplayName"
        case enabled = "Enabled"
        case iconURL = "IconURL"
        case launchParameters = "LaunchParameters"
        case launchPath = "LaunchPath"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let iconURL = iconURL {
            try encodeContainer.encode(iconURL, forKey: .iconURL)
        }
        if let launchParameters = launchParameters {
            try encodeContainer.encode(launchParameters, forKey: .launchParameters)
        }
        if let launchPath = launchPath {
            try encodeContainer.encode(launchPath, forKey: .launchPath)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metadata)
            for (dictKey0, metadata0) in metadata {
                try metadataContainer.encode(metadata0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let iconURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iconURL)
        iconURL = iconURLDecoded
        let launchPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchPath)
        launchPath = launchPathDecoded
        let launchParametersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchParameters)
        launchParameters = launchParametersDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let metadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .metadata)
        var metadataDecoded0: [String:String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [String:String]()
            for (key0, string0) in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?[key0] = string0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension Application: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Application(displayName: \(String(describing: displayName)), enabled: \(String(describing: enabled)), iconURL: \(String(describing: iconURL)), launchParameters: \(String(describing: launchParameters)), launchPath: \(String(describing: launchPath)), metadata: \(String(describing: metadata)), name: \(String(describing: name)))"}
}

/// <p>Describes an application in the application catalog.</p>
public struct Application: Equatable {
    /// <p>The application name to display.</p>
    public let displayName: String?
    /// <p>If there is a problem, the application can be disabled after image creation.</p>
    public let enabled: Bool
    /// <p>The URL for the application icon. This URL might be time-limited.</p>
    public let iconURL: String?
    /// <p>The arguments that are passed to the application at launch.</p>
    public let launchParameters: String?
    /// <p>The path to the application executable in the instance.</p>
    public let launchPath: String?
    /// <p>Additional attributes that describe the application.</p>
    public let metadata: [String:String]?
    /// <p>The name of the application.</p>
    public let name: String?

    public init (
        displayName: String? = nil,
        enabled: Bool = false,
        iconURL: String? = nil,
        launchParameters: String? = nil,
        launchPath: String? = nil,
        metadata: [String:String]? = nil,
        name: String? = nil
    )
    {
        self.displayName = displayName
        self.enabled = enabled
        self.iconURL = iconURL
        self.launchParameters = launchParameters
        self.launchPath = launchPath
        self.metadata = metadata
        self.name = name
    }
}

extension ApplicationSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case settingsGroup = "SettingsGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let settingsGroup = settingsGroup {
            try encodeContainer.encode(settingsGroup, forKey: .settingsGroup)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let settingsGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .settingsGroup)
        settingsGroup = settingsGroupDecoded
    }
}

extension ApplicationSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationSettings(enabled: \(String(describing: enabled)), settingsGroup: \(String(describing: settingsGroup)))"}
}

/// <p>The persistent application settings for users of a stack.</p>
public struct ApplicationSettings: Equatable {
    /// <p>Enables or disables persistent application settings for users during their streaming sessions. </p>
    public let enabled: Bool
    /// <p>The path prefix for the S3 bucket where users’ persistent application settings are stored. You can allow the same persistent application settings to be used across multiple stacks by specifying the same settings group for each stack. </p>
    public let settingsGroup: String?

    public init (
        enabled: Bool = false,
        settingsGroup: String? = nil
    )
    {
        self.enabled = enabled
        self.settingsGroup = settingsGroup
    }
}

extension ApplicationSettingsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case s3BucketName = "S3BucketName"
        case settingsGroup = "SettingsGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let settingsGroup = settingsGroup {
            try encodeContainer.encode(settingsGroup, forKey: .settingsGroup)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let settingsGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .settingsGroup)
        settingsGroup = settingsGroupDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
    }
}

extension ApplicationSettingsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationSettingsResponse(enabled: \(String(describing: enabled)), s3BucketName: \(String(describing: s3BucketName)), settingsGroup: \(String(describing: settingsGroup)))"}
}

/// <p>Describes the persistent application settings for users of a stack.</p>
public struct ApplicationSettingsResponse: Equatable {
    /// <p>Specifies whether persistent application settings are enabled for users during their streaming sessions.</p>
    public let enabled: Bool
    /// <p>The S3 bucket where users’ persistent application settings are stored. When persistent application settings are enabled for the first time for an account in an AWS Region, an S3 bucket is created. The bucket is unique to the AWS account and the Region.
    ///         </p>
    public let s3BucketName: String?
    /// <p>The path prefix for the S3 bucket where users’ persistent application settings are stored.</p>
    public let settingsGroup: String?

    public init (
        enabled: Bool = false,
        s3BucketName: String? = nil,
        settingsGroup: String? = nil
    )
    {
        self.enabled = enabled
        self.s3BucketName = s3BucketName
        self.settingsGroup = settingsGroup
    }
}

public struct AssociateFleetInputBodyMiddleware: Middleware {
    public let id: String = "AssociateFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateFleetInput>
    public typealias MOutput = OperationOutput<AssociateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateFleetOutputError>
}

extension AssociateFleetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateFleetInput(fleetName: \(String(describing: fleetName)), stackName: \(String(describing: stackName)))"}
}

extension AssociateFleetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetName = "FleetName"
        case stackName = "StackName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

public struct AssociateFleetInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateFleetInput>
    public typealias MOutput = OperationOutput<AssociateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateFleetOutputError>
}

public struct AssociateFleetInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateFleetInput>
    public typealias MOutput = OperationOutput<AssociateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateFleetOutputError>
}

public struct AssociateFleetInput: Equatable {
    /// <p>The name of the fleet. </p>
    public let fleetName: String?
    /// <p>The name of the stack.</p>
    public let stackName: String?

    public init (
        fleetName: String? = nil,
        stackName: String? = nil
    )
    {
        self.fleetName = fleetName
        self.stackName = stackName
    }
}

struct AssociateFleetInputBody: Equatable {
    public let fleetName: String?
    public let stackName: String?
}

extension AssociateFleetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetName = "FleetName"
        case stackName = "StackName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
    }
}

extension AssociateFleetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateFleetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateFleetOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateFleetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateFleetOutputResponse()"}
}

extension AssociateFleetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateFleetOutputResponse: Equatable {

    public init() {}
}

struct AssociateFleetOutputResponseBody: Equatable {
}

extension AssociateFleetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum AuthenticationType {
    case api
    case saml
    case userpool
    case sdkUnknown(String)
}

extension AuthenticationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthenticationType] {
        return [
            .api,
            .saml,
            .userpool,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .api: return "API"
        case .saml: return "SAML"
        case .userpool: return "USERPOOL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthenticationType(rawValue: rawValue) ?? AuthenticationType.sdkUnknown(rawValue)
    }
}

public struct BatchAssociateUserStackInputBodyMiddleware: Middleware {
    public let id: String = "BatchAssociateUserStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateUserStackInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateUserStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateUserStackInput>
    public typealias MOutput = OperationOutput<BatchAssociateUserStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateUserStackOutputError>
}

extension BatchAssociateUserStackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAssociateUserStackInput(userStackAssociations: \(String(describing: userStackAssociations)))"}
}

extension BatchAssociateUserStackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userStackAssociations = "UserStackAssociations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userStackAssociations = userStackAssociations {
            var userStackAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userStackAssociations)
            for userstackassociationlist0 in userStackAssociations {
                try userStackAssociationsContainer.encode(userstackassociationlist0)
            }
        }
    }
}

public struct BatchAssociateUserStackInputHeadersMiddleware: Middleware {
    public let id: String = "BatchAssociateUserStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateUserStackInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateUserStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateUserStackInput>
    public typealias MOutput = OperationOutput<BatchAssociateUserStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateUserStackOutputError>
}

public struct BatchAssociateUserStackInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchAssociateUserStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateUserStackInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateUserStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateUserStackInput>
    public typealias MOutput = OperationOutput<BatchAssociateUserStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateUserStackOutputError>
}

public struct BatchAssociateUserStackInput: Equatable {
    /// <p>The list of UserStackAssociation objects.</p>
    public let userStackAssociations: [UserStackAssociation]?

    public init (
        userStackAssociations: [UserStackAssociation]? = nil
    )
    {
        self.userStackAssociations = userStackAssociations
    }
}

struct BatchAssociateUserStackInputBody: Equatable {
    public let userStackAssociations: [UserStackAssociation]?
}

extension BatchAssociateUserStackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userStackAssociations = "UserStackAssociations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userStackAssociationsContainer = try containerValues.decodeIfPresent([UserStackAssociation?].self, forKey: .userStackAssociations)
        var userStackAssociationsDecoded0:[UserStackAssociation]? = nil
        if let userStackAssociationsContainer = userStackAssociationsContainer {
            userStackAssociationsDecoded0 = [UserStackAssociation]()
            for structure0 in userStackAssociationsContainer {
                if let structure0 = structure0 {
                    userStackAssociationsDecoded0?.append(structure0)
                }
            }
        }
        userStackAssociations = userStackAssociationsDecoded0
    }
}

extension BatchAssociateUserStackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateUserStackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchAssociateUserStackOutputError: Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateUserStackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAssociateUserStackOutputResponse(errors: \(String(describing: errors)))"}
}

extension BatchAssociateUserStackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchAssociateUserStackOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchAssociateUserStackOutputResponse: Equatable {
    /// <p>The list of UserStackAssociationError objects.</p>
    public let errors: [UserStackAssociationError]?

    public init (
        errors: [UserStackAssociationError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchAssociateUserStackOutputResponseBody: Equatable {
    public let errors: [UserStackAssociationError]?
}

extension BatchAssociateUserStackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([UserStackAssociationError?].self, forKey: .errors)
        var errorsDecoded0:[UserStackAssociationError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [UserStackAssociationError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct BatchDisassociateUserStackInputBodyMiddleware: Middleware {
    public let id: String = "BatchDisassociateUserStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateUserStackInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateUserStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateUserStackInput>
    public typealias MOutput = OperationOutput<BatchDisassociateUserStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateUserStackOutputError>
}

extension BatchDisassociateUserStackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisassociateUserStackInput(userStackAssociations: \(String(describing: userStackAssociations)))"}
}

extension BatchDisassociateUserStackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userStackAssociations = "UserStackAssociations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userStackAssociations = userStackAssociations {
            var userStackAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userStackAssociations)
            for userstackassociationlist0 in userStackAssociations {
                try userStackAssociationsContainer.encode(userstackassociationlist0)
            }
        }
    }
}

public struct BatchDisassociateUserStackInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDisassociateUserStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateUserStackInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateUserStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateUserStackInput>
    public typealias MOutput = OperationOutput<BatchDisassociateUserStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateUserStackOutputError>
}

public struct BatchDisassociateUserStackInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDisassociateUserStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateUserStackInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateUserStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateUserStackInput>
    public typealias MOutput = OperationOutput<BatchDisassociateUserStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateUserStackOutputError>
}

public struct BatchDisassociateUserStackInput: Equatable {
    /// <p>The list of UserStackAssociation objects.</p>
    public let userStackAssociations: [UserStackAssociation]?

    public init (
        userStackAssociations: [UserStackAssociation]? = nil
    )
    {
        self.userStackAssociations = userStackAssociations
    }
}

struct BatchDisassociateUserStackInputBody: Equatable {
    public let userStackAssociations: [UserStackAssociation]?
}

extension BatchDisassociateUserStackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userStackAssociations = "UserStackAssociations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userStackAssociationsContainer = try containerValues.decodeIfPresent([UserStackAssociation?].self, forKey: .userStackAssociations)
        var userStackAssociationsDecoded0:[UserStackAssociation]? = nil
        if let userStackAssociationsContainer = userStackAssociationsContainer {
            userStackAssociationsDecoded0 = [UserStackAssociation]()
            for structure0 in userStackAssociationsContainer {
                if let structure0 = structure0 {
                    userStackAssociationsDecoded0?.append(structure0)
                }
            }
        }
        userStackAssociations = userStackAssociationsDecoded0
    }
}

extension BatchDisassociateUserStackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateUserStackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDisassociateUserStackOutputError: Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateUserStackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisassociateUserStackOutputResponse(errors: \(String(describing: errors)))"}
}

extension BatchDisassociateUserStackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDisassociateUserStackOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDisassociateUserStackOutputResponse: Equatable {
    /// <p>The list of UserStackAssociationError objects.</p>
    public let errors: [UserStackAssociationError]?

    public init (
        errors: [UserStackAssociationError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDisassociateUserStackOutputResponseBody: Equatable {
    public let errors: [UserStackAssociationError]?
}

extension BatchDisassociateUserStackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([UserStackAssociationError?].self, forKey: .errors)
        var errorsDecoded0:[UserStackAssociationError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [UserStackAssociationError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension ComputeCapacity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case desiredInstances = "DesiredInstances"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredInstances = desiredInstances {
            try encodeContainer.encode(desiredInstances, forKey: .desiredInstances)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredInstancesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .desiredInstances)
        desiredInstances = desiredInstancesDecoded
    }
}

extension ComputeCapacity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComputeCapacity(desiredInstances: \(String(describing: desiredInstances)))"}
}

/// <p>Describes the capacity for a fleet.</p>
public struct ComputeCapacity: Equatable {
    /// <p>The desired number of streaming instances.</p>
    public let desiredInstances: Int?

    public init (
        desiredInstances: Int? = nil
    )
    {
        self.desiredInstances = desiredInstances
    }
}

extension ComputeCapacityStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case available = "Available"
        case desired = "Desired"
        case inUse = "InUse"
        case running = "Running"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let available = available {
            try encodeContainer.encode(available, forKey: .available)
        }
        if let desired = desired {
            try encodeContainer.encode(desired, forKey: .desired)
        }
        if let inUse = inUse {
            try encodeContainer.encode(inUse, forKey: .inUse)
        }
        if let running = running {
            try encodeContainer.encode(running, forKey: .running)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .desired)
        desired = desiredDecoded
        let runningDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .running)
        running = runningDecoded
        let inUseDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .inUse)
        inUse = inUseDecoded
        let availableDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .available)
        available = availableDecoded
    }
}

extension ComputeCapacityStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComputeCapacityStatus(available: \(String(describing: available)), desired: \(String(describing: desired)), inUse: \(String(describing: inUse)), running: \(String(describing: running)))"}
}

/// <p>Describes the capacity status for a fleet.</p>
public struct ComputeCapacityStatus: Equatable {
    /// <p>The number of currently available instances that can be used to stream
    ///             sessions.</p>
    public let available: Int?
    /// <p>The desired number of streaming instances.</p>
    public let desired: Int?
    /// <p>The number of instances in use for streaming.</p>
    public let inUse: Int?
    /// <p>The total number of simultaneous streaming instances that are running.</p>
    public let running: Int?

    public init (
        available: Int? = nil,
        desired: Int? = nil,
        inUse: Int? = nil,
        running: Int? = nil
    )
    {
        self.available = available
        self.desired = desired
        self.inUse = inUse
        self.running = running
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An API error occurred. Wait a few minutes and try again.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message in the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CopyImageInputBodyMiddleware: Middleware {
    public let id: String = "CopyImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyImageInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyImageInput>
    public typealias MOutput = OperationOutput<CopyImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyImageOutputError>
}

extension CopyImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyImageInput(destinationImageDescription: \(String(describing: destinationImageDescription)), destinationImageName: \(String(describing: destinationImageName)), destinationRegion: \(String(describing: destinationRegion)), sourceImageName: \(String(describing: sourceImageName)))"}
}

extension CopyImageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationImageDescription = "DestinationImageDescription"
        case destinationImageName = "DestinationImageName"
        case destinationRegion = "DestinationRegion"
        case sourceImageName = "SourceImageName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationImageDescription = destinationImageDescription {
            try encodeContainer.encode(destinationImageDescription, forKey: .destinationImageDescription)
        }
        if let destinationImageName = destinationImageName {
            try encodeContainer.encode(destinationImageName, forKey: .destinationImageName)
        }
        if let destinationRegion = destinationRegion {
            try encodeContainer.encode(destinationRegion, forKey: .destinationRegion)
        }
        if let sourceImageName = sourceImageName {
            try encodeContainer.encode(sourceImageName, forKey: .sourceImageName)
        }
    }
}

public struct CopyImageInputHeadersMiddleware: Middleware {
    public let id: String = "CopyImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyImageInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyImageInput>
    public typealias MOutput = OperationOutput<CopyImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyImageOutputError>
}

public struct CopyImageInputQueryItemMiddleware: Middleware {
    public let id: String = "CopyImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyImageInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyImageInput>
    public typealias MOutput = OperationOutput<CopyImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyImageOutputError>
}

public struct CopyImageInput: Equatable {
    /// <p>The description that the image will have when it is copied to the destination.</p>
    public let destinationImageDescription: String?
    /// <p>The name that the image will have when it is copied to the destination.</p>
    public let destinationImageName: String?
    /// <p>The destination region to which the image will be copied. This parameter is required, even if you are copying an image within the same region.</p>
    public let destinationRegion: String?
    /// <p>The name of the image to copy.</p>
    public let sourceImageName: String?

    public init (
        destinationImageDescription: String? = nil,
        destinationImageName: String? = nil,
        destinationRegion: String? = nil,
        sourceImageName: String? = nil
    )
    {
        self.destinationImageDescription = destinationImageDescription
        self.destinationImageName = destinationImageName
        self.destinationRegion = destinationRegion
        self.sourceImageName = sourceImageName
    }
}

struct CopyImageInputBody: Equatable {
    public let sourceImageName: String?
    public let destinationImageName: String?
    public let destinationRegion: String?
    public let destinationImageDescription: String?
}

extension CopyImageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationImageDescription = "DestinationImageDescription"
        case destinationImageName = "DestinationImageName"
        case destinationRegion = "DestinationRegion"
        case sourceImageName = "SourceImageName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceImageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceImageName)
        sourceImageName = sourceImageNameDecoded
        let destinationImageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationImageName)
        destinationImageName = destinationImageNameDecoded
        let destinationRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
        let destinationImageDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationImageDescription)
        destinationImageDescription = destinationImageDescriptionDecoded
    }
}

extension CopyImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CopyImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyImageOutputError: Equatable {
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyImageOutputResponse(destinationImageName: \(String(describing: destinationImageName)))"}
}

extension CopyImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CopyImageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.destinationImageName = output.destinationImageName
        } else {
            self.destinationImageName = nil
        }
    }
}

public struct CopyImageOutputResponse: Equatable {
    /// <p>The name of the destination image.</p>
    public let destinationImageName: String?

    public init (
        destinationImageName: String? = nil
    )
    {
        self.destinationImageName = destinationImageName
    }
}

struct CopyImageOutputResponseBody: Equatable {
    public let destinationImageName: String?
}

extension CopyImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationImageName = "DestinationImageName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationImageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationImageName)
        destinationImageName = destinationImageNameDecoded
    }
}

public struct CreateDirectoryConfigInputBodyMiddleware: Middleware {
    public let id: String = "CreateDirectoryConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectoryConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectoryConfigInput>
    public typealias MOutput = OperationOutput<CreateDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectoryConfigOutputError>
}

extension CreateDirectoryConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDirectoryConfigInput(directoryName: \(String(describing: directoryName)), organizationalUnitDistinguishedNames: \(String(describing: organizationalUnitDistinguishedNames)), serviceAccountCredentials: \(String(describing: serviceAccountCredentials)))"}
}

extension CreateDirectoryConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames {
            var organizationalUnitDistinguishedNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitDistinguishedNames)
            for organizationalunitdistinguishednameslist0 in organizationalUnitDistinguishedNames {
                try organizationalUnitDistinguishedNamesContainer.encode(organizationalunitdistinguishednameslist0)
            }
        }
        if let serviceAccountCredentials = serviceAccountCredentials {
            try encodeContainer.encode(serviceAccountCredentials, forKey: .serviceAccountCredentials)
        }
    }
}

public struct CreateDirectoryConfigInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDirectoryConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectoryConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectoryConfigInput>
    public typealias MOutput = OperationOutput<CreateDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectoryConfigOutputError>
}

public struct CreateDirectoryConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDirectoryConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDirectoryConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDirectoryConfigInput>
    public typealias MOutput = OperationOutput<CreateDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDirectoryConfigOutputError>
}

public struct CreateDirectoryConfigInput: Equatable {
    /// <p>The fully qualified name of the directory (for example, corp.example.com).</p>
    public let directoryName: String?
    /// <p>The distinguished names of the organizational units for computer accounts.</p>
    public let organizationalUnitDistinguishedNames: [String]?
    /// <p>The credentials for the service account used by the fleet or image builder to connect to the directory.</p>
    public let serviceAccountCredentials: ServiceAccountCredentials?

    public init (
        directoryName: String? = nil,
        organizationalUnitDistinguishedNames: [String]? = nil,
        serviceAccountCredentials: ServiceAccountCredentials? = nil
    )
    {
        self.directoryName = directoryName
        self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
        self.serviceAccountCredentials = serviceAccountCredentials
    }
}

struct CreateDirectoryConfigInputBody: Equatable {
    public let directoryName: String?
    public let organizationalUnitDistinguishedNames: [String]?
    public let serviceAccountCredentials: ServiceAccountCredentials?
}

extension CreateDirectoryConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let organizationalUnitDistinguishedNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .organizationalUnitDistinguishedNames)
        var organizationalUnitDistinguishedNamesDecoded0:[String]? = nil
        if let organizationalUnitDistinguishedNamesContainer = organizationalUnitDistinguishedNamesContainer {
            organizationalUnitDistinguishedNamesDecoded0 = [String]()
            for string0 in organizationalUnitDistinguishedNamesContainer {
                if let string0 = string0 {
                    organizationalUnitDistinguishedNamesDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNamesDecoded0
        let serviceAccountCredentialsDecoded = try containerValues.decodeIfPresent(ServiceAccountCredentials.self, forKey: .serviceAccountCredentials)
        serviceAccountCredentials = serviceAccountCredentialsDecoded
    }
}

extension CreateDirectoryConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDirectoryConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDirectoryConfigOutputError: Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDirectoryConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDirectoryConfigOutputResponse(directoryConfig: \(String(describing: directoryConfig)))"}
}

extension CreateDirectoryConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDirectoryConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.directoryConfig = output.directoryConfig
        } else {
            self.directoryConfig = nil
        }
    }
}

public struct CreateDirectoryConfigOutputResponse: Equatable {
    /// <p>Information about the directory configuration.</p>
    public let directoryConfig: DirectoryConfig?

    public init (
        directoryConfig: DirectoryConfig? = nil
    )
    {
        self.directoryConfig = directoryConfig
    }
}

struct CreateDirectoryConfigOutputResponseBody: Equatable {
    public let directoryConfig: DirectoryConfig?
}

extension CreateDirectoryConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryConfig = "DirectoryConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryConfigDecoded = try containerValues.decodeIfPresent(DirectoryConfig.self, forKey: .directoryConfig)
        directoryConfig = directoryConfigDecoded
    }
}

public struct CreateFleetInputBodyMiddleware: Middleware {
    public let id: String = "CreateFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFleetInput>
    public typealias MOutput = OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFleetOutputError>
}

extension CreateFleetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFleetInput(computeCapacity: \(String(describing: computeCapacity)), description: \(String(describing: description)), disconnectTimeoutInSeconds: \(String(describing: disconnectTimeoutInSeconds)), displayName: \(String(describing: displayName)), domainJoinInfo: \(String(describing: domainJoinInfo)), enableDefaultInternetAccess: \(String(describing: enableDefaultInternetAccess)), fleetType: \(String(describing: fleetType)), iamRoleArn: \(String(describing: iamRoleArn)), idleDisconnectTimeoutInSeconds: \(String(describing: idleDisconnectTimeoutInSeconds)), imageArn: \(String(describing: imageArn)), imageName: \(String(describing: imageName)), instanceType: \(String(describing: instanceType)), maxUserDurationInSeconds: \(String(describing: maxUserDurationInSeconds)), name: \(String(describing: name)), streamView: \(String(describing: streamView)), tags: \(String(describing: tags)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension CreateFleetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case computeCapacity = "ComputeCapacity"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case fleetType = "FleetType"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case streamView = "StreamView"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeCapacity = computeCapacity {
            try encodeContainer.encode(computeCapacity, forKey: .computeCapacity)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disconnectTimeoutInSeconds = disconnectTimeoutInSeconds {
            try encodeContainer.encode(disconnectTimeoutInSeconds, forKey: .disconnectTimeoutInSeconds)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let fleetType = fleetType {
            try encodeContainer.encode(fleetType.rawValue, forKey: .fleetType)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds {
            try encodeContainer.encode(idleDisconnectTimeoutInSeconds, forKey: .idleDisconnectTimeoutInSeconds)
        }
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageName = imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let maxUserDurationInSeconds = maxUserDurationInSeconds {
            try encodeContainer.encode(maxUserDurationInSeconds, forKey: .maxUserDurationInSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamView = streamView {
            try encodeContainer.encode(streamView.rawValue, forKey: .streamView)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct CreateFleetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFleetInput>
    public typealias MOutput = OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFleetOutputError>
}

public struct CreateFleetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFleetInput>
    public typealias MOutput = OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFleetOutputError>
}

public struct CreateFleetInput: Equatable {
    /// <p>The desired capacity for the fleet.</p>
    public let computeCapacity: ComputeCapacity?
    /// <p>The description to display.</p>
    public let description: String?
    /// <p>The amount of time that a streaming session remains active after users disconnect. If users try to reconnect to the streaming session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance. </p>
    ///         <p>Specify a value between 60 and 360000.</p>
    public let disconnectTimeoutInSeconds: Int?
    /// <p>The fleet name to display.</p>
    public let displayName: String?
    /// <p>The name of the directory and organizational unit (OU) to use to join the fleet to a Microsoft Active Directory domain. </p>
    public let domainJoinInfo: DomainJoinInfo?
    /// <p>Enables or disables default internet access for the fleet.</p>
    public let enableDefaultInternetAccess: Bool?
    /// <p>The fleet type.</p>
    ///         <dl>
    ///             <dt>ALWAYS_ON</dt>
    ///             <dd>
    ///                     <p>Provides users with instant-on access to their apps.
    ///                         You are charged for all running instances in your fleet, even if no users are streaming apps.</p>
    ///                 </dd>
    ///             <dt>ON_DEMAND</dt>
    ///             <dd>
    ///                     <p>Provide users with access to applications after they connect, which takes one to two minutes.
    ///                         You are charged for instance streaming when users are connected and a
    ///                         small hourly fee for instances that are not streaming apps.</p>
    ///                 </dd>
    ///          </dl>
    public let fleetType: FleetType?
    /// <p>The Amazon Resource Name (ARN) of the IAM role to apply to the fleet. To assume a role, a fleet instance calls the AWS Security Token Service (STS) <code>AssumeRole</code> API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the <b>appstream_machine_role</b> credential profile on the instance.</p>
    ///
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html">Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances</a> in the <i>Amazon AppStream 2.0 Administration Guide</i>.</p>
    public let iamRoleArn: String?
    /// <p>The amount of time that users can be idle (inactive) before they are disconnected
    ///             from their streaming session and the <code>DisconnectTimeoutInSeconds</code> time
    ///             interval begins. Users are notified before they are disconnected due to inactivity. If
    ///             they try to reconnect to the streaming session before the time interval specified in
    ///             <code>DisconnectTimeoutInSeconds</code> elapses, they are connected to their
    ///             previous session. Users are considered idle when they stop providing keyboard or mouse
    ///             input during their streaming session. File uploads and downloads, audio in, audio out,
    ///             and pixels changing do not qualify as user activity. If users continue to be idle after
    ///             the time interval in <code>IdleDisconnectTimeoutInSeconds</code> elapses, they are
    ///             disconnected.</p>
    ///         <p>To prevent users from being disconnected due to inactivity, specify a value of 0. Otherwise, specify a value between 60 and 3600. The default value is 0.</p>
    ///         <note>
    ///             <p>If you enable this feature, we recommend that you specify a value that corresponds exactly to a whole number of minutes (for example, 60, 120, and 180). If you don't do this, the value is rounded to the nearest minute. For example, if you specify a value of 70, users are disconnected after 1 minute of inactivity. If you specify a value that is at the midpoint between two different minutes, the value is rounded up. For example, if you specify a value of 90, users are disconnected after 2 minutes of inactivity. </p>
    ///          </note>
    public let idleDisconnectTimeoutInSeconds: Int?
    /// <p>The ARN of the public, private, or shared image to use.</p>
    public let imageArn: String?
    /// <p>The name of the image used to create the fleet.</p>
    public let imageName: String?
    /// <p>The instance type to use when launching fleet instances. The following instance types are available:</p>
    ///         <ul>
    ///             <li>
    ///                <p>stream.standard.small</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.standard.medium</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.standard.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.3xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.6xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.12xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-desktop.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.12xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.16xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-pro.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-pro.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-pro.16xlarge</p>
    ///             </li>
    ///          </ul>
    public let instanceType: String?
    /// <p>The maximum amount of time that a streaming session can remain active, in seconds. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected. After this time elapses, the instance is terminated and replaced by a new instance.</p>
    ///         <p>Specify a value between 600 and 360000.</p>
    public let maxUserDurationInSeconds: Int?
    /// <p>A unique name for the fleet.</p>
    public let name: String?
    /// <p>The AppStream 2.0 view that is displayed to your users when they stream from the fleet. When <code>APP</code> is specified, only the windows of applications opened by users display. When <code>DESKTOP</code> is specified, the standard desktop that is provided by the operating system displays.</p>
    ///
    ///         <p>The default value is <code>APP</code>.</p>
    public let streamView: StreamView?
    /// <p>The tags to associate with the fleet. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. </p>
    ///
    ///         <p>If you do not specify a value, the value is set to an empty string.</p>
    ///
    ///         <p>Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: </p>
    ///         <p>_ . : / = + \ - @</p>
    ///
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html">Tagging Your Resources</a> in the <i>Amazon AppStream 2.0 Administration Guide</i>.</p>
    public let tags: [String:String]?
    /// <p>The VPC configuration for the fleet.</p>
    public let vpcConfig: VpcConfig?

    public init (
        computeCapacity: ComputeCapacity? = nil,
        description: String? = nil,
        disconnectTimeoutInSeconds: Int? = nil,
        displayName: String? = nil,
        domainJoinInfo: DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Bool? = nil,
        fleetType: FleetType? = nil,
        iamRoleArn: String? = nil,
        idleDisconnectTimeoutInSeconds: Int? = nil,
        imageArn: String? = nil,
        imageName: String? = nil,
        instanceType: String? = nil,
        maxUserDurationInSeconds: Int? = nil,
        name: String? = nil,
        streamView: StreamView? = nil,
        tags: [String:String]? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.computeCapacity = computeCapacity
        self.description = description
        self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.fleetType = fleetType
        self.iamRoleArn = iamRoleArn
        self.idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds
        self.imageArn = imageArn
        self.imageName = imageName
        self.instanceType = instanceType
        self.maxUserDurationInSeconds = maxUserDurationInSeconds
        self.name = name
        self.streamView = streamView
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateFleetInputBody: Equatable {
    public let name: String?
    public let imageName: String?
    public let imageArn: String?
    public let instanceType: String?
    public let fleetType: FleetType?
    public let computeCapacity: ComputeCapacity?
    public let vpcConfig: VpcConfig?
    public let maxUserDurationInSeconds: Int?
    public let disconnectTimeoutInSeconds: Int?
    public let description: String?
    public let displayName: String?
    public let enableDefaultInternetAccess: Bool?
    public let domainJoinInfo: DomainJoinInfo?
    public let tags: [String:String]?
    public let idleDisconnectTimeoutInSeconds: Int?
    public let iamRoleArn: String?
    public let streamView: StreamView?
}

extension CreateFleetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case computeCapacity = "ComputeCapacity"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case fleetType = "FleetType"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case streamView = "StreamView"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let fleetTypeDecoded = try containerValues.decodeIfPresent(FleetType.self, forKey: .fleetType)
        fleetType = fleetTypeDecoded
        let computeCapacityDecoded = try containerValues.decodeIfPresent(ComputeCapacity.self, forKey: .computeCapacity)
        computeCapacity = computeCapacityDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let maxUserDurationInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxUserDurationInSeconds)
        maxUserDurationInSeconds = maxUserDurationInSecondsDecoded
        let disconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .disconnectTimeoutInSeconds)
        disconnectTimeoutInSeconds = disconnectTimeoutInSecondsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let idleDisconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .idleDisconnectTimeoutInSeconds)
        idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSecondsDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let streamViewDecoded = try containerValues.decodeIfPresent(StreamView.self, forKey: .streamView)
        streamView = streamViewDecoded
    }
}

extension CreateFleetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFleetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestLimitExceededException" : self = .requestLimitExceededException(try RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFleetOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case requestLimitExceededException(RequestLimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFleetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFleetOutputResponse(fleet: \(String(describing: fleet)))"}
}

extension CreateFleetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFleetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fleet = output.fleet
        } else {
            self.fleet = nil
        }
    }
}

public struct CreateFleetOutputResponse: Equatable {
    /// <p>Information about the fleet.</p>
    public let fleet: Fleet?

    public init (
        fleet: Fleet? = nil
    )
    {
        self.fleet = fleet
    }
}

struct CreateFleetOutputResponseBody: Equatable {
    public let fleet: Fleet?
}

extension CreateFleetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleet = "Fleet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Fleet.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

public struct CreateImageBuilderInputBodyMiddleware: Middleware {
    public let id: String = "CreateImageBuilderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImageBuilderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImageBuilderInput>
    public typealias MOutput = OperationOutput<CreateImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImageBuilderOutputError>
}

extension CreateImageBuilderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateImageBuilderInput(accessEndpoints: \(String(describing: accessEndpoints)), appstreamAgentVersion: \(String(describing: appstreamAgentVersion)), description: \(String(describing: description)), displayName: \(String(describing: displayName)), domainJoinInfo: \(String(describing: domainJoinInfo)), enableDefaultInternetAccess: \(String(describing: enableDefaultInternetAccess)), iamRoleArn: \(String(describing: iamRoleArn)), imageArn: \(String(describing: imageArn)), imageName: \(String(describing: imageName)), instanceType: \(String(describing: instanceType)), name: \(String(describing: name)), tags: \(String(describing: tags)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension CreateImageBuilderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case description = "Description"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case name = "Name"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpointlist0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpointlist0)
            }
        }
        if let appstreamAgentVersion = appstreamAgentVersion {
            try encodeContainer.encode(appstreamAgentVersion, forKey: .appstreamAgentVersion)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageName = imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct CreateImageBuilderInputHeadersMiddleware: Middleware {
    public let id: String = "CreateImageBuilderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImageBuilderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImageBuilderInput>
    public typealias MOutput = OperationOutput<CreateImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImageBuilderOutputError>
}

public struct CreateImageBuilderInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateImageBuilderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImageBuilderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImageBuilderInput>
    public typealias MOutput = OperationOutput<CreateImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImageBuilderOutputError>
}

public struct CreateImageBuilderInput: Equatable {
    /// <p>The list of interface VPC endpoint (interface endpoint) objects. Administrators can connect to the image builder only through the specified endpoints.</p>
    public let accessEndpoints: [AccessEndpoint]?
    /// <p>The version of the AppStream 2.0 agent to use for this image builder. To use the latest version of the AppStream 2.0 agent, specify [LATEST]. </p>
    public let appstreamAgentVersion: String?
    /// <p>The description to display.</p>
    public let description: String?
    /// <p>The image builder name to display.</p>
    public let displayName: String?
    /// <p>The name of the directory and organizational unit (OU) to use to join the image builder to a Microsoft Active Directory domain. </p>
    public let domainJoinInfo: DomainJoinInfo?
    /// <p>Enables or disables default internet access for the image builder.</p>
    public let enableDefaultInternetAccess: Bool?
    /// <p>The Amazon Resource Name (ARN) of the IAM role to apply to the image builder. To assume a role, the image builder calls the AWS Security Token Service (STS) <code>AssumeRole</code> API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the <b>appstream_machine_role</b> credential profile on the instance.</p>
    ///
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html">Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances</a> in the <i>Amazon AppStream 2.0 Administration Guide</i>.</p>
    public let iamRoleArn: String?
    /// <p>The ARN of the public, private, or shared image to use.</p>
    public let imageArn: String?
    /// <p>The name of the image used to create the image builder.</p>
    public let imageName: String?
    /// <p>The instance type to use when launching the image builder. The following instance types are available:</p>
    ///         <ul>
    ///             <li>
    ///                <p>stream.standard.small</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.standard.medium</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.standard.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.3xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.6xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.12xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-desktop.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.12xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.16xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-pro.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-pro.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-pro.16xlarge</p>
    ///             </li>
    ///          </ul>
    public let instanceType: String?
    /// <p>A unique name for the image builder.</p>
    public let name: String?
    /// <p>The tags to associate with the image builder. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. </p>
    ///
    ///         <p>Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: </p>
    ///         <p>_ . : / = + \ - @</p>
    ///
    ///         <p>If you do not specify a value, the value is set to an empty string.</p>
    ///
    ///         <p>For more information about tags, see <a href="https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html">Tagging Your Resources</a> in the <i>Amazon AppStream 2.0 Administration Guide</i>.</p>
    public let tags: [String:String]?
    /// <p>The VPC configuration for the image builder. You can specify only one subnet.</p>
    public let vpcConfig: VpcConfig?

    public init (
        accessEndpoints: [AccessEndpoint]? = nil,
        appstreamAgentVersion: String? = nil,
        description: String? = nil,
        displayName: String? = nil,
        domainJoinInfo: DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Bool? = nil,
        iamRoleArn: String? = nil,
        imageArn: String? = nil,
        imageName: String? = nil,
        instanceType: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.appstreamAgentVersion = appstreamAgentVersion
        self.description = description
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.iamRoleArn = iamRoleArn
        self.imageArn = imageArn
        self.imageName = imageName
        self.instanceType = instanceType
        self.name = name
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateImageBuilderInputBody: Equatable {
    public let name: String?
    public let imageName: String?
    public let imageArn: String?
    public let instanceType: String?
    public let description: String?
    public let displayName: String?
    public let vpcConfig: VpcConfig?
    public let iamRoleArn: String?
    public let enableDefaultInternetAccess: Bool?
    public let domainJoinInfo: DomainJoinInfo?
    public let appstreamAgentVersion: String?
    public let tags: [String:String]?
    public let accessEndpoints: [AccessEndpoint]?
}

extension CreateImageBuilderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case description = "Description"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case name = "Name"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let appstreamAgentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appstreamAgentVersion)
        appstreamAgentVersion = appstreamAgentVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
    }
}

extension CreateImageBuilderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImageBuilderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestLimitExceededException" : self = .requestLimitExceededException(try RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateImageBuilderOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case requestLimitExceededException(RequestLimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImageBuilderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateImageBuilderOutputResponse(imageBuilder: \(String(describing: imageBuilder)))"}
}

extension CreateImageBuilderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateImageBuilderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageBuilder = output.imageBuilder
        } else {
            self.imageBuilder = nil
        }
    }
}

public struct CreateImageBuilderOutputResponse: Equatable {
    /// <p>Information about the image builder.</p>
    public let imageBuilder: ImageBuilder?

    public init (
        imageBuilder: ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

struct CreateImageBuilderOutputResponseBody: Equatable {
    public let imageBuilder: ImageBuilder?
}

extension CreateImageBuilderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageBuilder = "ImageBuilder"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuilderDecoded = try containerValues.decodeIfPresent(ImageBuilder.self, forKey: .imageBuilder)
        imageBuilder = imageBuilderDecoded
    }
}

public struct CreateImageBuilderStreamingURLInputBodyMiddleware: Middleware {
    public let id: String = "CreateImageBuilderStreamingURLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImageBuilderStreamingURLInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImageBuilderStreamingURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImageBuilderStreamingURLInput>
    public typealias MOutput = OperationOutput<CreateImageBuilderStreamingURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImageBuilderStreamingURLOutputError>
}

extension CreateImageBuilderStreamingURLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateImageBuilderStreamingURLInput(name: \(String(describing: name)), validity: \(String(describing: validity)))"}
}

extension CreateImageBuilderStreamingURLInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case validity = "Validity"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }
}

public struct CreateImageBuilderStreamingURLInputHeadersMiddleware: Middleware {
    public let id: String = "CreateImageBuilderStreamingURLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImageBuilderStreamingURLInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImageBuilderStreamingURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImageBuilderStreamingURLInput>
    public typealias MOutput = OperationOutput<CreateImageBuilderStreamingURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImageBuilderStreamingURLOutputError>
}

public struct CreateImageBuilderStreamingURLInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateImageBuilderStreamingURLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImageBuilderStreamingURLInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImageBuilderStreamingURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImageBuilderStreamingURLInput>
    public typealias MOutput = OperationOutput<CreateImageBuilderStreamingURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImageBuilderStreamingURLOutputError>
}

public struct CreateImageBuilderStreamingURLInput: Equatable {
    /// <p>The name of the image builder.</p>
    public let name: String?
    /// <p>The time that the streaming URL will be valid, in seconds.
    ///             Specify a value between 1 and 604800 seconds. The default is 3600 seconds.</p>
    public let validity: Int?

    public init (
        name: String? = nil,
        validity: Int? = nil
    )
    {
        self.name = name
        self.validity = validity
    }
}

struct CreateImageBuilderStreamingURLInputBody: Equatable {
    public let name: String?
    public let validity: Int?
}

extension CreateImageBuilderStreamingURLInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case validity = "Validity"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let validityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .validity)
        validity = validityDecoded
    }
}

extension CreateImageBuilderStreamingURLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImageBuilderStreamingURLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateImageBuilderStreamingURLOutputError: Equatable {
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImageBuilderStreamingURLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateImageBuilderStreamingURLOutputResponse(expires: \(String(describing: expires)), streamingURL: \(String(describing: streamingURL)))"}
}

extension CreateImageBuilderStreamingURLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateImageBuilderStreamingURLOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.expires = output.expires
            self.streamingURL = output.streamingURL
        } else {
            self.expires = nil
            self.streamingURL = nil
        }
    }
}

public struct CreateImageBuilderStreamingURLOutputResponse: Equatable {
    /// <p>The elapsed time, in seconds after the Unix epoch, when this URL expires.</p>
    public let expires: Date?
    /// <p>The URL to start the AppStream 2.0 streaming session.</p>
    public let streamingURL: String?

    public init (
        expires: Date? = nil,
        streamingURL: String? = nil
    )
    {
        self.expires = expires
        self.streamingURL = streamingURL
    }
}

struct CreateImageBuilderStreamingURLOutputResponseBody: Equatable {
    public let streamingURL: String?
    public let expires: Date?
}

extension CreateImageBuilderStreamingURLOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expires = "Expires"
        case streamingURL = "StreamingURL"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamingURL)
        streamingURL = streamingURLDecoded
        let expiresDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expires)
        expires = expiresDecoded
    }
}

public struct CreateStackInputBodyMiddleware: Middleware {
    public let id: String = "CreateStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStackInput>
    public typealias MOutput = OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStackOutputError>
}

extension CreateStackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStackInput(accessEndpoints: \(String(describing: accessEndpoints)), applicationSettings: \(String(describing: applicationSettings)), description: \(String(describing: description)), displayName: \(String(describing: displayName)), embedHostDomains: \(String(describing: embedHostDomains)), feedbackURL: \(String(describing: feedbackURL)), name: \(String(describing: name)), redirectURL: \(String(describing: redirectURL)), storageConnectors: \(String(describing: storageConnectors)), tags: \(String(describing: tags)), userSettings: \(String(describing: userSettings)))"}
}

extension CreateStackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case storageConnectors = "StorageConnectors"
        case tags = "Tags"
        case userSettings = "UserSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpointlist0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpointlist0)
            }
        }
        if let applicationSettings = applicationSettings {
            try encodeContainer.encode(applicationSettings, forKey: .applicationSettings)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let embedHostDomains = embedHostDomains {
            var embedHostDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .embedHostDomains)
            for embedhostdomains0 in embedHostDomains {
                try embedHostDomainsContainer.encode(embedhostdomains0)
            }
        }
        if let feedbackURL = feedbackURL {
            try encodeContainer.encode(feedbackURL, forKey: .feedbackURL)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let redirectURL = redirectURL {
            try encodeContainer.encode(redirectURL, forKey: .redirectURL)
        }
        if let storageConnectors = storageConnectors {
            var storageConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .storageConnectors)
            for storageconnectorlist0 in storageConnectors {
                try storageConnectorsContainer.encode(storageconnectorlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let userSettings = userSettings {
            var userSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userSettings)
            for usersettinglist0 in userSettings {
                try userSettingsContainer.encode(usersettinglist0)
            }
        }
    }
}

public struct CreateStackInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStackInput>
    public typealias MOutput = OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStackOutputError>
}

public struct CreateStackInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStackInput>
    public typealias MOutput = OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStackOutputError>
}

public struct CreateStackInput: Equatable {
    /// <p>The list of interface VPC endpoint (interface endpoint) objects. Users of the stack can connect to AppStream 2.0 only through the specified endpoints.</p>
    public let accessEndpoints: [AccessEndpoint]?
    /// <p>The persistent application settings for users of a stack. When these settings are enabled, changes that users make to applications and Windows settings are automatically saved after each session and applied to the next session.</p>
    public let applicationSettings: ApplicationSettings?
    /// <p>The description to display.</p>
    public let description: String?
    /// <p>The stack name to display.</p>
    public let displayName: String?
    /// <p>The domains where AppStream 2.0 streaming sessions can be embedded in an iframe. You must approve the domains that you want to host embedded AppStream 2.0 streaming sessions. </p>
    public let embedHostDomains: [String]?
    /// <p>The URL that users are redirected to after they click the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.</p>
    public let feedbackURL: String?
    /// <p>The name of the stack.</p>
    public let name: String?
    /// <p>The URL that users are redirected to after their streaming session ends.</p>
    public let redirectURL: String?
    /// <p>The storage connectors to enable.</p>
    public let storageConnectors: [StorageConnector]?
    /// <p>The tags to associate with the stack. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. </p>
    ///
    ///         <p>If you do not specify a value, the value is set to an empty string.</p>
    ///
    ///         <p>Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: </p>
    ///         <p>_ . : / = + \ - @</p>
    ///
    ///         <p>For more information about tags, see <a href="https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html">Tagging Your Resources</a> in the <i>Amazon AppStream 2.0 Administration Guide</i>.</p>
    public let tags: [String:String]?
    /// <p>The actions that are enabled or disabled for users during their streaming sessions. By default, these actions are enabled. </p>
    public let userSettings: [UserSetting]?

    public init (
        accessEndpoints: [AccessEndpoint]? = nil,
        applicationSettings: ApplicationSettings? = nil,
        description: String? = nil,
        displayName: String? = nil,
        embedHostDomains: [String]? = nil,
        feedbackURL: String? = nil,
        name: String? = nil,
        redirectURL: String? = nil,
        storageConnectors: [StorageConnector]? = nil,
        tags: [String:String]? = nil,
        userSettings: [UserSetting]? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.applicationSettings = applicationSettings
        self.description = description
        self.displayName = displayName
        self.embedHostDomains = embedHostDomains
        self.feedbackURL = feedbackURL
        self.name = name
        self.redirectURL = redirectURL
        self.storageConnectors = storageConnectors
        self.tags = tags
        self.userSettings = userSettings
    }
}

struct CreateStackInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let displayName: String?
    public let storageConnectors: [StorageConnector]?
    public let redirectURL: String?
    public let feedbackURL: String?
    public let userSettings: [UserSetting]?
    public let applicationSettings: ApplicationSettings?
    public let tags: [String:String]?
    public let accessEndpoints: [AccessEndpoint]?
    public let embedHostDomains: [String]?
}

extension CreateStackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case storageConnectors = "StorageConnectors"
        case tags = "Tags"
        case userSettings = "UserSettings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let storageConnectorsContainer = try containerValues.decodeIfPresent([StorageConnector?].self, forKey: .storageConnectors)
        var storageConnectorsDecoded0:[StorageConnector]? = nil
        if let storageConnectorsContainer = storageConnectorsContainer {
            storageConnectorsDecoded0 = [StorageConnector]()
            for structure0 in storageConnectorsContainer {
                if let structure0 = structure0 {
                    storageConnectorsDecoded0?.append(structure0)
                }
            }
        }
        storageConnectors = storageConnectorsDecoded0
        let redirectURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .redirectURL)
        redirectURL = redirectURLDecoded
        let feedbackURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .feedbackURL)
        feedbackURL = feedbackURLDecoded
        let userSettingsContainer = try containerValues.decodeIfPresent([UserSetting?].self, forKey: .userSettings)
        var userSettingsDecoded0:[UserSetting]? = nil
        if let userSettingsContainer = userSettingsContainer {
            userSettingsDecoded0 = [UserSetting]()
            for structure0 in userSettingsContainer {
                if let structure0 = structure0 {
                    userSettingsDecoded0?.append(structure0)
                }
            }
        }
        userSettings = userSettingsDecoded0
        let applicationSettingsDecoded = try containerValues.decodeIfPresent(ApplicationSettings.self, forKey: .applicationSettings)
        applicationSettings = applicationSettingsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
        let embedHostDomainsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .embedHostDomains)
        var embedHostDomainsDecoded0:[String]? = nil
        if let embedHostDomainsContainer = embedHostDomainsContainer {
            embedHostDomainsDecoded0 = [String]()
            for string0 in embedHostDomainsContainer {
                if let string0 = string0 {
                    embedHostDomainsDecoded0?.append(string0)
                }
            }
        }
        embedHostDomains = embedHostDomainsDecoded0
    }
}

extension CreateStackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStackOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStackOutputResponse(stack: \(String(describing: stack)))"}
}

extension CreateStackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateStackOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stack = output.stack
        } else {
            self.stack = nil
        }
    }
}

public struct CreateStackOutputResponse: Equatable {
    /// <p>Information about the stack.</p>
    public let stack: Stack?

    public init (
        stack: Stack? = nil
    )
    {
        self.stack = stack
    }
}

struct CreateStackOutputResponseBody: Equatable {
    public let stack: Stack?
}

extension CreateStackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stack = "Stack"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackDecoded = try containerValues.decodeIfPresent(Stack.self, forKey: .stack)
        stack = stackDecoded
    }
}

public struct CreateStreamingURLInputBodyMiddleware: Middleware {
    public let id: String = "CreateStreamingURLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingURLInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingURLInput>
    public typealias MOutput = OperationOutput<CreateStreamingURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingURLOutputError>
}

extension CreateStreamingURLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamingURLInput(applicationId: \(String(describing: applicationId)), fleetName: \(String(describing: fleetName)), sessionContext: \(String(describing: sessionContext)), stackName: \(String(describing: stackName)), userId: \(String(describing: userId)), validity: \(String(describing: validity)))"}
}

extension CreateStreamingURLInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case fleetName = "FleetName"
        case sessionContext = "SessionContext"
        case stackName = "StackName"
        case userId = "UserId"
        case validity = "Validity"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let sessionContext = sessionContext {
            try encodeContainer.encode(sessionContext, forKey: .sessionContext)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }
}

public struct CreateStreamingURLInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStreamingURLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingURLInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingURLInput>
    public typealias MOutput = OperationOutput<CreateStreamingURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingURLOutputError>
}

public struct CreateStreamingURLInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStreamingURLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingURLInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingURLInput>
    public typealias MOutput = OperationOutput<CreateStreamingURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingURLOutputError>
}

public struct CreateStreamingURLInput: Equatable {
    /// <p>The name of the application to launch after the session starts. This is the name that you specified
    ///             as <b>Name</b> in the Image Assistant. If your fleet is enabled for the <b>Desktop</b> stream view, you can also choose to launch directly to the operating system desktop. To do so, specify <b>Desktop</b>.</p>
    public let applicationId: String?
    /// <p>The name of the fleet.</p>
    public let fleetName: String?
    /// <p>The session context. For more information, see <a href="https://docs.aws.amazon.com/appstream2/latest/developerguide/managing-stacks-fleets.html#managing-stacks-fleets-parameters">Session Context</a> in the <i>Amazon AppStream 2.0 Administration Guide</i>.</p>
    public let sessionContext: String?
    /// <p>The name of the stack.</p>
    public let stackName: String?
    /// <p>The identifier of the user.</p>
    public let userId: String?
    /// <p>The time that the streaming URL will be valid, in seconds.
    ///             Specify a value between 1 and 604800 seconds. The default is 60 seconds.</p>
    public let validity: Int?

    public init (
        applicationId: String? = nil,
        fleetName: String? = nil,
        sessionContext: String? = nil,
        stackName: String? = nil,
        userId: String? = nil,
        validity: Int? = nil
    )
    {
        self.applicationId = applicationId
        self.fleetName = fleetName
        self.sessionContext = sessionContext
        self.stackName = stackName
        self.userId = userId
        self.validity = validity
    }
}

struct CreateStreamingURLInputBody: Equatable {
    public let stackName: String?
    public let fleetName: String?
    public let userId: String?
    public let applicationId: String?
    public let validity: Int?
    public let sessionContext: String?
}

extension CreateStreamingURLInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case fleetName = "FleetName"
        case sessionContext = "SessionContext"
        case stackName = "StackName"
        case userId = "UserId"
        case validity = "Validity"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let validityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .validity)
        validity = validityDecoded
        let sessionContextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionContext)
        sessionContext = sessionContextDecoded
    }
}

extension CreateStreamingURLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamingURLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingURLOutputError: Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingURLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamingURLOutputResponse(expires: \(String(describing: expires)), streamingURL: \(String(describing: streamingURL)))"}
}

extension CreateStreamingURLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateStreamingURLOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.expires = output.expires
            self.streamingURL = output.streamingURL
        } else {
            self.expires = nil
            self.streamingURL = nil
        }
    }
}

public struct CreateStreamingURLOutputResponse: Equatable {
    /// <p>The elapsed time, in seconds after the Unix epoch, when this URL expires.</p>
    public let expires: Date?
    /// <p>The URL to start the AppStream 2.0 streaming session.</p>
    public let streamingURL: String?

    public init (
        expires: Date? = nil,
        streamingURL: String? = nil
    )
    {
        self.expires = expires
        self.streamingURL = streamingURL
    }
}

struct CreateStreamingURLOutputResponseBody: Equatable {
    public let streamingURL: String?
    public let expires: Date?
}

extension CreateStreamingURLOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expires = "Expires"
        case streamingURL = "StreamingURL"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamingURL)
        streamingURL = streamingURLDecoded
        let expiresDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expires)
        expires = expiresDecoded
    }
}

public struct CreateUpdatedImageInputBodyMiddleware: Middleware {
    public let id: String = "CreateUpdatedImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUpdatedImageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUpdatedImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUpdatedImageInput>
    public typealias MOutput = OperationOutput<CreateUpdatedImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUpdatedImageOutputError>
}

extension CreateUpdatedImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUpdatedImageInput(dryRun: \(String(describing: dryRun)), existingImageName: \(String(describing: existingImageName)), newImageDescription: \(String(describing: newImageDescription)), newImageDisplayName: \(String(describing: newImageDisplayName)), newImageName: \(String(describing: newImageName)), newImageTags: \(String(describing: newImageTags)))"}
}

extension CreateUpdatedImageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dryRun
        case existingImageName
        case newImageDescription
        case newImageDisplayName
        case newImageName
        case newImageTags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let existingImageName = existingImageName {
            try encodeContainer.encode(existingImageName, forKey: .existingImageName)
        }
        if let newImageDescription = newImageDescription {
            try encodeContainer.encode(newImageDescription, forKey: .newImageDescription)
        }
        if let newImageDisplayName = newImageDisplayName {
            try encodeContainer.encode(newImageDisplayName, forKey: .newImageDisplayName)
        }
        if let newImageName = newImageName {
            try encodeContainer.encode(newImageName, forKey: .newImageName)
        }
        if let newImageTags = newImageTags {
            var newImageTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .newImageTags)
            for (dictKey0, tags0) in newImageTags {
                try newImageTagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateUpdatedImageInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUpdatedImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUpdatedImageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUpdatedImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUpdatedImageInput>
    public typealias MOutput = OperationOutput<CreateUpdatedImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUpdatedImageOutputError>
}

public struct CreateUpdatedImageInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUpdatedImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUpdatedImageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUpdatedImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUpdatedImageInput>
    public typealias MOutput = OperationOutput<CreateUpdatedImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUpdatedImageOutputError>
}

public struct CreateUpdatedImageInput: Equatable {
    /// <p>Indicates whether to display the status of image update availability before AppStream 2.0 initiates the process of creating a new updated image. If this value is set to <code>true</code>, AppStream 2.0 displays whether image updates are available. If this value is set to <code>false</code>, AppStream 2.0 initiates the process of creating a new updated image without displaying whether image updates are available.</p>
    public let dryRun: Bool
    /// <p>The name of the image to update.</p>
    public let existingImageName: String?
    /// <p>The description to display for the new image.</p>
    public let newImageDescription: String?
    /// <p>The name to display for the new image.</p>
    public let newImageDisplayName: String?
    /// <p>The name of the new image. The name must be unique within the AWS account and Region.</p>
    public let newImageName: String?
    /// <p>The tags to associate with the new image. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. </p>
    ///         <p>Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: </p>
    ///         <p>_ . : / = + \ - @</p>
    ///         <p>If you do not specify a value, the value is set to an empty string.</p>
    ///         <p>For more information about tags, see <a href="https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html">Tagging Your Resources</a> in the <i>Amazon AppStream 2.0 Administration Guide</i>.</p>
    public let newImageTags: [String:String]?

    public init (
        dryRun: Bool = false,
        existingImageName: String? = nil,
        newImageDescription: String? = nil,
        newImageDisplayName: String? = nil,
        newImageName: String? = nil,
        newImageTags: [String:String]? = nil
    )
    {
        self.dryRun = dryRun
        self.existingImageName = existingImageName
        self.newImageDescription = newImageDescription
        self.newImageDisplayName = newImageDisplayName
        self.newImageName = newImageName
        self.newImageTags = newImageTags
    }
}

struct CreateUpdatedImageInputBody: Equatable {
    public let existingImageName: String?
    public let newImageName: String?
    public let newImageDescription: String?
    public let newImageDisplayName: String?
    public let newImageTags: [String:String]?
    public let dryRun: Bool
}

extension CreateUpdatedImageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dryRun
        case existingImageName
        case newImageDescription
        case newImageDisplayName
        case newImageName
        case newImageTags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let existingImageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .existingImageName)
        existingImageName = existingImageNameDecoded
        let newImageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .newImageName)
        newImageName = newImageNameDecoded
        let newImageDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .newImageDescription)
        newImageDescription = newImageDescriptionDecoded
        let newImageDisplayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .newImageDisplayName)
        newImageDisplayName = newImageDisplayNameDecoded
        let newImageTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .newImageTags)
        var newImageTagsDecoded0: [String:String]? = nil
        if let newImageTagsContainer = newImageTagsContainer {
            newImageTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in newImageTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    newImageTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        newImageTags = newImageTagsDecoded0
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension CreateUpdatedImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUpdatedImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUpdatedImageOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUpdatedImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUpdatedImageOutputResponse(canUpdateImage: \(String(describing: canUpdateImage)), image: \(String(describing: image)))"}
}

extension CreateUpdatedImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUpdatedImageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.canUpdateImage = output.canUpdateImage
            self.image = output.image
        } else {
            self.canUpdateImage = false
            self.image = nil
        }
    }
}

public struct CreateUpdatedImageOutputResponse: Equatable {
    /// <p>Indicates whether a new image can be created.</p>
    public let canUpdateImage: Bool
    /// <p>Describes an image.</p>
    public let image: Image?

    public init (
        canUpdateImage: Bool = false,
        image: Image? = nil
    )
    {
        self.canUpdateImage = canUpdateImage
        self.image = image
    }
}

struct CreateUpdatedImageOutputResponseBody: Equatable {
    public let image: Image?
    public let canUpdateImage: Bool
}

extension CreateUpdatedImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case canUpdateImage
        case image
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(Image.self, forKey: .image)
        image = imageDecoded
        let canUpdateImageDecoded = try containerValues.decode(Bool.self, forKey: .canUpdateImage)
        canUpdateImage = canUpdateImageDecoded
    }
}

extension CreateUsageReportSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUsageReportSubscriptionInput()"}
}

extension CreateUsageReportSubscriptionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CreateUsageReportSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUsageReportSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUsageReportSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUsageReportSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUsageReportSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateUsageReportSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUsageReportSubscriptionOutputError>
}

public struct CreateUsageReportSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUsageReportSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUsageReportSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUsageReportSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUsageReportSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateUsageReportSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUsageReportSubscriptionOutputError>
}

public struct CreateUsageReportSubscriptionInput: Equatable {

    public init() {}
}

struct CreateUsageReportSubscriptionInputBody: Equatable {
}

extension CreateUsageReportSubscriptionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateUsageReportSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUsageReportSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUsageReportSubscriptionOutputError: Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUsageReportSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUsageReportSubscriptionOutputResponse(s3BucketName: \(String(describing: s3BucketName)), schedule: \(String(describing: schedule)))"}
}

extension CreateUsageReportSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUsageReportSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.s3BucketName = output.s3BucketName
            self.schedule = output.schedule
        } else {
            self.s3BucketName = nil
            self.schedule = nil
        }
    }
}

public struct CreateUsageReportSubscriptionOutputResponse: Equatable {
    /// <p>The Amazon S3 bucket where generated reports are stored.</p>
    ///
    ///             <p>If you enabled on-instance session scripts and Amazon S3 logging for your session script
    ///             configuration, AppStream 2.0 created an S3 bucket to store the script output. The bucket is
    ///             unique to your account and Region. When you enable usage reporting in this case, AppStream 2.0
    ///             uses the same bucket to store your usage reports. If you haven't already enabled on-instance session scripts,
    ///             when you enable usage reports, AppStream 2.0 creates a new S3 bucket.</p>
    public let s3BucketName: String?
    /// <p>The schedule for generating usage reports.</p>
    public let schedule: UsageReportSchedule?

    public init (
        s3BucketName: String? = nil,
        schedule: UsageReportSchedule? = nil
    )
    {
        self.s3BucketName = s3BucketName
        self.schedule = schedule
    }
}

struct CreateUsageReportSubscriptionOutputResponseBody: Equatable {
    public let s3BucketName: String?
    public let schedule: UsageReportSchedule?
}

extension CreateUsageReportSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case s3BucketName = "S3BucketName"
        case schedule = "Schedule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(UsageReportSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
    }
}

public struct CreateUserInputBodyMiddleware: Middleware {
    public let id: String = "CreateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

extension CreateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserInput(authenticationType: \(String(describing: authenticationType)), firstName: \(String(describing: firstName)), lastName: \(String(describing: lastName)), messageAction: \(String(describing: messageAction)), userName: \(String(describing: userName)))"}
}

extension CreateUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case firstName = "FirstName"
        case lastName = "LastName"
        case messageAction = "MessageAction"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let messageAction = messageAction {
            try encodeContainer.encode(messageAction.rawValue, forKey: .messageAction)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct CreateUserInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

public struct CreateUserInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

public struct CreateUserInput: Equatable {
    /// <p>The authentication type for the user. You must specify USERPOOL. </p>
    public let authenticationType: AuthenticationType?
    /// <p>The first name, or given name, of the user.</p>
    public let firstName: String?
    /// <p>The last name, or surname, of the user.</p>
    public let lastName: String?
    /// <p>The action to take for the welcome email that is sent to a user after the user is created in the user pool. If you specify SUPPRESS, no email is sent. If you specify RESEND, do not specify the first name or last name of the user. If the value is null, the email is sent. </p>
    ///
    ///         <note>
    ///             <p>The temporary password in the welcome email is valid for only 7 days. If users don’t set their passwords within 7 days, you must send them a new welcome email.</p>
    ///          </note>
    public let messageAction: MessageAction?
    /// <p>The email address of the user.</p>
    ///
    ///         <note>
    ///             <p>Users' email addresses are case-sensitive. During login, if they specify an email address that doesn't use the same capitalization as the email address specified when their user pool account was created, a "user does not exist" error message displays.</p>
    ///          </note>
    public let userName: String?

    public init (
        authenticationType: AuthenticationType? = nil,
        firstName: String? = nil,
        lastName: String? = nil,
        messageAction: MessageAction? = nil,
        userName: String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.firstName = firstName
        self.lastName = lastName
        self.messageAction = messageAction
        self.userName = userName
    }
}

struct CreateUserInputBody: Equatable {
    public let userName: String?
    public let messageAction: MessageAction?
    public let firstName: String?
    public let lastName: String?
    public let authenticationType: AuthenticationType?
}

extension CreateUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case firstName = "FirstName"
        case lastName = "LastName"
        case messageAction = "MessageAction"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let messageActionDecoded = try containerValues.decodeIfPresent(MessageAction.self, forKey: .messageAction)
        messageAction = messageActionDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension CreateUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserOutputResponse()"}
}

extension CreateUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateUserOutputResponse: Equatable {

    public init() {}
}

struct CreateUserOutputResponseBody: Equatable {
}

extension CreateUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDirectoryConfigInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDirectoryConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectoryConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectoryConfigInput>
    public typealias MOutput = OperationOutput<DeleteDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectoryConfigOutputError>
}

extension DeleteDirectoryConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDirectoryConfigInput(directoryName: \(String(describing: directoryName)))"}
}

extension DeleteDirectoryConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryName = "DirectoryName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
    }
}

public struct DeleteDirectoryConfigInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDirectoryConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectoryConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectoryConfigInput>
    public typealias MOutput = OperationOutput<DeleteDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectoryConfigOutputError>
}

public struct DeleteDirectoryConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDirectoryConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDirectoryConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDirectoryConfigInput>
    public typealias MOutput = OperationOutput<DeleteDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDirectoryConfigOutputError>
}

public struct DeleteDirectoryConfigInput: Equatable {
    /// <p>The name of the directory configuration.</p>
    public let directoryName: String?

    public init (
        directoryName: String? = nil
    )
    {
        self.directoryName = directoryName
    }
}

struct DeleteDirectoryConfigInputBody: Equatable {
    public let directoryName: String?
}

extension DeleteDirectoryConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryName = "DirectoryName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
    }
}

extension DeleteDirectoryConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDirectoryConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDirectoryConfigOutputError: Equatable {
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDirectoryConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDirectoryConfigOutputResponse()"}
}

extension DeleteDirectoryConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDirectoryConfigOutputResponse: Equatable {

    public init() {}
}

struct DeleteDirectoryConfigOutputResponseBody: Equatable {
}

extension DeleteDirectoryConfigOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteFleetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFleetOutputError>
}

extension DeleteFleetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFleetInput(name: \(String(describing: name)))"}
}

extension DeleteFleetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteFleetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFleetOutputError>
}

public struct DeleteFleetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFleetOutputError>
}

public struct DeleteFleetInput: Equatable {
    /// <p>The name of the fleet.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteFleetInputBody: Equatable {
    public let name: String?
}

extension DeleteFleetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteFleetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFleetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFleetOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFleetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFleetOutputResponse()"}
}

extension DeleteFleetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFleetOutputResponse: Equatable {

    public init() {}
}

struct DeleteFleetOutputResponseBody: Equatable {
}

extension DeleteFleetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteImageBuilderInputBodyMiddleware: Middleware {
    public let id: String = "DeleteImageBuilderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImageBuilderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImageBuilderInput>
    public typealias MOutput = OperationOutput<DeleteImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImageBuilderOutputError>
}

extension DeleteImageBuilderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteImageBuilderInput(name: \(String(describing: name)))"}
}

extension DeleteImageBuilderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteImageBuilderInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteImageBuilderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImageBuilderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImageBuilderInput>
    public typealias MOutput = OperationOutput<DeleteImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImageBuilderOutputError>
}

public struct DeleteImageBuilderInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteImageBuilderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImageBuilderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImageBuilderInput>
    public typealias MOutput = OperationOutput<DeleteImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImageBuilderOutputError>
}

public struct DeleteImageBuilderInput: Equatable {
    /// <p>The name of the image builder.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteImageBuilderInputBody: Equatable {
    public let name: String?
}

extension DeleteImageBuilderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteImageBuilderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImageBuilderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImageBuilderOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImageBuilderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteImageBuilderOutputResponse(imageBuilder: \(String(describing: imageBuilder)))"}
}

extension DeleteImageBuilderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteImageBuilderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageBuilder = output.imageBuilder
        } else {
            self.imageBuilder = nil
        }
    }
}

public struct DeleteImageBuilderOutputResponse: Equatable {
    /// <p>Information about the image builder.</p>
    public let imageBuilder: ImageBuilder?

    public init (
        imageBuilder: ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

struct DeleteImageBuilderOutputResponseBody: Equatable {
    public let imageBuilder: ImageBuilder?
}

extension DeleteImageBuilderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageBuilder = "ImageBuilder"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuilderDecoded = try containerValues.decodeIfPresent(ImageBuilder.self, forKey: .imageBuilder)
        imageBuilder = imageBuilderDecoded
    }
}

public struct DeleteImageInputBodyMiddleware: Middleware {
    public let id: String = "DeleteImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImageInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImageInput>
    public typealias MOutput = OperationOutput<DeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImageOutputError>
}

extension DeleteImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteImageInput(name: \(String(describing: name)))"}
}

extension DeleteImageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteImageInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImageInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImageInput>
    public typealias MOutput = OperationOutput<DeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImageOutputError>
}

public struct DeleteImageInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImageInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImageInput>
    public typealias MOutput = OperationOutput<DeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImageOutputError>
}

public struct DeleteImageInput: Equatable {
    /// <p>The name of the image.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteImageInputBody: Equatable {
    public let name: String?
}

extension DeleteImageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImageOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteImageOutputResponse(image: \(String(describing: image)))"}
}

extension DeleteImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteImageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.image = output.image
        } else {
            self.image = nil
        }
    }
}

public struct DeleteImageOutputResponse: Equatable {
    /// <p>Information about the image.</p>
    public let image: Image?

    public init (
        image: Image? = nil
    )
    {
        self.image = image
    }
}

struct DeleteImageOutputResponseBody: Equatable {
    public let image: Image?
}

extension DeleteImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case image = "Image"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(Image.self, forKey: .image)
        image = imageDecoded
    }
}

public struct DeleteImagePermissionsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteImagePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImagePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImagePermissionsInput>
    public typealias MOutput = OperationOutput<DeleteImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImagePermissionsOutputError>
}

extension DeleteImagePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteImagePermissionsInput(name: \(String(describing: name)), sharedAccountId: \(String(describing: sharedAccountId)))"}
}

extension DeleteImagePermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sharedAccountId = sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }
}

public struct DeleteImagePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteImagePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImagePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImagePermissionsInput>
    public typealias MOutput = OperationOutput<DeleteImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImagePermissionsOutputError>
}

public struct DeleteImagePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteImagePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImagePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImagePermissionsInput>
    public typealias MOutput = OperationOutput<DeleteImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImagePermissionsOutputError>
}

public struct DeleteImagePermissionsInput: Equatable {
    /// <p>The name of the private image.</p>
    public let name: String?
    /// <p>The 12-digit identifier of the AWS account for which to delete image permissions.</p>
    public let sharedAccountId: String?

    public init (
        name: String? = nil,
        sharedAccountId: String? = nil
    )
    {
        self.name = name
        self.sharedAccountId = sharedAccountId
    }
}

struct DeleteImagePermissionsInputBody: Equatable {
    public let name: String?
    public let sharedAccountId: String?
}

extension DeleteImagePermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case sharedAccountId = "SharedAccountId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
    }
}

extension DeleteImagePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImagePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImagePermissionsOutputError: Equatable {
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImagePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteImagePermissionsOutputResponse()"}
}

extension DeleteImagePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteImagePermissionsOutputResponse: Equatable {

    public init() {}
}

struct DeleteImagePermissionsOutputResponseBody: Equatable {
}

extension DeleteImagePermissionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteStackInputBodyMiddleware: Middleware {
    public let id: String = "DeleteStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStackInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStackInput>
    public typealias MOutput = OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStackOutputError>
}

extension DeleteStackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStackInput(name: \(String(describing: name)))"}
}

extension DeleteStackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteStackInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStackInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStackInput>
    public typealias MOutput = OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStackOutputError>
}

public struct DeleteStackInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStackInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStackInput>
    public typealias MOutput = OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStackOutputError>
}

public struct DeleteStackInput: Equatable {
    /// <p>The name of the stack.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteStackInputBody: Equatable {
    public let name: String?
}

extension DeleteStackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteStackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStackOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStackOutputResponse()"}
}

extension DeleteStackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStackOutputResponse: Equatable {

    public init() {}
}

struct DeleteStackOutputResponseBody: Equatable {
}

extension DeleteStackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUsageReportSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUsageReportSubscriptionInput()"}
}

extension DeleteUsageReportSubscriptionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteUsageReportSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUsageReportSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUsageReportSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUsageReportSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUsageReportSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteUsageReportSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUsageReportSubscriptionOutputError>
}

public struct DeleteUsageReportSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUsageReportSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUsageReportSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUsageReportSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUsageReportSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteUsageReportSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUsageReportSubscriptionOutputError>
}

public struct DeleteUsageReportSubscriptionInput: Equatable {

    public init() {}
}

struct DeleteUsageReportSubscriptionInputBody: Equatable {
}

extension DeleteUsageReportSubscriptionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUsageReportSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUsageReportSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUsageReportSubscriptionOutputError: Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUsageReportSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUsageReportSubscriptionOutputResponse()"}
}

extension DeleteUsageReportSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUsageReportSubscriptionOutputResponse: Equatable {

    public init() {}
}

struct DeleteUsageReportSubscriptionOutputResponseBody: Equatable {
}

extension DeleteUsageReportSubscriptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteUserInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

extension DeleteUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserInput(authenticationType: \(String(describing: authenticationType)), userName: \(String(describing: userName)))"}
}

extension DeleteUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct DeleteUserInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInput: Equatable {
    /// <p>The authentication type for the user. You must specify USERPOOL.</p>
    public let authenticationType: AuthenticationType?
    /// <p>The email address of the user.</p>
    ///
    ///         <note>
    ///             <p>Users' email addresses are case-sensitive.</p>
    ///          </note>
    public let userName: String?

    public init (
        authenticationType: AuthenticationType? = nil,
        userName: String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.userName = userName
    }
}

struct DeleteUserInputBody: Equatable {
    public let userName: String?
    public let authenticationType: AuthenticationType?
}

extension DeleteUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension DeleteUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserOutputResponse()"}
}

extension DeleteUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserOutputResponseBody: Equatable {
}

extension DeleteUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeDirectoryConfigsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDirectoryConfigsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectoryConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectoryConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectoryConfigsInput>
    public typealias MOutput = OperationOutput<DescribeDirectoryConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectoryConfigsOutputError>
}

extension DescribeDirectoryConfigsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDirectoryConfigsInput(directoryNames: \(String(describing: directoryNames)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeDirectoryConfigsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryNames = "DirectoryNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryNames = directoryNames {
            var directoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .directoryNames)
            for directorynamelist0 in directoryNames {
                try directoryNamesContainer.encode(directorynamelist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeDirectoryConfigsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDirectoryConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectoryConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectoryConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectoryConfigsInput>
    public typealias MOutput = OperationOutput<DescribeDirectoryConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectoryConfigsOutputError>
}

public struct DescribeDirectoryConfigsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDirectoryConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDirectoryConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDirectoryConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDirectoryConfigsInput>
    public typealias MOutput = OperationOutput<DescribeDirectoryConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDirectoryConfigsOutputError>
}

public struct DescribeDirectoryConfigsInput: Equatable {
    /// <p>The directory names.</p>
    public let directoryNames: [String]?
    /// <p>The maximum size of each page of results.</p>
    public let maxResults: Int?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?

    public init (
        directoryNames: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.directoryNames = directoryNames
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeDirectoryConfigsInputBody: Equatable {
    public let directoryNames: [String]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeDirectoryConfigsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryNames = "DirectoryNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .directoryNames)
        var directoryNamesDecoded0:[String]? = nil
        if let directoryNamesContainer = directoryNamesContainer {
            directoryNamesDecoded0 = [String]()
            for string0 in directoryNamesContainer {
                if let string0 = string0 {
                    directoryNamesDecoded0?.append(string0)
                }
            }
        }
        directoryNames = directoryNamesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDirectoryConfigsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDirectoryConfigsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDirectoryConfigsOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDirectoryConfigsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDirectoryConfigsOutputResponse(directoryConfigs: \(String(describing: directoryConfigs)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeDirectoryConfigsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDirectoryConfigsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.directoryConfigs = output.directoryConfigs
            self.nextToken = output.nextToken
        } else {
            self.directoryConfigs = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDirectoryConfigsOutputResponse: Equatable {
    /// <p>Information about the directory configurations. Note that although the response syntax in this topic includes the account password, this password is not returned in the actual response. </p>
    public let directoryConfigs: [DirectoryConfig]?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?

    public init (
        directoryConfigs: [DirectoryConfig]? = nil,
        nextToken: String? = nil
    )
    {
        self.directoryConfigs = directoryConfigs
        self.nextToken = nextToken
    }
}

struct DescribeDirectoryConfigsOutputResponseBody: Equatable {
    public let directoryConfigs: [DirectoryConfig]?
    public let nextToken: String?
}

extension DescribeDirectoryConfigsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryConfigs = "DirectoryConfigs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryConfigsContainer = try containerValues.decodeIfPresent([DirectoryConfig?].self, forKey: .directoryConfigs)
        var directoryConfigsDecoded0:[DirectoryConfig]? = nil
        if let directoryConfigsContainer = directoryConfigsContainer {
            directoryConfigsDecoded0 = [DirectoryConfig]()
            for structure0 in directoryConfigsContainer {
                if let structure0 = structure0 {
                    directoryConfigsDecoded0?.append(structure0)
                }
            }
        }
        directoryConfigs = directoryConfigsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeFleetsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFleetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFleetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFleetsInput>
    public typealias MOutput = OperationOutput<DescribeFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFleetsOutputError>
}

extension DescribeFleetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFleetsInput(names: \(String(describing: names)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeFleetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for stringlist0 in names {
                try namesContainer.encode(stringlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeFleetsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFleetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFleetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFleetsInput>
    public typealias MOutput = OperationOutput<DescribeFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFleetsOutputError>
}

public struct DescribeFleetsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFleetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFleetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFleetsInput>
    public typealias MOutput = OperationOutput<DescribeFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFleetsOutputError>
}

public struct DescribeFleetsInput: Equatable {
    /// <p>The names of the fleets to describe.</p>
    public let names: [String]?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?

    public init (
        names: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

struct DescribeFleetsInputBody: Equatable {
    public let names: [String]?
    public let nextToken: String?
}

extension DescribeFleetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFleetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFleetsOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFleetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFleetsOutputResponse(fleets: \(String(describing: fleets)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeFleetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFleetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fleets = output.fleets
            self.nextToken = output.nextToken
        } else {
            self.fleets = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFleetsOutputResponse: Equatable {
    /// <p>Information about the fleets.</p>
    public let fleets: [Fleet]?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?

    public init (
        fleets: [Fleet]? = nil,
        nextToken: String? = nil
    )
    {
        self.fleets = fleets
        self.nextToken = nextToken
    }
}

struct DescribeFleetsOutputResponseBody: Equatable {
    public let fleets: [Fleet]?
    public let nextToken: String?
}

extension DescribeFleetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleets = "Fleets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetsContainer = try containerValues.decodeIfPresent([Fleet?].self, forKey: .fleets)
        var fleetsDecoded0:[Fleet]? = nil
        if let fleetsContainer = fleetsContainer {
            fleetsDecoded0 = [Fleet]()
            for structure0 in fleetsContainer {
                if let structure0 = structure0 {
                    fleetsDecoded0?.append(structure0)
                }
            }
        }
        fleets = fleetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeImageBuildersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeImageBuildersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImageBuildersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImageBuildersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImageBuildersInput>
    public typealias MOutput = OperationOutput<DescribeImageBuildersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImageBuildersOutputError>
}

extension DescribeImageBuildersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImageBuildersInput(maxResults: \(String(describing: maxResults)), names: \(String(describing: names)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeImageBuildersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for stringlist0 in names {
                try namesContainer.encode(stringlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeImageBuildersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeImageBuildersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImageBuildersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImageBuildersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImageBuildersInput>
    public typealias MOutput = OperationOutput<DescribeImageBuildersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImageBuildersOutputError>
}

public struct DescribeImageBuildersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeImageBuildersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImageBuildersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImageBuildersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImageBuildersInput>
    public typealias MOutput = OperationOutput<DescribeImageBuildersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImageBuildersOutputError>
}

public struct DescribeImageBuildersInput: Equatable {
    /// <p>The maximum size of each page of results.</p>
    public let maxResults: Int?
    /// <p>The names of the image builders to describe.</p>
    public let names: [String]?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        names: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
    }
}

struct DescribeImageBuildersInputBody: Equatable {
    public let names: [String]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeImageBuildersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImageBuildersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImageBuildersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImageBuildersOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImageBuildersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImageBuildersOutputResponse(imageBuilders: \(String(describing: imageBuilders)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeImageBuildersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeImageBuildersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageBuilders = output.imageBuilders
            self.nextToken = output.nextToken
        } else {
            self.imageBuilders = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImageBuildersOutputResponse: Equatable {
    /// <p>Information about the image builders.</p>
    public let imageBuilders: [ImageBuilder]?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?

    public init (
        imageBuilders: [ImageBuilder]? = nil,
        nextToken: String? = nil
    )
    {
        self.imageBuilders = imageBuilders
        self.nextToken = nextToken
    }
}

struct DescribeImageBuildersOutputResponseBody: Equatable {
    public let imageBuilders: [ImageBuilder]?
    public let nextToken: String?
}

extension DescribeImageBuildersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageBuilders = "ImageBuilders"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuildersContainer = try containerValues.decodeIfPresent([ImageBuilder?].self, forKey: .imageBuilders)
        var imageBuildersDecoded0:[ImageBuilder]? = nil
        if let imageBuildersContainer = imageBuildersContainer {
            imageBuildersDecoded0 = [ImageBuilder]()
            for structure0 in imageBuildersContainer {
                if let structure0 = structure0 {
                    imageBuildersDecoded0?.append(structure0)
                }
            }
        }
        imageBuilders = imageBuildersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeImagePermissionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeImagePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImagePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImagePermissionsInput>
    public typealias MOutput = OperationOutput<DescribeImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImagePermissionsOutputError>
}

extension DescribeImagePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImagePermissionsInput(maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)), sharedAwsAccountIds: \(String(describing: sharedAwsAccountIds)))"}
}

extension DescribeImagePermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case sharedAwsAccountIds = "SharedAwsAccountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sharedAwsAccountIds = sharedAwsAccountIds {
            var sharedAwsAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sharedAwsAccountIds)
            for awsaccountidlist0 in sharedAwsAccountIds {
                try sharedAwsAccountIdsContainer.encode(awsaccountidlist0)
            }
        }
    }
}

public struct DescribeImagePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeImagePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImagePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImagePermissionsInput>
    public typealias MOutput = OperationOutput<DescribeImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImagePermissionsOutputError>
}

public struct DescribeImagePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeImagePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImagePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImagePermissionsInput>
    public typealias MOutput = OperationOutput<DescribeImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImagePermissionsOutputError>
}

public struct DescribeImagePermissionsInput: Equatable {
    /// <p>The maximum size of each page of results.</p>
    public let maxResults: Int?
    /// <p>The name of the private image for which to describe permissions. The image must be one that you own. </p>
    public let name: String?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?
    /// <p>The 12-digit identifier of one or more AWS accounts with which the image is shared.</p>
    public let sharedAwsAccountIds: [String]?

    public init (
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil,
        sharedAwsAccountIds: [String]? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.sharedAwsAccountIds = sharedAwsAccountIds
    }
}

struct DescribeImagePermissionsInputBody: Equatable {
    public let name: String?
    public let maxResults: Int?
    public let sharedAwsAccountIds: [String]?
    public let nextToken: String?
}

extension DescribeImagePermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case sharedAwsAccountIds = "SharedAwsAccountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sharedAwsAccountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sharedAwsAccountIds)
        var sharedAwsAccountIdsDecoded0:[String]? = nil
        if let sharedAwsAccountIdsContainer = sharedAwsAccountIdsContainer {
            sharedAwsAccountIdsDecoded0 = [String]()
            for string0 in sharedAwsAccountIdsContainer {
                if let string0 = string0 {
                    sharedAwsAccountIdsDecoded0?.append(string0)
                }
            }
        }
        sharedAwsAccountIds = sharedAwsAccountIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImagePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImagePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImagePermissionsOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImagePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImagePermissionsOutputResponse(name: \(String(describing: name)), nextToken: \(String(describing: nextToken)), sharedImagePermissionsList: \(String(describing: sharedImagePermissionsList)))"}
}

extension DescribeImagePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeImagePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
            self.nextToken = output.nextToken
            self.sharedImagePermissionsList = output.sharedImagePermissionsList
        } else {
            self.name = nil
            self.nextToken = nil
            self.sharedImagePermissionsList = nil
        }
    }
}

public struct DescribeImagePermissionsOutputResponse: Equatable {
    /// <p>The name of the private image.</p>
    public let name: String?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?
    /// <p>The permissions for a private image that you own. </p>
    public let sharedImagePermissionsList: [SharedImagePermissions]?

    public init (
        name: String? = nil,
        nextToken: String? = nil,
        sharedImagePermissionsList: [SharedImagePermissions]? = nil
    )
    {
        self.name = name
        self.nextToken = nextToken
        self.sharedImagePermissionsList = sharedImagePermissionsList
    }
}

struct DescribeImagePermissionsOutputResponseBody: Equatable {
    public let name: String?
    public let sharedImagePermissionsList: [SharedImagePermissions]?
    public let nextToken: String?
}

extension DescribeImagePermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case nextToken = "NextToken"
        case sharedImagePermissionsList = "SharedImagePermissionsList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sharedImagePermissionsListContainer = try containerValues.decodeIfPresent([SharedImagePermissions?].self, forKey: .sharedImagePermissionsList)
        var sharedImagePermissionsListDecoded0:[SharedImagePermissions]? = nil
        if let sharedImagePermissionsListContainer = sharedImagePermissionsListContainer {
            sharedImagePermissionsListDecoded0 = [SharedImagePermissions]()
            for structure0 in sharedImagePermissionsListContainer {
                if let structure0 = structure0 {
                    sharedImagePermissionsListDecoded0?.append(structure0)
                }
            }
        }
        sharedImagePermissionsList = sharedImagePermissionsListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeImagesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeImagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImagesOutputError>
}

extension DescribeImagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImagesInput(arns: \(String(describing: arns)), maxResults: \(String(describing: maxResults)), names: \(String(describing: names)), nextToken: \(String(describing: nextToken)), type: \(String(describing: type)))"}
}

extension DescribeImagesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arns = "Arns"
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for arnlist0 in arns {
                try arnsContainer.encode(arnlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for stringlist0 in names {
                try namesContainer.encode(stringlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct DescribeImagesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImagesOutputError>
}

public struct DescribeImagesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImagesOutputError>
}

public struct DescribeImagesInput: Equatable {
    /// <p>The ARNs of the public, private, and shared images to describe.</p>
    public let arns: [String]?
    /// <p>The maximum size of each page of results.</p>
    public let maxResults: Int?
    /// <p>The names of the public or private images to describe.</p>
    public let names: [String]?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?
    /// <p>The type of image (public, private, or shared) to describe. </p>
    public let type: VisibilityType?

    public init (
        arns: [String]? = nil,
        maxResults: Int? = nil,
        names: [String]? = nil,
        nextToken: String? = nil,
        type: VisibilityType? = nil
    )
    {
        self.arns = arns
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
        self.type = type
    }
}

struct DescribeImagesInputBody: Equatable {
    public let names: [String]?
    public let arns: [String]?
    public let type: VisibilityType?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeImagesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arns = "Arns"
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let arnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .arns)
        var arnsDecoded0:[String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(VisibilityType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeImagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImagesOutputError: Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImagesOutputResponse(images: \(String(describing: images)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeImagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeImagesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.images = output.images
            self.nextToken = output.nextToken
        } else {
            self.images = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImagesOutputResponse: Equatable {
    /// <p>Information about the images.</p>
    public let images: [Image]?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?

    public init (
        images: [Image]? = nil,
        nextToken: String? = nil
    )
    {
        self.images = images
        self.nextToken = nextToken
    }
}

struct DescribeImagesOutputResponseBody: Equatable {
    public let images: [Image]?
    public let nextToken: String?
}

extension DescribeImagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case images = "Images"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagesContainer = try containerValues.decodeIfPresent([Image?].self, forKey: .images)
        var imagesDecoded0:[Image]? = nil
        if let imagesContainer = imagesContainer {
            imagesDecoded0 = [Image]()
            for structure0 in imagesContainer {
                if let structure0 = structure0 {
                    imagesDecoded0?.append(structure0)
                }
            }
        }
        images = imagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeSessionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSessionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSessionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSessionsInput>
    public typealias MOutput = OperationOutput<DescribeSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSessionsOutputError>
}

extension DescribeSessionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSessionsInput(authenticationType: \(String(describing: authenticationType)), fleetName: \(String(describing: fleetName)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), stackName: \(String(describing: stackName)), userId: \(String(describing: userId)))"}
}

extension DescribeSessionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case fleetName = "FleetName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case stackName = "StackName"
        case userId = "UserId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct DescribeSessionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSessionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSessionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSessionsInput>
    public typealias MOutput = OperationOutput<DescribeSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSessionsOutputError>
}

public struct DescribeSessionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSessionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSessionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSessionsInput>
    public typealias MOutput = OperationOutput<DescribeSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSessionsOutputError>
}

public struct DescribeSessionsInput: Equatable {
    /// <p>The authentication method. Specify <code>API</code> for a user
    ///             authenticated using a streaming URL or <code>SAML</code> for a SAML federated user.
    ///             The default is to authenticate users using a streaming URL.</p>
    public let authenticationType: AuthenticationType?
    /// <p>The name of the fleet. This value is case-sensitive.</p>
    public let fleetName: String?
    /// <p>The size of each page of results. The default value is 20 and the maximum value is 50.</p>
    public let limit: Int?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?
    /// <p>The name of the stack. This value is case-sensitive.</p>
    public let stackName: String?
    /// <p>The user identifier (ID). If you specify a user ID, you must also specify the authentication type.</p>
    public let userId: String?

    public init (
        authenticationType: AuthenticationType? = nil,
        fleetName: String? = nil,
        limit: Int? = nil,
        nextToken: String? = nil,
        stackName: String? = nil,
        userId: String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.fleetName = fleetName
        self.limit = limit
        self.nextToken = nextToken
        self.stackName = stackName
        self.userId = userId
    }
}

struct DescribeSessionsInputBody: Equatable {
    public let stackName: String?
    public let fleetName: String?
    public let userId: String?
    public let nextToken: String?
    public let limit: Int?
    public let authenticationType: AuthenticationType?
}

extension DescribeSessionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case fleetName = "FleetName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case stackName = "StackName"
        case userId = "UserId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension DescribeSessionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSessionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSessionsOutputError: Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSessionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSessionsOutputResponse(nextToken: \(String(describing: nextToken)), sessions: \(String(describing: sessions)))"}
}

extension DescribeSessionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSessionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.sessions = output.sessions
        } else {
            self.nextToken = nil
            self.sessions = nil
        }
    }
}

public struct DescribeSessionsOutputResponse: Equatable {
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?
    /// <p>Information about the streaming sessions.</p>
    public let sessions: [Session]?

    public init (
        nextToken: String? = nil,
        sessions: [Session]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

struct DescribeSessionsOutputResponseBody: Equatable {
    public let sessions: [Session]?
    public let nextToken: String?
}

extension DescribeSessionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case sessions = "Sessions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionsContainer = try containerValues.decodeIfPresent([Session?].self, forKey: .sessions)
        var sessionsDecoded0:[Session]? = nil
        if let sessionsContainer = sessionsContainer {
            sessionsDecoded0 = [Session]()
            for structure0 in sessionsContainer {
                if let structure0 = structure0 {
                    sessionsDecoded0?.append(structure0)
                }
            }
        }
        sessions = sessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeStacksInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStacksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStacksInput>
    public typealias MOutput = OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStacksOutputError>
}

extension DescribeStacksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStacksInput(names: \(String(describing: names)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeStacksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for stringlist0 in names {
                try namesContainer.encode(stringlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeStacksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStacksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStacksInput>
    public typealias MOutput = OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStacksOutputError>
}

public struct DescribeStacksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStacksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStacksInput>
    public typealias MOutput = OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStacksOutputError>
}

public struct DescribeStacksInput: Equatable {
    /// <p>The names of the stacks to describe.</p>
    public let names: [String]?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?

    public init (
        names: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

struct DescribeStacksInputBody: Equatable {
    public let names: [String]?
    public let nextToken: String?
}

extension DescribeStacksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeStacksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStacksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStacksOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStacksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStacksOutputResponse(nextToken: \(String(describing: nextToken)), stacks: \(String(describing: stacks)))"}
}

extension DescribeStacksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStacksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.stacks = output.stacks
        } else {
            self.nextToken = nil
            self.stacks = nil
        }
    }
}

public struct DescribeStacksOutputResponse: Equatable {
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?
    /// <p>Information about the stacks.</p>
    public let stacks: [Stack]?

    public init (
        nextToken: String? = nil,
        stacks: [Stack]? = nil
    )
    {
        self.nextToken = nextToken
        self.stacks = stacks
    }
}

struct DescribeStacksOutputResponseBody: Equatable {
    public let stacks: [Stack]?
    public let nextToken: String?
}

extension DescribeStacksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case stacks = "Stacks"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stacksContainer = try containerValues.decodeIfPresent([Stack?].self, forKey: .stacks)
        var stacksDecoded0:[Stack]? = nil
        if let stacksContainer = stacksContainer {
            stacksDecoded0 = [Stack]()
            for structure0 in stacksContainer {
                if let structure0 = structure0 {
                    stacksDecoded0?.append(structure0)
                }
            }
        }
        stacks = stacksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeUsageReportSubscriptionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeUsageReportSubscriptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUsageReportSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUsageReportSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUsageReportSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeUsageReportSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUsageReportSubscriptionsOutputError>
}

extension DescribeUsageReportSubscriptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUsageReportSubscriptionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeUsageReportSubscriptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeUsageReportSubscriptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUsageReportSubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUsageReportSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUsageReportSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUsageReportSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeUsageReportSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUsageReportSubscriptionsOutputError>
}

public struct DescribeUsageReportSubscriptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUsageReportSubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUsageReportSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUsageReportSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUsageReportSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeUsageReportSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUsageReportSubscriptionsOutputError>
}

public struct DescribeUsageReportSubscriptionsInput: Equatable {
    /// <p>The maximum size of each page of results.</p>
    public let maxResults: Int?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeUsageReportSubscriptionsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeUsageReportSubscriptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUsageReportSubscriptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUsageReportSubscriptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUsageReportSubscriptionsOutputError: Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUsageReportSubscriptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUsageReportSubscriptionsOutputResponse(nextToken: \(String(describing: nextToken)), usageReportSubscriptions: \(String(describing: usageReportSubscriptions)))"}
}

extension DescribeUsageReportSubscriptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUsageReportSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.usageReportSubscriptions = output.usageReportSubscriptions
        } else {
            self.nextToken = nil
            self.usageReportSubscriptions = nil
        }
    }
}

public struct DescribeUsageReportSubscriptionsOutputResponse: Equatable {
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?
    /// <p>Information about the usage report subscription.</p>
    public let usageReportSubscriptions: [UsageReportSubscription]?

    public init (
        nextToken: String? = nil,
        usageReportSubscriptions: [UsageReportSubscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.usageReportSubscriptions = usageReportSubscriptions
    }
}

struct DescribeUsageReportSubscriptionsOutputResponseBody: Equatable {
    public let usageReportSubscriptions: [UsageReportSubscription]?
    public let nextToken: String?
}

extension DescribeUsageReportSubscriptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case usageReportSubscriptions = "UsageReportSubscriptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageReportSubscriptionsContainer = try containerValues.decodeIfPresent([UsageReportSubscription?].self, forKey: .usageReportSubscriptions)
        var usageReportSubscriptionsDecoded0:[UsageReportSubscription]? = nil
        if let usageReportSubscriptionsContainer = usageReportSubscriptionsContainer {
            usageReportSubscriptionsDecoded0 = [UsageReportSubscription]()
            for structure0 in usageReportSubscriptionsContainer {
                if let structure0 = structure0 {
                    usageReportSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        usageReportSubscriptions = usageReportSubscriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeUserStackAssociationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeUserStackAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserStackAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserStackAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserStackAssociationsInput>
    public typealias MOutput = OperationOutput<DescribeUserStackAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserStackAssociationsOutputError>
}

extension DescribeUserStackAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserStackAssociationsInput(authenticationType: \(String(describing: authenticationType)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), stackName: \(String(describing: stackName)), userName: \(String(describing: userName)))"}
}

extension DescribeUserStackAssociationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stackName = "StackName"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct DescribeUserStackAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUserStackAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserStackAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserStackAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserStackAssociationsInput>
    public typealias MOutput = OperationOutput<DescribeUserStackAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserStackAssociationsOutputError>
}

public struct DescribeUserStackAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUserStackAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserStackAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserStackAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserStackAssociationsInput>
    public typealias MOutput = OperationOutput<DescribeUserStackAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserStackAssociationsOutputError>
}

public struct DescribeUserStackAssociationsInput: Equatable {
    /// <p>The authentication type for the user who is associated with the stack. You must specify USERPOOL.</p>
    public let authenticationType: AuthenticationType?
    /// <p>The maximum size of each page of results.</p>
    public let maxResults: Int?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?
    /// <p>The name of the stack that is associated with the user.</p>
    public let stackName: String?
    /// <p>The email address of the user who is associated with the stack.</p>
    ///
    ///         <note>
    ///             <p>Users' email addresses are case-sensitive.</p>
    ///          </note>
    public let userName: String?

    public init (
        authenticationType: AuthenticationType? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        stackName: String? = nil,
        userName: String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stackName = stackName
        self.userName = userName
    }
}

struct DescribeUserStackAssociationsInputBody: Equatable {
    public let stackName: String?
    public let userName: String?
    public let authenticationType: AuthenticationType?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeUserStackAssociationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stackName = "StackName"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUserStackAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserStackAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserStackAssociationsOutputError: Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserStackAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserStackAssociationsOutputResponse(nextToken: \(String(describing: nextToken)), userStackAssociations: \(String(describing: userStackAssociations)))"}
}

extension DescribeUserStackAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUserStackAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.userStackAssociations = output.userStackAssociations
        } else {
            self.nextToken = nil
            self.userStackAssociations = nil
        }
    }
}

public struct DescribeUserStackAssociationsOutputResponse: Equatable {
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?
    /// <p>The UserStackAssociation objects.</p>
    public let userStackAssociations: [UserStackAssociation]?

    public init (
        nextToken: String? = nil,
        userStackAssociations: [UserStackAssociation]? = nil
    )
    {
        self.nextToken = nextToken
        self.userStackAssociations = userStackAssociations
    }
}

struct DescribeUserStackAssociationsOutputResponseBody: Equatable {
    public let userStackAssociations: [UserStackAssociation]?
    public let nextToken: String?
}

extension DescribeUserStackAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case userStackAssociations = "UserStackAssociations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userStackAssociationsContainer = try containerValues.decodeIfPresent([UserStackAssociation?].self, forKey: .userStackAssociations)
        var userStackAssociationsDecoded0:[UserStackAssociation]? = nil
        if let userStackAssociationsContainer = userStackAssociationsContainer {
            userStackAssociationsDecoded0 = [UserStackAssociation]()
            for structure0 in userStackAssociationsContainer {
                if let structure0 = structure0 {
                    userStackAssociationsDecoded0?.append(structure0)
                }
            }
        }
        userStackAssociations = userStackAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeUsersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeUsersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUsersInput>
    public typealias MOutput = OperationOutput<DescribeUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUsersOutputError>
}

extension DescribeUsersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUsersInput(authenticationType: \(String(describing: authenticationType)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeUsersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeUsersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUsersInput>
    public typealias MOutput = OperationOutput<DescribeUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUsersOutputError>
}

public struct DescribeUsersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUsersInput>
    public typealias MOutput = OperationOutput<DescribeUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUsersOutputError>
}

public struct DescribeUsersInput: Equatable {
    /// <p>The authentication type for the users in the user pool to describe. You must specify USERPOOL.</p>
    public let authenticationType: AuthenticationType?
    /// <p>The maximum size of each page of results.</p>
    public let maxResults: Int?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?

    public init (
        authenticationType: AuthenticationType? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeUsersInputBody: Equatable {
    public let authenticationType: AuthenticationType?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeUsersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUsersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUsersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUsersOutputError: Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUsersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUsersOutputResponse(nextToken: \(String(describing: nextToken)), users: \(String(describing: users)))"}
}

extension DescribeUsersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUsersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct DescribeUsersOutputResponse: Equatable {
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?
    /// <p>Information about users in the user pool.</p>
    public let users: [User]?

    public init (
        nextToken: String? = nil,
        users: [User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct DescribeUsersOutputResponseBody: Equatable {
    public let users: [User]?
    public let nextToken: String?
}

extension DescribeUsersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case users = "Users"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([User?].self, forKey: .users)
        var usersDecoded0:[User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DirectoryConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames {
            var organizationalUnitDistinguishedNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitDistinguishedNames)
            for organizationalunitdistinguishednameslist0 in organizationalUnitDistinguishedNames {
                try organizationalUnitDistinguishedNamesContainer.encode(organizationalunitdistinguishednameslist0)
            }
        }
        if let serviceAccountCredentials = serviceAccountCredentials {
            try encodeContainer.encode(serviceAccountCredentials, forKey: .serviceAccountCredentials)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let organizationalUnitDistinguishedNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .organizationalUnitDistinguishedNames)
        var organizationalUnitDistinguishedNamesDecoded0:[String]? = nil
        if let organizationalUnitDistinguishedNamesContainer = organizationalUnitDistinguishedNamesContainer {
            organizationalUnitDistinguishedNamesDecoded0 = [String]()
            for string0 in organizationalUnitDistinguishedNamesContainer {
                if let string0 = string0 {
                    organizationalUnitDistinguishedNamesDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNamesDecoded0
        let serviceAccountCredentialsDecoded = try containerValues.decodeIfPresent(ServiceAccountCredentials.self, forKey: .serviceAccountCredentials)
        serviceAccountCredentials = serviceAccountCredentialsDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension DirectoryConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryConfig(createdTime: \(String(describing: createdTime)), directoryName: \(String(describing: directoryName)), organizationalUnitDistinguishedNames: \(String(describing: organizationalUnitDistinguishedNames)), serviceAccountCredentials: \(String(describing: serviceAccountCredentials)))"}
}

/// <p>Describes the configuration information required to join fleets and image builders to Microsoft Active Directory domains.</p>
public struct DirectoryConfig: Equatable {
    /// <p>The time the directory configuration was created.</p>
    public let createdTime: Date?
    /// <p>The fully qualified name of the directory (for example, corp.example.com).</p>
    public let directoryName: String?
    /// <p>The distinguished names of the organizational units for computer accounts.</p>
    public let organizationalUnitDistinguishedNames: [String]?
    /// <p>The credentials for the service account used by the fleet or image builder to connect to the directory.</p>
    public let serviceAccountCredentials: ServiceAccountCredentials?

    public init (
        createdTime: Date? = nil,
        directoryName: String? = nil,
        organizationalUnitDistinguishedNames: [String]? = nil,
        serviceAccountCredentials: ServiceAccountCredentials? = nil
    )
    {
        self.createdTime = createdTime
        self.directoryName = directoryName
        self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
        self.serviceAccountCredentials = serviceAccountCredentials
    }
}

public struct DisableUserInputBodyMiddleware: Middleware {
    public let id: String = "DisableUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableUserInput>
    public typealias MOutput = OperationOutput<DisableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableUserOutputError>
}

extension DisableUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableUserInput(authenticationType: \(String(describing: authenticationType)), userName: \(String(describing: userName)))"}
}

extension DisableUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct DisableUserInputHeadersMiddleware: Middleware {
    public let id: String = "DisableUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableUserInput>
    public typealias MOutput = OperationOutput<DisableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableUserOutputError>
}

public struct DisableUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableUserInput>
    public typealias MOutput = OperationOutput<DisableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableUserOutputError>
}

public struct DisableUserInput: Equatable {
    /// <p>The authentication type for the user. You must specify USERPOOL.</p>
    public let authenticationType: AuthenticationType?
    /// <p>The email address of the user.</p>
    ///
    ///         <note>
    ///             <p>Users' email addresses are case-sensitive.</p>
    ///          </note>
    public let userName: String?

    public init (
        authenticationType: AuthenticationType? = nil,
        userName: String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.userName = userName
    }
}

struct DisableUserInputBody: Equatable {
    public let userName: String?
    public let authenticationType: AuthenticationType?
}

extension DisableUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension DisableUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableUserOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableUserOutputResponse()"}
}

extension DisableUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableUserOutputResponse: Equatable {

    public init() {}
}

struct DisableUserOutputResponseBody: Equatable {
}

extension DisableUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateFleetInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFleetInput>
    public typealias MOutput = OperationOutput<DisassociateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFleetOutputError>
}

extension DisassociateFleetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFleetInput(fleetName: \(String(describing: fleetName)), stackName: \(String(describing: stackName)))"}
}

extension DisassociateFleetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetName = "FleetName"
        case stackName = "StackName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

public struct DisassociateFleetInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFleetInput>
    public typealias MOutput = OperationOutput<DisassociateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFleetOutputError>
}

public struct DisassociateFleetInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFleetInput>
    public typealias MOutput = OperationOutput<DisassociateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFleetOutputError>
}

public struct DisassociateFleetInput: Equatable {
    /// <p>The name of the fleet.</p>
    public let fleetName: String?
    /// <p>The name of the stack.</p>
    public let stackName: String?

    public init (
        fleetName: String? = nil,
        stackName: String? = nil
    )
    {
        self.fleetName = fleetName
        self.stackName = stackName
    }
}

struct DisassociateFleetInputBody: Equatable {
    public let fleetName: String?
    public let stackName: String?
}

extension DisassociateFleetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetName = "FleetName"
        case stackName = "StackName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
    }
}

extension DisassociateFleetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFleetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateFleetOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFleetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFleetOutputResponse()"}
}

extension DisassociateFleetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateFleetOutputResponse: Equatable {

    public init() {}
}

struct DisassociateFleetOutputResponseBody: Equatable {
}

extension DisassociateFleetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DomainJoinInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedName = "OrganizationalUnitDistinguishedName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let organizationalUnitDistinguishedName = organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
    }
}

extension DomainJoinInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainJoinInfo(directoryName: \(String(describing: directoryName)), organizationalUnitDistinguishedName: \(String(describing: organizationalUnitDistinguishedName)))"}
}

/// <p>Describes the configuration information required to join fleets and image builders to Microsoft Active Directory domains.</p>
public struct DomainJoinInfo: Equatable {
    /// <p>The fully qualified name of the directory (for example, corp.example.com).</p>
    public let directoryName: String?
    /// <p>The distinguished name of the organizational unit for computer accounts.</p>
    public let organizationalUnitDistinguishedName: String?

    public init (
        directoryName: String? = nil,
        organizationalUnitDistinguishedName: String? = nil
    )
    {
        self.directoryName = directoryName
        self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
    }
}

public struct EnableUserInputBodyMiddleware: Middleware {
    public let id: String = "EnableUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableUserInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableUserInput>
    public typealias MOutput = OperationOutput<EnableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableUserOutputError>
}

extension EnableUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableUserInput(authenticationType: \(String(describing: authenticationType)), userName: \(String(describing: userName)))"}
}

extension EnableUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct EnableUserInputHeadersMiddleware: Middleware {
    public let id: String = "EnableUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableUserInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableUserInput>
    public typealias MOutput = OperationOutput<EnableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableUserOutputError>
}

public struct EnableUserInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableUserInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableUserInput>
    public typealias MOutput = OperationOutput<EnableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableUserOutputError>
}

public struct EnableUserInput: Equatable {
    /// <p>The authentication type for the user. You must specify USERPOOL.</p>
    public let authenticationType: AuthenticationType?
    /// <p>The email address of the user.</p>
    ///
    ///         <note>
    ///             <p>Users' email addresses are case-sensitive. During login, if they specify an email address that doesn't use the same capitalization as the email address specified when their user pool account was created, a "user does not exist" error message displays. </p>
    ///          </note>
    public let userName: String?

    public init (
        authenticationType: AuthenticationType? = nil,
        userName: String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.userName = userName
    }
}

struct EnableUserInputBody: Equatable {
    public let userName: String?
    public let authenticationType: AuthenticationType?
}

extension EnableUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension EnableUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableUserOutputError: Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableUserOutputResponse()"}
}

extension EnableUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableUserOutputResponse: Equatable {

    public init() {}
}

struct EnableUserOutputResponseBody: Equatable {
}

extension EnableUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ExpireSessionInputBodyMiddleware: Middleware {
    public let id: String = "ExpireSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExpireSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<ExpireSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExpireSessionInput>
    public typealias MOutput = OperationOutput<ExpireSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExpireSessionOutputError>
}

extension ExpireSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExpireSessionInput(sessionId: \(String(describing: sessionId)))"}
}

extension ExpireSessionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

public struct ExpireSessionInputHeadersMiddleware: Middleware {
    public let id: String = "ExpireSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExpireSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<ExpireSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExpireSessionInput>
    public typealias MOutput = OperationOutput<ExpireSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExpireSessionOutputError>
}

public struct ExpireSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "ExpireSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExpireSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<ExpireSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExpireSessionInput>
    public typealias MOutput = OperationOutput<ExpireSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExpireSessionOutputError>
}

public struct ExpireSessionInput: Equatable {
    /// <p>The identifier of the streaming session.</p>
    public let sessionId: String?

    public init (
        sessionId: String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct ExpireSessionInputBody: Equatable {
    public let sessionId: String?
}

extension ExpireSessionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sessionId = "SessionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension ExpireSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExpireSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExpireSessionOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ExpireSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExpireSessionOutputResponse()"}
}

extension ExpireSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ExpireSessionOutputResponse: Equatable {

    public init() {}
}

struct ExpireSessionOutputResponseBody: Equatable {
}

extension ExpireSessionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Fleet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case computeCapacityStatus = "ComputeCapacityStatus"
        case createdTime = "CreatedTime"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case fleetErrors = "FleetErrors"
        case fleetType = "FleetType"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case state = "State"
        case streamView = "StreamView"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let computeCapacityStatus = computeCapacityStatus {
            try encodeContainer.encode(computeCapacityStatus, forKey: .computeCapacityStatus)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disconnectTimeoutInSeconds = disconnectTimeoutInSeconds {
            try encodeContainer.encode(disconnectTimeoutInSeconds, forKey: .disconnectTimeoutInSeconds)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let fleetErrors = fleetErrors {
            var fleetErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fleetErrors)
            for fleeterrors0 in fleetErrors {
                try fleetErrorsContainer.encode(fleeterrors0)
            }
        }
        if let fleetType = fleetType {
            try encodeContainer.encode(fleetType.rawValue, forKey: .fleetType)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds {
            try encodeContainer.encode(idleDisconnectTimeoutInSeconds, forKey: .idleDisconnectTimeoutInSeconds)
        }
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageName = imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let maxUserDurationInSeconds = maxUserDurationInSeconds {
            try encodeContainer.encode(maxUserDurationInSeconds, forKey: .maxUserDurationInSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let streamView = streamView {
            try encodeContainer.encode(streamView.rawValue, forKey: .streamView)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let fleetTypeDecoded = try containerValues.decodeIfPresent(FleetType.self, forKey: .fleetType)
        fleetType = fleetTypeDecoded
        let computeCapacityStatusDecoded = try containerValues.decodeIfPresent(ComputeCapacityStatus.self, forKey: .computeCapacityStatus)
        computeCapacityStatus = computeCapacityStatusDecoded
        let maxUserDurationInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxUserDurationInSeconds)
        maxUserDurationInSeconds = maxUserDurationInSecondsDecoded
        let disconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .disconnectTimeoutInSeconds)
        disconnectTimeoutInSeconds = disconnectTimeoutInSecondsDecoded
        let stateDecoded = try containerValues.decodeIfPresent(FleetState.self, forKey: .state)
        state = stateDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let fleetErrorsContainer = try containerValues.decodeIfPresent([FleetError?].self, forKey: .fleetErrors)
        var fleetErrorsDecoded0:[FleetError]? = nil
        if let fleetErrorsContainer = fleetErrorsContainer {
            fleetErrorsDecoded0 = [FleetError]()
            for structure0 in fleetErrorsContainer {
                if let structure0 = structure0 {
                    fleetErrorsDecoded0?.append(structure0)
                }
            }
        }
        fleetErrors = fleetErrorsDecoded0
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let idleDisconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .idleDisconnectTimeoutInSeconds)
        idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSecondsDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let streamViewDecoded = try containerValues.decodeIfPresent(StreamView.self, forKey: .streamView)
        streamView = streamViewDecoded
    }
}

extension Fleet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Fleet(arn: \(String(describing: arn)), computeCapacityStatus: \(String(describing: computeCapacityStatus)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), disconnectTimeoutInSeconds: \(String(describing: disconnectTimeoutInSeconds)), displayName: \(String(describing: displayName)), domainJoinInfo: \(String(describing: domainJoinInfo)), enableDefaultInternetAccess: \(String(describing: enableDefaultInternetAccess)), fleetErrors: \(String(describing: fleetErrors)), fleetType: \(String(describing: fleetType)), iamRoleArn: \(String(describing: iamRoleArn)), idleDisconnectTimeoutInSeconds: \(String(describing: idleDisconnectTimeoutInSeconds)), imageArn: \(String(describing: imageArn)), imageName: \(String(describing: imageName)), instanceType: \(String(describing: instanceType)), maxUserDurationInSeconds: \(String(describing: maxUserDurationInSeconds)), name: \(String(describing: name)), state: \(String(describing: state)), streamView: \(String(describing: streamView)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Describes a fleet.</p>
public struct Fleet: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the fleet.</p>
    public let arn: String?
    /// <p>The capacity status for the fleet.</p>
    public let computeCapacityStatus: ComputeCapacityStatus?
    /// <p>The time the fleet was created.</p>
    public let createdTime: Date?
    /// <p>The description to display.</p>
    public let description: String?
    /// <p>The amount of time that a streaming session remains active after users disconnect. If they try to reconnect to the streaming session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance.</p>
    ///         <p>Specify a value between 60 and 360000.</p>
    public let disconnectTimeoutInSeconds: Int?
    /// <p>The fleet name to display.</p>
    public let displayName: String?
    /// <p>The name of the directory and organizational unit (OU) to use to join the fleet to a Microsoft Active Directory domain. </p>
    public let domainJoinInfo: DomainJoinInfo?
    /// <p>Indicates whether default internet access is enabled for the fleet.</p>
    public let enableDefaultInternetAccess: Bool?
    /// <p>The fleet errors.</p>
    public let fleetErrors: [FleetError]?
    /// <p>The fleet type.</p>
    ///         <dl>
    ///             <dt>ALWAYS_ON</dt>
    ///             <dd>
    ///                     <p>Provides users with instant-on access to their apps.
    ///                         You are charged for all running instances in your fleet, even if no users are streaming apps.</p>
    ///                 </dd>
    ///             <dt>ON_DEMAND</dt>
    ///             <dd>
    ///                     <p>Provide users with access to applications after they connect, which takes one to two minutes.
    ///                         You are charged for instance streaming when users are connected and a
    ///                         small hourly fee for instances that are not streaming apps.</p>
    ///                 </dd>
    ///          </dl>
    public let fleetType: FleetType?
    /// <p>The ARN of the IAM role that is applied to the fleet. To assume a role, the fleet instance calls the AWS Security Token Service (STS) <code>AssumeRole</code> API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the <b>appstream_machine_role</b> credential profile on the instance.</p>
    ///
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html">Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances</a> in the <i>Amazon AppStream 2.0 Administration Guide</i>.</p>
    public let iamRoleArn: String?
    /// <p>The amount of time that users can be idle (inactive) before they are disconnected
    ///             from their streaming session and the <code>DisconnectTimeoutInSeconds</code> time
    ///             interval begins. Users are notified before they are disconnected due to inactivity. If
    ///             users try to reconnect to the streaming session before the time interval specified in
    ///             <code>DisconnectTimeoutInSeconds</code> elapses, they are connected to their
    ///             previous session. Users are considered idle when they stop providing keyboard or mouse
    ///             input during their streaming session. File uploads and downloads, audio in, audio out,
    ///             and pixels changing do not qualify as user activity. If users continue to be idle after
    ///             the time interval in <code>IdleDisconnectTimeoutInSeconds</code> elapses, they are
    ///             disconnected.</p>
    ///         <p>To prevent users from being disconnected due to inactivity, specify a value of 0. Otherwise, specify a value between 60 and 3600. The default value is 0.</p>
    ///
    ///         <note>
    ///             <p>If you enable this feature, we recommend that you specify a value that corresponds exactly to a whole number of minutes (for example, 60, 120, and 180). If you don't do this, the value is rounded to the nearest minute. For example, if you specify a value of 70, users are disconnected after 1 minute of inactivity. If you specify a value that is at the midpoint between two different minutes, the value is rounded up. For example, if you specify a value of 90, users are disconnected after 2 minutes of inactivity. </p>
    ///          </note>
    public let idleDisconnectTimeoutInSeconds: Int?
    /// <p>The ARN for the public, private, or shared image.</p>
    public let imageArn: String?
    /// <p>The name of the image used to create the fleet.</p>
    public let imageName: String?
    /// <p>The instance type to use when launching fleet instances. The following instance types are available:</p>
    ///         <ul>
    ///             <li>
    ///                <p>stream.standard.small</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.standard.medium</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.standard.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.3xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.6xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.12xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-desktop.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.12xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.16xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-pro.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-pro.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-pro.16xlarge</p>
    ///             </li>
    ///          </ul>
    public let instanceType: String?
    /// <p>The maximum amount of time that a streaming session can remain active, in seconds. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected. After this time elapses, the instance is terminated and replaced by a new instance. </p>
    ///         <p>Specify a value between 600 and 360000.</p>
    public let maxUserDurationInSeconds: Int?
    /// <p>The name of the fleet.</p>
    public let name: String?
    /// <p>The current state for the fleet.</p>
    public let state: FleetState?
    /// <p>The AppStream 2.0 view that is displayed to your users when they stream from the fleet. When <code>APP</code> is specified, only the windows of applications opened by users display. When <code>DESKTOP</code> is specified, the standard desktop that is provided by the operating system displays.</p>
    ///
    ///         <p>The default value is <code>APP</code>.</p>
    public let streamView: StreamView?
    /// <p>The VPC configuration for the fleet.</p>
    public let vpcConfig: VpcConfig?

    public init (
        arn: String? = nil,
        computeCapacityStatus: ComputeCapacityStatus? = nil,
        createdTime: Date? = nil,
        description: String? = nil,
        disconnectTimeoutInSeconds: Int? = nil,
        displayName: String? = nil,
        domainJoinInfo: DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Bool? = nil,
        fleetErrors: [FleetError]? = nil,
        fleetType: FleetType? = nil,
        iamRoleArn: String? = nil,
        idleDisconnectTimeoutInSeconds: Int? = nil,
        imageArn: String? = nil,
        imageName: String? = nil,
        instanceType: String? = nil,
        maxUserDurationInSeconds: Int? = nil,
        name: String? = nil,
        state: FleetState? = nil,
        streamView: StreamView? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.arn = arn
        self.computeCapacityStatus = computeCapacityStatus
        self.createdTime = createdTime
        self.description = description
        self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.fleetErrors = fleetErrors
        self.fleetType = fleetType
        self.iamRoleArn = iamRoleArn
        self.idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds
        self.imageArn = imageArn
        self.imageName = imageName
        self.instanceType = instanceType
        self.maxUserDurationInSeconds = maxUserDurationInSeconds
        self.name = name
        self.state = state
        self.streamView = streamView
        self.vpcConfig = vpcConfig
    }
}

/// <p>The fleet attribute.</p>
public enum FleetAttribute {
    case domainJoinInfo
    case iamRoleArn
    case vpcConfiguration
    case vpcConfigurationSecurityGroupIds
    case sdkUnknown(String)
}

extension FleetAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FleetAttribute] {
        return [
            .domainJoinInfo,
            .iamRoleArn,
            .vpcConfiguration,
            .vpcConfigurationSecurityGroupIds,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .domainJoinInfo: return "DOMAIN_JOIN_INFO"
        case .iamRoleArn: return "IAM_ROLE_ARN"
        case .vpcConfiguration: return "VPC_CONFIGURATION"
        case .vpcConfigurationSecurityGroupIds: return "VPC_CONFIGURATION_SECURITY_GROUP_IDS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FleetAttribute(rawValue: rawValue) ?? FleetAttribute.sdkUnknown(rawValue)
    }
}

extension FleetError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(FleetErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension FleetError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FleetError(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>Describes a fleet error.</p>
public struct FleetError: Equatable {
    /// <p>The error code.</p>
    public let errorCode: FleetErrorCode?
    /// <p>The error message.</p>
    public let errorMessage: String?

    public init (
        errorCode: FleetErrorCode? = nil,
        errorMessage: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }
}

public enum FleetErrorCode {
    case domainJoinErrorAccessDenied
    case domainJoinErrorDsMachineAccountQuotaExceeded
    case domainJoinErrorFileNotFound
    case domainJoinErrorInvalidParameter
    case domainJoinErrorLogonFailure
    case domainJoinErrorMoreData
    case domainJoinErrorNotSupported
    case domainJoinErrorNoSuchDomain
    case domainJoinInternalServiceError
    case domainJoinNerrInvalidWorkgroupName
    case domainJoinNerrPasswordExpired
    case domainJoinNerrWorkstationNotStarted
    case fleetInstanceProvisioningFailure
    case fleetStopped
    case iamServiceRoleIsMissing
    case iamServiceRoleMissingDescribeSecurityGroupsAction
    case iamServiceRoleMissingDescribeSubnetAction
    case iamServiceRoleMissingEniCreateAction
    case iamServiceRoleMissingEniDeleteAction
    case iamServiceRoleMissingEniDescribeAction
    case igwNotAttached
    case imageNotFound
    case internalServiceError
    case invalidSubnetConfiguration
    case machineRoleIsMissing
    case networkInterfaceLimitExceeded
    case securityGroupsNotFound
    case stsDisabledInRegion
    case subnetHasInsufficientIpAddresses
    case subnetNotFound
    case sdkUnknown(String)
}

extension FleetErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FleetErrorCode] {
        return [
            .domainJoinErrorAccessDenied,
            .domainJoinErrorDsMachineAccountQuotaExceeded,
            .domainJoinErrorFileNotFound,
            .domainJoinErrorInvalidParameter,
            .domainJoinErrorLogonFailure,
            .domainJoinErrorMoreData,
            .domainJoinErrorNotSupported,
            .domainJoinErrorNoSuchDomain,
            .domainJoinInternalServiceError,
            .domainJoinNerrInvalidWorkgroupName,
            .domainJoinNerrPasswordExpired,
            .domainJoinNerrWorkstationNotStarted,
            .fleetInstanceProvisioningFailure,
            .fleetStopped,
            .iamServiceRoleIsMissing,
            .iamServiceRoleMissingDescribeSecurityGroupsAction,
            .iamServiceRoleMissingDescribeSubnetAction,
            .iamServiceRoleMissingEniCreateAction,
            .iamServiceRoleMissingEniDeleteAction,
            .iamServiceRoleMissingEniDescribeAction,
            .igwNotAttached,
            .imageNotFound,
            .internalServiceError,
            .invalidSubnetConfiguration,
            .machineRoleIsMissing,
            .networkInterfaceLimitExceeded,
            .securityGroupsNotFound,
            .stsDisabledInRegion,
            .subnetHasInsufficientIpAddresses,
            .subnetNotFound,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .domainJoinErrorAccessDenied: return "DOMAIN_JOIN_ERROR_ACCESS_DENIED"
        case .domainJoinErrorDsMachineAccountQuotaExceeded: return "DOMAIN_JOIN_ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED"
        case .domainJoinErrorFileNotFound: return "DOMAIN_JOIN_ERROR_FILE_NOT_FOUND"
        case .domainJoinErrorInvalidParameter: return "DOMAIN_JOIN_ERROR_INVALID_PARAMETER"
        case .domainJoinErrorLogonFailure: return "DOMAIN_JOIN_ERROR_LOGON_FAILURE"
        case .domainJoinErrorMoreData: return "DOMAIN_JOIN_ERROR_MORE_DATA"
        case .domainJoinErrorNotSupported: return "DOMAIN_JOIN_ERROR_NOT_SUPPORTED"
        case .domainJoinErrorNoSuchDomain: return "DOMAIN_JOIN_ERROR_NO_SUCH_DOMAIN"
        case .domainJoinInternalServiceError: return "DOMAIN_JOIN_INTERNAL_SERVICE_ERROR"
        case .domainJoinNerrInvalidWorkgroupName: return "DOMAIN_JOIN_NERR_INVALID_WORKGROUP_NAME"
        case .domainJoinNerrPasswordExpired: return "DOMAIN_JOIN_NERR_PASSWORD_EXPIRED"
        case .domainJoinNerrWorkstationNotStarted: return "DOMAIN_JOIN_NERR_WORKSTATION_NOT_STARTED"
        case .fleetInstanceProvisioningFailure: return "FLEET_INSTANCE_PROVISIONING_FAILURE"
        case .fleetStopped: return "FLEET_STOPPED"
        case .iamServiceRoleIsMissing: return "IAM_SERVICE_ROLE_IS_MISSING"
        case .iamServiceRoleMissingDescribeSecurityGroupsAction: return "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SECURITY_GROUPS_ACTION"
        case .iamServiceRoleMissingDescribeSubnetAction: return "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SUBNET_ACTION"
        case .iamServiceRoleMissingEniCreateAction: return "IAM_SERVICE_ROLE_MISSING_ENI_CREATE_ACTION"
        case .iamServiceRoleMissingEniDeleteAction: return "IAM_SERVICE_ROLE_MISSING_ENI_DELETE_ACTION"
        case .iamServiceRoleMissingEniDescribeAction: return "IAM_SERVICE_ROLE_MISSING_ENI_DESCRIBE_ACTION"
        case .igwNotAttached: return "IGW_NOT_ATTACHED"
        case .imageNotFound: return "IMAGE_NOT_FOUND"
        case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
        case .invalidSubnetConfiguration: return "INVALID_SUBNET_CONFIGURATION"
        case .machineRoleIsMissing: return "MACHINE_ROLE_IS_MISSING"
        case .networkInterfaceLimitExceeded: return "NETWORK_INTERFACE_LIMIT_EXCEEDED"
        case .securityGroupsNotFound: return "SECURITY_GROUPS_NOT_FOUND"
        case .stsDisabledInRegion: return "STS_DISABLED_IN_REGION"
        case .subnetHasInsufficientIpAddresses: return "SUBNET_HAS_INSUFFICIENT_IP_ADDRESSES"
        case .subnetNotFound: return "SUBNET_NOT_FOUND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FleetErrorCode(rawValue: rawValue) ?? FleetErrorCode.sdkUnknown(rawValue)
    }
}

public enum FleetState {
    case running
    case starting
    case stopped
    case stopping
    case sdkUnknown(String)
}

extension FleetState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FleetState] {
        return [
            .running,
            .starting,
            .stopped,
            .stopping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .running: return "RUNNING"
        case .starting: return "STARTING"
        case .stopped: return "STOPPED"
        case .stopping: return "STOPPING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FleetState(rawValue: rawValue) ?? FleetState.sdkUnknown(rawValue)
    }
}

public enum FleetType {
    case alwaysOn
    case onDemand
    case sdkUnknown(String)
}

extension FleetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FleetType] {
        return [
            .alwaysOn,
            .onDemand,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .alwaysOn: return "ALWAYS_ON"
        case .onDemand: return "ON_DEMAND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FleetType(rawValue: rawValue) ?? FleetType.sdkUnknown(rawValue)
    }
}

extension Image: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applications = "Applications"
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case arn = "Arn"
        case baseImageArn = "BaseImageArn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case imageBuilderName = "ImageBuilderName"
        case imageBuilderSupported = "ImageBuilderSupported"
        case imageErrors = "ImageErrors"
        case imagePermissions = "ImagePermissions"
        case name = "Name"
        case platform = "Platform"
        case publicBaseImageReleasedDate = "PublicBaseImageReleasedDate"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for applications0 in applications {
                try applicationsContainer.encode(applications0)
            }
        }
        if let appstreamAgentVersion = appstreamAgentVersion {
            try encodeContainer.encode(appstreamAgentVersion, forKey: .appstreamAgentVersion)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let baseImageArn = baseImageArn {
            try encodeContainer.encode(baseImageArn, forKey: .baseImageArn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let imageBuilderName = imageBuilderName {
            try encodeContainer.encode(imageBuilderName, forKey: .imageBuilderName)
        }
        if imageBuilderSupported != false {
            try encodeContainer.encode(imageBuilderSupported, forKey: .imageBuilderSupported)
        }
        if let imageErrors = imageErrors {
            var imageErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageErrors)
            for resourceerrors0 in imageErrors {
                try imageErrorsContainer.encode(resourceerrors0)
            }
        }
        if let imagePermissions = imagePermissions {
            try encodeContainer.encode(imagePermissions, forKey: .imagePermissions)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let publicBaseImageReleasedDate = publicBaseImageReleasedDate {
            try encodeContainer.encode(publicBaseImageReleasedDate.timeIntervalSince1970, forKey: .publicBaseImageReleasedDate)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
        if let visibility = visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let baseImageArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baseImageArn)
        baseImageArn = baseImageArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImageState.self, forKey: .state)
        state = stateDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(VisibilityType.self, forKey: .visibility)
        visibility = visibilityDecoded
        let imageBuilderSupportedDecoded = try containerValues.decode(Bool.self, forKey: .imageBuilderSupported)
        imageBuilderSupported = imageBuilderSupportedDecoded
        let imageBuilderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageBuilderName)
        imageBuilderName = imageBuilderNameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(ImageStateChangeReason.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
        let applicationsContainer = try containerValues.decodeIfPresent([Application?].self, forKey: .applications)
        var applicationsDecoded0:[Application]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [Application]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let publicBaseImageReleasedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .publicBaseImageReleasedDate)
        publicBaseImageReleasedDate = publicBaseImageReleasedDateDecoded
        let appstreamAgentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appstreamAgentVersion)
        appstreamAgentVersion = appstreamAgentVersionDecoded
        let imagePermissionsDecoded = try containerValues.decodeIfPresent(ImagePermissions.self, forKey: .imagePermissions)
        imagePermissions = imagePermissionsDecoded
        let imageErrorsContainer = try containerValues.decodeIfPresent([ResourceError?].self, forKey: .imageErrors)
        var imageErrorsDecoded0:[ResourceError]? = nil
        if let imageErrorsContainer = imageErrorsContainer {
            imageErrorsDecoded0 = [ResourceError]()
            for structure0 in imageErrorsContainer {
                if let structure0 = structure0 {
                    imageErrorsDecoded0?.append(structure0)
                }
            }
        }
        imageErrors = imageErrorsDecoded0
    }
}

extension Image: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Image(applications: \(String(describing: applications)), appstreamAgentVersion: \(String(describing: appstreamAgentVersion)), arn: \(String(describing: arn)), baseImageArn: \(String(describing: baseImageArn)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), displayName: \(String(describing: displayName)), imageBuilderName: \(String(describing: imageBuilderName)), imageBuilderSupported: \(String(describing: imageBuilderSupported)), imageErrors: \(String(describing: imageErrors)), imagePermissions: \(String(describing: imagePermissions)), name: \(String(describing: name)), platform: \(String(describing: platform)), publicBaseImageReleasedDate: \(String(describing: publicBaseImageReleasedDate)), state: \(String(describing: state)), stateChangeReason: \(String(describing: stateChangeReason)), visibility: \(String(describing: visibility)))"}
}

/// <p>Describes an image.</p>
public struct Image: Equatable {
    /// <p>The applications associated with the image.</p>
    public let applications: [Application]?
    /// <p>The version of the AppStream 2.0 agent to use for instances that are launched from this image. </p>
    public let appstreamAgentVersion: String?
    /// <p>The ARN of the image.</p>
    public let arn: String?
    /// <p>The ARN of the image from which this image was created.</p>
    public let baseImageArn: String?
    /// <p>The time the image was created.</p>
    public let createdTime: Date?
    /// <p>The description to display.</p>
    public let description: String?
    /// <p>The image name to display.</p>
    public let displayName: String?
    /// <p>The name of the image builder that was used to create the private image. If the image is shared, this value is null.</p>
    public let imageBuilderName: String?
    /// <p>Indicates whether an image builder can be launched from this image.</p>
    public let imageBuilderSupported: Bool
    /// <p>Describes the errors that are returned when a new image can't be created.</p>
    public let imageErrors: [ResourceError]?
    /// <p>The permissions to provide to the destination AWS account for the specified image.</p>
    public let imagePermissions: ImagePermissions?
    /// <p>The name of the image.</p>
    public let name: String?
    /// <p>The operating system platform of the image.</p>
    public let platform: PlatformType?
    /// <p>The release date of the public base image.
    ///             For private images, this date is the release date of the base image from which the image was created.</p>
    public let publicBaseImageReleasedDate: Date?
    /// <p>The image starts in the <code>PENDING</code> state. If image creation succeeds, the
    ///             state is <code>AVAILABLE</code>. If image creation fails, the state is <code>FAILED</code>.</p>
    public let state: ImageState?
    /// <p>The reason why the last state change occurred.</p>
    public let stateChangeReason: ImageStateChangeReason?
    /// <p>Indicates whether the image is public or private.</p>
    public let visibility: VisibilityType?

    public init (
        applications: [Application]? = nil,
        appstreamAgentVersion: String? = nil,
        arn: String? = nil,
        baseImageArn: String? = nil,
        createdTime: Date? = nil,
        description: String? = nil,
        displayName: String? = nil,
        imageBuilderName: String? = nil,
        imageBuilderSupported: Bool = false,
        imageErrors: [ResourceError]? = nil,
        imagePermissions: ImagePermissions? = nil,
        name: String? = nil,
        platform: PlatformType? = nil,
        publicBaseImageReleasedDate: Date? = nil,
        state: ImageState? = nil,
        stateChangeReason: ImageStateChangeReason? = nil,
        visibility: VisibilityType? = nil
    )
    {
        self.applications = applications
        self.appstreamAgentVersion = appstreamAgentVersion
        self.arn = arn
        self.baseImageArn = baseImageArn
        self.createdTime = createdTime
        self.description = description
        self.displayName = displayName
        self.imageBuilderName = imageBuilderName
        self.imageBuilderSupported = imageBuilderSupported
        self.imageErrors = imageErrors
        self.imagePermissions = imagePermissions
        self.name = name
        self.platform = platform
        self.publicBaseImageReleasedDate = publicBaseImageReleasedDate
        self.state = state
        self.stateChangeReason = stateChangeReason
        self.visibility = visibility
    }
}

extension ImageBuilder: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case imageArn = "ImageArn"
        case imageBuilderErrors = "ImageBuilderErrors"
        case instanceType = "InstanceType"
        case name = "Name"
        case networkAccessConfiguration = "NetworkAccessConfiguration"
        case platform = "Platform"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpointlist0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpointlist0)
            }
        }
        if let appstreamAgentVersion = appstreamAgentVersion {
            try encodeContainer.encode(appstreamAgentVersion, forKey: .appstreamAgentVersion)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageBuilderErrors = imageBuilderErrors {
            var imageBuilderErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageBuilderErrors)
            for resourceerrors0 in imageBuilderErrors {
                try imageBuilderErrorsContainer.encode(resourceerrors0)
            }
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkAccessConfiguration = networkAccessConfiguration {
            try encodeContainer.encode(networkAccessConfiguration, forKey: .networkAccessConfiguration)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImageBuilderState.self, forKey: .state)
        state = stateDecoded
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(ImageBuilderStateChangeReason.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let networkAccessConfigurationDecoded = try containerValues.decodeIfPresent(NetworkAccessConfiguration.self, forKey: .networkAccessConfiguration)
        networkAccessConfiguration = networkAccessConfigurationDecoded
        let imageBuilderErrorsContainer = try containerValues.decodeIfPresent([ResourceError?].self, forKey: .imageBuilderErrors)
        var imageBuilderErrorsDecoded0:[ResourceError]? = nil
        if let imageBuilderErrorsContainer = imageBuilderErrorsContainer {
            imageBuilderErrorsDecoded0 = [ResourceError]()
            for structure0 in imageBuilderErrorsContainer {
                if let structure0 = structure0 {
                    imageBuilderErrorsDecoded0?.append(structure0)
                }
            }
        }
        imageBuilderErrors = imageBuilderErrorsDecoded0
        let appstreamAgentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appstreamAgentVersion)
        appstreamAgentVersion = appstreamAgentVersionDecoded
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
    }
}

extension ImageBuilder: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageBuilder(accessEndpoints: \(String(describing: accessEndpoints)), appstreamAgentVersion: \(String(describing: appstreamAgentVersion)), arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), displayName: \(String(describing: displayName)), domainJoinInfo: \(String(describing: domainJoinInfo)), enableDefaultInternetAccess: \(String(describing: enableDefaultInternetAccess)), iamRoleArn: \(String(describing: iamRoleArn)), imageArn: \(String(describing: imageArn)), imageBuilderErrors: \(String(describing: imageBuilderErrors)), instanceType: \(String(describing: instanceType)), name: \(String(describing: name)), networkAccessConfiguration: \(String(describing: networkAccessConfiguration)), platform: \(String(describing: platform)), state: \(String(describing: state)), stateChangeReason: \(String(describing: stateChangeReason)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Describes a virtual machine that is used to create an image. </p>
public struct ImageBuilder: Equatable {
    /// <p>The list of virtual private cloud (VPC) interface endpoint objects. Administrators can connect to the image builder only through the specified endpoints.</p>
    public let accessEndpoints: [AccessEndpoint]?
    /// <p>The version of the AppStream 2.0 agent that is currently being used by the image builder. </p>
    public let appstreamAgentVersion: String?
    /// <p>The ARN for the image builder.</p>
    public let arn: String?
    /// <p>The time stamp when the image builder was created.</p>
    public let createdTime: Date?
    /// <p>The description to display.</p>
    public let description: String?
    /// <p>The image builder name to display.</p>
    public let displayName: String?
    /// <p>The name of the directory and organizational unit (OU) to use to join the image builder to a Microsoft Active Directory domain. </p>
    public let domainJoinInfo: DomainJoinInfo?
    /// <p>Enables or disables default internet access for the image builder.</p>
    public let enableDefaultInternetAccess: Bool?
    /// <p>The ARN of the IAM role that is applied to the image builder. To assume a role, the image builder calls the AWS Security Token Service (STS) <code>AssumeRole</code> API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the <b>appstream_machine_role</b> credential profile on the instance.</p>
    ///
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html">Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances</a> in the <i>Amazon AppStream 2.0 Administration Guide</i>.</p>
    public let iamRoleArn: String?
    /// <p>The ARN of the image from which this builder was created.</p>
    public let imageArn: String?
    /// <p>The image builder errors.</p>
    public let imageBuilderErrors: [ResourceError]?
    /// <p>The instance type for the image builder. The following instance types are available:</p>
    ///             <ul>
    ///             <li>
    ///                <p>stream.standard.small</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.standard.medium</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.standard.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.3xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.6xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.12xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-desktop.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.12xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.16xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-pro.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-pro.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-pro.16xlarge</p>
    ///             </li>
    ///          </ul>
    public let instanceType: String?
    /// <p>The name of the image builder.</p>
    public let name: String?
    /// <p>Describes the network details of the fleet or image builder instance.</p>
    public let networkAccessConfiguration: NetworkAccessConfiguration?
    /// <p>The operating system platform of the image builder.</p>
    public let platform: PlatformType?
    /// <p>The state of the image builder.</p>
    public let state: ImageBuilderState?
    /// <p>The reason why the last state change occurred.</p>
    public let stateChangeReason: ImageBuilderStateChangeReason?
    /// <p>The VPC configuration of the image builder.</p>
    public let vpcConfig: VpcConfig?

    public init (
        accessEndpoints: [AccessEndpoint]? = nil,
        appstreamAgentVersion: String? = nil,
        arn: String? = nil,
        createdTime: Date? = nil,
        description: String? = nil,
        displayName: String? = nil,
        domainJoinInfo: DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Bool? = nil,
        iamRoleArn: String? = nil,
        imageArn: String? = nil,
        imageBuilderErrors: [ResourceError]? = nil,
        instanceType: String? = nil,
        name: String? = nil,
        networkAccessConfiguration: NetworkAccessConfiguration? = nil,
        platform: PlatformType? = nil,
        state: ImageBuilderState? = nil,
        stateChangeReason: ImageBuilderStateChangeReason? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.appstreamAgentVersion = appstreamAgentVersion
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.iamRoleArn = iamRoleArn
        self.imageArn = imageArn
        self.imageBuilderErrors = imageBuilderErrors
        self.instanceType = instanceType
        self.name = name
        self.networkAccessConfiguration = networkAccessConfiguration
        self.platform = platform
        self.state = state
        self.stateChangeReason = stateChangeReason
        self.vpcConfig = vpcConfig
    }
}

public enum ImageBuilderState {
    case deleting
    case failed
    case pending
    case pendingQualification
    case rebooting
    case running
    case snapshotting
    case stopped
    case stopping
    case updating
    case updatingAgent
    case sdkUnknown(String)
}

extension ImageBuilderState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImageBuilderState] {
        return [
            .deleting,
            .failed,
            .pending,
            .pendingQualification,
            .rebooting,
            .running,
            .snapshotting,
            .stopped,
            .stopping,
            .updating,
            .updatingAgent,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case .pendingQualification: return "PENDING_QUALIFICATION"
        case .rebooting: return "REBOOTING"
        case .running: return "RUNNING"
        case .snapshotting: return "SNAPSHOTTING"
        case .stopped: return "STOPPED"
        case .stopping: return "STOPPING"
        case .updating: return "UPDATING"
        case .updatingAgent: return "UPDATING_AGENT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImageBuilderState(rawValue: rawValue) ?? ImageBuilderState.sdkUnknown(rawValue)
    }
}

extension ImageBuilderStateChangeReason: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ImageBuilderStateChangeReasonCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImageBuilderStateChangeReason: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageBuilderStateChangeReason(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

/// <p>Describes the reason why the last image builder state change occurred.</p>
public struct ImageBuilderStateChangeReason: Equatable {
    /// <p>The state change reason code.</p>
    public let code: ImageBuilderStateChangeReasonCode?
    /// <p>The state change reason message.</p>
    public let message: String?

    public init (
        code: ImageBuilderStateChangeReasonCode? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

public enum ImageBuilderStateChangeReasonCode {
    case imageUnavailable
    case internalError
    case sdkUnknown(String)
}

extension ImageBuilderStateChangeReasonCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImageBuilderStateChangeReasonCode] {
        return [
            .imageUnavailable,
            .internalError,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .imageUnavailable: return "IMAGE_UNAVAILABLE"
        case .internalError: return "INTERNAL_ERROR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImageBuilderStateChangeReasonCode(rawValue: rawValue) ?? ImageBuilderStateChangeReasonCode.sdkUnknown(rawValue)
    }
}

extension ImagePermissions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowFleet
        case allowImageBuilder
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowFleet = allowFleet {
            try encodeContainer.encode(allowFleet, forKey: .allowFleet)
        }
        if let allowImageBuilder = allowImageBuilder {
            try encodeContainer.encode(allowImageBuilder, forKey: .allowImageBuilder)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowFleetDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowFleet)
        allowFleet = allowFleetDecoded
        let allowImageBuilderDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowImageBuilder)
        allowImageBuilder = allowImageBuilderDecoded
    }
}

extension ImagePermissions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImagePermissions(allowFleet: \(String(describing: allowFleet)), allowImageBuilder: \(String(describing: allowImageBuilder)))"}
}

/// <p>Describes the permissions for an image. </p>
public struct ImagePermissions: Equatable {
    /// <p>Indicates whether the image can be used for a fleet.</p>
    public let allowFleet: Bool?
    /// <p>Indicates whether the image can be used for an image builder.</p>
    public let allowImageBuilder: Bool?

    public init (
        allowFleet: Bool? = nil,
        allowImageBuilder: Bool? = nil
    )
    {
        self.allowFleet = allowFleet
        self.allowImageBuilder = allowImageBuilder
    }
}

public enum ImageState {
    case available
    case copying
    case creating
    case deleting
    case failed
    case importing
    case pending
    case sdkUnknown(String)
}

extension ImageState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImageState] {
        return [
            .available,
            .copying,
            .creating,
            .deleting,
            .failed,
            .importing,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .copying: return "COPYING"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .importing: return "IMPORTING"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImageState(rawValue: rawValue) ?? ImageState.sdkUnknown(rawValue)
    }
}

extension ImageStateChangeReason: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ImageStateChangeReasonCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImageStateChangeReason: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageStateChangeReason(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

/// <p>Describes the reason why the last image state change occurred.</p>
public struct ImageStateChangeReason: Equatable {
    /// <p>The state change reason code.</p>
    public let code: ImageStateChangeReasonCode?
    /// <p>The state change reason message.</p>
    public let message: String?

    public init (
        code: ImageStateChangeReasonCode? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

public enum ImageStateChangeReasonCode {
    case imageBuilderNotAvailable
    case imageCopyFailure
    case internalError
    case sdkUnknown(String)
}

extension ImageStateChangeReasonCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImageStateChangeReasonCode] {
        return [
            .imageBuilderNotAvailable,
            .imageCopyFailure,
            .internalError,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .imageBuilderNotAvailable: return "IMAGE_BUILDER_NOT_AVAILABLE"
        case .imageCopyFailure: return "IMAGE_COPY_FAILURE"
        case .internalError: return "INTERNAL_ERROR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImageStateChangeReasonCode(rawValue: rawValue) ?? ImageStateChangeReasonCode.sdkUnknown(rawValue)
    }
}

extension IncompatibleImageException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncompatibleImageException(message: \(String(describing: message)))"}
}

extension IncompatibleImageException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IncompatibleImageExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The image can't be updated because it's not compatible for updates.</p>
public struct IncompatibleImageException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message in the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IncompatibleImageExceptionBody: Equatable {
    public let message: String?
}

extension IncompatibleImageExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAccountStatusException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAccountStatusException(message: \(String(describing: message)))"}
}

extension InvalidAccountStatusException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidAccountStatusExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource cannot be created because your AWS account is suspended. For assistance, contact AWS Support. </p>
public struct InvalidAccountStatusException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message in the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAccountStatusExceptionBody: Equatable {
    public let message: String?
}

extension InvalidAccountStatusExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterCombinationException(message: \(String(describing: message)))"}
}

extension InvalidParameterCombinationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates an incorrect combination of parameters, or a missing parameter.</p>
public struct InvalidParameterCombinationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message in the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterCombinationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRoleException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRoleException(message: \(String(describing: message)))"}
}

extension InvalidRoleException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRoleExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified role is invalid.</p>
public struct InvalidRoleException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message in the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRoleExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRoleExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LastReportGenerationExecutionError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(UsageReportExecutionErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension LastReportGenerationExecutionError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LastReportGenerationExecutionError(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>Describes the error that is returned when a usage report can't be generated.</p>
public struct LastReportGenerationExecutionError: Equatable {
    /// <p>The error code for the error that is returned when a usage report can't be generated.</p>
    public let errorCode: UsageReportExecutionErrorCode?
    /// <p>The error message for the error that is returned when a usage report can't be generated.</p>
    public let errorMessage: String?

    public init (
        errorCode: UsageReportExecutionErrorCode? = nil,
        errorMessage: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested limit exceeds the permitted limit for an account.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message in the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAssociatedFleetsInputBodyMiddleware: Middleware {
    public let id: String = "ListAssociatedFleetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociatedFleetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociatedFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociatedFleetsInput>
    public typealias MOutput = OperationOutput<ListAssociatedFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociatedFleetsOutputError>
}

extension ListAssociatedFleetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociatedFleetsInput(nextToken: \(String(describing: nextToken)), stackName: \(String(describing: stackName)))"}
}

extension ListAssociatedFleetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case stackName = "StackName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

public struct ListAssociatedFleetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssociatedFleetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociatedFleetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociatedFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociatedFleetsInput>
    public typealias MOutput = OperationOutput<ListAssociatedFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociatedFleetsOutputError>
}

public struct ListAssociatedFleetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssociatedFleetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociatedFleetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociatedFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociatedFleetsInput>
    public typealias MOutput = OperationOutput<ListAssociatedFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociatedFleetsOutputError>
}

public struct ListAssociatedFleetsInput: Equatable {
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?
    /// <p>The name of the stack.</p>
    public let stackName: String?

    public init (
        nextToken: String? = nil,
        stackName: String? = nil
    )
    {
        self.nextToken = nextToken
        self.stackName = stackName
    }
}

struct ListAssociatedFleetsInputBody: Equatable {
    public let stackName: String?
    public let nextToken: String?
}

extension ListAssociatedFleetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case stackName = "StackName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedFleetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociatedFleetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociatedFleetsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociatedFleetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociatedFleetsOutputResponse(names: \(String(describing: names)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssociatedFleetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssociatedFleetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.names = output.names
            self.nextToken = output.nextToken
        } else {
            self.names = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedFleetsOutputResponse: Equatable {
    /// <p>The name of the fleet.</p>
    public let names: [String]?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?

    public init (
        names: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

struct ListAssociatedFleetsOutputResponseBody: Equatable {
    public let names: [String]?
    public let nextToken: String?
}

extension ListAssociatedFleetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAssociatedStacksInputBodyMiddleware: Middleware {
    public let id: String = "ListAssociatedStacksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociatedStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociatedStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociatedStacksInput>
    public typealias MOutput = OperationOutput<ListAssociatedStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociatedStacksOutputError>
}

extension ListAssociatedStacksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociatedStacksInput(fleetName: \(String(describing: fleetName)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssociatedStacksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetName = "FleetName"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssociatedStacksInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssociatedStacksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociatedStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociatedStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociatedStacksInput>
    public typealias MOutput = OperationOutput<ListAssociatedStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociatedStacksOutputError>
}

public struct ListAssociatedStacksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssociatedStacksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociatedStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociatedStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociatedStacksInput>
    public typealias MOutput = OperationOutput<ListAssociatedStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociatedStacksOutputError>
}

public struct ListAssociatedStacksInput: Equatable {
    /// <p>The name of the fleet.</p>
    public let fleetName: String?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?

    public init (
        fleetName: String? = nil,
        nextToken: String? = nil
    )
    {
        self.fleetName = fleetName
        self.nextToken = nextToken
    }
}

struct ListAssociatedStacksInputBody: Equatable {
    public let fleetName: String?
    public let nextToken: String?
}

extension ListAssociatedStacksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetName = "FleetName"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedStacksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociatedStacksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociatedStacksOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociatedStacksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociatedStacksOutputResponse(names: \(String(describing: names)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssociatedStacksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssociatedStacksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.names = output.names
            self.nextToken = output.nextToken
        } else {
            self.names = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedStacksOutputResponse: Equatable {
    /// <p>The name of the stack.</p>
    public let names: [String]?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.</p>
    public let nextToken: String?

    public init (
        names: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

struct ListAssociatedStacksOutputResponseBody: Equatable {
    public let names: [String]?
    public let nextToken: String?
}

extension ListAssociatedStacksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The information about the tags.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum MessageAction {
    case resend
    case suppress
    case sdkUnknown(String)
}

extension MessageAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MessageAction] {
        return [
            .resend,
            .suppress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .resend: return "RESEND"
        case .suppress: return "SUPPRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MessageAction(rawValue: rawValue) ?? MessageAction.sdkUnknown(rawValue)
    }
}

extension NetworkAccessConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eniId = "EniId"
        case eniPrivateIpAddress = "EniPrivateIpAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eniId = eniId {
            try encodeContainer.encode(eniId, forKey: .eniId)
        }
        if let eniPrivateIpAddress = eniPrivateIpAddress {
            try encodeContainer.encode(eniPrivateIpAddress, forKey: .eniPrivateIpAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eniPrivateIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eniPrivateIpAddress)
        eniPrivateIpAddress = eniPrivateIpAddressDecoded
        let eniIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eniId)
        eniId = eniIdDecoded
    }
}

extension NetworkAccessConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkAccessConfiguration(eniId: \(String(describing: eniId)), eniPrivateIpAddress: \(String(describing: eniPrivateIpAddress)))"}
}

/// <p>Describes the network details of the fleet or image builder instance.</p>
public struct NetworkAccessConfiguration: Equatable {
    /// <p>The resource identifier of the elastic network interface that is attached to instances in your VPC. All network interfaces have the eni-xxxxxxxx resource identifier.</p>
    public let eniId: String?
    /// <p>The private IP address of the elastic network interface that is attached to instances in your VPC.</p>
    public let eniPrivateIpAddress: String?

    public init (
        eniId: String? = nil,
        eniPrivateIpAddress: String? = nil
    )
    {
        self.eniId = eniId
        self.eniPrivateIpAddress = eniPrivateIpAddress
    }
}

extension OperationNotPermittedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationNotPermittedException(message: \(String(describing: message)))"}
}

extension OperationNotPermittedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The attempted operation is not permitted.</p>
public struct OperationNotPermittedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message in the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Equatable {
    public let message: String?
}

extension OperationNotPermittedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Permission {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension Permission : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Permission] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
    }
}

public enum PlatformType {
    case windows
    case windowsServer2016
    case windowsServer2019
    case sdkUnknown(String)
}

extension PlatformType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PlatformType] {
        return [
            .windows,
            .windowsServer2016,
            .windowsServer2019,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .windows: return "WINDOWS"
        case .windowsServer2016: return "WINDOWS_SERVER_2016"
        case .windowsServer2019: return "WINDOWS_SERVER_2019"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PlatformType(rawValue: rawValue) ?? PlatformType.sdkUnknown(rawValue)
    }
}

extension RequestLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestLimitExceededException(message: \(String(describing: message)))"}
}

extension RequestLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RequestLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AppStream 2.0 can’t process the request right now because the Describe calls from your AWS account are being throttled by Amazon EC2. Try again later.</p>
public struct RequestLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message in the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RequestLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension RequestLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message in the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case errorTimestamp = "ErrorTimestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorTimestamp = errorTimestamp {
            try encodeContainer.encode(errorTimestamp.timeIntervalSince1970, forKey: .errorTimestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(FleetErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .errorTimestamp)
        errorTimestamp = errorTimestampDecoded
    }
}

extension ResourceError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceError(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), errorTimestamp: \(String(describing: errorTimestamp)))"}
}

/// <p>Describes a resource error.</p>
public struct ResourceError: Equatable {
    /// <p>The error code.</p>
    public let errorCode: FleetErrorCode?
    /// <p>The error message.</p>
    public let errorMessage: String?
    /// <p>The time the error occurred.</p>
    public let errorTimestamp: Date?

    public init (
        errorCode: FleetErrorCode? = nil,
        errorMessage: String? = nil,
        errorTimestamp: Date? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.errorTimestamp = errorTimestamp
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource is in use.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message in the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotAvailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotAvailableException(message: \(String(describing: message)))"}
}

extension ResourceNotAvailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotAvailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource exists and is not in use, but isn't available.</p>
public struct ResourceNotAvailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message in the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotAvailableExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotAvailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message in the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceAccountCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountName = "AccountName"
        case accountPassword = "AccountPassword"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountName = accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let accountPassword = accountPassword {
            try encodeContainer.encode(accountPassword, forKey: .accountPassword)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let accountPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountPassword)
        accountPassword = accountPasswordDecoded
    }
}

extension ServiceAccountCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceAccountCredentials(accountName: \(String(describing: accountName)), accountPassword: \(String(describing: accountPassword)))"}
}

/// <p>Describes the credentials for the service account used by the fleet or image builder to connect to the directory.</p>
public struct ServiceAccountCredentials: Equatable {
    /// <p>The user name of the account. This account must have the following privileges: create computer objects,
    ///             join computers to the domain, and change/reset the password on descendant computer objects for the
    ///             organizational units specified.</p>
    public let accountName: String?
    /// <p>The password for the account.</p>
    public let accountPassword: String?

    public init (
        accountName: String? = nil,
        accountPassword: String? = nil
    )
    {
        self.accountName = accountName
        self.accountPassword = accountPassword
    }
}

extension Session: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case connectionState = "ConnectionState"
        case fleetName = "FleetName"
        case id = "Id"
        case maxExpirationTime = "MaxExpirationTime"
        case networkAccessConfiguration = "NetworkAccessConfiguration"
        case stackName = "StackName"
        case startTime = "StartTime"
        case state = "State"
        case userId = "UserId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let connectionState = connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxExpirationTime = maxExpirationTime {
            try encodeContainer.encode(maxExpirationTime.timeIntervalSince1970, forKey: .maxExpirationTime)
        }
        if let networkAccessConfiguration = networkAccessConfiguration {
            try encodeContainer.encode(networkAccessConfiguration, forKey: .networkAccessConfiguration)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SessionState.self, forKey: .state)
        state = stateDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(SessionConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let maxExpirationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .maxExpirationTime)
        maxExpirationTime = maxExpirationTimeDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let networkAccessConfigurationDecoded = try containerValues.decodeIfPresent(NetworkAccessConfiguration.self, forKey: .networkAccessConfiguration)
        networkAccessConfiguration = networkAccessConfigurationDecoded
    }
}

extension Session: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Session(authenticationType: \(String(describing: authenticationType)), connectionState: \(String(describing: connectionState)), fleetName: \(String(describing: fleetName)), id: \(String(describing: id)), maxExpirationTime: \(String(describing: maxExpirationTime)), networkAccessConfiguration: \(String(describing: networkAccessConfiguration)), stackName: \(String(describing: stackName)), startTime: \(String(describing: startTime)), state: \(String(describing: state)), userId: \(String(describing: userId)))"}
}

/// <p>Describes a streaming session.</p>
public struct Session: Equatable {
    /// <p>The authentication method. The user is authenticated using a streaming URL
    ///             (<code>API</code>) or SAML 2.0 federation (<code>SAML</code>).</p>
    public let authenticationType: AuthenticationType?
    /// <p>Specifies whether a user is connected to the streaming session.</p>
    public let connectionState: SessionConnectionState?
    /// <p>The name of the fleet for the streaming session.</p>
    public let fleetName: String?
    /// <p>The identifier of the streaming session.</p>
    public let id: String?
    /// <p>The time when the streaming session is set to expire. This time is based on the <code>MaxUserDurationinSeconds</code> value, which determines the maximum length of time that a streaming session can run. A streaming session might end earlier than the time specified in <code>SessionMaxExpirationTime</code>, when the <code>DisconnectTimeOutInSeconds</code> elapses or the user chooses to end his or her session. If the <code>DisconnectTimeOutInSeconds</code> elapses, or the user chooses to end his or her session, the streaming instance is terminated and the streaming session ends.</p>
    public let maxExpirationTime: Date?
    /// <p>The network details for the streaming session.</p>
    public let networkAccessConfiguration: NetworkAccessConfiguration?
    /// <p>The name of the stack for the streaming session.</p>
    public let stackName: String?
    /// <p>The time when a streaming instance is dedicated for the user.</p>
    public let startTime: Date?
    /// <p>The current state of the streaming session.</p>
    public let state: SessionState?
    /// <p>The identifier of the user for whom the session was created.</p>
    public let userId: String?

    public init (
        authenticationType: AuthenticationType? = nil,
        connectionState: SessionConnectionState? = nil,
        fleetName: String? = nil,
        id: String? = nil,
        maxExpirationTime: Date? = nil,
        networkAccessConfiguration: NetworkAccessConfiguration? = nil,
        stackName: String? = nil,
        startTime: Date? = nil,
        state: SessionState? = nil,
        userId: String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.connectionState = connectionState
        self.fleetName = fleetName
        self.id = id
        self.maxExpirationTime = maxExpirationTime
        self.networkAccessConfiguration = networkAccessConfiguration
        self.stackName = stackName
        self.startTime = startTime
        self.state = state
        self.userId = userId
    }
}

public enum SessionConnectionState {
    case connected
    case notConnected
    case sdkUnknown(String)
}

extension SessionConnectionState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SessionConnectionState] {
        return [
            .connected,
            .notConnected,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .connected: return "CONNECTED"
        case .notConnected: return "NOT_CONNECTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SessionConnectionState(rawValue: rawValue) ?? SessionConnectionState.sdkUnknown(rawValue)
    }
}

/// <p>Possible values for the state of a streaming session.</p>
public enum SessionState {
    case active
    case expired
    case pending
    case sdkUnknown(String)
}

extension SessionState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SessionState] {
        return [
            .active,
            .expired,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .expired: return "EXPIRED"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SessionState(rawValue: rawValue) ?? SessionState.sdkUnknown(rawValue)
    }
}

extension SharedImagePermissions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imagePermissions
        case sharedAccountId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imagePermissions = imagePermissions {
            try encodeContainer.encode(imagePermissions, forKey: .imagePermissions)
        }
        if let sharedAccountId = sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
        let imagePermissionsDecoded = try containerValues.decodeIfPresent(ImagePermissions.self, forKey: .imagePermissions)
        imagePermissions = imagePermissionsDecoded
    }
}

extension SharedImagePermissions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SharedImagePermissions(imagePermissions: \(String(describing: imagePermissions)), sharedAccountId: \(String(describing: sharedAccountId)))"}
}

/// <p>Describes the permissions that are available to the specified AWS account for a shared image.</p>
public struct SharedImagePermissions: Equatable {
    /// <p>Describes the permissions for a shared image.</p>
    public let imagePermissions: ImagePermissions?
    /// <p>The 12-digit identifier of the AWS account with which the image is shared.</p>
    public let sharedAccountId: String?

    public init (
        imagePermissions: ImagePermissions? = nil,
        sharedAccountId: String? = nil
    )
    {
        self.imagePermissions = imagePermissions
        self.sharedAccountId = sharedAccountId
    }
}

extension Stack: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case stackErrors = "StackErrors"
        case storageConnectors = "StorageConnectors"
        case userSettings = "UserSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpointlist0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpointlist0)
            }
        }
        if let applicationSettings = applicationSettings {
            try encodeContainer.encode(applicationSettings, forKey: .applicationSettings)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let embedHostDomains = embedHostDomains {
            var embedHostDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .embedHostDomains)
            for embedhostdomains0 in embedHostDomains {
                try embedHostDomainsContainer.encode(embedhostdomains0)
            }
        }
        if let feedbackURL = feedbackURL {
            try encodeContainer.encode(feedbackURL, forKey: .feedbackURL)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let redirectURL = redirectURL {
            try encodeContainer.encode(redirectURL, forKey: .redirectURL)
        }
        if let stackErrors = stackErrors {
            var stackErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackErrors)
            for stackerrors0 in stackErrors {
                try stackErrorsContainer.encode(stackerrors0)
            }
        }
        if let storageConnectors = storageConnectors {
            var storageConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .storageConnectors)
            for storageconnectorlist0 in storageConnectors {
                try storageConnectorsContainer.encode(storageconnectorlist0)
            }
        }
        if let userSettings = userSettings {
            var userSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userSettings)
            for usersettinglist0 in userSettings {
                try userSettingsContainer.encode(usersettinglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let storageConnectorsContainer = try containerValues.decodeIfPresent([StorageConnector?].self, forKey: .storageConnectors)
        var storageConnectorsDecoded0:[StorageConnector]? = nil
        if let storageConnectorsContainer = storageConnectorsContainer {
            storageConnectorsDecoded0 = [StorageConnector]()
            for structure0 in storageConnectorsContainer {
                if let structure0 = structure0 {
                    storageConnectorsDecoded0?.append(structure0)
                }
            }
        }
        storageConnectors = storageConnectorsDecoded0
        let redirectURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .redirectURL)
        redirectURL = redirectURLDecoded
        let feedbackURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .feedbackURL)
        feedbackURL = feedbackURLDecoded
        let stackErrorsContainer = try containerValues.decodeIfPresent([StackError?].self, forKey: .stackErrors)
        var stackErrorsDecoded0:[StackError]? = nil
        if let stackErrorsContainer = stackErrorsContainer {
            stackErrorsDecoded0 = [StackError]()
            for structure0 in stackErrorsContainer {
                if let structure0 = structure0 {
                    stackErrorsDecoded0?.append(structure0)
                }
            }
        }
        stackErrors = stackErrorsDecoded0
        let userSettingsContainer = try containerValues.decodeIfPresent([UserSetting?].self, forKey: .userSettings)
        var userSettingsDecoded0:[UserSetting]? = nil
        if let userSettingsContainer = userSettingsContainer {
            userSettingsDecoded0 = [UserSetting]()
            for structure0 in userSettingsContainer {
                if let structure0 = structure0 {
                    userSettingsDecoded0?.append(structure0)
                }
            }
        }
        userSettings = userSettingsDecoded0
        let applicationSettingsDecoded = try containerValues.decodeIfPresent(ApplicationSettingsResponse.self, forKey: .applicationSettings)
        applicationSettings = applicationSettingsDecoded
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
        let embedHostDomainsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .embedHostDomains)
        var embedHostDomainsDecoded0:[String]? = nil
        if let embedHostDomainsContainer = embedHostDomainsContainer {
            embedHostDomainsDecoded0 = [String]()
            for string0 in embedHostDomainsContainer {
                if let string0 = string0 {
                    embedHostDomainsDecoded0?.append(string0)
                }
            }
        }
        embedHostDomains = embedHostDomainsDecoded0
    }
}

extension Stack: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Stack(accessEndpoints: \(String(describing: accessEndpoints)), applicationSettings: \(String(describing: applicationSettings)), arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), displayName: \(String(describing: displayName)), embedHostDomains: \(String(describing: embedHostDomains)), feedbackURL: \(String(describing: feedbackURL)), name: \(String(describing: name)), redirectURL: \(String(describing: redirectURL)), stackErrors: \(String(describing: stackErrors)), storageConnectors: \(String(describing: storageConnectors)), userSettings: \(String(describing: userSettings)))"}
}

/// <p>Describes a stack.</p>
public struct Stack: Equatable {
    /// <p>The list of virtual private cloud (VPC) interface endpoint objects. Users of the stack can connect to AppStream 2.0 only through the specified endpoints. </p>
    public let accessEndpoints: [AccessEndpoint]?
    /// <p>The persistent application settings for users of the stack.</p>
    public let applicationSettings: ApplicationSettingsResponse?
    /// <p>The ARN of the stack.</p>
    public let arn: String?
    /// <p>The time the stack was created.</p>
    public let createdTime: Date?
    /// <p>The description to display.</p>
    public let description: String?
    /// <p>The stack name to display.</p>
    public let displayName: String?
    /// <p>The domains where AppStream 2.0 streaming sessions can be embedded in an iframe. You must approve the domains that you want to host embedded AppStream 2.0 streaming sessions.</p>
    public let embedHostDomains: [String]?
    /// <p>The URL that users are redirected to after they click the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.</p>
    public let feedbackURL: String?
    /// <p>The name of the stack.</p>
    public let name: String?
    /// <p>The URL that users are redirected to after their streaming session ends.</p>
    public let redirectURL: String?
    /// <p>The errors for the stack.</p>
    public let stackErrors: [StackError]?
    /// <p>The storage connectors to enable.</p>
    public let storageConnectors: [StorageConnector]?
    /// <p>The actions that are enabled or disabled for users during their streaming sessions. By default these actions are enabled.</p>
    public let userSettings: [UserSetting]?

    public init (
        accessEndpoints: [AccessEndpoint]? = nil,
        applicationSettings: ApplicationSettingsResponse? = nil,
        arn: String? = nil,
        createdTime: Date? = nil,
        description: String? = nil,
        displayName: String? = nil,
        embedHostDomains: [String]? = nil,
        feedbackURL: String? = nil,
        name: String? = nil,
        redirectURL: String? = nil,
        stackErrors: [StackError]? = nil,
        storageConnectors: [StorageConnector]? = nil,
        userSettings: [UserSetting]? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.applicationSettings = applicationSettings
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.displayName = displayName
        self.embedHostDomains = embedHostDomains
        self.feedbackURL = feedbackURL
        self.name = name
        self.redirectURL = redirectURL
        self.stackErrors = stackErrors
        self.storageConnectors = storageConnectors
        self.userSettings = userSettings
    }
}

public enum StackAttribute {
    case accessEndpoints
    case embedHostDomains
    case feedbackUrl
    case iamRoleArn
    case redirectUrl
    case storageConnectors
    case storageConnectorGoogleDrive
    case storageConnectorHomefolders
    case storageConnectorOneDrive
    case themeName
    case userSettings
    case sdkUnknown(String)
}

extension StackAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackAttribute] {
        return [
            .accessEndpoints,
            .embedHostDomains,
            .feedbackUrl,
            .iamRoleArn,
            .redirectUrl,
            .storageConnectors,
            .storageConnectorGoogleDrive,
            .storageConnectorHomefolders,
            .storageConnectorOneDrive,
            .themeName,
            .userSettings,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessEndpoints: return "ACCESS_ENDPOINTS"
        case .embedHostDomains: return "EMBED_HOST_DOMAINS"
        case .feedbackUrl: return "FEEDBACK_URL"
        case .iamRoleArn: return "IAM_ROLE_ARN"
        case .redirectUrl: return "REDIRECT_URL"
        case .storageConnectors: return "STORAGE_CONNECTORS"
        case .storageConnectorGoogleDrive: return "STORAGE_CONNECTOR_GOOGLE_DRIVE"
        case .storageConnectorHomefolders: return "STORAGE_CONNECTOR_HOMEFOLDERS"
        case .storageConnectorOneDrive: return "STORAGE_CONNECTOR_ONE_DRIVE"
        case .themeName: return "THEME_NAME"
        case .userSettings: return "USER_SETTINGS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackAttribute(rawValue: rawValue) ?? StackAttribute.sdkUnknown(rawValue)
    }
}

extension StackError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(StackErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension StackError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackError(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>Describes a stack error.</p>
public struct StackError: Equatable {
    /// <p>The error code.</p>
    public let errorCode: StackErrorCode?
    /// <p>The error message.</p>
    public let errorMessage: String?

    public init (
        errorCode: StackErrorCode? = nil,
        errorMessage: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }
}

public enum StackErrorCode {
    case internalServiceError
    case storageConnectorError
    case sdkUnknown(String)
}

extension StackErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackErrorCode] {
        return [
            .internalServiceError,
            .storageConnectorError,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
        case .storageConnectorError: return "STORAGE_CONNECTOR_ERROR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackErrorCode(rawValue: rawValue) ?? StackErrorCode.sdkUnknown(rawValue)
    }
}

public struct StartFleetInputBodyMiddleware: Middleware {
    public let id: String = "StartFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<StartFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartFleetInput>
    public typealias MOutput = OperationOutput<StartFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartFleetOutputError>
}

extension StartFleetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartFleetInput(name: \(String(describing: name)))"}
}

extension StartFleetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StartFleetInputHeadersMiddleware: Middleware {
    public let id: String = "StartFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<StartFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartFleetInput>
    public typealias MOutput = OperationOutput<StartFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartFleetOutputError>
}

public struct StartFleetInputQueryItemMiddleware: Middleware {
    public let id: String = "StartFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<StartFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartFleetInput>
    public typealias MOutput = OperationOutput<StartFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartFleetOutputError>
}

public struct StartFleetInput: Equatable {
    /// <p>The name of the fleet.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct StartFleetInputBody: Equatable {
    public let name: String?
}

extension StartFleetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StartFleetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFleetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestLimitExceededException" : self = .requestLimitExceededException(try RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFleetOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case requestLimitExceededException(RequestLimitExceededException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFleetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartFleetOutputResponse()"}
}

extension StartFleetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartFleetOutputResponse: Equatable {

    public init() {}
}

struct StartFleetOutputResponseBody: Equatable {
}

extension StartFleetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StartImageBuilderInputBodyMiddleware: Middleware {
    public let id: String = "StartImageBuilderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImageBuilderInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImageBuilderInput>
    public typealias MOutput = OperationOutput<StartImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImageBuilderOutputError>
}

extension StartImageBuilderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartImageBuilderInput(appstreamAgentVersion: \(String(describing: appstreamAgentVersion)), name: \(String(describing: name)))"}
}

extension StartImageBuilderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appstreamAgentVersion = appstreamAgentVersion {
            try encodeContainer.encode(appstreamAgentVersion, forKey: .appstreamAgentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StartImageBuilderInputHeadersMiddleware: Middleware {
    public let id: String = "StartImageBuilderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImageBuilderInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImageBuilderInput>
    public typealias MOutput = OperationOutput<StartImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImageBuilderOutputError>
}

public struct StartImageBuilderInputQueryItemMiddleware: Middleware {
    public let id: String = "StartImageBuilderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImageBuilderInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImageBuilderInput>
    public typealias MOutput = OperationOutput<StartImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImageBuilderOutputError>
}

public struct StartImageBuilderInput: Equatable {
    /// <p>The version of the AppStream 2.0 agent to use for this image builder. To use the latest version of the AppStream 2.0 agent, specify [LATEST]. </p>
    public let appstreamAgentVersion: String?
    /// <p>The name of the image builder.</p>
    public let name: String?

    public init (
        appstreamAgentVersion: String? = nil,
        name: String? = nil
    )
    {
        self.appstreamAgentVersion = appstreamAgentVersion
        self.name = name
    }
}

struct StartImageBuilderInputBody: Equatable {
    public let name: String?
    public let appstreamAgentVersion: String?
}

extension StartImageBuilderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let appstreamAgentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appstreamAgentVersion)
        appstreamAgentVersion = appstreamAgentVersionDecoded
    }
}

extension StartImageBuilderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartImageBuilderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartImageBuilderOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartImageBuilderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartImageBuilderOutputResponse(imageBuilder: \(String(describing: imageBuilder)))"}
}

extension StartImageBuilderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartImageBuilderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageBuilder = output.imageBuilder
        } else {
            self.imageBuilder = nil
        }
    }
}

public struct StartImageBuilderOutputResponse: Equatable {
    /// <p>Information about the image builder.</p>
    public let imageBuilder: ImageBuilder?

    public init (
        imageBuilder: ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

struct StartImageBuilderOutputResponseBody: Equatable {
    public let imageBuilder: ImageBuilder?
}

extension StartImageBuilderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageBuilder = "ImageBuilder"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuilderDecoded = try containerValues.decodeIfPresent(ImageBuilder.self, forKey: .imageBuilder)
        imageBuilder = imageBuilderDecoded
    }
}

public struct StopFleetInputBodyMiddleware: Middleware {
    public let id: String = "StopFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<StopFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopFleetInput>
    public typealias MOutput = OperationOutput<StopFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopFleetOutputError>
}

extension StopFleetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopFleetInput(name: \(String(describing: name)))"}
}

extension StopFleetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StopFleetInputHeadersMiddleware: Middleware {
    public let id: String = "StopFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<StopFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopFleetInput>
    public typealias MOutput = OperationOutput<StopFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopFleetOutputError>
}

public struct StopFleetInputQueryItemMiddleware: Middleware {
    public let id: String = "StopFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<StopFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopFleetInput>
    public typealias MOutput = OperationOutput<StopFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopFleetOutputError>
}

public struct StopFleetInput: Equatable {
    /// <p>The name of the fleet.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct StopFleetInputBody: Equatable {
    public let name: String?
}

extension StopFleetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StopFleetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopFleetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopFleetOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopFleetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopFleetOutputResponse()"}
}

extension StopFleetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopFleetOutputResponse: Equatable {

    public init() {}
}

struct StopFleetOutputResponseBody: Equatable {
}

extension StopFleetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StopImageBuilderInputBodyMiddleware: Middleware {
    public let id: String = "StopImageBuilderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopImageBuilderInput>,
                  next: H) -> Swift.Result<OperationOutput<StopImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopImageBuilderInput>
    public typealias MOutput = OperationOutput<StopImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopImageBuilderOutputError>
}

extension StopImageBuilderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopImageBuilderInput(name: \(String(describing: name)))"}
}

extension StopImageBuilderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StopImageBuilderInputHeadersMiddleware: Middleware {
    public let id: String = "StopImageBuilderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopImageBuilderInput>,
                  next: H) -> Swift.Result<OperationOutput<StopImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopImageBuilderInput>
    public typealias MOutput = OperationOutput<StopImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopImageBuilderOutputError>
}

public struct StopImageBuilderInputQueryItemMiddleware: Middleware {
    public let id: String = "StopImageBuilderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopImageBuilderInput>,
                  next: H) -> Swift.Result<OperationOutput<StopImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopImageBuilderInput>
    public typealias MOutput = OperationOutput<StopImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopImageBuilderOutputError>
}

public struct StopImageBuilderInput: Equatable {
    /// <p>The name of the image builder.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct StopImageBuilderInputBody: Equatable {
    public let name: String?
}

extension StopImageBuilderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StopImageBuilderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopImageBuilderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopImageBuilderOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopImageBuilderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopImageBuilderOutputResponse(imageBuilder: \(String(describing: imageBuilder)))"}
}

extension StopImageBuilderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopImageBuilderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageBuilder = output.imageBuilder
        } else {
            self.imageBuilder = nil
        }
    }
}

public struct StopImageBuilderOutputResponse: Equatable {
    /// <p>Information about the image builder.</p>
    public let imageBuilder: ImageBuilder?

    public init (
        imageBuilder: ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

struct StopImageBuilderOutputResponseBody: Equatable {
    public let imageBuilder: ImageBuilder?
}

extension StopImageBuilderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageBuilder = "ImageBuilder"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuilderDecoded = try containerValues.decodeIfPresent(ImageBuilder.self, forKey: .imageBuilder)
        imageBuilder = imageBuilderDecoded
    }
}

extension StorageConnector: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectorType = "ConnectorType"
        case domains = "Domains"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for domainlist0 in domains {
                try domainsContainer.encode(domainlist0)
            }
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypeDecoded = try containerValues.decodeIfPresent(StorageConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let domainsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .domains)
        var domainsDecoded0:[String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
    }
}

extension StorageConnector: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageConnector(connectorType: \(String(describing: connectorType)), domains: \(String(describing: domains)), resourceIdentifier: \(String(describing: resourceIdentifier)))"}
}

/// <p>Describes a connector that enables persistent storage for users.</p>
public struct StorageConnector: Equatable {
    /// <p>The type of storage connector.</p>
    public let connectorType: StorageConnectorType?
    /// <p>The names of the domains for the account.</p>
    public let domains: [String]?
    /// <p>The ARN of the storage connector.</p>
    public let resourceIdentifier: String?

    public init (
        connectorType: StorageConnectorType? = nil,
        domains: [String]? = nil,
        resourceIdentifier: String? = nil
    )
    {
        self.connectorType = connectorType
        self.domains = domains
        self.resourceIdentifier = resourceIdentifier
    }
}

/// <p>The type of storage connector.</p>
public enum StorageConnectorType {
    case googleDrive
    case homefolders
    case oneDrive
    case sdkUnknown(String)
}

extension StorageConnectorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StorageConnectorType] {
        return [
            .googleDrive,
            .homefolders,
            .oneDrive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .googleDrive: return "GOOGLE_DRIVE"
        case .homefolders: return "HOMEFOLDERS"
        case .oneDrive: return "ONE_DRIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StorageConnectorType(rawValue: rawValue) ?? StorageConnectorType.sdkUnknown(rawValue)
    }
}

public enum StreamView {
    case app
    case desktop
    case sdkUnknown(String)
}

extension StreamView : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamView] {
        return [
            .app,
            .desktop,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .app: return "APP"
        case .desktop: return "DESKTOP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamView(rawValue: rawValue) ?? StreamView.sdkUnknown(rawValue)
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>The tags to associate. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. </p>
    ///
    ///         <p>If you do not specify a value, the value is set to an empty string.</p>
    ///
    ///         <p>Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: </p>
    ///         <p>_ . : / = + \ - @</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>The tag keys for the tags to disassociate.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDirectoryConfigInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDirectoryConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDirectoryConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDirectoryConfigInput>
    public typealias MOutput = OperationOutput<UpdateDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDirectoryConfigOutputError>
}

extension UpdateDirectoryConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDirectoryConfigInput(directoryName: \(String(describing: directoryName)), organizationalUnitDistinguishedNames: \(String(describing: organizationalUnitDistinguishedNames)), serviceAccountCredentials: \(String(describing: serviceAccountCredentials)))"}
}

extension UpdateDirectoryConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames {
            var organizationalUnitDistinguishedNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitDistinguishedNames)
            for organizationalunitdistinguishednameslist0 in organizationalUnitDistinguishedNames {
                try organizationalUnitDistinguishedNamesContainer.encode(organizationalunitdistinguishednameslist0)
            }
        }
        if let serviceAccountCredentials = serviceAccountCredentials {
            try encodeContainer.encode(serviceAccountCredentials, forKey: .serviceAccountCredentials)
        }
    }
}

public struct UpdateDirectoryConfigInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDirectoryConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDirectoryConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDirectoryConfigInput>
    public typealias MOutput = OperationOutput<UpdateDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDirectoryConfigOutputError>
}

public struct UpdateDirectoryConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDirectoryConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDirectoryConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDirectoryConfigInput>
    public typealias MOutput = OperationOutput<UpdateDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDirectoryConfigOutputError>
}

public struct UpdateDirectoryConfigInput: Equatable {
    /// <p>The name of the Directory Config object.</p>
    public let directoryName: String?
    /// <p>The distinguished names of the organizational units for computer accounts.</p>
    public let organizationalUnitDistinguishedNames: [String]?
    /// <p>The credentials for the service account used by the fleet or image builder to connect to the directory.</p>
    public let serviceAccountCredentials: ServiceAccountCredentials?

    public init (
        directoryName: String? = nil,
        organizationalUnitDistinguishedNames: [String]? = nil,
        serviceAccountCredentials: ServiceAccountCredentials? = nil
    )
    {
        self.directoryName = directoryName
        self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
        self.serviceAccountCredentials = serviceAccountCredentials
    }
}

struct UpdateDirectoryConfigInputBody: Equatable {
    public let directoryName: String?
    public let organizationalUnitDistinguishedNames: [String]?
    public let serviceAccountCredentials: ServiceAccountCredentials?
}

extension UpdateDirectoryConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let organizationalUnitDistinguishedNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .organizationalUnitDistinguishedNames)
        var organizationalUnitDistinguishedNamesDecoded0:[String]? = nil
        if let organizationalUnitDistinguishedNamesContainer = organizationalUnitDistinguishedNamesContainer {
            organizationalUnitDistinguishedNamesDecoded0 = [String]()
            for string0 in organizationalUnitDistinguishedNamesContainer {
                if let string0 = string0 {
                    organizationalUnitDistinguishedNamesDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNamesDecoded0
        let serviceAccountCredentialsDecoded = try containerValues.decodeIfPresent(ServiceAccountCredentials.self, forKey: .serviceAccountCredentials)
        serviceAccountCredentials = serviceAccountCredentialsDecoded
    }
}

extension UpdateDirectoryConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDirectoryConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDirectoryConfigOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidRoleException(InvalidRoleException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDirectoryConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDirectoryConfigOutputResponse(directoryConfig: \(String(describing: directoryConfig)))"}
}

extension UpdateDirectoryConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDirectoryConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.directoryConfig = output.directoryConfig
        } else {
            self.directoryConfig = nil
        }
    }
}

public struct UpdateDirectoryConfigOutputResponse: Equatable {
    /// <p>Information about the Directory Config object.</p>
    public let directoryConfig: DirectoryConfig?

    public init (
        directoryConfig: DirectoryConfig? = nil
    )
    {
        self.directoryConfig = directoryConfig
    }
}

struct UpdateDirectoryConfigOutputResponseBody: Equatable {
    public let directoryConfig: DirectoryConfig?
}

extension UpdateDirectoryConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case directoryConfig = "DirectoryConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryConfigDecoded = try containerValues.decodeIfPresent(DirectoryConfig.self, forKey: .directoryConfig)
        directoryConfig = directoryConfigDecoded
    }
}

public struct UpdateFleetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFleetInput>
    public typealias MOutput = OperationOutput<UpdateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFleetOutputError>
}

extension UpdateFleetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFleetInput(attributesToDelete: \(String(describing: attributesToDelete)), computeCapacity: \(String(describing: computeCapacity)), deleteVpcConfig: \(String(describing: deleteVpcConfig)), description: \(String(describing: description)), disconnectTimeoutInSeconds: \(String(describing: disconnectTimeoutInSeconds)), displayName: \(String(describing: displayName)), domainJoinInfo: \(String(describing: domainJoinInfo)), enableDefaultInternetAccess: \(String(describing: enableDefaultInternetAccess)), iamRoleArn: \(String(describing: iamRoleArn)), idleDisconnectTimeoutInSeconds: \(String(describing: idleDisconnectTimeoutInSeconds)), imageArn: \(String(describing: imageArn)), imageName: \(String(describing: imageName)), instanceType: \(String(describing: instanceType)), maxUserDurationInSeconds: \(String(describing: maxUserDurationInSeconds)), name: \(String(describing: name)), streamView: \(String(describing: streamView)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension UpdateFleetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributesToDelete = "AttributesToDelete"
        case computeCapacity = "ComputeCapacity"
        case deleteVpcConfig = "DeleteVpcConfig"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case streamView = "StreamView"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributesToDelete = attributesToDelete {
            var attributesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributesToDelete)
            for fleetattributes0 in attributesToDelete {
                try attributesToDeleteContainer.encode(fleetattributes0.rawValue)
            }
        }
        if let computeCapacity = computeCapacity {
            try encodeContainer.encode(computeCapacity, forKey: .computeCapacity)
        }
        if deleteVpcConfig != false {
            try encodeContainer.encode(deleteVpcConfig, forKey: .deleteVpcConfig)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disconnectTimeoutInSeconds = disconnectTimeoutInSeconds {
            try encodeContainer.encode(disconnectTimeoutInSeconds, forKey: .disconnectTimeoutInSeconds)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds {
            try encodeContainer.encode(idleDisconnectTimeoutInSeconds, forKey: .idleDisconnectTimeoutInSeconds)
        }
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageName = imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let maxUserDurationInSeconds = maxUserDurationInSeconds {
            try encodeContainer.encode(maxUserDurationInSeconds, forKey: .maxUserDurationInSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamView = streamView {
            try encodeContainer.encode(streamView.rawValue, forKey: .streamView)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct UpdateFleetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFleetInput>
    public typealias MOutput = OperationOutput<UpdateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFleetOutputError>
}

public struct UpdateFleetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFleetInput>
    public typealias MOutput = OperationOutput<UpdateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFleetOutputError>
}

public struct UpdateFleetInput: Equatable {
    /// <p>The fleet attributes to delete.</p>
    public let attributesToDelete: [FleetAttribute]?
    /// <p>The desired capacity for the fleet.</p>
    public let computeCapacity: ComputeCapacity?
    /// <p>Deletes the VPC association for the specified fleet.</p>
    @available(*, deprecated)
    public let deleteVpcConfig: Bool
    /// <p>The description to display.</p>
    public let description: String?
    /// <p>The amount of time that a streaming session remains active after users disconnect. If users try to reconnect to the streaming session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance. </p>
    ///         <p>Specify a value between 60 and 360000.</p>
    public let disconnectTimeoutInSeconds: Int?
    /// <p>The fleet name to display.</p>
    public let displayName: String?
    /// <p>The name of the directory and organizational unit (OU) to use to join the fleet to a Microsoft Active Directory domain. </p>
    public let domainJoinInfo: DomainJoinInfo?
    /// <p>Enables or disables default internet access for the fleet.</p>
    public let enableDefaultInternetAccess: Bool?
    /// <p>The Amazon Resource Name (ARN) of the IAM role to apply to the fleet. To assume a role, a fleet instance calls the AWS Security Token Service (STS) <code>AssumeRole</code> API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the <b>appstream_machine_role</b> credential profile on the instance.</p>
    ///
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html">Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances</a> in the <i>Amazon AppStream 2.0 Administration Guide</i>.</p>
    public let iamRoleArn: String?
    /// <p>The amount of time that users can be idle (inactive) before they are disconnected
    ///             from their streaming session and the <code>DisconnectTimeoutInSeconds</code> time
    ///             interval begins. Users are notified before they are disconnected due to inactivity. If
    ///             users try to reconnect to the streaming session before the time interval specified in
    ///             <code>DisconnectTimeoutInSeconds</code> elapses, they are connected to their
    ///             previous session. Users are considered idle when they stop providing keyboard or mouse
    ///             input during their streaming session. File uploads and downloads, audio in, audio out,
    ///             and pixels changing do not qualify as user activity. If users continue to be idle after
    ///             the time interval in <code>IdleDisconnectTimeoutInSeconds</code> elapses, they are
    ///             disconnected. </p>
    ///         <p>To prevent users from being disconnected due to inactivity, specify a value of 0. Otherwise, specify a value between 60 and 3600. The default value is 0.</p>
    ///
    ///         <note>
    ///             <p>If you enable this feature, we recommend that you specify a value that corresponds exactly to a whole number of minutes (for example, 60, 120, and 180). If you don't do this, the value is rounded to the nearest minute. For example, if you specify a value of 70, users are disconnected after 1 minute of inactivity. If you specify a value that is at the midpoint between two different minutes, the value is rounded up. For example, if you specify a value of 90, users are disconnected after 2 minutes of inactivity. </p>
    ///          </note>
    public let idleDisconnectTimeoutInSeconds: Int?
    /// <p>The ARN of the public, private, or shared image to use.</p>
    public let imageArn: String?
    /// <p>The name of the image used to create the fleet.</p>
    public let imageName: String?
    /// <p>The instance type to use when launching fleet instances. The following instance types are available:</p>
    ///         <ul>
    ///             <li>
    ///                <p>stream.standard.small</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.standard.medium</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.standard.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.compute.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.3xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.6xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.memory.z1d.12xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.large</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-design.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-desktop.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.2xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.12xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics.g4dn.16xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-pro.4xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-pro.8xlarge</p>
    ///             </li>
    ///             <li>
    ///                <p>stream.graphics-pro.16xlarge</p>
    ///             </li>
    ///          </ul>
    public let instanceType: String?
    /// <p>The maximum amount of time that a streaming session can remain active, in seconds. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected. After this time elapses, the instance is terminated and replaced by a new instance.</p>
    ///         <p>Specify a value between 600 and 360000.</p>
    public let maxUserDurationInSeconds: Int?
    /// <p>A unique name for the fleet.</p>
    public let name: String?
    /// <p>The AppStream 2.0 view that is displayed to your users when they stream from the fleet. When <code>APP</code> is specified, only the windows of applications opened by users display. When <code>DESKTOP</code> is specified, the standard desktop that is provided by the operating system displays.</p>
    ///
    ///         <p>The default value is <code>APP</code>.</p>
    public let streamView: StreamView?
    /// <p>The VPC configuration for the fleet.</p>
    public let vpcConfig: VpcConfig?

    public init (
        attributesToDelete: [FleetAttribute]? = nil,
        computeCapacity: ComputeCapacity? = nil,
        deleteVpcConfig: Bool = false,
        description: String? = nil,
        disconnectTimeoutInSeconds: Int? = nil,
        displayName: String? = nil,
        domainJoinInfo: DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Bool? = nil,
        iamRoleArn: String? = nil,
        idleDisconnectTimeoutInSeconds: Int? = nil,
        imageArn: String? = nil,
        imageName: String? = nil,
        instanceType: String? = nil,
        maxUserDurationInSeconds: Int? = nil,
        name: String? = nil,
        streamView: StreamView? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.attributesToDelete = attributesToDelete
        self.computeCapacity = computeCapacity
        self.deleteVpcConfig = deleteVpcConfig
        self.description = description
        self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.iamRoleArn = iamRoleArn
        self.idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds
        self.imageArn = imageArn
        self.imageName = imageName
        self.instanceType = instanceType
        self.maxUserDurationInSeconds = maxUserDurationInSeconds
        self.name = name
        self.streamView = streamView
        self.vpcConfig = vpcConfig
    }
}

struct UpdateFleetInputBody: Equatable {
    public let imageName: String?
    public let imageArn: String?
    public let name: String?
    public let instanceType: String?
    public let computeCapacity: ComputeCapacity?
    public let vpcConfig: VpcConfig?
    public let maxUserDurationInSeconds: Int?
    public let disconnectTimeoutInSeconds: Int?
    public let deleteVpcConfig: Bool
    public let description: String?
    public let displayName: String?
    public let enableDefaultInternetAccess: Bool?
    public let domainJoinInfo: DomainJoinInfo?
    public let idleDisconnectTimeoutInSeconds: Int?
    public let attributesToDelete: [FleetAttribute]?
    public let iamRoleArn: String?
    public let streamView: StreamView?
}

extension UpdateFleetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributesToDelete = "AttributesToDelete"
        case computeCapacity = "ComputeCapacity"
        case deleteVpcConfig = "DeleteVpcConfig"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case streamView = "StreamView"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let computeCapacityDecoded = try containerValues.decodeIfPresent(ComputeCapacity.self, forKey: .computeCapacity)
        computeCapacity = computeCapacityDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let maxUserDurationInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxUserDurationInSeconds)
        maxUserDurationInSeconds = maxUserDurationInSecondsDecoded
        let disconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .disconnectTimeoutInSeconds)
        disconnectTimeoutInSeconds = disconnectTimeoutInSecondsDecoded
        let deleteVpcConfigDecoded = try containerValues.decode(Bool.self, forKey: .deleteVpcConfig)
        deleteVpcConfig = deleteVpcConfigDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let idleDisconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .idleDisconnectTimeoutInSeconds)
        idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSecondsDecoded
        let attributesToDeleteContainer = try containerValues.decodeIfPresent([FleetAttribute?].self, forKey: .attributesToDelete)
        var attributesToDeleteDecoded0:[FleetAttribute]? = nil
        if let attributesToDeleteContainer = attributesToDeleteContainer {
            attributesToDeleteDecoded0 = [FleetAttribute]()
            for string0 in attributesToDeleteContainer {
                if let string0 = string0 {
                    attributesToDeleteDecoded0?.append(string0)
                }
            }
        }
        attributesToDelete = attributesToDeleteDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let streamViewDecoded = try containerValues.decodeIfPresent(StreamView.self, forKey: .streamView)
        streamView = streamViewDecoded
    }
}

extension UpdateFleetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFleetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestLimitExceededException" : self = .requestLimitExceededException(try RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFleetOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case requestLimitExceededException(RequestLimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFleetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFleetOutputResponse(fleet: \(String(describing: fleet)))"}
}

extension UpdateFleetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFleetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fleet = output.fleet
        } else {
            self.fleet = nil
        }
    }
}

public struct UpdateFleetOutputResponse: Equatable {
    /// <p>Information about the fleet.</p>
    public let fleet: Fleet?

    public init (
        fleet: Fleet? = nil
    )
    {
        self.fleet = fleet
    }
}

struct UpdateFleetOutputResponseBody: Equatable {
    public let fleet: Fleet?
}

extension UpdateFleetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleet = "Fleet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Fleet.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

public struct UpdateImagePermissionsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateImagePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateImagePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateImagePermissionsInput>
    public typealias MOutput = OperationOutput<UpdateImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateImagePermissionsOutputError>
}

extension UpdateImagePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateImagePermissionsInput(imagePermissions: \(String(describing: imagePermissions)), name: \(String(describing: name)), sharedAccountId: \(String(describing: sharedAccountId)))"}
}

extension UpdateImagePermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imagePermissions = "ImagePermissions"
        case name = "Name"
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imagePermissions = imagePermissions {
            try encodeContainer.encode(imagePermissions, forKey: .imagePermissions)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sharedAccountId = sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }
}

public struct UpdateImagePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateImagePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateImagePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateImagePermissionsInput>
    public typealias MOutput = OperationOutput<UpdateImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateImagePermissionsOutputError>
}

public struct UpdateImagePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateImagePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateImagePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateImagePermissionsInput>
    public typealias MOutput = OperationOutput<UpdateImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateImagePermissionsOutputError>
}

public struct UpdateImagePermissionsInput: Equatable {
    /// <p>The permissions for the image.</p>
    public let imagePermissions: ImagePermissions?
    /// <p>The name of the private image.</p>
    public let name: String?
    /// <p>The 12-digit identifier of the AWS account for which you want add or update image permissions.</p>
    public let sharedAccountId: String?

    public init (
        imagePermissions: ImagePermissions? = nil,
        name: String? = nil,
        sharedAccountId: String? = nil
    )
    {
        self.imagePermissions = imagePermissions
        self.name = name
        self.sharedAccountId = sharedAccountId
    }
}

struct UpdateImagePermissionsInputBody: Equatable {
    public let name: String?
    public let sharedAccountId: String?
    public let imagePermissions: ImagePermissions?
}

extension UpdateImagePermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imagePermissions = "ImagePermissions"
        case name = "Name"
        case sharedAccountId = "SharedAccountId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
        let imagePermissionsDecoded = try containerValues.decodeIfPresent(ImagePermissions.self, forKey: .imagePermissions)
        imagePermissions = imagePermissionsDecoded
    }
}

extension UpdateImagePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateImagePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateImagePermissionsOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateImagePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateImagePermissionsOutputResponse()"}
}

extension UpdateImagePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateImagePermissionsOutputResponse: Equatable {

    public init() {}
}

struct UpdateImagePermissionsOutputResponseBody: Equatable {
}

extension UpdateImagePermissionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateStackInputBodyMiddleware: Middleware {
    public let id: String = "UpdateStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStackInput>
    public typealias MOutput = OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStackOutputError>
}

extension UpdateStackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStackInput(accessEndpoints: \(String(describing: accessEndpoints)), applicationSettings: \(String(describing: applicationSettings)), attributesToDelete: \(String(describing: attributesToDelete)), deleteStorageConnectors: \(String(describing: deleteStorageConnectors)), description: \(String(describing: description)), displayName: \(String(describing: displayName)), embedHostDomains: \(String(describing: embedHostDomains)), feedbackURL: \(String(describing: feedbackURL)), name: \(String(describing: name)), redirectURL: \(String(describing: redirectURL)), storageConnectors: \(String(describing: storageConnectors)), userSettings: \(String(describing: userSettings)))"}
}

extension UpdateStackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case attributesToDelete = "AttributesToDelete"
        case deleteStorageConnectors = "DeleteStorageConnectors"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case storageConnectors = "StorageConnectors"
        case userSettings = "UserSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpointlist0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpointlist0)
            }
        }
        if let applicationSettings = applicationSettings {
            try encodeContainer.encode(applicationSettings, forKey: .applicationSettings)
        }
        if let attributesToDelete = attributesToDelete {
            var attributesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributesToDelete)
            for stackattributes0 in attributesToDelete {
                try attributesToDeleteContainer.encode(stackattributes0.rawValue)
            }
        }
        if deleteStorageConnectors != false {
            try encodeContainer.encode(deleteStorageConnectors, forKey: .deleteStorageConnectors)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let embedHostDomains = embedHostDomains {
            var embedHostDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .embedHostDomains)
            for embedhostdomains0 in embedHostDomains {
                try embedHostDomainsContainer.encode(embedhostdomains0)
            }
        }
        if let feedbackURL = feedbackURL {
            try encodeContainer.encode(feedbackURL, forKey: .feedbackURL)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let redirectURL = redirectURL {
            try encodeContainer.encode(redirectURL, forKey: .redirectURL)
        }
        if let storageConnectors = storageConnectors {
            var storageConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .storageConnectors)
            for storageconnectorlist0 in storageConnectors {
                try storageConnectorsContainer.encode(storageconnectorlist0)
            }
        }
        if let userSettings = userSettings {
            var userSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userSettings)
            for usersettinglist0 in userSettings {
                try userSettingsContainer.encode(usersettinglist0)
            }
        }
    }
}

public struct UpdateStackInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStackInput>
    public typealias MOutput = OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStackOutputError>
}

public struct UpdateStackInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStackInput>
    public typealias MOutput = OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStackOutputError>
}

public struct UpdateStackInput: Equatable {
    /// <p>The list of interface VPC endpoint (interface endpoint) objects. Users of the stack can connect to AppStream 2.0 only through the specified endpoints.</p>
    public let accessEndpoints: [AccessEndpoint]?
    /// <p>The persistent application settings for users of a stack. When these settings are enabled, changes that users make to applications and Windows settings are automatically saved after each session and applied to the next session.</p>
    public let applicationSettings: ApplicationSettings?
    /// <p>The stack attributes to delete.</p>
    public let attributesToDelete: [StackAttribute]?
    /// <p>Deletes the storage connectors currently enabled for the stack.</p>
    @available(*, deprecated)
    public let deleteStorageConnectors: Bool
    /// <p>The description to display.</p>
    public let description: String?
    /// <p>The stack name to display.</p>
    public let displayName: String?
    /// <p>The domains where AppStream 2.0 streaming sessions can be embedded in an iframe. You must approve the domains that you want to host embedded AppStream 2.0 streaming sessions. </p>
    public let embedHostDomains: [String]?
    /// <p>The URL that users are redirected to after they choose the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.</p>
    public let feedbackURL: String?
    /// <p>The name of the stack.</p>
    public let name: String?
    /// <p>The URL that users are redirected to after their streaming session ends.</p>
    public let redirectURL: String?
    /// <p>The storage connectors to enable.</p>
    public let storageConnectors: [StorageConnector]?
    /// <p>The actions that are enabled or disabled for users during their streaming sessions. By default, these actions are enabled.</p>
    public let userSettings: [UserSetting]?

    public init (
        accessEndpoints: [AccessEndpoint]? = nil,
        applicationSettings: ApplicationSettings? = nil,
        attributesToDelete: [StackAttribute]? = nil,
        deleteStorageConnectors: Bool = false,
        description: String? = nil,
        displayName: String? = nil,
        embedHostDomains: [String]? = nil,
        feedbackURL: String? = nil,
        name: String? = nil,
        redirectURL: String? = nil,
        storageConnectors: [StorageConnector]? = nil,
        userSettings: [UserSetting]? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.applicationSettings = applicationSettings
        self.attributesToDelete = attributesToDelete
        self.deleteStorageConnectors = deleteStorageConnectors
        self.description = description
        self.displayName = displayName
        self.embedHostDomains = embedHostDomains
        self.feedbackURL = feedbackURL
        self.name = name
        self.redirectURL = redirectURL
        self.storageConnectors = storageConnectors
        self.userSettings = userSettings
    }
}

struct UpdateStackInputBody: Equatable {
    public let displayName: String?
    public let description: String?
    public let name: String?
    public let storageConnectors: [StorageConnector]?
    public let deleteStorageConnectors: Bool
    public let redirectURL: String?
    public let feedbackURL: String?
    public let attributesToDelete: [StackAttribute]?
    public let userSettings: [UserSetting]?
    public let applicationSettings: ApplicationSettings?
    public let accessEndpoints: [AccessEndpoint]?
    public let embedHostDomains: [String]?
}

extension UpdateStackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case attributesToDelete = "AttributesToDelete"
        case deleteStorageConnectors = "DeleteStorageConnectors"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case storageConnectors = "StorageConnectors"
        case userSettings = "UserSettings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let storageConnectorsContainer = try containerValues.decodeIfPresent([StorageConnector?].self, forKey: .storageConnectors)
        var storageConnectorsDecoded0:[StorageConnector]? = nil
        if let storageConnectorsContainer = storageConnectorsContainer {
            storageConnectorsDecoded0 = [StorageConnector]()
            for structure0 in storageConnectorsContainer {
                if let structure0 = structure0 {
                    storageConnectorsDecoded0?.append(structure0)
                }
            }
        }
        storageConnectors = storageConnectorsDecoded0
        let deleteStorageConnectorsDecoded = try containerValues.decode(Bool.self, forKey: .deleteStorageConnectors)
        deleteStorageConnectors = deleteStorageConnectorsDecoded
        let redirectURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .redirectURL)
        redirectURL = redirectURLDecoded
        let feedbackURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .feedbackURL)
        feedbackURL = feedbackURLDecoded
        let attributesToDeleteContainer = try containerValues.decodeIfPresent([StackAttribute?].self, forKey: .attributesToDelete)
        var attributesToDeleteDecoded0:[StackAttribute]? = nil
        if let attributesToDeleteContainer = attributesToDeleteContainer {
            attributesToDeleteDecoded0 = [StackAttribute]()
            for string0 in attributesToDeleteContainer {
                if let string0 = string0 {
                    attributesToDeleteDecoded0?.append(string0)
                }
            }
        }
        attributesToDelete = attributesToDeleteDecoded0
        let userSettingsContainer = try containerValues.decodeIfPresent([UserSetting?].self, forKey: .userSettings)
        var userSettingsDecoded0:[UserSetting]? = nil
        if let userSettingsContainer = userSettingsContainer {
            userSettingsDecoded0 = [UserSetting]()
            for structure0 in userSettingsContainer {
                if let structure0 = structure0 {
                    userSettingsDecoded0?.append(structure0)
                }
            }
        }
        userSettings = userSettingsDecoded0
        let applicationSettingsDecoded = try containerValues.decodeIfPresent(ApplicationSettings.self, forKey: .applicationSettings)
        applicationSettings = applicationSettingsDecoded
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
        let embedHostDomainsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .embedHostDomains)
        var embedHostDomainsDecoded0:[String]? = nil
        if let embedHostDomainsContainer = embedHostDomainsContainer {
            embedHostDomainsDecoded0 = [String]()
            for string0 in embedHostDomainsContainer {
                if let string0 = string0 {
                    embedHostDomainsDecoded0?.append(string0)
                }
            }
        }
        embedHostDomains = embedHostDomainsDecoded0
    }
}

extension UpdateStackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStackOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStackOutputResponse(stack: \(String(describing: stack)))"}
}

extension UpdateStackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateStackOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stack = output.stack
        } else {
            self.stack = nil
        }
    }
}

public struct UpdateStackOutputResponse: Equatable {
    /// <p>Information about the stack.</p>
    public let stack: Stack?

    public init (
        stack: Stack? = nil
    )
    {
        self.stack = stack
    }
}

struct UpdateStackOutputResponseBody: Equatable {
    public let stack: Stack?
}

extension UpdateStackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stack = "Stack"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackDecoded = try containerValues.decodeIfPresent(Stack.self, forKey: .stack)
        stack = stackDecoded
    }
}

public enum UsageReportExecutionErrorCode {
    case accessDenied
    case internalServiceError
    case resourceNotFound
    case sdkUnknown(String)
}

extension UsageReportExecutionErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UsageReportExecutionErrorCode] {
        return [
            .accessDenied,
            .internalServiceError,
            .resourceNotFound,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessDenied: return "ACCESS_DENIED"
        case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
        case .resourceNotFound: return "RESOURCE_NOT_FOUND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UsageReportExecutionErrorCode(rawValue: rawValue) ?? UsageReportExecutionErrorCode.sdkUnknown(rawValue)
    }
}

public enum UsageReportSchedule {
    case daily
    case sdkUnknown(String)
}

extension UsageReportSchedule : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UsageReportSchedule] {
        return [
            .daily,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .daily: return "DAILY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UsageReportSchedule(rawValue: rawValue) ?? UsageReportSchedule.sdkUnknown(rawValue)
    }
}

extension UsageReportSubscription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastGeneratedReportDate = "LastGeneratedReportDate"
        case s3BucketName = "S3BucketName"
        case schedule = "Schedule"
        case subscriptionErrors = "SubscriptionErrors"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastGeneratedReportDate = lastGeneratedReportDate {
            try encodeContainer.encode(lastGeneratedReportDate.timeIntervalSince1970, forKey: .lastGeneratedReportDate)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule.rawValue, forKey: .schedule)
        }
        if let subscriptionErrors = subscriptionErrors {
            var subscriptionErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptionErrors)
            for lastreportgenerationexecutionerrors0 in subscriptionErrors {
                try subscriptionErrorsContainer.encode(lastreportgenerationexecutionerrors0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(UsageReportSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let lastGeneratedReportDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastGeneratedReportDate)
        lastGeneratedReportDate = lastGeneratedReportDateDecoded
        let subscriptionErrorsContainer = try containerValues.decodeIfPresent([LastReportGenerationExecutionError?].self, forKey: .subscriptionErrors)
        var subscriptionErrorsDecoded0:[LastReportGenerationExecutionError]? = nil
        if let subscriptionErrorsContainer = subscriptionErrorsContainer {
            subscriptionErrorsDecoded0 = [LastReportGenerationExecutionError]()
            for structure0 in subscriptionErrorsContainer {
                if let structure0 = structure0 {
                    subscriptionErrorsDecoded0?.append(structure0)
                }
            }
        }
        subscriptionErrors = subscriptionErrorsDecoded0
    }
}

extension UsageReportSubscription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageReportSubscription(lastGeneratedReportDate: \(String(describing: lastGeneratedReportDate)), s3BucketName: \(String(describing: s3BucketName)), schedule: \(String(describing: schedule)), subscriptionErrors: \(String(describing: subscriptionErrors)))"}
}

/// <p>Describes information about the usage report subscription.</p>
public struct UsageReportSubscription: Equatable {
    /// <p>The time when the last usage report was generated.</p>
    public let lastGeneratedReportDate: Date?
    /// <p>The Amazon S3 bucket where generated reports are stored.</p>
    ///
    ///         <p>If you enabled on-instance session scripts and Amazon S3 logging for your session script
    ///             configuration, AppStream 2.0 created an S3 bucket to store the script output. The bucket is
    ///             unique to your account and Region. When you enable usage reporting in this case, AppStream 2.0
    ///             uses the same bucket to store your usage reports. If you haven't already enabled on-instance session scripts,
    ///             when you enable usage reports, AppStream 2.0 creates a new S3 bucket.</p>
    public let s3BucketName: String?
    /// <p>The schedule for generating usage reports.</p>
    public let schedule: UsageReportSchedule?
    /// <p>The errors that were returned if usage reports couldn't be generated.</p>
    public let subscriptionErrors: [LastReportGenerationExecutionError]?

    public init (
        lastGeneratedReportDate: Date? = nil,
        s3BucketName: String? = nil,
        schedule: UsageReportSchedule? = nil,
        subscriptionErrors: [LastReportGenerationExecutionError]? = nil
    )
    {
        self.lastGeneratedReportDate = lastGeneratedReportDate
        self.s3BucketName = s3BucketName
        self.schedule = schedule
        self.subscriptionErrors = subscriptionErrors
    }
}

extension User: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case authenticationType = "AuthenticationType"
        case createdTime = "CreatedTime"
        case enabled = "Enabled"
        case firstName = "FirstName"
        case lastName = "LastName"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension User: CustomDebugStringConvertible {
    public var debugDescription: String {
        "User(arn: \(String(describing: arn)), authenticationType: \(String(describing: authenticationType)), createdTime: \(String(describing: createdTime)), enabled: \(String(describing: enabled)), firstName: \(String(describing: firstName)), lastName: \(String(describing: lastName)), status: \(String(describing: status)), userName: \(String(describing: userName)))"}
}

/// <p>Describes a user in the user pool.</p>
public struct User: Equatable {
    /// <p>The ARN of the user.</p>
    public let arn: String?
    /// <p>The authentication type for the user.</p>
    public let authenticationType: AuthenticationType?
    /// <p>The date and time the user was created in the user pool.</p>
    public let createdTime: Date?
    /// <p>Specifies whether the user in the user pool is enabled.</p>
    public let enabled: Bool
    /// <p>The first name, or given name, of the user.</p>
    public let firstName: String?
    /// <p>The last name, or surname, of the user.</p>
    public let lastName: String?
    /// <p>The status of the user in the user pool. The status can be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                <p>UNCONFIRMED – The user is created but not confirmed.</p>
    ///             </li>
    ///             <li>
    ///                <p>CONFIRMED – The user is confirmed.</p>
    ///             </li>
    ///             <li>
    ///                <p>ARCHIVED – The user is no longer active.</p>
    ///             </li>
    ///             <li>
    ///                <p>COMPROMISED – The user is disabled because of a potential security threat.</p>
    ///             </li>
    ///             <li>
    ///                <p>UNKNOWN – The user status is not known.</p>
    ///             </li>
    ///          </ul>
    public let status: String?
    /// <p>The email address of the user.</p>
    ///
    ///         <note>
    ///             <p>Users' email addresses are case-sensitive.</p>
    ///          </note>
    public let userName: String?

    public init (
        arn: String? = nil,
        authenticationType: AuthenticationType? = nil,
        createdTime: Date? = nil,
        enabled: Bool = false,
        firstName: String? = nil,
        lastName: String? = nil,
        status: String? = nil,
        userName: String? = nil
    )
    {
        self.arn = arn
        self.authenticationType = authenticationType
        self.createdTime = createdTime
        self.enabled = enabled
        self.firstName = firstName
        self.lastName = lastName
        self.status = status
        self.userName = userName
    }
}

extension UserSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case permission = "Permission"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let permission = permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(Permission.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension UserSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserSetting(action: \(String(describing: action)), permission: \(String(describing: permission)))"}
}

/// <p>Describes an action and whether the action is enabled or disabled for users during their streaming sessions.</p>
public struct UserSetting: Equatable {
    /// <p>The action that is enabled or disabled.</p>
    public let action: Action?
    /// <p>Indicates whether the action is enabled or disabled.</p>
    public let permission: Permission?

    public init (
        action: Action? = nil,
        permission: Permission? = nil
    )
    {
        self.action = action
        self.permission = permission
    }
}

extension UserStackAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationType = "AuthenticationType"
        case sendEmailNotification = "SendEmailNotification"
        case stackName = "StackName"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if sendEmailNotification != false {
            try encodeContainer.encode(sendEmailNotification, forKey: .sendEmailNotification)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let sendEmailNotificationDecoded = try containerValues.decode(Bool.self, forKey: .sendEmailNotification)
        sendEmailNotification = sendEmailNotificationDecoded
    }
}

extension UserStackAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserStackAssociation(authenticationType: \(String(describing: authenticationType)), sendEmailNotification: \(String(describing: sendEmailNotification)), stackName: \(String(describing: stackName)), userName: \(String(describing: userName)))"}
}

/// <p>Describes a user in the user pool and the associated stack.</p>
public struct UserStackAssociation: Equatable {
    /// <p>The authentication type for the user.</p>
    public let authenticationType: AuthenticationType?
    /// <p>Specifies whether a welcome email is sent to a user after the user is created in the user pool.</p>
    public let sendEmailNotification: Bool
    /// <p>The name of the stack that is associated with the user.</p>
    public let stackName: String?
    /// <p>The email address of the user who is associated with the stack.</p>
    ///
    ///         <note>
    ///             <p>Users' email addresses are case-sensitive.</p>
    ///          </note>
    public let userName: String?

    public init (
        authenticationType: AuthenticationType? = nil,
        sendEmailNotification: Bool = false,
        stackName: String? = nil,
        userName: String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.sendEmailNotification = sendEmailNotification
        self.stackName = stackName
        self.userName = userName
    }
}

extension UserStackAssociationError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case userStackAssociation = "UserStackAssociation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let userStackAssociation = userStackAssociation {
            try encodeContainer.encode(userStackAssociation, forKey: .userStackAssociation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userStackAssociationDecoded = try containerValues.decodeIfPresent(UserStackAssociation.self, forKey: .userStackAssociation)
        userStackAssociation = userStackAssociationDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(UserStackAssociationErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension UserStackAssociationError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserStackAssociationError(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), userStackAssociation: \(String(describing: userStackAssociation)))"}
}

/// <p>Describes the error that is returned when a user can’t be associated with or disassociated from a stack. </p>
public struct UserStackAssociationError: Equatable {
    /// <p>The error code for the error that is returned when a user can’t be associated with or disassociated from a stack.</p>
    public let errorCode: UserStackAssociationErrorCode?
    /// <p>The error message for the error that is returned when a user can’t be associated with or disassociated from a stack.</p>
    public let errorMessage: String?
    /// <p>Information about the user and associated stack.</p>
    public let userStackAssociation: UserStackAssociation?

    public init (
        errorCode: UserStackAssociationErrorCode? = nil,
        errorMessage: String? = nil,
        userStackAssociation: UserStackAssociation? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.userStackAssociation = userStackAssociation
    }
}

public enum UserStackAssociationErrorCode {
    case directoryNotFound
    case internalError
    case stackNotFound
    case userNameNotFound
    case sdkUnknown(String)
}

extension UserStackAssociationErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UserStackAssociationErrorCode] {
        return [
            .directoryNotFound,
            .internalError,
            .stackNotFound,
            .userNameNotFound,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .directoryNotFound: return "DIRECTORY_NOT_FOUND"
        case .internalError: return "INTERNAL_ERROR"
        case .stackNotFound: return "STACK_NOT_FOUND"
        case .userNameNotFound: return "USER_NAME_NOT_FOUND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UserStackAssociationErrorCode(rawValue: rawValue) ?? UserStackAssociationErrorCode.sdkUnknown(rawValue)
    }
}

public enum VisibilityType {
    case `private`
    case `public`
    case shared
    case sdkUnknown(String)
}

extension VisibilityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VisibilityType] {
        return [
            .private,
            .public,
            .shared,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .private: return "PRIVATE"
        case .public: return "PUBLIC"
        case .shared: return "SHARED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VisibilityType(rawValue: rawValue) ?? VisibilityType.sdkUnknown(rawValue)
    }
}

extension VpcConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension VpcConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcConfig(securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)))"}
}

/// <p>Describes VPC configuration information for fleets and image builders.</p>
public struct VpcConfig: Equatable {
    /// <p>The identifiers of the security groups for the fleet or image builder.</p>
    public let securityGroupIds: [String]?
    /// <p>The identifiers of the subnets to which a network interface is attached from the fleet instance or image builder instance. Fleet instances use one or more subnets. Image builder instances use one subnet.</p>
    public let subnetIds: [String]?

    public init (
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
    }
}
