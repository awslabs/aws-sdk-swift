// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension JobDescriptor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case confirmationRequired = "ConfirmationRequired"
        case creationTime = "CreationTime"
        case description = "Description"
        case failureReasons = "FailureReasons"
        case jobArn = "JobArn"
        case jobId = "JobId"
        case manifest = "Manifest"
        case operation = "Operation"
        case priority = "Priority"
        case progressSummary = "ProgressSummary"
        case report = "Report"
        case roleArn = "RoleArn"
        case status = "Status"
        case statusUpdateReason = "StatusUpdateReason"
        case suspendedCause = "SuspendedCause"
        case suspendedDate = "SuspendedDate"
        case terminationDate = "TerminationDate"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if confirmationRequired != false {
            try container.encode(confirmationRequired, forKey: Key("confirmationRequired"))
        }
        if let creationTime = creationTime {
            try container.encode(TimestampWrapper(creationTime, format: .dateTime), forKey: Key("creationTime"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("description"))
        }
        if let failureReasons = failureReasons {
            var failureReasonsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("failureReasons"))
            for jobfailure0 in failureReasons {
                try failureReasonsContainer.encode(jobfailure0, forKey: Key("member"))
            }
        }
        if let jobArn = jobArn {
            try container.encode(jobArn, forKey: Key("jobArn"))
        }
        if let jobId = jobId {
            try container.encode(jobId, forKey: Key("jobId"))
        }
        if let manifest = manifest {
            try container.encode(manifest, forKey: Key("manifest"))
        }
        if let operation = operation {
            try container.encode(operation, forKey: Key("operation"))
        }
        if priority != 0 {
            try container.encode(priority, forKey: Key("priority"))
        }
        if let progressSummary = progressSummary {
            try container.encode(progressSummary, forKey: Key("progressSummary"))
        }
        if let report = report {
            try container.encode(report, forKey: Key("report"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("roleArn"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
        if let statusUpdateReason = statusUpdateReason {
            try container.encode(statusUpdateReason, forKey: Key("statusUpdateReason"))
        }
        if let suspendedCause = suspendedCause {
            try container.encode(suspendedCause, forKey: Key("suspendedCause"))
        }
        if let suspendedDate = suspendedDate {
            try container.encode(TimestampWrapper(suspendedDate, format: .dateTime), forKey: Key("suspendedDate"))
        }
        if let terminationDate = terminationDate {
            try container.encode(TimestampWrapper(terminationDate, format: .dateTime), forKey: Key("terminationDate"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let confirmationRequiredDecoded = try containerValues.decode(Bool.self, forKey: .confirmationRequired)
        confirmationRequired = confirmationRequiredDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let jobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .status)
        status = statusDecoded
        let manifestDecoded = try containerValues.decodeIfPresent(JobManifest.self, forKey: .manifest)
        manifest = manifestDecoded
        let operationDecoded = try containerValues.decodeIfPresent(JobOperation.self, forKey: .operation)
        operation = operationDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let progressSummaryDecoded = try containerValues.decodeIfPresent(JobProgressSummary.self, forKey: .progressSummary)
        progressSummary = progressSummaryDecoded
        let statusUpdateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusUpdateReason)
        statusUpdateReason = statusUpdateReasonDecoded
        if containerValues.contains(.failureReasons) {
            struct KeyVal0{struct member{}}
            let failureReasonsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .failureReasons)
            if let failureReasonsWrappedContainer = failureReasonsWrappedContainer {
                let failureReasonsContainer = try failureReasonsWrappedContainer.decodeIfPresent([JobFailure].self, forKey: .member)
                var failureReasonsBuffer:[JobFailure]? = nil
                if let failureReasonsContainer = failureReasonsContainer {
                    failureReasonsBuffer = [JobFailure]()
                    for structureContainer0 in failureReasonsContainer {
                        failureReasonsBuffer?.append(structureContainer0)
                    }
                }
                failureReasons = failureReasonsBuffer
            } else {
                failureReasons = []
            }
        } else {
            failureReasons = nil
        }
        let reportDecoded = try containerValues.decodeIfPresent(JobReport.self, forKey: .report)
        report = reportDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        var creationTimeBuffer:Date? = nil
        if let creationTimeDecoded = creationTimeDecoded {
            creationTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationTimeDecoded, format: .dateTime)
        }
        creationTime = creationTimeBuffer
        let terminationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .terminationDate)
        var terminationDateBuffer:Date? = nil
        if let terminationDateDecoded = terminationDateDecoded {
            terminationDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(terminationDateDecoded, format: .dateTime)
        }
        terminationDate = terminationDateBuffer
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let suspendedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suspendedDate)
        var suspendedDateBuffer:Date? = nil
        if let suspendedDateDecoded = suspendedDateDecoded {
            suspendedDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(suspendedDateDecoded, format: .dateTime)
        }
        suspendedDate = suspendedDateBuffer
        let suspendedCauseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suspendedCause)
        suspendedCause = suspendedCauseDecoded
    }
}
