// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AbortIncompleteMultipartUpload: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case daysAfterInitiation = "DaysAfterInitiation"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if daysAfterInitiation != 0 {
            try container.encode(daysAfterInitiation, forKey: Key("daysAfterInitiation"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let daysAfterInitiationDecoded = try containerValues.decode(Int.self, forKey: .daysAfterInitiation)
        daysAfterInitiation = daysAfterInitiationDecoded
    }
}

extension AbortIncompleteMultipartUpload: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbortIncompleteMultipartUpload(daysAfterInitiation: \(String(describing: daysAfterInitiation)))"}
}

extension AbortIncompleteMultipartUpload: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container for abort incomplete multipart upload</p>
public struct AbortIncompleteMultipartUpload: Equatable {
    /// <p>Specifies the number of days after which Amazon S3 aborts an incomplete multipart upload to
    ///          the Outposts bucket.</p>
    public let daysAfterInitiation: Int

    public init (
        daysAfterInitiation: Int = 0
    )
    {
        self.daysAfterInitiation = daysAfterInitiation
    }
}

extension AccessPoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessPointArn = "AccessPointArn"
        case bucket = "Bucket"
        case name = "Name"
        case networkOrigin = "NetworkOrigin"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let accessPointArn = accessPointArn {
            try container.encode(accessPointArn, forKey: Key("accessPointArn"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: Key("bucket"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
        if let networkOrigin = networkOrigin {
            try container.encode(networkOrigin, forKey: Key("networkOrigin"))
        }
        if let vpcConfiguration = vpcConfiguration {
            try container.encode(vpcConfiguration, forKey: Key("vpcConfiguration"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let networkOriginDecoded = try containerValues.decodeIfPresent(NetworkOrigin.self, forKey: .networkOrigin)
        networkOrigin = networkOriginDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let accessPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
    }
}

extension AccessPoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessPoint(accessPointArn: \(String(describing: accessPointArn)), bucket: \(String(describing: bucket)), name: \(String(describing: name)), networkOrigin: \(String(describing: networkOrigin)), vpcConfiguration: \(String(describing: vpcConfiguration)))"}
}

extension AccessPoint: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>An access point used to access a bucket.</p>
public struct AccessPoint: Equatable {
    /// <p>The ARN for the access point.</p>
    public let accessPointArn: String?
    /// <p>The name of the bucket associated with this access point.</p>
    public let bucket: String?
    /// <p>The name of this access point.</p>
    public let name: String?
    /// <p>Indicates whether this access point allows access from the public internet. If
    ///             <code>VpcConfiguration</code> is specified for this access point, then
    ///             <code>NetworkOrigin</code> is <code>VPC</code>, and the access point doesn't allow access from
    ///          the public internet. Otherwise, <code>NetworkOrigin</code> is <code>Internet</code>, and
    ///          the access point allows access from the public internet, subject to the access point and bucket access
    ///          policies.</p>
    public let networkOrigin: NetworkOrigin?
    /// <p>The virtual private cloud (VPC) configuration for this access point, if one exists.</p>
    ///          <note>
    ///             <p>This element is empty if this access point is an Amazon S3 on Outposts access point that is used by other AWS services.</p>
    ///          </note>
    public let vpcConfiguration: VpcConfiguration?

    public init (
        accessPointArn: String? = nil,
        bucket: String? = nil,
        name: String? = nil,
        networkOrigin: NetworkOrigin? = nil,
        vpcConfiguration: VpcConfiguration? = nil
    )
    {
        self.accessPointArn = accessPointArn
        self.bucket = bucket
        self.name = name
        self.networkOrigin = networkOrigin
        self.vpcConfiguration = vpcConfiguration
    }
}

extension AccountLevel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activityMetrics = "ActivityMetrics"
        case bucketLevel = "BucketLevel"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let activityMetrics = activityMetrics {
            try container.encode(activityMetrics, forKey: Key("activityMetrics"))
        }
        if let bucketLevel = bucketLevel {
            try container.encode(bucketLevel, forKey: Key("bucketLevel"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityMetricsDecoded = try containerValues.decodeIfPresent(ActivityMetrics.self, forKey: .activityMetrics)
        activityMetrics = activityMetricsDecoded
        let bucketLevelDecoded = try containerValues.decodeIfPresent(BucketLevel.self, forKey: .bucketLevel)
        bucketLevel = bucketLevelDecoded
    }
}

extension AccountLevel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountLevel(activityMetrics: \(String(describing: activityMetrics)), bucketLevel: \(String(describing: bucketLevel)))"}
}

extension AccountLevel: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for the account level Amazon S3 Storage Lens configuration.</p>
public struct AccountLevel: Equatable {
    /// <p>A container for the S3 Storage Lens activity metrics.</p>
    public let activityMetrics: ActivityMetrics?
    /// <p>A container for the S3 Storage Lens bucket-level configuration.</p>
    public let bucketLevel: BucketLevel?

    public init (
        activityMetrics: ActivityMetrics? = nil,
        bucketLevel: BucketLevel? = nil
    )
    {
        self.activityMetrics = activityMetrics
        self.bucketLevel = bucketLevel
    }
}

extension ActivityMetrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isEnabled = "IsEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if isEnabled != false {
            try container.encode(isEnabled, forKey: Key("isEnabled"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isEnabledDecoded = try containerValues.decode(Bool.self, forKey: .isEnabled)
        isEnabled = isEnabledDecoded
    }
}

extension ActivityMetrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivityMetrics(isEnabled: \(String(describing: isEnabled)))"}
}

extension ActivityMetrics: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for the activity metrics.</p>
public struct ActivityMetrics: Equatable {
    /// <p>A container for whether the activity metrics are enabled.</p>
    public let isEnabled: Bool

    public init (
        isEnabled: Bool = false
    )
    {
        self.isEnabled = isEnabled
    }
}

extension AwsLambdaTransformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case functionArn = "FunctionArn"
        case functionPayload = "FunctionPayload"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let functionArn = functionArn {
            try container.encode(functionArn, forKey: Key("functionArn"))
        }
        if let functionPayload = functionPayload {
            try container.encode(functionPayload, forKey: Key("functionPayload"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let functionPayloadDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionPayload)
        functionPayload = functionPayloadDecoded
    }
}

extension AwsLambdaTransformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsLambdaTransformation(functionArn: \(String(describing: functionArn)), functionPayload: \(String(describing: functionPayload)))"}
}

extension AwsLambdaTransformation: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>AWS Lambda function used to transform objects through an Object Lambda Access Point.</p>
public struct AwsLambdaTransformation: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS Lambda function.</p>
    public let functionArn: String?
    /// <p>Additional JSON that provides supplemental data to the Lambda function used to transform objects.</p>
    public let functionPayload: String?

    public init (
        functionArn: String? = nil,
        functionPayload: String? = nil
    )
    {
        self.functionArn = functionArn
        self.functionPayload = functionPayload
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<BadRequestExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BucketAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketAlreadyExists()"}
}

extension BucketAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested Outposts bucket name is not available. The bucket namespace is shared by
///          all users of the AWS Outposts in this Region. Select a different name and try
///          again.</p>
public struct BucketAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension BucketAlreadyOwnedByYou: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketAlreadyOwnedByYou()"}
}

extension BucketAlreadyOwnedByYou: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Outposts bucket you tried to create already exists, and you own it. </p>
public struct BucketAlreadyOwnedByYou: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

public enum BucketCannedACL {
    case authenticatedRead
    case `private`
    case publicRead
    case publicReadWrite
    case sdkUnknown(String)
}

extension BucketCannedACL : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BucketCannedACL] {
        return [
            .authenticatedRead,
            .private,
            .publicRead,
            .publicReadWrite,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .authenticatedRead: return "authenticated-read"
        case .private: return "private"
        case .publicRead: return "public-read"
        case .publicReadWrite: return "public-read-write"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BucketCannedACL(rawValue: rawValue) ?? BucketCannedACL.sdkUnknown(rawValue)
    }
}

extension BucketLevel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activityMetrics = "ActivityMetrics"
        case prefixLevel = "PrefixLevel"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let activityMetrics = activityMetrics {
            try container.encode(activityMetrics, forKey: Key("activityMetrics"))
        }
        if let prefixLevel = prefixLevel {
            try container.encode(prefixLevel, forKey: Key("prefixLevel"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityMetricsDecoded = try containerValues.decodeIfPresent(ActivityMetrics.self, forKey: .activityMetrics)
        activityMetrics = activityMetricsDecoded
        let prefixLevelDecoded = try containerValues.decodeIfPresent(PrefixLevel.self, forKey: .prefixLevel)
        prefixLevel = prefixLevelDecoded
    }
}

extension BucketLevel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketLevel(activityMetrics: \(String(describing: activityMetrics)), prefixLevel: \(String(describing: prefixLevel)))"}
}

extension BucketLevel: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for the bucket-level configuration.</p>
public struct BucketLevel: Equatable {
    /// <p>A container for the bucket-level activity metrics for Amazon S3 Storage Lens</p>
    public let activityMetrics: ActivityMetrics?
    /// <p>A container for the bucket-level prefix-level metrics for S3 Storage Lens</p>
    public let prefixLevel: PrefixLevel?

    public init (
        activityMetrics: ActivityMetrics? = nil,
        prefixLevel: PrefixLevel? = nil
    )
    {
        self.activityMetrics = activityMetrics
        self.prefixLevel = prefixLevel
    }
}

public enum BucketLocationConstraint {
    case eu
    case apNortheast1
    case apSouth1
    case apSoutheast1
    case apSoutheast2
    case cnNorth1
    case euCentral1
    case euWest1
    case saEast1
    case usWest1
    case usWest2
    case sdkUnknown(String)
}

extension BucketLocationConstraint : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BucketLocationConstraint] {
        return [
            .eu,
            .apNortheast1,
            .apSouth1,
            .apSoutheast1,
            .apSoutheast2,
            .cnNorth1,
            .euCentral1,
            .euWest1,
            .saEast1,
            .usWest1,
            .usWest2,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .eu: return "EU"
        case .apNortheast1: return "ap-northeast-1"
        case .apSouth1: return "ap-south-1"
        case .apSoutheast1: return "ap-southeast-1"
        case .apSoutheast2: return "ap-southeast-2"
        case .cnNorth1: return "cn-north-1"
        case .euCentral1: return "eu-central-1"
        case .euWest1: return "eu-west-1"
        case .saEast1: return "sa-east-1"
        case .usWest1: return "us-west-1"
        case .usWest2: return "us-west-2"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BucketLocationConstraint(rawValue: rawValue) ?? BucketLocationConstraint.sdkUnknown(rawValue)
    }
}

public struct CreateAccessPointForObjectLambdaInputBodyMiddleware: Middleware {
    public let id: String = "CreateAccessPointForObjectLambdaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessPointForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessPointForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessPointForObjectLambdaInput>
    public typealias MOutput = OperationOutput<CreateAccessPointForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessPointForObjectLambdaOutputError>
}

extension CreateAccessPointForObjectLambdaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccessPointForObjectLambdaInput(accountId: \(String(describing: accountId)), configuration: \(String(describing: configuration)), name: \(String(describing: name)))"}
}

extension CreateAccessPointForObjectLambdaInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateAccessPointForObjectLambdaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let configuration = configuration {
            try container.encode(configuration, forKey: Key("configuration"))
        }
    }
}

public struct CreateAccessPointForObjectLambdaInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAccessPointForObjectLambdaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessPointForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessPointForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessPointForObjectLambdaInput>
    public typealias MOutput = OperationOutput<CreateAccessPointForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessPointForObjectLambdaOutputError>
}

public struct CreateAccessPointForObjectLambdaInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAccessPointForObjectLambdaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessPointForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessPointForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessPointForObjectLambdaInput>
    public typealias MOutput = OperationOutput<CreateAccessPointForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessPointForObjectLambdaOutputError>
}

public struct CreateAccessPointForObjectLambdaInput: Equatable {
    /// <p>The AWS account ID for owner of the specified Object Lambda Access Point.</p>
    public let accountId: String?
    /// <p>Object Lambda Access Point configuration as a JSON document.</p>
    public let configuration: ObjectLambdaConfiguration?
    /// <p>The name you want to assign to this Object Lambda Access Point.</p>
    public let name: String?

    public init (
        accountId: String? = nil,
        configuration: ObjectLambdaConfiguration? = nil,
        name: String? = nil
    )
    {
        self.accountId = accountId
        self.configuration = configuration
        self.name = name
    }
}

struct CreateAccessPointForObjectLambdaInputBody: Equatable {
    public let configuration: ObjectLambdaConfiguration?
}

extension CreateAccessPointForObjectLambdaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(ObjectLambdaConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension CreateAccessPointForObjectLambdaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateAccessPointForObjectLambdaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccessPointForObjectLambdaOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessPointForObjectLambdaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccessPointForObjectLambdaOutputResponse(objectLambdaAccessPointArn: \(String(describing: objectLambdaAccessPointArn)))"}
}

extension CreateAccessPointForObjectLambdaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAccessPointForObjectLambdaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.objectLambdaAccessPointArn = output.objectLambdaAccessPointArn
        } else {
            self.objectLambdaAccessPointArn = nil
        }
    }
}

public struct CreateAccessPointForObjectLambdaOutputResponse: Equatable {
    /// <p>Specifies the ARN for the Object Lambda Access Point.</p>
    public let objectLambdaAccessPointArn: String?

    public init (
        objectLambdaAccessPointArn: String? = nil
    )
    {
        self.objectLambdaAccessPointArn = objectLambdaAccessPointArn
    }
}

struct CreateAccessPointForObjectLambdaOutputResponseBody: Equatable {
    public let objectLambdaAccessPointArn: String?
}

extension CreateAccessPointForObjectLambdaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case objectLambdaAccessPointArn = "ObjectLambdaAccessPointArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectLambdaAccessPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectLambdaAccessPointArn)
        objectLambdaAccessPointArn = objectLambdaAccessPointArnDecoded
    }
}

public struct CreateAccessPointInputBodyMiddleware: Middleware {
    public let id: String = "CreateAccessPointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessPointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessPointInput>
    public typealias MOutput = OperationOutput<CreateAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessPointOutputError>
}

extension CreateAccessPointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccessPointInput(accountId: \(String(describing: accountId)), bucket: \(String(describing: bucket)), name: \(String(describing: name)), publicAccessBlockConfiguration: \(String(describing: publicAccessBlockConfiguration)), vpcConfiguration: \(String(describing: vpcConfiguration)))"}
}

extension CreateAccessPointInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateAccessPointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: Key("bucket"))
        }
        if let publicAccessBlockConfiguration = publicAccessBlockConfiguration {
            try container.encode(publicAccessBlockConfiguration, forKey: Key("publicAccessBlockConfiguration"))
        }
        if let vpcConfiguration = vpcConfiguration {
            try container.encode(vpcConfiguration, forKey: Key("vpcConfiguration"))
        }
    }
}

public struct CreateAccessPointInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAccessPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessPointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessPointInput>
    public typealias MOutput = OperationOutput<CreateAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessPointOutputError>
}

public struct CreateAccessPointInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAccessPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessPointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessPointInput>
    public typealias MOutput = OperationOutput<CreateAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessPointOutputError>
}

public struct CreateAccessPointInput: Equatable {
    /// <p>The AWS account ID for the owner of the bucket for which you want to create an access point.</p>
    public let accountId: String?
    /// <p>The name of the bucket that you want to associate this access point with.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
    public let bucket: String?
    /// <p>The name you want to assign to this access point.</p>
    public let name: String?
    /// <p>
    ///         The <code>PublicAccessBlock</code> configuration that you want to apply to the access point.
    ///       </p>
    public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?
    /// <p>If you include this field, Amazon S3 restricts access to this access point to requests from the
    ///          specified virtual private cloud (VPC).</p>
    ///          <note>
    ///             <p>This is required for creating an access point for Amazon S3 on Outposts buckets.</p>
    ///          </note>
    public let vpcConfiguration: VpcConfiguration?

    public init (
        accountId: String? = nil,
        bucket: String? = nil,
        name: String? = nil,
        publicAccessBlockConfiguration: PublicAccessBlockConfiguration? = nil,
        vpcConfiguration: VpcConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.name = name
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
        self.vpcConfiguration = vpcConfiguration
    }
}

struct CreateAccessPointInputBody: Equatable {
    public let bucket: String?
    public let vpcConfiguration: VpcConfiguration?
    public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?
}

extension CreateAccessPointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        case vpcConfiguration = "VpcConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
    }
}

extension CreateAccessPointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateAccessPointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccessPointOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessPointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccessPointOutputResponse(accessPointArn: \(String(describing: accessPointArn)))"}
}

extension CreateAccessPointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAccessPointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessPointArn = output.accessPointArn
        } else {
            self.accessPointArn = nil
        }
    }
}

public struct CreateAccessPointOutputResponse: Equatable {
    /// <p>The ARN of the access point.</p>
    ///          <note>
    ///             <p>This is only supported by Amazon S3 on Outposts.</p>
    ///          </note>
    public let accessPointArn: String?

    public init (
        accessPointArn: String? = nil
    )
    {
        self.accessPointArn = accessPointArn
    }
}

struct CreateAccessPointOutputResponseBody: Equatable {
    public let accessPointArn: String?
}

extension CreateAccessPointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessPointArn = "AccessPointArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
    }
}

extension CreateBucketConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locationConstraint = "LocationConstraint"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let locationConstraint = locationConstraint {
            try container.encode(locationConstraint, forKey: Key("locationConstraint"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationConstraintDecoded = try containerValues.decodeIfPresent(BucketLocationConstraint.self, forKey: .locationConstraint)
        locationConstraint = locationConstraintDecoded
    }
}

extension CreateBucketConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBucketConfiguration(locationConstraint: \(String(describing: locationConstraint)))"}
}

extension CreateBucketConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container for the bucket configuration.</p>
///          <note>
///             <p>This is not supported by Amazon S3 on Outposts buckets.</p>
///          </note>
public struct CreateBucketConfiguration: Equatable {
    /// <p>Specifies the Region where the bucket will be created.
    ///          If you are creating a bucket on the US East (N. Virginia) Region (us-east-1),
    ///          you do not need to specify the location.
    ///       </p>
    ///          <note>
    ///             <p>This is not supported by Amazon S3 on Outposts buckets.</p>
    ///          </note>
    public let locationConstraint: BucketLocationConstraint?

    public init (
        locationConstraint: BucketLocationConstraint? = nil
    )
    {
        self.locationConstraint = locationConstraint
    }
}

public struct CreateBucketInputBodyMiddleware: Middleware {
    public let id: String = "CreateBucketInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let createBucketConfiguration = input.operationInput.createBucketConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(createBucketConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBucketInput>
    public typealias MOutput = OperationOutput<CreateBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBucketOutputError>
}

extension CreateBucketInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBucketInput(aCL: \(String(describing: aCL)), bucket: \(String(describing: bucket)), createBucketConfiguration: \(String(describing: createBucketConfiguration)), grantFullControl: \(String(describing: grantFullControl)), grantRead: \(String(describing: grantRead)), grantReadACP: \(String(describing: grantReadACP)), grantWrite: \(String(describing: grantWrite)), grantWriteACP: \(String(describing: grantWriteACP)), objectLockEnabledForBucket: \(String(describing: objectLockEnabledForBucket)), outpostId: \(String(describing: outpostId)))"}
}

extension CreateBucketInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateBucketInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createBucketConfiguration = "CreateBucketConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let createBucketConfiguration = createBucketConfiguration {
            try container.encode(createBucketConfiguration, forKey: Key("CreateBucketConfiguration"))
        }
    }
}

public struct CreateBucketInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBucketInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aCL = input.operationInput.aCL {
            input.builder.withHeader(name: "x-amz-acl", value: String(aCL.rawValue))
        }
        if let grantFullControl = input.operationInput.grantFullControl {
            input.builder.withHeader(name: "x-amz-grant-full-control", value: String(grantFullControl))
        }
        if let grantRead = input.operationInput.grantRead {
            input.builder.withHeader(name: "x-amz-grant-read", value: String(grantRead))
        }
        if let grantReadACP = input.operationInput.grantReadACP {
            input.builder.withHeader(name: "x-amz-grant-read-acp", value: String(grantReadACP))
        }
        if let grantWrite = input.operationInput.grantWrite {
            input.builder.withHeader(name: "x-amz-grant-write", value: String(grantWrite))
        }
        if let grantWriteACP = input.operationInput.grantWriteACP {
            input.builder.withHeader(name: "x-amz-grant-write-acp", value: String(grantWriteACP))
        }
        input.builder.withHeader(name: "x-amz-bucket-object-lock-enabled", value: String(input.operationInput.objectLockEnabledForBucket))
        if let outpostId = input.operationInput.outpostId {
            input.builder.withHeader(name: "x-amz-outpost-id", value: String(outpostId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBucketInput>
    public typealias MOutput = OperationOutput<CreateBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBucketOutputError>
}

public struct CreateBucketInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBucketInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBucketInput>
    public typealias MOutput = OperationOutput<CreateBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBucketOutputError>
}

public struct CreateBucketInput: Equatable {
    /// <p>The canned ACL to apply to the bucket.</p>
    ///          <note>
    ///             <p>This is not supported by Amazon S3 on Outposts buckets.</p>
    ///          </note>
    public let aCL: BucketCannedACL?
    /// <p>The name of the bucket.</p>
    public let bucket: String?
    /// <p>The configuration information for the bucket.</p>
    ///          <note>
    ///             <p>This is not supported by Amazon S3 on Outposts buckets.</p>
    ///          </note>
    public let createBucketConfiguration: CreateBucketConfiguration?
    /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the bucket.</p>
    ///          <note>
    ///             <p>This is not supported by Amazon S3 on Outposts buckets.</p>
    ///          </note>
    public let grantFullControl: String?
    /// <p>Allows grantee to list the objects in the bucket.</p>
    ///          <note>
    ///             <p>This is not supported by Amazon S3 on Outposts buckets.</p>
    ///          </note>
    public let grantRead: String?
    /// <p>Allows grantee to read the bucket ACL.</p>
    ///          <note>
    ///             <p>This is not supported by Amazon S3 on Outposts buckets.</p>
    ///          </note>
    public let grantReadACP: String?
    /// <p>Allows grantee to create, overwrite, and delete any object in the bucket.</p>
    ///          <note>
    ///             <p>This is not supported by Amazon S3 on Outposts buckets.</p>
    ///          </note>
    public let grantWrite: String?
    /// <p>Allows grantee to write the ACL for the applicable bucket.</p>
    ///          <note>
    ///             <p>This is not supported by Amazon S3 on Outposts buckets.</p>
    ///          </note>
    public let grantWriteACP: String?
    /// <p>Specifies whether you want S3 Object Lock to be enabled for the new bucket.</p>
    ///          <note>
    ///             <p>This is not supported by Amazon S3 on Outposts buckets.</p>
    ///          </note>
    public let objectLockEnabledForBucket: Bool
    /// <p>The ID of the Outposts where the bucket is being created.</p>
    ///          <note>
    ///             <p>This is required by Amazon S3 on Outposts buckets.</p>
    ///          </note>
    public let outpostId: String?

    public init (
        aCL: BucketCannedACL? = nil,
        bucket: String? = nil,
        createBucketConfiguration: CreateBucketConfiguration? = nil,
        grantFullControl: String? = nil,
        grantRead: String? = nil,
        grantReadACP: String? = nil,
        grantWrite: String? = nil,
        grantWriteACP: String? = nil,
        objectLockEnabledForBucket: Bool = false,
        outpostId: String? = nil
    )
    {
        self.aCL = aCL
        self.bucket = bucket
        self.createBucketConfiguration = createBucketConfiguration
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWrite = grantWrite
        self.grantWriteACP = grantWriteACP
        self.objectLockEnabledForBucket = objectLockEnabledForBucket
        self.outpostId = outpostId
    }
}

struct CreateBucketInputBody: Equatable {
    public let createBucketConfiguration: CreateBucketConfiguration?
}

extension CreateBucketInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createBucketConfiguration = "CreateBucketConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createBucketConfigurationDecoded = try containerValues.decodeIfPresent(CreateBucketConfiguration.self, forKey: .createBucketConfiguration)
        createBucketConfiguration = createBucketConfigurationDecoded
    }
}

extension CreateBucketOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateBucketOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BucketAlreadyExists" : self = .bucketAlreadyExists(try BucketAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BucketAlreadyOwnedByYou" : self = .bucketAlreadyOwnedByYou(try BucketAlreadyOwnedByYou(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBucketOutputError: Equatable {
    case bucketAlreadyExists(BucketAlreadyExists)
    case bucketAlreadyOwnedByYou(BucketAlreadyOwnedByYou)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBucketOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBucketOutputResponse(bucketArn: \(String(describing: bucketArn)), location: \(String(describing: location)))"}
}

extension CreateBucketOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBucketOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bucketArn = output.bucketArn
        } else {
            self.bucketArn = nil
        }
    }
}

public struct CreateBucketOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the bucket.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
    public let bucketArn: String?
    /// <p>The location of the bucket.</p>
    public let location: String?

    public init (
        bucketArn: String? = nil,
        location: String? = nil
    )
    {
        self.bucketArn = bucketArn
        self.location = location
    }
}

struct CreateBucketOutputResponseBody: Equatable {
    public let bucketArn: String?
}

extension CreateBucketOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucketArn = "BucketArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
    }
}

public struct CreateJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

extension CreateJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJobInput(accountId: \(String(describing: accountId)), clientRequestToken: \(String(describing: clientRequestToken)), confirmationRequired: \(String(describing: confirmationRequired)), description: \(String(describing: description)), manifest: \(String(describing: manifest)), operation: \(String(describing: operation)), priority: \(String(describing: priority)), report: \(String(describing: report)), roleArn: \(String(describing: roleArn)), tags: \(String(describing: tags)))"}
}

extension CreateJobInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case confirmationRequired = "ConfirmationRequired"
        case description = "Description"
        case manifest = "Manifest"
        case operation = "Operation"
        case priority = "Priority"
        case report = "Report"
        case roleArn = "RoleArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let clientRequestToken = clientRequestToken {
            try container.encode(clientRequestToken, forKey: Key("clientRequestToken"))
        }
        if confirmationRequired != false {
            try container.encode(confirmationRequired, forKey: Key("confirmationRequired"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("description"))
        }
        if let manifest = manifest {
            try container.encode(manifest, forKey: Key("manifest"))
        }
        if let operation = operation {
            try container.encode(operation, forKey: Key("operation"))
        }
        if priority != 0 {
            try container.encode(priority, forKey: Key("priority"))
        }
        if let report = report {
            try container.encode(report, forKey: Key("report"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("roleArn"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("tags"))
            for s3tag0 in tags {
                try tagsContainer.encode(s3tag0, forKey: Key("member"))
            }
        }
    }
}

public struct CreateJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

public struct CreateJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

public struct CreateJobInput: Equatable {
    /// <p>The AWS account ID that creates the job.</p>
    public let accountId: String?
    /// <p>An idempotency token to ensure that you don't accidentally submit the same request twice. You can use any string up to the maximum length.</p>
    public var clientRequestToken: String?
    /// <p>Indicates whether confirmation is required before Amazon S3 runs the job. Confirmation is only required for jobs created through the Amazon S3 console.</p>
    public let confirmationRequired: Bool
    /// <p>A description for this job. You can use any string within the permitted length. Descriptions don't need to be unique and can be used for multiple jobs.</p>
    public let description: String?
    /// <p>Configuration parameters for the manifest.</p>
    public let manifest: JobManifest?
    /// <p>The action that you want this job to perform on every object listed in the manifest.
    ///          For more information about the available actions, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-actions.html">Operations</a> in the
    ///             <i>Amazon S3 User Guide</i>.</p>
    public let operation: JobOperation?
    /// <p>The numerical priority for this job. Higher numbers indicate higher priority.</p>
    public let priority: Int
    /// <p>Configuration parameters for the optional job-completion report.</p>
    public let report: JobReport?
    /// <p>The Amazon Resource Name (ARN) for the AWS Identity and Access Management (IAM) role
    ///          that Batch Operations will use to run this job's action on every object in the
    ///          manifest.</p>
    public let roleArn: String?
    /// <p>A set of tags to associate with the S3 Batch Operations job. This is an optional parameter. </p>
    public let tags: [S3Tag]?

    public init (
        accountId: String? = nil,
        clientRequestToken: String? = nil,
        confirmationRequired: Bool = false,
        description: String? = nil,
        manifest: JobManifest? = nil,
        operation: JobOperation? = nil,
        priority: Int = 0,
        report: JobReport? = nil,
        roleArn: String? = nil,
        tags: [S3Tag]? = nil
    )
    {
        self.accountId = accountId
        self.clientRequestToken = clientRequestToken
        self.confirmationRequired = confirmationRequired
        self.description = description
        self.manifest = manifest
        self.operation = operation
        self.priority = priority
        self.report = report
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateJobInputBody: Equatable {
    public let confirmationRequired: Bool
    public let operation: JobOperation?
    public let report: JobReport?
    public let clientRequestToken: String?
    public let manifest: JobManifest?
    public let description: String?
    public let priority: Int
    public let roleArn: String?
    public let tags: [S3Tag]?
}

extension CreateJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case confirmationRequired = "ConfirmationRequired"
        case description = "Description"
        case manifest = "Manifest"
        case operation = "Operation"
        case priority = "Priority"
        case report = "Report"
        case roleArn = "RoleArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confirmationRequiredDecoded = try containerValues.decode(Bool.self, forKey: .confirmationRequired)
        confirmationRequired = confirmationRequiredDecoded
        let operationDecoded = try containerValues.decodeIfPresent(JobOperation.self, forKey: .operation)
        operation = operationDecoded
        let reportDecoded = try containerValues.decodeIfPresent(JobReport.self, forKey: .report)
        report = reportDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let manifestDecoded = try containerValues.decodeIfPresent(JobManifest.self, forKey: .manifest)
        manifest = manifestDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3Tag].self, forKey: .member)
                var tagsBuffer:[S3Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotencyException" : self = .idempotencyException(try IdempotencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateJobOutputError: Equatable {
    case badRequestException(BadRequestException)
    case idempotencyException(IdempotencyException)
    case internalServiceException(InternalServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJobOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension CreateJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct CreateJobOutputResponse: Equatable {
    /// <p>The ID for this job. Amazon S3 generates this ID automatically and returns it after a
    ///          successful <code>Create Job</code> request.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CreateJobOutputResponseBody: Equatable {
    public let jobId: String?
}

extension CreateJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DeleteAccessPointForObjectLambdaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessPointForObjectLambdaInput(accountId: \(String(describing: accountId)), name: \(String(describing: name)))"}
}

extension DeleteAccessPointForObjectLambdaInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAccessPointForObjectLambdaInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAccessPointForObjectLambdaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessPointForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessPointForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessPointForObjectLambdaInput>
    public typealias MOutput = OperationOutput<DeleteAccessPointForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessPointForObjectLambdaOutputError>
}

public struct DeleteAccessPointForObjectLambdaInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAccessPointForObjectLambdaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessPointForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessPointForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessPointForObjectLambdaInput>
    public typealias MOutput = OperationOutput<DeleteAccessPointForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessPointForObjectLambdaOutputError>
}

public struct DeleteAccessPointForObjectLambdaInput: Equatable {
    /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
    public let accountId: String?
    /// <p>The name of the access point you want to delete.</p>
    public let name: String?

    public init (
        accountId: String? = nil,
        name: String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct DeleteAccessPointForObjectLambdaInputBody: Equatable {
}

extension DeleteAccessPointForObjectLambdaInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAccessPointForObjectLambdaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteAccessPointForObjectLambdaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccessPointForObjectLambdaOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessPointForObjectLambdaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessPointForObjectLambdaOutputResponse()"}
}

extension DeleteAccessPointForObjectLambdaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessPointForObjectLambdaOutputResponse: Equatable {

    public init() {}
}

struct DeleteAccessPointForObjectLambdaOutputResponseBody: Equatable {
}

extension DeleteAccessPointForObjectLambdaOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAccessPointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessPointInput(accountId: \(String(describing: accountId)), name: \(String(describing: name)))"}
}

extension DeleteAccessPointInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAccessPointInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAccessPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessPointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessPointInput>
    public typealias MOutput = OperationOutput<DeleteAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessPointOutputError>
}

public struct DeleteAccessPointInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAccessPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessPointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessPointInput>
    public typealias MOutput = OperationOutput<DeleteAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessPointOutputError>
}

public struct DeleteAccessPointInput: Equatable {
    /// <p>The account ID for the account that owns the specified access point.</p>
    public let accountId: String?
    /// <p>The name of the access point you want to delete.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the access point accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/accesspoint/<my-accesspoint-name></code>. For example, to access the access point <code>reports-ap</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap</code>. The value must be URL encoded. </p>
    public let name: String?

    public init (
        accountId: String? = nil,
        name: String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct DeleteAccessPointInputBody: Equatable {
}

extension DeleteAccessPointInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAccessPointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteAccessPointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccessPointOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessPointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessPointOutputResponse()"}
}

extension DeleteAccessPointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessPointOutputResponse: Equatable {

    public init() {}
}

struct DeleteAccessPointOutputResponseBody: Equatable {
}

extension DeleteAccessPointOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAccessPointPolicyForObjectLambdaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessPointPolicyForObjectLambdaInput(accountId: \(String(describing: accountId)), name: \(String(describing: name)))"}
}

extension DeleteAccessPointPolicyForObjectLambdaInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAccessPointPolicyForObjectLambdaInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAccessPointPolicyForObjectLambdaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessPointPolicyForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessPointPolicyForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessPointPolicyForObjectLambdaInput>
    public typealias MOutput = OperationOutput<DeleteAccessPointPolicyForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessPointPolicyForObjectLambdaOutputError>
}

public struct DeleteAccessPointPolicyForObjectLambdaInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAccessPointPolicyForObjectLambdaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessPointPolicyForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessPointPolicyForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessPointPolicyForObjectLambdaInput>
    public typealias MOutput = OperationOutput<DeleteAccessPointPolicyForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessPointPolicyForObjectLambdaOutputError>
}

public struct DeleteAccessPointPolicyForObjectLambdaInput: Equatable {
    /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
    public let accountId: String?
    /// <p>The name of the Object Lambda Access Point you want to delete the policy for.</p>
    public let name: String?

    public init (
        accountId: String? = nil,
        name: String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct DeleteAccessPointPolicyForObjectLambdaInputBody: Equatable {
}

extension DeleteAccessPointPolicyForObjectLambdaInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAccessPointPolicyForObjectLambdaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteAccessPointPolicyForObjectLambdaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccessPointPolicyForObjectLambdaOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessPointPolicyForObjectLambdaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessPointPolicyForObjectLambdaOutputResponse()"}
}

extension DeleteAccessPointPolicyForObjectLambdaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessPointPolicyForObjectLambdaOutputResponse: Equatable {

    public init() {}
}

struct DeleteAccessPointPolicyForObjectLambdaOutputResponseBody: Equatable {
}

extension DeleteAccessPointPolicyForObjectLambdaOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAccessPointPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessPointPolicyInput(accountId: \(String(describing: accountId)), name: \(String(describing: name)))"}
}

extension DeleteAccessPointPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAccessPointPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAccessPointPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessPointPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessPointPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessPointPolicyInput>
    public typealias MOutput = OperationOutput<DeleteAccessPointPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessPointPolicyOutputError>
}

public struct DeleteAccessPointPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAccessPointPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessPointPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessPointPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessPointPolicyInput>
    public typealias MOutput = OperationOutput<DeleteAccessPointPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessPointPolicyOutputError>
}

public struct DeleteAccessPointPolicyInput: Equatable {
    /// <p>The account ID for the account that owns the specified access point.</p>
    public let accountId: String?
    /// <p>The name of the access point whose policy you want to delete.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the access point accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/accesspoint/<my-accesspoint-name></code>. For example, to access the access point <code>reports-ap</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap</code>. The value must be URL encoded. </p>
    public let name: String?

    public init (
        accountId: String? = nil,
        name: String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct DeleteAccessPointPolicyInputBody: Equatable {
}

extension DeleteAccessPointPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAccessPointPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteAccessPointPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccessPointPolicyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessPointPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessPointPolicyOutputResponse()"}
}

extension DeleteAccessPointPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessPointPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteAccessPointPolicyOutputResponseBody: Equatable {
}

extension DeleteAccessPointPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketInput(accountId: \(String(describing: accountId)), bucket: \(String(describing: bucket)))"}
}

extension DeleteBucketInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketInput>
    public typealias MOutput = OperationOutput<DeleteBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketOutputError>
}

public struct DeleteBucketInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketInput>
    public typealias MOutput = OperationOutput<DeleteBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketOutputError>
}

public struct DeleteBucketInput: Equatable {
    /// <p>The account ID that owns the Outposts bucket.</p>
    public let accountId: String?
    /// <p>Specifies the bucket being deleted.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
    public let bucket: String?

    public init (
        accountId: String? = nil,
        bucket: String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct DeleteBucketInputBody: Equatable {
}

extension DeleteBucketInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketLifecycleConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketLifecycleConfigurationInput(accountId: \(String(describing: accountId)), bucket: \(String(describing: bucket)))"}
}

extension DeleteBucketLifecycleConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketLifecycleConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketLifecycleConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteBucketLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketLifecycleConfigurationOutputError>
}

public struct DeleteBucketLifecycleConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketLifecycleConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteBucketLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketLifecycleConfigurationOutputError>
}

public struct DeleteBucketLifecycleConfigurationInput: Equatable {
    /// <p>The account ID of the lifecycle configuration to delete.</p>
    public let accountId: String?
    /// <p>Specifies the bucket.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
    public let bucket: String?

    public init (
        accountId: String? = nil,
        bucket: String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct DeleteBucketLifecycleConfigurationInputBody: Equatable {
}

extension DeleteBucketLifecycleConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketLifecycleConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketLifecycleConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketLifecycleConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketLifecycleConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketLifecycleConfigurationOutputResponse()"}
}

extension DeleteBucketLifecycleConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketLifecycleConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketLifecycleConfigurationOutputResponseBody: Equatable {
}

extension DeleteBucketLifecycleConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketOutputResponse()"}
}

extension DeleteBucketOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketOutputResponseBody: Equatable {
}

extension DeleteBucketOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketPolicyInput(accountId: \(String(describing: accountId)), bucket: \(String(describing: bucket)))"}
}

extension DeleteBucketPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketPolicyInput>
    public typealias MOutput = OperationOutput<DeleteBucketPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketPolicyOutputError>
}

public struct DeleteBucketPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketPolicyInput>
    public typealias MOutput = OperationOutput<DeleteBucketPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketPolicyOutputError>
}

public struct DeleteBucketPolicyInput: Equatable {
    /// <p>The account ID of the Outposts bucket.</p>
    public let accountId: String?
    /// <p>Specifies the bucket.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
    public let bucket: String?

    public init (
        accountId: String? = nil,
        bucket: String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct DeleteBucketPolicyInputBody: Equatable {
}

extension DeleteBucketPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketPolicyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketPolicyOutputResponse()"}
}

extension DeleteBucketPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketPolicyOutputResponseBody: Equatable {
}

extension DeleteBucketPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketTaggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketTaggingInput(accountId: \(String(describing: accountId)), bucket: \(String(describing: bucket)))"}
}

extension DeleteBucketTaggingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBucketTaggingInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBucketTaggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketTaggingInput>
    public typealias MOutput = OperationOutput<DeleteBucketTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketTaggingOutputError>
}

public struct DeleteBucketTaggingInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBucketTaggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBucketTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBucketTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBucketTaggingInput>
    public typealias MOutput = OperationOutput<DeleteBucketTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBucketTaggingOutputError>
}

public struct DeleteBucketTaggingInput: Equatable {
    /// <p>The AWS account ID of the Outposts bucket tag set to be removed.</p>
    public let accountId: String?
    /// <p>The bucket ARN that has the tag set to be removed.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
    public let bucket: String?

    public init (
        accountId: String? = nil,
        bucket: String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct DeleteBucketTaggingInputBody: Equatable {
}

extension DeleteBucketTaggingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBucketTaggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteBucketTaggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBucketTaggingOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBucketTaggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBucketTaggingOutputResponse()"}
}

extension DeleteBucketTaggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBucketTaggingOutputResponse: Equatable {

    public init() {}
}

struct DeleteBucketTaggingOutputResponseBody: Equatable {
}

extension DeleteBucketTaggingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteJobTaggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJobTaggingInput(accountId: \(String(describing: accountId)), jobId: \(String(describing: jobId)))"}
}

extension DeleteJobTaggingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteJobTaggingInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteJobTaggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobTaggingInput>
    public typealias MOutput = OperationOutput<DeleteJobTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobTaggingOutputError>
}

public struct DeleteJobTaggingInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteJobTaggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobTaggingInput>
    public typealias MOutput = OperationOutput<DeleteJobTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobTaggingOutputError>
}

public struct DeleteJobTaggingInput: Equatable {
    /// <p>The AWS account ID associated with the S3 Batch Operations job.</p>
    public let accountId: String?
    /// <p>The ID for the S3 Batch Operations job whose tags you want to delete.</p>
    public let jobId: String?

    public init (
        accountId: String? = nil,
        jobId: String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
    }
}

struct DeleteJobTaggingInputBody: Equatable {
}

extension DeleteJobTaggingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteJobTaggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteJobTaggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteJobTaggingOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteJobTaggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJobTaggingOutputResponse()"}
}

extension DeleteJobTaggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteJobTaggingOutputResponse: Equatable {

    public init() {}
}

struct DeleteJobTaggingOutputResponseBody: Equatable {
}

extension DeleteJobTaggingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePublicAccessBlockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePublicAccessBlockInput(accountId: \(String(describing: accountId)))"}
}

extension DeletePublicAccessBlockInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeletePublicAccessBlockInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePublicAccessBlockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePublicAccessBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePublicAccessBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePublicAccessBlockInput>
    public typealias MOutput = OperationOutput<DeletePublicAccessBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePublicAccessBlockOutputError>
}

public struct DeletePublicAccessBlockInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePublicAccessBlockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePublicAccessBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePublicAccessBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePublicAccessBlockInput>
    public typealias MOutput = OperationOutput<DeletePublicAccessBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePublicAccessBlockOutputError>
}

public struct DeletePublicAccessBlockInput: Equatable {
    /// <p>The account ID for the AWS account whose <code>PublicAccessBlock</code> configuration you want
    ///          to remove.</p>
    public let accountId: String?

    public init (
        accountId: String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct DeletePublicAccessBlockInputBody: Equatable {
}

extension DeletePublicAccessBlockInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePublicAccessBlockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeletePublicAccessBlockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePublicAccessBlockOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePublicAccessBlockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePublicAccessBlockOutputResponse()"}
}

extension DeletePublicAccessBlockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePublicAccessBlockOutputResponse: Equatable {

    public init() {}
}

struct DeletePublicAccessBlockOutputResponseBody: Equatable {
}

extension DeletePublicAccessBlockOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStorageLensConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStorageLensConfigurationInput(accountId: \(String(describing: accountId)), configId: \(String(describing: configId)))"}
}

extension DeleteStorageLensConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteStorageLensConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStorageLensConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStorageLensConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStorageLensConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStorageLensConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteStorageLensConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStorageLensConfigurationOutputError>
}

public struct DeleteStorageLensConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStorageLensConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStorageLensConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStorageLensConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStorageLensConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteStorageLensConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStorageLensConfigurationOutputError>
}

public struct DeleteStorageLensConfigurationInput: Equatable {
    /// <p>The account ID of the requester.</p>
    public let accountId: String?
    /// <p>The ID of the S3 Storage Lens configuration.</p>
    public let configId: String?

    public init (
        accountId: String? = nil,
        configId: String? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
    }
}

struct DeleteStorageLensConfigurationInputBody: Equatable {
}

extension DeleteStorageLensConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStorageLensConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteStorageLensConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStorageLensConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStorageLensConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStorageLensConfigurationOutputResponse()"}
}

extension DeleteStorageLensConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStorageLensConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteStorageLensConfigurationOutputResponseBody: Equatable {
}

extension DeleteStorageLensConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStorageLensConfigurationTaggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStorageLensConfigurationTaggingInput(accountId: \(String(describing: accountId)), configId: \(String(describing: configId)))"}
}

extension DeleteStorageLensConfigurationTaggingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteStorageLensConfigurationTaggingInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStorageLensConfigurationTaggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStorageLensConfigurationTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStorageLensConfigurationTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStorageLensConfigurationTaggingInput>
    public typealias MOutput = OperationOutput<DeleteStorageLensConfigurationTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStorageLensConfigurationTaggingOutputError>
}

public struct DeleteStorageLensConfigurationTaggingInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStorageLensConfigurationTaggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStorageLensConfigurationTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStorageLensConfigurationTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStorageLensConfigurationTaggingInput>
    public typealias MOutput = OperationOutput<DeleteStorageLensConfigurationTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStorageLensConfigurationTaggingOutputError>
}

public struct DeleteStorageLensConfigurationTaggingInput: Equatable {
    /// <p>The account ID of the requester.</p>
    public let accountId: String?
    /// <p>The ID of the S3 Storage Lens configuration.</p>
    public let configId: String?

    public init (
        accountId: String? = nil,
        configId: String? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
    }
}

struct DeleteStorageLensConfigurationTaggingInputBody: Equatable {
}

extension DeleteStorageLensConfigurationTaggingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStorageLensConfigurationTaggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteStorageLensConfigurationTaggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStorageLensConfigurationTaggingOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStorageLensConfigurationTaggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStorageLensConfigurationTaggingOutputResponse()"}
}

extension DeleteStorageLensConfigurationTaggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStorageLensConfigurationTaggingOutputResponse: Equatable {

    public init() {}
}

struct DeleteStorageLensConfigurationTaggingOutputResponseBody: Equatable {
}

extension DeleteStorageLensConfigurationTaggingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobInput(accountId: \(String(describing: accountId)), jobId: \(String(describing: jobId)))"}
}

extension DescribeJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobInput>
    public typealias MOutput = OperationOutput<DescribeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobOutputError>
}

public struct DescribeJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobInput>
    public typealias MOutput = OperationOutput<DescribeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobOutputError>
}

public struct DescribeJobInput: Equatable {
    /// <p>The AWS account ID associated with the S3 Batch Operations job.</p>
    public let accountId: String?
    /// <p>The ID for the job whose information you want to retrieve.</p>
    public let jobId: String?

    public init (
        accountId: String? = nil,
        jobId: String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
    }
}

struct DescribeJobInputBody: Equatable {
}

extension DescribeJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobOutputResponse(job: \(String(describing: job)))"}
}

extension DescribeJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct DescribeJobOutputResponse: Equatable {
    /// <p>Contains the configuration parameters and status for the job specified in the <code>Describe Job</code> request.</p>
    public let job: JobDescriptor?

    public init (
        job: JobDescriptor? = nil
    )
    {
        self.job = job
    }
}

struct DescribeJobOutputResponseBody: Equatable {
    public let job: JobDescriptor?
}

extension DescribeJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job = "Job"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(JobDescriptor.self, forKey: .job)
        job = jobDecoded
    }
}

extension Exclude: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case buckets = "Buckets"
        case regions = "Regions"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let buckets = buckets {
            var bucketsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("buckets"))
            for s3bucketarnstring0 in buckets {
                try bucketsContainer.encode(s3bucketarnstring0, forKey: Key("Arn"))
            }
        }
        if let regions = regions {
            var regionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("regions"))
            for s3awsregion0 in regions {
                try regionsContainer.encode(s3awsregion0, forKey: Key("Region"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.buckets) {
            struct KeyVal0{struct Arn{}}
            let bucketsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Arn>.CodingKeys.self, forKey: .buckets)
            if let bucketsWrappedContainer = bucketsWrappedContainer {
                let bucketsContainer = try bucketsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var bucketsBuffer:[String]? = nil
                if let bucketsContainer = bucketsContainer {
                    bucketsBuffer = [String]()
                    for stringContainer0 in bucketsContainer {
                        bucketsBuffer?.append(stringContainer0)
                    }
                }
                buckets = bucketsBuffer
            } else {
                buckets = []
            }
        } else {
            buckets = nil
        }
        if containerValues.contains(.regions) {
            struct KeyVal0{struct Region{}}
            let regionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Region>.CodingKeys.self, forKey: .regions)
            if let regionsWrappedContainer = regionsWrappedContainer {
                let regionsContainer = try regionsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var regionsBuffer:[String]? = nil
                if let regionsContainer = regionsContainer {
                    regionsBuffer = [String]()
                    for stringContainer0 in regionsContainer {
                        regionsBuffer?.append(stringContainer0)
                    }
                }
                regions = regionsBuffer
            } else {
                regions = []
            }
        } else {
            regions = nil
        }
    }
}

extension Exclude: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Exclude(buckets: \(String(describing: buckets)), regions: \(String(describing: regions)))"}
}

extension Exclude: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for what Amazon S3 Storage Lens will exclude.</p>
public struct Exclude: Equatable {
    /// <p>A container for the S3 Storage Lens bucket excludes.</p>
    public let buckets: [String]?
    /// <p>A container for the S3 Storage Lens Region excludes.</p>
    public let regions: [String]?

    public init (
        buckets: [String]? = nil,
        regions: [String]? = nil
    )
    {
        self.buckets = buckets
        self.regions = regions
    }
}

public enum ExpirationStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension ExpirationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExpirationStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExpirationStatus(rawValue: rawValue) ?? ExpirationStatus.sdkUnknown(rawValue)
    }
}

public enum Format {
    case csv
    case parquet
    case sdkUnknown(String)
}

extension Format : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Format] {
        return [
            .csv,
            .parquet,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case .parquet: return "Parquet"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
    }
}

extension GetAccessPointConfigurationForObjectLambdaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessPointConfigurationForObjectLambdaInput(accountId: \(String(describing: accountId)), name: \(String(describing: name)))"}
}

extension GetAccessPointConfigurationForObjectLambdaInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAccessPointConfigurationForObjectLambdaInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccessPointConfigurationForObjectLambdaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessPointConfigurationForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessPointConfigurationForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessPointConfigurationForObjectLambdaInput>
    public typealias MOutput = OperationOutput<GetAccessPointConfigurationForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessPointConfigurationForObjectLambdaOutputError>
}

public struct GetAccessPointConfigurationForObjectLambdaInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccessPointConfigurationForObjectLambdaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessPointConfigurationForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessPointConfigurationForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessPointConfigurationForObjectLambdaInput>
    public typealias MOutput = OperationOutput<GetAccessPointConfigurationForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessPointConfigurationForObjectLambdaOutputError>
}

public struct GetAccessPointConfigurationForObjectLambdaInput: Equatable {
    /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
    public let accountId: String?
    /// <p>The name of the Object Lambda Access Point you want to return the configuration for.</p>
    public let name: String?

    public init (
        accountId: String? = nil,
        name: String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetAccessPointConfigurationForObjectLambdaInputBody: Equatable {
}

extension GetAccessPointConfigurationForObjectLambdaInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAccessPointConfigurationForObjectLambdaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccessPointConfigurationForObjectLambdaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessPointConfigurationForObjectLambdaOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessPointConfigurationForObjectLambdaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessPointConfigurationForObjectLambdaOutputResponse(configuration: \(String(describing: configuration)))"}
}

extension GetAccessPointConfigurationForObjectLambdaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccessPointConfigurationForObjectLambdaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configuration = output.configuration
        } else {
            self.configuration = nil
        }
    }
}

public struct GetAccessPointConfigurationForObjectLambdaOutputResponse: Equatable {
    /// <p>Object Lambda Access Point configuration document.</p>
    public let configuration: ObjectLambdaConfiguration?

    public init (
        configuration: ObjectLambdaConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct GetAccessPointConfigurationForObjectLambdaOutputResponseBody: Equatable {
    public let configuration: ObjectLambdaConfiguration?
}

extension GetAccessPointConfigurationForObjectLambdaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(ObjectLambdaConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension GetAccessPointForObjectLambdaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessPointForObjectLambdaInput(accountId: \(String(describing: accountId)), name: \(String(describing: name)))"}
}

extension GetAccessPointForObjectLambdaInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAccessPointForObjectLambdaInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccessPointForObjectLambdaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessPointForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessPointForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessPointForObjectLambdaInput>
    public typealias MOutput = OperationOutput<GetAccessPointForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessPointForObjectLambdaOutputError>
}

public struct GetAccessPointForObjectLambdaInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccessPointForObjectLambdaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessPointForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessPointForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessPointForObjectLambdaInput>
    public typealias MOutput = OperationOutput<GetAccessPointForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessPointForObjectLambdaOutputError>
}

public struct GetAccessPointForObjectLambdaInput: Equatable {
    /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
    public let accountId: String?
    /// <p>The name of the Object Lambda Access Point.</p>
    public let name: String?

    public init (
        accountId: String? = nil,
        name: String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetAccessPointForObjectLambdaInputBody: Equatable {
}

extension GetAccessPointForObjectLambdaInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAccessPointForObjectLambdaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccessPointForObjectLambdaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessPointForObjectLambdaOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessPointForObjectLambdaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessPointForObjectLambdaOutputResponse(creationDate: \(String(describing: creationDate)), name: \(String(describing: name)), publicAccessBlockConfiguration: \(String(describing: publicAccessBlockConfiguration)))"}
}

extension GetAccessPointForObjectLambdaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccessPointForObjectLambdaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.name = output.name
            self.publicAccessBlockConfiguration = output.publicAccessBlockConfiguration
        } else {
            self.creationDate = nil
            self.name = nil
            self.publicAccessBlockConfiguration = nil
        }
    }
}

public struct GetAccessPointForObjectLambdaOutputResponse: Equatable {
    /// <p>The date and time when the specified Object Lambda Access Point was created.</p>
    public let creationDate: Date?
    /// <p>The name of the Object Lambda Access Point.</p>
    public let name: String?
    /// <p>Configuration to block all public access. This setting is turned on and can not be edited. </p>
    public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?

    public init (
        creationDate: Date? = nil,
        name: String? = nil,
        publicAccessBlockConfiguration: PublicAccessBlockConfiguration? = nil
    )
    {
        self.creationDate = creationDate
        self.name = name
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
    }
}

struct GetAccessPointForObjectLambdaOutputResponseBody: Equatable {
    public let name: String?
    public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?
    public let creationDate: Date?
}

extension GetAccessPointForObjectLambdaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case name = "Name"
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        var creationDateBuffer:Date? = nil
        if let creationDateDecoded = creationDateDecoded {
            creationDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationDateDecoded, format: .dateTime)
        }
        creationDate = creationDateBuffer
    }
}

extension GetAccessPointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessPointInput(accountId: \(String(describing: accountId)), name: \(String(describing: name)))"}
}

extension GetAccessPointInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAccessPointInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccessPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessPointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessPointInput>
    public typealias MOutput = OperationOutput<GetAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessPointOutputError>
}

public struct GetAccessPointInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccessPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessPointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessPointInput>
    public typealias MOutput = OperationOutput<GetAccessPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessPointOutputError>
}

public struct GetAccessPointInput: Equatable {
    /// <p>The account ID for the account that owns the specified access point.</p>
    public let accountId: String?
    /// <p>The name of the access point whose configuration information you want to retrieve.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the access point accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/accesspoint/<my-accesspoint-name></code>. For example, to access the access point <code>reports-ap</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap</code>. The value must be URL encoded. </p>
    public let name: String?

    public init (
        accountId: String? = nil,
        name: String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetAccessPointInputBody: Equatable {
}

extension GetAccessPointInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAccessPointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccessPointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessPointOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessPointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessPointOutputResponse(bucket: \(String(describing: bucket)), creationDate: \(String(describing: creationDate)), name: \(String(describing: name)), networkOrigin: \(String(describing: networkOrigin)), publicAccessBlockConfiguration: \(String(describing: publicAccessBlockConfiguration)), vpcConfiguration: \(String(describing: vpcConfiguration)))"}
}

extension GetAccessPointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccessPointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bucket = output.bucket
            self.creationDate = output.creationDate
            self.name = output.name
            self.networkOrigin = output.networkOrigin
            self.publicAccessBlockConfiguration = output.publicAccessBlockConfiguration
            self.vpcConfiguration = output.vpcConfiguration
        } else {
            self.bucket = nil
            self.creationDate = nil
            self.name = nil
            self.networkOrigin = nil
            self.publicAccessBlockConfiguration = nil
            self.vpcConfiguration = nil
        }
    }
}

public struct GetAccessPointOutputResponse: Equatable {
    /// <p>The name of the bucket associated with the specified access point.</p>
    public let bucket: String?
    /// <p>The date and time when the specified access point was created.</p>
    public let creationDate: Date?
    /// <p>The name of the specified access point.</p>
    public let name: String?
    /// <p>Indicates whether this access point allows access from the public internet. If
    ///             <code>VpcConfiguration</code> is specified for this access point, then
    ///             <code>NetworkOrigin</code> is <code>VPC</code>, and the access point doesn't allow access from
    ///          the public internet. Otherwise, <code>NetworkOrigin</code> is <code>Internet</code>, and
    ///          the access point allows access from the public internet, subject to the access point and bucket access
    ///          policies.</p>
    ///          <p>This will always be true for an Amazon S3 on Outposts access point</p>
    public let networkOrigin: NetworkOrigin?
    /// <p>The <code>PublicAccessBlock</code> configuration that you want to apply to this Amazon S3 account.
    ///          You can enable the configuration options in any combination. For more information about
    ///          when Amazon S3 considers a bucket or object public, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status">The Meaning of "Public"</a> in the <i>Amazon S3 User Guide</i>.</p>
    ///          <p>This is not supported for Amazon S3 on Outposts.</p>
    public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?
    /// <p>Contains the virtual private cloud (VPC) configuration for the specified access point.</p>
    ///          <note>
    ///             <p>This element is empty if this access point is an Amazon S3 on Outposts access point that is used by other AWS services.</p>
    ///          </note>
    public let vpcConfiguration: VpcConfiguration?

    public init (
        bucket: String? = nil,
        creationDate: Date? = nil,
        name: String? = nil,
        networkOrigin: NetworkOrigin? = nil,
        publicAccessBlockConfiguration: PublicAccessBlockConfiguration? = nil,
        vpcConfiguration: VpcConfiguration? = nil
    )
    {
        self.bucket = bucket
        self.creationDate = creationDate
        self.name = name
        self.networkOrigin = networkOrigin
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
        self.vpcConfiguration = vpcConfiguration
    }
}

struct GetAccessPointOutputResponseBody: Equatable {
    public let name: String?
    public let bucket: String?
    public let networkOrigin: NetworkOrigin?
    public let vpcConfiguration: VpcConfiguration?
    public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?
    public let creationDate: Date?
}

extension GetAccessPointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case creationDate = "CreationDate"
        case name = "Name"
        case networkOrigin = "NetworkOrigin"
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        case vpcConfiguration = "VpcConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let networkOriginDecoded = try containerValues.decodeIfPresent(NetworkOrigin.self, forKey: .networkOrigin)
        networkOrigin = networkOriginDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        var creationDateBuffer:Date? = nil
        if let creationDateDecoded = creationDateDecoded {
            creationDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationDateDecoded, format: .dateTime)
        }
        creationDate = creationDateBuffer
    }
}

extension GetAccessPointPolicyForObjectLambdaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessPointPolicyForObjectLambdaInput(accountId: \(String(describing: accountId)), name: \(String(describing: name)))"}
}

extension GetAccessPointPolicyForObjectLambdaInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAccessPointPolicyForObjectLambdaInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccessPointPolicyForObjectLambdaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessPointPolicyForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessPointPolicyForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessPointPolicyForObjectLambdaInput>
    public typealias MOutput = OperationOutput<GetAccessPointPolicyForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessPointPolicyForObjectLambdaOutputError>
}

public struct GetAccessPointPolicyForObjectLambdaInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccessPointPolicyForObjectLambdaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessPointPolicyForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessPointPolicyForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessPointPolicyForObjectLambdaInput>
    public typealias MOutput = OperationOutput<GetAccessPointPolicyForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessPointPolicyForObjectLambdaOutputError>
}

public struct GetAccessPointPolicyForObjectLambdaInput: Equatable {
    /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
    public let accountId: String?
    /// <p>The name of the Object Lambda Access Point.</p>
    public let name: String?

    public init (
        accountId: String? = nil,
        name: String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetAccessPointPolicyForObjectLambdaInputBody: Equatable {
}

extension GetAccessPointPolicyForObjectLambdaInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAccessPointPolicyForObjectLambdaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccessPointPolicyForObjectLambdaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessPointPolicyForObjectLambdaOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessPointPolicyForObjectLambdaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessPointPolicyForObjectLambdaOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetAccessPointPolicyForObjectLambdaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccessPointPolicyForObjectLambdaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetAccessPointPolicyForObjectLambdaOutputResponse: Equatable {
    /// <p>Object Lambda Access Point resource policy document.</p>
    public let policy: String?

    public init (
        policy: String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetAccessPointPolicyForObjectLambdaOutputResponseBody: Equatable {
    public let policy: String?
}

extension GetAccessPointPolicyForObjectLambdaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetAccessPointPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessPointPolicyInput(accountId: \(String(describing: accountId)), name: \(String(describing: name)))"}
}

extension GetAccessPointPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAccessPointPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccessPointPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessPointPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessPointPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessPointPolicyInput>
    public typealias MOutput = OperationOutput<GetAccessPointPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessPointPolicyOutputError>
}

public struct GetAccessPointPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccessPointPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessPointPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessPointPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessPointPolicyInput>
    public typealias MOutput = OperationOutput<GetAccessPointPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessPointPolicyOutputError>
}

public struct GetAccessPointPolicyInput: Equatable {
    /// <p>The account ID for the account that owns the specified access point.</p>
    public let accountId: String?
    /// <p>The name of the access point whose policy you want to retrieve.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the access point accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/accesspoint/<my-accesspoint-name></code>. For example, to access the access point <code>reports-ap</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap</code>. The value must be URL encoded. </p>
    public let name: String?

    public init (
        accountId: String? = nil,
        name: String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetAccessPointPolicyInputBody: Equatable {
}

extension GetAccessPointPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAccessPointPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccessPointPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessPointPolicyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessPointPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessPointPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetAccessPointPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccessPointPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetAccessPointPolicyOutputResponse: Equatable {
    /// <p>The access point policy associated with the specified access point.</p>
    public let policy: String?

    public init (
        policy: String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetAccessPointPolicyOutputResponseBody: Equatable {
    public let policy: String?
}

extension GetAccessPointPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetAccessPointPolicyStatusForObjectLambdaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessPointPolicyStatusForObjectLambdaInput(accountId: \(String(describing: accountId)), name: \(String(describing: name)))"}
}

extension GetAccessPointPolicyStatusForObjectLambdaInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAccessPointPolicyStatusForObjectLambdaInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccessPointPolicyStatusForObjectLambdaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessPointPolicyStatusForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessPointPolicyStatusForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessPointPolicyStatusForObjectLambdaInput>
    public typealias MOutput = OperationOutput<GetAccessPointPolicyStatusForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessPointPolicyStatusForObjectLambdaOutputError>
}

public struct GetAccessPointPolicyStatusForObjectLambdaInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccessPointPolicyStatusForObjectLambdaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessPointPolicyStatusForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessPointPolicyStatusForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessPointPolicyStatusForObjectLambdaInput>
    public typealias MOutput = OperationOutput<GetAccessPointPolicyStatusForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessPointPolicyStatusForObjectLambdaOutputError>
}

public struct GetAccessPointPolicyStatusForObjectLambdaInput: Equatable {
    /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
    public let accountId: String?
    /// <p>The name of the Object Lambda Access Point.</p>
    public let name: String?

    public init (
        accountId: String? = nil,
        name: String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetAccessPointPolicyStatusForObjectLambdaInputBody: Equatable {
}

extension GetAccessPointPolicyStatusForObjectLambdaInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAccessPointPolicyStatusForObjectLambdaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccessPointPolicyStatusForObjectLambdaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessPointPolicyStatusForObjectLambdaOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessPointPolicyStatusForObjectLambdaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessPointPolicyStatusForObjectLambdaOutputResponse(policyStatus: \(String(describing: policyStatus)))"}
}

extension GetAccessPointPolicyStatusForObjectLambdaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccessPointPolicyStatusForObjectLambdaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyStatus = output.policyStatus
        } else {
            self.policyStatus = nil
        }
    }
}

public struct GetAccessPointPolicyStatusForObjectLambdaOutputResponse: Equatable {
    /// <p>Indicates whether this access point policy is public. For more information about how Amazon S3 evaluates policies to determine whether they are public, see
    ///          <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status">The Meaning of "Public"</a> in the
    /// 	 <i>Amazon S3 User Guide</i>.
    ///       </p>
    public let policyStatus: PolicyStatus?

    public init (
        policyStatus: PolicyStatus? = nil
    )
    {
        self.policyStatus = policyStatus
    }
}

struct GetAccessPointPolicyStatusForObjectLambdaOutputResponseBody: Equatable {
    public let policyStatus: PolicyStatus?
}

extension GetAccessPointPolicyStatusForObjectLambdaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyStatus = "PolicyStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStatusDecoded = try containerValues.decodeIfPresent(PolicyStatus.self, forKey: .policyStatus)
        policyStatus = policyStatusDecoded
    }
}

extension GetAccessPointPolicyStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessPointPolicyStatusInput(accountId: \(String(describing: accountId)), name: \(String(describing: name)))"}
}

extension GetAccessPointPolicyStatusInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAccessPointPolicyStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccessPointPolicyStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessPointPolicyStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessPointPolicyStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessPointPolicyStatusInput>
    public typealias MOutput = OperationOutput<GetAccessPointPolicyStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessPointPolicyStatusOutputError>
}

public struct GetAccessPointPolicyStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccessPointPolicyStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessPointPolicyStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessPointPolicyStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessPointPolicyStatusInput>
    public typealias MOutput = OperationOutput<GetAccessPointPolicyStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessPointPolicyStatusOutputError>
}

public struct GetAccessPointPolicyStatusInput: Equatable {
    /// <p>The account ID for the account that owns the specified access point.</p>
    public let accountId: String?
    /// <p>The name of the access point whose policy status you want to retrieve.</p>
    public let name: String?

    public init (
        accountId: String? = nil,
        name: String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetAccessPointPolicyStatusInputBody: Equatable {
}

extension GetAccessPointPolicyStatusInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAccessPointPolicyStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccessPointPolicyStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessPointPolicyStatusOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessPointPolicyStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessPointPolicyStatusOutputResponse(policyStatus: \(String(describing: policyStatus)))"}
}

extension GetAccessPointPolicyStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccessPointPolicyStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyStatus = output.policyStatus
        } else {
            self.policyStatus = nil
        }
    }
}

public struct GetAccessPointPolicyStatusOutputResponse: Equatable {
    /// <p>Indicates the current policy status of the specified access point.</p>
    public let policyStatus: PolicyStatus?

    public init (
        policyStatus: PolicyStatus? = nil
    )
    {
        self.policyStatus = policyStatus
    }
}

struct GetAccessPointPolicyStatusOutputResponseBody: Equatable {
    public let policyStatus: PolicyStatus?
}

extension GetAccessPointPolicyStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyStatus = "PolicyStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStatusDecoded = try containerValues.decodeIfPresent(PolicyStatus.self, forKey: .policyStatus)
        policyStatus = policyStatusDecoded
    }
}

extension GetBucketInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketInput(accountId: \(String(describing: accountId)), bucket: \(String(describing: bucket)))"}
}

extension GetBucketInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketInput>
    public typealias MOutput = OperationOutput<GetBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketOutputError>
}

public struct GetBucketInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketInput>
    public typealias MOutput = OperationOutput<GetBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketOutputError>
}

public struct GetBucketInput: Equatable {
    /// <p>The AWS account ID of the Outposts bucket.</p>
    public let accountId: String?
    /// <p>Specifies the bucket.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
    public let bucket: String?

    public init (
        accountId: String? = nil,
        bucket: String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct GetBucketInputBody: Equatable {
}

extension GetBucketInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketLifecycleConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketLifecycleConfigurationInput(accountId: \(String(describing: accountId)), bucket: \(String(describing: bucket)))"}
}

extension GetBucketLifecycleConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketLifecycleConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketLifecycleConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<GetBucketLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketLifecycleConfigurationOutputError>
}

public struct GetBucketLifecycleConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketLifecycleConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<GetBucketLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketLifecycleConfigurationOutputError>
}

public struct GetBucketLifecycleConfigurationInput: Equatable {
    /// <p>The AWS account ID of the Outposts bucket.</p>
    public let accountId: String?
    /// <p>The Amazon Resource Name (ARN) of the bucket.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
    public let bucket: String?

    public init (
        accountId: String? = nil,
        bucket: String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct GetBucketLifecycleConfigurationInputBody: Equatable {
}

extension GetBucketLifecycleConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketLifecycleConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketLifecycleConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketLifecycleConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketLifecycleConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketLifecycleConfigurationOutputResponse(rules: \(String(describing: rules)))"}
}

extension GetBucketLifecycleConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBucketLifecycleConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct GetBucketLifecycleConfigurationOutputResponse: Equatable {
    /// <p>Container for the lifecycle rule of the Outposts bucket.</p>
    public let rules: [LifecycleRule]?

    public init (
        rules: [LifecycleRule]? = nil
    )
    {
        self.rules = rules
    }
}

struct GetBucketLifecycleConfigurationOutputResponseBody: Equatable {
    public let rules: [LifecycleRule]?
}

extension GetBucketLifecycleConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rules = "Rules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.rules) {
            struct KeyVal0{struct Rule{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Rule>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([LifecycleRule].self, forKey: .member)
                var rulesBuffer:[LifecycleRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [LifecycleRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension GetBucketOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketOutputResponse(bucket: \(String(describing: bucket)), creationDate: \(String(describing: creationDate)), publicAccessBlockEnabled: \(String(describing: publicAccessBlockEnabled)))"}
}

extension GetBucketOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBucketOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bucket = output.bucket
            self.creationDate = output.creationDate
            self.publicAccessBlockEnabled = output.publicAccessBlockEnabled
        } else {
            self.bucket = nil
            self.creationDate = nil
            self.publicAccessBlockEnabled = false
        }
    }
}

public struct GetBucketOutputResponse: Equatable {
    /// <p>The Outposts bucket requested.</p>
    public let bucket: String?
    /// <p>The creation date of the Outposts bucket.</p>
    public let creationDate: Date?
    /// <p></p>
    public let publicAccessBlockEnabled: Bool

    public init (
        bucket: String? = nil,
        creationDate: Date? = nil,
        publicAccessBlockEnabled: Bool = false
    )
    {
        self.bucket = bucket
        self.creationDate = creationDate
        self.publicAccessBlockEnabled = publicAccessBlockEnabled
    }
}

struct GetBucketOutputResponseBody: Equatable {
    public let bucket: String?
    public let publicAccessBlockEnabled: Bool
    public let creationDate: Date?
}

extension GetBucketOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case creationDate = "CreationDate"
        case publicAccessBlockEnabled = "PublicAccessBlockEnabled"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let publicAccessBlockEnabledDecoded = try containerValues.decode(Bool.self, forKey: .publicAccessBlockEnabled)
        publicAccessBlockEnabled = publicAccessBlockEnabledDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        var creationDateBuffer:Date? = nil
        if let creationDateDecoded = creationDateDecoded {
            creationDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationDateDecoded, format: .dateTime)
        }
        creationDate = creationDateBuffer
    }
}

extension GetBucketPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketPolicyInput(accountId: \(String(describing: accountId)), bucket: \(String(describing: bucket)))"}
}

extension GetBucketPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketPolicyInput>
    public typealias MOutput = OperationOutput<GetBucketPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketPolicyOutputError>
}

public struct GetBucketPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketPolicyInput>
    public typealias MOutput = OperationOutput<GetBucketPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketPolicyOutputError>
}

public struct GetBucketPolicyInput: Equatable {
    /// <p>The AWS account ID of the Outposts bucket.</p>
    public let accountId: String?
    /// <p>Specifies the bucket.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
    public let bucket: String?

    public init (
        accountId: String? = nil,
        bucket: String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct GetBucketPolicyInputBody: Equatable {
}

extension GetBucketPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketPolicyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetBucketPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBucketPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetBucketPolicyOutputResponse: Equatable {
    /// <p>The policy of the Outposts bucket.</p>
    public let policy: String?

    public init (
        policy: String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetBucketPolicyOutputResponseBody: Equatable {
    public let policy: String?
}

extension GetBucketPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetBucketTaggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketTaggingInput(accountId: \(String(describing: accountId)), bucket: \(String(describing: bucket)))"}
}

extension GetBucketTaggingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBucketTaggingInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketTaggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketTaggingInput>
    public typealias MOutput = OperationOutput<GetBucketTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketTaggingOutputError>
}

public struct GetBucketTaggingInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketTaggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketTaggingInput>
    public typealias MOutput = OperationOutput<GetBucketTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketTaggingOutputError>
}

public struct GetBucketTaggingInput: Equatable {
    /// <p>The AWS account ID of the Outposts bucket.</p>
    public let accountId: String?
    /// <p>Specifies the bucket.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
    public let bucket: String?

    public init (
        accountId: String? = nil,
        bucket: String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct GetBucketTaggingInputBody: Equatable {
}

extension GetBucketTaggingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBucketTaggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetBucketTaggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketTaggingOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketTaggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketTaggingOutputResponse(tagSet: \(String(describing: tagSet)))"}
}

extension GetBucketTaggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBucketTaggingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagSet = output.tagSet
        } else {
            self.tagSet = nil
        }
    }
}

public struct GetBucketTaggingOutputResponse: Equatable {
    /// <p>The tags set of the Outposts bucket.</p>
    public let tagSet: [S3Tag]?

    public init (
        tagSet: [S3Tag]? = nil
    )
    {
        self.tagSet = tagSet
    }
}

struct GetBucketTaggingOutputResponseBody: Equatable {
    public let tagSet: [S3Tag]?
}

extension GetBucketTaggingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagSet = "TagSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tagSet) {
            struct KeyVal0{struct member{}}
            let tagSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagSet)
            if let tagSetWrappedContainer = tagSetWrappedContainer {
                let tagSetContainer = try tagSetWrappedContainer.decodeIfPresent([S3Tag].self, forKey: .member)
                var tagSetBuffer:[S3Tag]? = nil
                if let tagSetContainer = tagSetContainer {
                    tagSetBuffer = [S3Tag]()
                    for structureContainer0 in tagSetContainer {
                        tagSetBuffer?.append(structureContainer0)
                    }
                }
                tagSet = tagSetBuffer
            } else {
                tagSet = []
            }
        } else {
            tagSet = nil
        }
    }
}

extension GetJobTaggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobTaggingInput(accountId: \(String(describing: accountId)), jobId: \(String(describing: jobId)))"}
}

extension GetJobTaggingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetJobTaggingInputHeadersMiddleware: Middleware {
    public let id: String = "GetJobTaggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobTaggingInput>
    public typealias MOutput = OperationOutput<GetJobTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobTaggingOutputError>
}

public struct GetJobTaggingInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJobTaggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobTaggingInput>
    public typealias MOutput = OperationOutput<GetJobTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobTaggingOutputError>
}

public struct GetJobTaggingInput: Equatable {
    /// <p>The AWS account ID associated with the S3 Batch Operations job.</p>
    public let accountId: String?
    /// <p>The ID for the S3 Batch Operations job whose tags you want to retrieve.</p>
    public let jobId: String?

    public init (
        accountId: String? = nil,
        jobId: String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
    }
}

struct GetJobTaggingInputBody: Equatable {
}

extension GetJobTaggingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetJobTaggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetJobTaggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobTaggingOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobTaggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobTaggingOutputResponse(tags: \(String(describing: tags)))"}
}

extension GetJobTaggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetJobTaggingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct GetJobTaggingOutputResponse: Equatable {
    /// <p>The set of tags associated with the S3 Batch Operations job.</p>
    public let tags: [S3Tag]?

    public init (
        tags: [S3Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct GetJobTaggingOutputResponseBody: Equatable {
    public let tags: [S3Tag]?
}

extension GetJobTaggingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3Tag].self, forKey: .member)
                var tagsBuffer:[S3Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension GetPublicAccessBlockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPublicAccessBlockInput(accountId: \(String(describing: accountId)))"}
}

extension GetPublicAccessBlockInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetPublicAccessBlockInputHeadersMiddleware: Middleware {
    public let id: String = "GetPublicAccessBlockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPublicAccessBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPublicAccessBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPublicAccessBlockInput>
    public typealias MOutput = OperationOutput<GetPublicAccessBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPublicAccessBlockOutputError>
}

public struct GetPublicAccessBlockInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPublicAccessBlockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPublicAccessBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPublicAccessBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPublicAccessBlockInput>
    public typealias MOutput = OperationOutput<GetPublicAccessBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPublicAccessBlockOutputError>
}

public struct GetPublicAccessBlockInput: Equatable {
    /// <p>The account ID for the AWS account whose <code>PublicAccessBlock</code> configuration you want
    ///          to retrieve.</p>
    public let accountId: String?

    public init (
        accountId: String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct GetPublicAccessBlockInputBody: Equatable {
}

extension GetPublicAccessBlockInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetPublicAccessBlockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPublicAccessBlockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchPublicAccessBlockConfiguration" : self = .noSuchPublicAccessBlockConfiguration(try NoSuchPublicAccessBlockConfiguration(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPublicAccessBlockOutputError: Equatable {
    case noSuchPublicAccessBlockConfiguration(NoSuchPublicAccessBlockConfiguration)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPublicAccessBlockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPublicAccessBlockOutputResponse(publicAccessBlockConfiguration: \(String(describing: publicAccessBlockConfiguration)))"}
}

extension GetPublicAccessBlockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: PublicAccessBlockConfiguration = try responseDecoder.decode(responseBody: unwrappedData)
                self.publicAccessBlockConfiguration = output
            } else {
                self.publicAccessBlockConfiguration = nil
            }
        } else {
            self.publicAccessBlockConfiguration = nil
        }
    }
}

public struct GetPublicAccessBlockOutputResponse: Equatable {
    /// <p>The <code>PublicAccessBlock</code> configuration currently in effect for this AWS
    ///          account.</p>
    public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?

    public init (
        publicAccessBlockConfiguration: PublicAccessBlockConfiguration? = nil
    )
    {
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
    }
}

struct GetPublicAccessBlockOutputResponseBody: Equatable {
    public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?
}

extension GetPublicAccessBlockOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
    }
}

extension GetStorageLensConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStorageLensConfigurationInput(accountId: \(String(describing: accountId)), configId: \(String(describing: configId)))"}
}

extension GetStorageLensConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetStorageLensConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetStorageLensConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStorageLensConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStorageLensConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStorageLensConfigurationInput>
    public typealias MOutput = OperationOutput<GetStorageLensConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStorageLensConfigurationOutputError>
}

public struct GetStorageLensConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStorageLensConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStorageLensConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStorageLensConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStorageLensConfigurationInput>
    public typealias MOutput = OperationOutput<GetStorageLensConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStorageLensConfigurationOutputError>
}

public struct GetStorageLensConfigurationInput: Equatable {
    /// <p>The account ID of the requester.</p>
    public let accountId: String?
    /// <p>The ID of the Amazon S3 Storage Lens configuration.</p>
    public let configId: String?

    public init (
        accountId: String? = nil,
        configId: String? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
    }
}

struct GetStorageLensConfigurationInputBody: Equatable {
}

extension GetStorageLensConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetStorageLensConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetStorageLensConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStorageLensConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStorageLensConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStorageLensConfigurationOutputResponse(storageLensConfiguration: \(String(describing: storageLensConfiguration)))"}
}

extension GetStorageLensConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: StorageLensConfiguration = try responseDecoder.decode(responseBody: unwrappedData)
                self.storageLensConfiguration = output
            } else {
                self.storageLensConfiguration = nil
            }
        } else {
            self.storageLensConfiguration = nil
        }
    }
}

public struct GetStorageLensConfigurationOutputResponse: Equatable {
    /// <p>The S3 Storage Lens configuration requested.</p>
    public let storageLensConfiguration: StorageLensConfiguration?

    public init (
        storageLensConfiguration: StorageLensConfiguration? = nil
    )
    {
        self.storageLensConfiguration = storageLensConfiguration
    }
}

struct GetStorageLensConfigurationOutputResponseBody: Equatable {
    public let storageLensConfiguration: StorageLensConfiguration?
}

extension GetStorageLensConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case storageLensConfiguration = "StorageLensConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageLensConfigurationDecoded = try containerValues.decodeIfPresent(StorageLensConfiguration.self, forKey: .storageLensConfiguration)
        storageLensConfiguration = storageLensConfigurationDecoded
    }
}

extension GetStorageLensConfigurationTaggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStorageLensConfigurationTaggingInput(accountId: \(String(describing: accountId)), configId: \(String(describing: configId)))"}
}

extension GetStorageLensConfigurationTaggingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetStorageLensConfigurationTaggingInputHeadersMiddleware: Middleware {
    public let id: String = "GetStorageLensConfigurationTaggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStorageLensConfigurationTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStorageLensConfigurationTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStorageLensConfigurationTaggingInput>
    public typealias MOutput = OperationOutput<GetStorageLensConfigurationTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStorageLensConfigurationTaggingOutputError>
}

public struct GetStorageLensConfigurationTaggingInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStorageLensConfigurationTaggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStorageLensConfigurationTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStorageLensConfigurationTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStorageLensConfigurationTaggingInput>
    public typealias MOutput = OperationOutput<GetStorageLensConfigurationTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStorageLensConfigurationTaggingOutputError>
}

public struct GetStorageLensConfigurationTaggingInput: Equatable {
    /// <p>The account ID of the requester.</p>
    public let accountId: String?
    /// <p>The ID of the Amazon S3 Storage Lens configuration.</p>
    public let configId: String?

    public init (
        accountId: String? = nil,
        configId: String? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
    }
}

struct GetStorageLensConfigurationTaggingInputBody: Equatable {
}

extension GetStorageLensConfigurationTaggingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetStorageLensConfigurationTaggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetStorageLensConfigurationTaggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStorageLensConfigurationTaggingOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStorageLensConfigurationTaggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStorageLensConfigurationTaggingOutputResponse(tags: \(String(describing: tags)))"}
}

extension GetStorageLensConfigurationTaggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetStorageLensConfigurationTaggingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct GetStorageLensConfigurationTaggingOutputResponse: Equatable {
    /// <p>The tags of S3 Storage Lens configuration requested.</p>
    public let tags: [StorageLensTag]?

    public init (
        tags: [StorageLensTag]? = nil
    )
    {
        self.tags = tags
    }
}

struct GetStorageLensConfigurationTaggingOutputResponseBody: Equatable {
    public let tags: [StorageLensTag]?
}

extension GetStorageLensConfigurationTaggingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([StorageLensTag].self, forKey: .member)
                var tagsBuffer:[StorageLensTag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [StorageLensTag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension IdempotencyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdempotencyException(message: \(String(describing: message)))"}
}

extension IdempotencyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<IdempotencyExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct IdempotencyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotencyExceptionBody: Equatable {
    public let message: String?
}

extension IdempotencyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Include: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case buckets = "Buckets"
        case regions = "Regions"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let buckets = buckets {
            var bucketsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("buckets"))
            for s3bucketarnstring0 in buckets {
                try bucketsContainer.encode(s3bucketarnstring0, forKey: Key("Arn"))
            }
        }
        if let regions = regions {
            var regionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("regions"))
            for s3awsregion0 in regions {
                try regionsContainer.encode(s3awsregion0, forKey: Key("Region"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.buckets) {
            struct KeyVal0{struct Arn{}}
            let bucketsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Arn>.CodingKeys.self, forKey: .buckets)
            if let bucketsWrappedContainer = bucketsWrappedContainer {
                let bucketsContainer = try bucketsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var bucketsBuffer:[String]? = nil
                if let bucketsContainer = bucketsContainer {
                    bucketsBuffer = [String]()
                    for stringContainer0 in bucketsContainer {
                        bucketsBuffer?.append(stringContainer0)
                    }
                }
                buckets = bucketsBuffer
            } else {
                buckets = []
            }
        } else {
            buckets = nil
        }
        if containerValues.contains(.regions) {
            struct KeyVal0{struct Region{}}
            let regionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Region>.CodingKeys.self, forKey: .regions)
            if let regionsWrappedContainer = regionsWrappedContainer {
                let regionsContainer = try regionsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var regionsBuffer:[String]? = nil
                if let regionsContainer = regionsContainer {
                    regionsBuffer = [String]()
                    for stringContainer0 in regionsContainer {
                        regionsBuffer?.append(stringContainer0)
                    }
                }
                regions = regionsBuffer
            } else {
                regions = []
            }
        } else {
            regions = nil
        }
    }
}

extension Include: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Include(buckets: \(String(describing: buckets)), regions: \(String(describing: regions)))"}
}

extension Include: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for what Amazon S3 Storage Lens configuration includes.</p>
public struct Include: Equatable {
    /// <p>A container for the S3 Storage Lens bucket includes.</p>
    public let buckets: [String]?
    /// <p>A container for the S3 Storage Lens Region includes.</p>
    public let regions: [String]?

    public init (
        buckets: [String]? = nil,
        regions: [String]? = nil
    )
    {
        self.buckets = buckets
        self.regions = regions
    }
}

extension InternalServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceException(message: \(String(describing: message)))"}
}

extension InternalServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InternalServiceExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct InternalServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidNextTokenExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidRequestExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension JobDescriptor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case confirmationRequired = "ConfirmationRequired"
        case creationTime = "CreationTime"
        case description = "Description"
        case failureReasons = "FailureReasons"
        case jobArn = "JobArn"
        case jobId = "JobId"
        case manifest = "Manifest"
        case operation = "Operation"
        case priority = "Priority"
        case progressSummary = "ProgressSummary"
        case report = "Report"
        case roleArn = "RoleArn"
        case status = "Status"
        case statusUpdateReason = "StatusUpdateReason"
        case suspendedCause = "SuspendedCause"
        case suspendedDate = "SuspendedDate"
        case terminationDate = "TerminationDate"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if confirmationRequired != false {
            try container.encode(confirmationRequired, forKey: Key("confirmationRequired"))
        }
        if let creationTime = creationTime {
            try container.encode(TimestampWrapper(creationTime, format: .dateTime), forKey: Key("creationTime"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("description"))
        }
        if let failureReasons = failureReasons {
            var failureReasonsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("failureReasons"))
            for jobfailure0 in failureReasons {
                try failureReasonsContainer.encode(jobfailure0, forKey: Key("member"))
            }
        }
        if let jobArn = jobArn {
            try container.encode(jobArn, forKey: Key("jobArn"))
        }
        if let jobId = jobId {
            try container.encode(jobId, forKey: Key("jobId"))
        }
        if let manifest = manifest {
            try container.encode(manifest, forKey: Key("manifest"))
        }
        if let operation = operation {
            try container.encode(operation, forKey: Key("operation"))
        }
        if priority != 0 {
            try container.encode(priority, forKey: Key("priority"))
        }
        if let progressSummary = progressSummary {
            try container.encode(progressSummary, forKey: Key("progressSummary"))
        }
        if let report = report {
            try container.encode(report, forKey: Key("report"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("roleArn"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
        if let statusUpdateReason = statusUpdateReason {
            try container.encode(statusUpdateReason, forKey: Key("statusUpdateReason"))
        }
        if let suspendedCause = suspendedCause {
            try container.encode(suspendedCause, forKey: Key("suspendedCause"))
        }
        if let suspendedDate = suspendedDate {
            try container.encode(TimestampWrapper(suspendedDate, format: .dateTime), forKey: Key("suspendedDate"))
        }
        if let terminationDate = terminationDate {
            try container.encode(TimestampWrapper(terminationDate, format: .dateTime), forKey: Key("terminationDate"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let confirmationRequiredDecoded = try containerValues.decode(Bool.self, forKey: .confirmationRequired)
        confirmationRequired = confirmationRequiredDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let jobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .status)
        status = statusDecoded
        let manifestDecoded = try containerValues.decodeIfPresent(JobManifest.self, forKey: .manifest)
        manifest = manifestDecoded
        let operationDecoded = try containerValues.decodeIfPresent(JobOperation.self, forKey: .operation)
        operation = operationDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let progressSummaryDecoded = try containerValues.decodeIfPresent(JobProgressSummary.self, forKey: .progressSummary)
        progressSummary = progressSummaryDecoded
        let statusUpdateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusUpdateReason)
        statusUpdateReason = statusUpdateReasonDecoded
        if containerValues.contains(.failureReasons) {
            struct KeyVal0{struct member{}}
            let failureReasonsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .failureReasons)
            if let failureReasonsWrappedContainer = failureReasonsWrappedContainer {
                let failureReasonsContainer = try failureReasonsWrappedContainer.decodeIfPresent([JobFailure].self, forKey: .member)
                var failureReasonsBuffer:[JobFailure]? = nil
                if let failureReasonsContainer = failureReasonsContainer {
                    failureReasonsBuffer = [JobFailure]()
                    for structureContainer0 in failureReasonsContainer {
                        failureReasonsBuffer?.append(structureContainer0)
                    }
                }
                failureReasons = failureReasonsBuffer
            } else {
                failureReasons = []
            }
        } else {
            failureReasons = nil
        }
        let reportDecoded = try containerValues.decodeIfPresent(JobReport.self, forKey: .report)
        report = reportDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        var creationTimeBuffer:Date? = nil
        if let creationTimeDecoded = creationTimeDecoded {
            creationTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationTimeDecoded, format: .dateTime)
        }
        creationTime = creationTimeBuffer
        let terminationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .terminationDate)
        var terminationDateBuffer:Date? = nil
        if let terminationDateDecoded = terminationDateDecoded {
            terminationDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(terminationDateDecoded, format: .dateTime)
        }
        terminationDate = terminationDateBuffer
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let suspendedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suspendedDate)
        var suspendedDateBuffer:Date? = nil
        if let suspendedDateDecoded = suspendedDateDecoded {
            suspendedDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(suspendedDateDecoded, format: .dateTime)
        }
        suspendedDate = suspendedDateBuffer
        let suspendedCauseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suspendedCause)
        suspendedCause = suspendedCauseDecoded
    }
}

extension JobDescriptor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobDescriptor(confirmationRequired: \(String(describing: confirmationRequired)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), failureReasons: \(String(describing: failureReasons)), jobArn: \(String(describing: jobArn)), jobId: \(String(describing: jobId)), manifest: \(String(describing: manifest)), operation: \(String(describing: operation)), priority: \(String(describing: priority)), progressSummary: \(String(describing: progressSummary)), report: \(String(describing: report)), roleArn: \(String(describing: roleArn)), status: \(String(describing: status)), statusUpdateReason: \(String(describing: statusUpdateReason)), suspendedCause: \(String(describing: suspendedCause)), suspendedDate: \(String(describing: suspendedDate)), terminationDate: \(String(describing: terminationDate)))"}
}

extension JobDescriptor: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container element for the job configuration and status information returned by a <code>Describe Job</code> request.</p>
public struct JobDescriptor: Equatable {
    /// <p>Indicates whether confirmation is required before Amazon S3 begins running the specified job. Confirmation is required only for jobs created through the Amazon S3 console.</p>
    public let confirmationRequired: Bool
    /// <p>A timestamp indicating when this job was created.</p>
    public let creationTime: Date?
    /// <p>The description for this job, if one was provided in this job's <code>Create Job</code> request.</p>
    public let description: String?
    /// <p>If the specified job failed, this field contains information describing the failure.</p>
    public let failureReasons: [JobFailure]?
    /// <p>The Amazon Resource Name (ARN) for this job.</p>
    public let jobArn: String?
    /// <p>The ID for the specified job.</p>
    public let jobId: String?
    /// <p>The configuration information for the specified job's manifest object.</p>
    public let manifest: JobManifest?
    /// <p>The operation that the specified job is configured to run on the objects listed in the manifest.</p>
    public let operation: JobOperation?
    /// <p>The priority of the specified job.</p>
    public let priority: Int
    /// <p>Describes the total number of tasks that the specified job has run, the number of tasks
    ///          that succeeded, and the number of tasks that failed.</p>
    public let progressSummary: JobProgressSummary?
    /// <p>Contains the configuration information for the job-completion report if you requested one in the <code>Create Job</code> request.</p>
    public let report: JobReport?
    /// <p>The Amazon Resource Name (ARN) for the AWS Identity and Access Management (IAM) role
    ///          assigned to run the tasks for this job.</p>
    public let roleArn: String?
    /// <p>The current status of the specified job.</p>
    public let status: JobStatus?
    /// <p>The reason for updating the job.</p>
    public let statusUpdateReason: String?
    /// <p>The reason why the specified job was suspended. A job is only suspended if you create it through the Amazon S3 console. When you create the job, it enters
    ///             the <code>Suspended</code> state to await confirmation before running. After you confirm the job, it automatically exits the <code>Suspended</code> state.</p>
    public let suspendedCause: String?
    /// <p>The timestamp when this job was suspended, if it has been suspended.</p>
    public let suspendedDate: Date?
    /// <p>A timestamp indicating when this job terminated. A job's termination date is the date and time when it succeeded, failed, or was canceled.</p>
    public let terminationDate: Date?

    public init (
        confirmationRequired: Bool = false,
        creationTime: Date? = nil,
        description: String? = nil,
        failureReasons: [JobFailure]? = nil,
        jobArn: String? = nil,
        jobId: String? = nil,
        manifest: JobManifest? = nil,
        operation: JobOperation? = nil,
        priority: Int = 0,
        progressSummary: JobProgressSummary? = nil,
        report: JobReport? = nil,
        roleArn: String? = nil,
        status: JobStatus? = nil,
        statusUpdateReason: String? = nil,
        suspendedCause: String? = nil,
        suspendedDate: Date? = nil,
        terminationDate: Date? = nil
    )
    {
        self.confirmationRequired = confirmationRequired
        self.creationTime = creationTime
        self.description = description
        self.failureReasons = failureReasons
        self.jobArn = jobArn
        self.jobId = jobId
        self.manifest = manifest
        self.operation = operation
        self.priority = priority
        self.progressSummary = progressSummary
        self.report = report
        self.roleArn = roleArn
        self.status = status
        self.statusUpdateReason = statusUpdateReason
        self.suspendedCause = suspendedCause
        self.suspendedDate = suspendedDate
        self.terminationDate = terminationDate
    }
}

extension JobFailure: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureCode = "FailureCode"
        case failureReason = "FailureReason"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let failureCode = failureCode {
            try container.encode(failureCode, forKey: Key("failureCode"))
        }
        if let failureReason = failureReason {
            try container.encode(failureReason, forKey: Key("failureReason"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension JobFailure: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobFailure(failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)))"}
}

extension JobFailure: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>If this job failed, this element indicates why the job failed.</p>
public struct JobFailure: Equatable {
    /// <p>The failure code, if any, for the specified job.</p>
    public let failureCode: String?
    /// <p>The failure reason, if any, for the specified job.</p>
    public let failureReason: String?

    public init (
        failureCode: String? = nil,
        failureReason: String? = nil
    )
    {
        self.failureCode = failureCode
        self.failureReason = failureReason
    }
}

extension JobListDescriptor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case description = "Description"
        case jobId = "JobId"
        case operation = "Operation"
        case priority = "Priority"
        case progressSummary = "ProgressSummary"
        case status = "Status"
        case terminationDate = "TerminationDate"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let creationTime = creationTime {
            try container.encode(TimestampWrapper(creationTime, format: .dateTime), forKey: Key("creationTime"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("description"))
        }
        if let jobId = jobId {
            try container.encode(jobId, forKey: Key("jobId"))
        }
        if let operation = operation {
            try container.encode(operation, forKey: Key("operation"))
        }
        if priority != 0 {
            try container.encode(priority, forKey: Key("priority"))
        }
        if let progressSummary = progressSummary {
            try container.encode(progressSummary, forKey: Key("progressSummary"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
        if let terminationDate = terminationDate {
            try container.encode(TimestampWrapper(terminationDate, format: .dateTime), forKey: Key("terminationDate"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let operationDecoded = try containerValues.decodeIfPresent(OperationName.self, forKey: .operation)
        operation = operationDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        var creationTimeBuffer:Date? = nil
        if let creationTimeDecoded = creationTimeDecoded {
            creationTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationTimeDecoded, format: .dateTime)
        }
        creationTime = creationTimeBuffer
        let terminationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .terminationDate)
        var terminationDateBuffer:Date? = nil
        if let terminationDateDecoded = terminationDateDecoded {
            terminationDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(terminationDateDecoded, format: .dateTime)
        }
        terminationDate = terminationDateBuffer
        let progressSummaryDecoded = try containerValues.decodeIfPresent(JobProgressSummary.self, forKey: .progressSummary)
        progressSummary = progressSummaryDecoded
    }
}

extension JobListDescriptor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobListDescriptor(creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), jobId: \(String(describing: jobId)), operation: \(String(describing: operation)), priority: \(String(describing: priority)), progressSummary: \(String(describing: progressSummary)), status: \(String(describing: status)), terminationDate: \(String(describing: terminationDate)))"}
}

extension JobListDescriptor: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the configuration and status information for a single job retrieved as part of a job list.</p>
public struct JobListDescriptor: Equatable {
    /// <p>A timestamp indicating when the specified job was created.</p>
    public let creationTime: Date?
    /// <p>The user-specified description that was included in the specified job's <code>Create Job</code> request.</p>
    public let description: String?
    /// <p>The ID for the specified job.</p>
    public let jobId: String?
    /// <p>The operation that the specified job is configured to run on every object listed in the manifest.</p>
    public let operation: OperationName?
    /// <p>The current priority for the specified job.</p>
    public let priority: Int
    /// <p>Describes the total number of tasks that the specified job has run, the number of tasks
    ///          that succeeded, and the number of tasks that failed.</p>
    public let progressSummary: JobProgressSummary?
    /// <p>The specified job's current status.</p>
    public let status: JobStatus?
    /// <p>A timestamp indicating when the specified job terminated. A job's termination date is the date and time when it succeeded, failed, or was canceled.</p>
    public let terminationDate: Date?

    public init (
        creationTime: Date? = nil,
        description: String? = nil,
        jobId: String? = nil,
        operation: OperationName? = nil,
        priority: Int = 0,
        progressSummary: JobProgressSummary? = nil,
        status: JobStatus? = nil,
        terminationDate: Date? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.jobId = jobId
        self.operation = operation
        self.priority = priority
        self.progressSummary = progressSummary
        self.status = status
        self.terminationDate = terminationDate
    }
}

extension JobManifest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case location = "Location"
        case spec = "Spec"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let location = location {
            try container.encode(location, forKey: Key("location"))
        }
        if let spec = spec {
            try container.encode(spec, forKey: Key("spec"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(JobManifestSpec.self, forKey: .spec)
        spec = specDecoded
        let locationDecoded = try containerValues.decodeIfPresent(JobManifestLocation.self, forKey: .location)
        location = locationDecoded
    }
}

extension JobManifest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobManifest(location: \(String(describing: location)), spec: \(String(describing: spec)))"}
}

extension JobManifest: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the configuration information for a job's manifest.</p>
public struct JobManifest: Equatable {
    /// <p>Contains the information required to locate the specified job's manifest.</p>
    public let location: JobManifestLocation?
    /// <p>Describes the format of the specified job's manifest. If the manifest is in CSV format, also describes the columns contained within the manifest.</p>
    public let spec: JobManifestSpec?

    public init (
        location: JobManifestLocation? = nil,
        spec: JobManifestSpec? = nil
    )
    {
        self.location = location
        self.spec = spec
    }
}

public enum JobManifestFieldName {
    case bucket
    case ignore
    case key
    case versionid
    case sdkUnknown(String)
}

extension JobManifestFieldName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobManifestFieldName] {
        return [
            .bucket,
            .ignore,
            .key,
            .versionid,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bucket: return "Bucket"
        case .ignore: return "Ignore"
        case .key: return "Key"
        case .versionid: return "VersionId"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobManifestFieldName(rawValue: rawValue) ?? JobManifestFieldName.sdkUnknown(rawValue)
    }
}

public enum JobManifestFormat {
    case s3batchoperationsCsv20180820
    case s3inventoryreportCsv20161130
    case sdkUnknown(String)
}

extension JobManifestFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobManifestFormat] {
        return [
            .s3batchoperationsCsv20180820,
            .s3inventoryreportCsv20161130,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .s3batchoperationsCsv20180820: return "S3BatchOperations_CSV_20180820"
        case .s3inventoryreportCsv20161130: return "S3InventoryReport_CSV_20161130"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobManifestFormat(rawValue: rawValue) ?? JobManifestFormat.sdkUnknown(rawValue)
    }
}

extension JobManifestLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eTag = "ETag"
        case objectArn = "ObjectArn"
        case objectVersionId = "ObjectVersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let eTag = eTag {
            try container.encode(eTag, forKey: Key("eTag"))
        }
        if let objectArn = objectArn {
            try container.encode(objectArn, forKey: Key("objectArn"))
        }
        if let objectVersionId = objectVersionId {
            try container.encode(objectVersionId, forKey: Key("objectVersionId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectArn)
        objectArn = objectArnDecoded
        let objectVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectVersionId)
        objectVersionId = objectVersionIdDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eTag)
        eTag = eTagDecoded
    }
}

extension JobManifestLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobManifestLocation(eTag: \(String(describing: eTag)), objectArn: \(String(describing: objectArn)), objectVersionId: \(String(describing: objectVersionId)))"}
}

extension JobManifestLocation: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the information required to locate a manifest object.</p>
public struct JobManifestLocation: Equatable {
    /// <p>The ETag for the specified manifest object.</p>
    public let eTag: String?
    /// <p>The Amazon Resource Name (ARN) for a manifest object.</p>
    ///          <important>
    ///             <p>Replacement must be made for object keys containing special characters (such as carriage returns) when using
    ///          XML requests. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints">
    ///             XML related object key constraints</a>.</p>
    ///          </important>
    public let objectArn: String?
    /// <p>The optional version ID to identify a specific version of the manifest object.</p>
    public let objectVersionId: String?

    public init (
        eTag: String? = nil,
        objectArn: String? = nil,
        objectVersionId: String? = nil
    )
    {
        self.eTag = eTag
        self.objectArn = objectArn
        self.objectVersionId = objectVersionId
    }
}

extension JobManifestSpec: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fields = "Fields"
        case format = "Format"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("fields"))
            for jobmanifestfieldname0 in fields {
                try fieldsContainer.encode(jobmanifestfieldname0, forKey: Key("member"))
            }
        }
        if let format = format {
            try container.encode(format, forKey: Key("format"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(JobManifestFormat.self, forKey: .format)
        format = formatDecoded
        if containerValues.contains(.fields) {
            struct KeyVal0{struct member{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([JobManifestFieldName].self, forKey: .member)
                var fieldsBuffer:[JobManifestFieldName]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [JobManifestFieldName]()
                    for stringContainer0 in fieldsContainer {
                        fieldsBuffer?.append(stringContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
    }
}

extension JobManifestSpec: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobManifestSpec(fields: \(String(describing: fields)), format: \(String(describing: format)))"}
}

extension JobManifestSpec: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Describes the format of a manifest. If the manifest is in CSV format, also describes the columns contained within the manifest.</p>
public struct JobManifestSpec: Equatable {
    /// <p>If the specified manifest object is in the <code>S3BatchOperations_CSV_20180820</code> format, this element describes which columns contain the required data.</p>
    public let fields: [JobManifestFieldName]?
    /// <p>Indicates which of the available formats the specified manifest uses.</p>
    public let format: JobManifestFormat?

    public init (
        fields: [JobManifestFieldName]? = nil,
        format: JobManifestFormat? = nil
    )
    {
        self.fields = fields
        self.format = format
    }
}

extension JobOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lambdaInvoke = "LambdaInvoke"
        case s3DeleteObjectTagging = "S3DeleteObjectTagging"
        case s3InitiateRestoreObject = "S3InitiateRestoreObject"
        case s3PutObjectAcl = "S3PutObjectAcl"
        case s3PutObjectCopy = "S3PutObjectCopy"
        case s3PutObjectLegalHold = "S3PutObjectLegalHold"
        case s3PutObjectRetention = "S3PutObjectRetention"
        case s3PutObjectTagging = "S3PutObjectTagging"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let lambdaInvoke = lambdaInvoke {
            try container.encode(lambdaInvoke, forKey: Key("lambdaInvoke"))
        }
        if let s3DeleteObjectTagging = s3DeleteObjectTagging {
            try container.encode(s3DeleteObjectTagging, forKey: Key("s3DeleteObjectTagging"))
        }
        if let s3InitiateRestoreObject = s3InitiateRestoreObject {
            try container.encode(s3InitiateRestoreObject, forKey: Key("s3InitiateRestoreObject"))
        }
        if let s3PutObjectAcl = s3PutObjectAcl {
            try container.encode(s3PutObjectAcl, forKey: Key("s3PutObjectAcl"))
        }
        if let s3PutObjectCopy = s3PutObjectCopy {
            try container.encode(s3PutObjectCopy, forKey: Key("s3PutObjectCopy"))
        }
        if let s3PutObjectLegalHold = s3PutObjectLegalHold {
            try container.encode(s3PutObjectLegalHold, forKey: Key("s3PutObjectLegalHold"))
        }
        if let s3PutObjectRetention = s3PutObjectRetention {
            try container.encode(s3PutObjectRetention, forKey: Key("s3PutObjectRetention"))
        }
        if let s3PutObjectTagging = s3PutObjectTagging {
            try container.encode(s3PutObjectTagging, forKey: Key("s3PutObjectTagging"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaInvokeDecoded = try containerValues.decodeIfPresent(LambdaInvokeOperation.self, forKey: .lambdaInvoke)
        lambdaInvoke = lambdaInvokeDecoded
        let s3PutObjectCopyDecoded = try containerValues.decodeIfPresent(S3CopyObjectOperation.self, forKey: .s3PutObjectCopy)
        s3PutObjectCopy = s3PutObjectCopyDecoded
        let s3PutObjectAclDecoded = try containerValues.decodeIfPresent(S3SetObjectAclOperation.self, forKey: .s3PutObjectAcl)
        s3PutObjectAcl = s3PutObjectAclDecoded
        let s3PutObjectTaggingDecoded = try containerValues.decodeIfPresent(S3SetObjectTaggingOperation.self, forKey: .s3PutObjectTagging)
        s3PutObjectTagging = s3PutObjectTaggingDecoded
        let s3DeleteObjectTaggingDecoded = try containerValues.decodeIfPresent(S3DeleteObjectTaggingOperation.self, forKey: .s3DeleteObjectTagging)
        s3DeleteObjectTagging = s3DeleteObjectTaggingDecoded
        let s3InitiateRestoreObjectDecoded = try containerValues.decodeIfPresent(S3InitiateRestoreObjectOperation.self, forKey: .s3InitiateRestoreObject)
        s3InitiateRestoreObject = s3InitiateRestoreObjectDecoded
        let s3PutObjectLegalHoldDecoded = try containerValues.decodeIfPresent(S3SetObjectLegalHoldOperation.self, forKey: .s3PutObjectLegalHold)
        s3PutObjectLegalHold = s3PutObjectLegalHoldDecoded
        let s3PutObjectRetentionDecoded = try containerValues.decodeIfPresent(S3SetObjectRetentionOperation.self, forKey: .s3PutObjectRetention)
        s3PutObjectRetention = s3PutObjectRetentionDecoded
    }
}

extension JobOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobOperation(lambdaInvoke: \(String(describing: lambdaInvoke)), s3DeleteObjectTagging: \(String(describing: s3DeleteObjectTagging)), s3InitiateRestoreObject: \(String(describing: s3InitiateRestoreObject)), s3PutObjectAcl: \(String(describing: s3PutObjectAcl)), s3PutObjectCopy: \(String(describing: s3PutObjectCopy)), s3PutObjectLegalHold: \(String(describing: s3PutObjectLegalHold)), s3PutObjectRetention: \(String(describing: s3PutObjectRetention)), s3PutObjectTagging: \(String(describing: s3PutObjectTagging)))"}
}

extension JobOperation: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The operation that you want this job to perform on every object listed in the manifest.
///          For more information about the available operations, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-operations.html">Operations</a> in the
///             <i>Amazon S3 User Guide</i>.</p>
public struct JobOperation: Equatable {
    /// <p>Directs the specified job to invoke an AWS Lambda function on every object in the manifest.</p>
    public let lambdaInvoke: LambdaInvokeOperation?
    /// <p>Directs the specified job to execute a DELETE Object tagging call on every object in the manifest.</p>
    public let s3DeleteObjectTagging: S3DeleteObjectTaggingOperation?
    /// <p>Directs the specified job to initiate restore requests for every archived object in the manifest.</p>
    public let s3InitiateRestoreObject: S3InitiateRestoreObjectOperation?
    /// <p>Directs the specified job to run a PUT Object acl call on every object in the manifest.</p>
    public let s3PutObjectAcl: S3SetObjectAclOperation?
    /// <p>Directs the specified job to run a PUT Copy object call on every object in the manifest.</p>
    public let s3PutObjectCopy: S3CopyObjectOperation?
    /// <p>Contains the configuration for an S3 Object Lock legal hold operation that an
    ///          S3 Batch Operations job passes every object to the underlying
    ///             <code>PutObjectLegalHold</code> API. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-legal-hold.html">Using
    ///             S3 Object Lock legal hold with S3 Batch Operations</a> in the
    ///             <i>Amazon S3 User Guide</i>.</p>
    public let s3PutObjectLegalHold: S3SetObjectLegalHoldOperation?
    /// <p>Contains the configuration parameters for the Object Lock retention action for an
    ///          S3 Batch Operations job. Batch Operations passes every object to the underlying
    ///             <code>PutObjectRetention</code> API. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-retention-date.html">Using
    ///             S3 Object Lock retention with S3 Batch Operations</a> in the
    ///             <i>Amazon S3 User Guide</i>.</p>
    public let s3PutObjectRetention: S3SetObjectRetentionOperation?
    /// <p>Directs the specified job to run a PUT Object tagging call on every object in the manifest.</p>
    public let s3PutObjectTagging: S3SetObjectTaggingOperation?

    public init (
        lambdaInvoke: LambdaInvokeOperation? = nil,
        s3DeleteObjectTagging: S3DeleteObjectTaggingOperation? = nil,
        s3InitiateRestoreObject: S3InitiateRestoreObjectOperation? = nil,
        s3PutObjectAcl: S3SetObjectAclOperation? = nil,
        s3PutObjectCopy: S3CopyObjectOperation? = nil,
        s3PutObjectLegalHold: S3SetObjectLegalHoldOperation? = nil,
        s3PutObjectRetention: S3SetObjectRetentionOperation? = nil,
        s3PutObjectTagging: S3SetObjectTaggingOperation? = nil
    )
    {
        self.lambdaInvoke = lambdaInvoke
        self.s3DeleteObjectTagging = s3DeleteObjectTagging
        self.s3InitiateRestoreObject = s3InitiateRestoreObject
        self.s3PutObjectAcl = s3PutObjectAcl
        self.s3PutObjectCopy = s3PutObjectCopy
        self.s3PutObjectLegalHold = s3PutObjectLegalHold
        self.s3PutObjectRetention = s3PutObjectRetention
        self.s3PutObjectTagging = s3PutObjectTagging
    }
}

extension JobProgressSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case numberOfTasksFailed = "NumberOfTasksFailed"
        case numberOfTasksSucceeded = "NumberOfTasksSucceeded"
        case totalNumberOfTasks = "TotalNumberOfTasks"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if numberOfTasksFailed != 0 {
            try container.encode(numberOfTasksFailed, forKey: Key("numberOfTasksFailed"))
        }
        if numberOfTasksSucceeded != 0 {
            try container.encode(numberOfTasksSucceeded, forKey: Key("numberOfTasksSucceeded"))
        }
        if totalNumberOfTasks != 0 {
            try container.encode(totalNumberOfTasks, forKey: Key("totalNumberOfTasks"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalNumberOfTasksDecoded = try containerValues.decode(Int.self, forKey: .totalNumberOfTasks)
        totalNumberOfTasks = totalNumberOfTasksDecoded
        let numberOfTasksSucceededDecoded = try containerValues.decode(Int.self, forKey: .numberOfTasksSucceeded)
        numberOfTasksSucceeded = numberOfTasksSucceededDecoded
        let numberOfTasksFailedDecoded = try containerValues.decode(Int.self, forKey: .numberOfTasksFailed)
        numberOfTasksFailed = numberOfTasksFailedDecoded
    }
}

extension JobProgressSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobProgressSummary(numberOfTasksFailed: \(String(describing: numberOfTasksFailed)), numberOfTasksSucceeded: \(String(describing: numberOfTasksSucceeded)), totalNumberOfTasks: \(String(describing: totalNumberOfTasks)))"}
}

extension JobProgressSummary: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Describes the total number of tasks that the specified job has started, the number of tasks that succeeded, and the number of tasks that failed.</p>
public struct JobProgressSummary: Equatable {
    /// <p></p>
    public let numberOfTasksFailed: Int
    /// <p></p>
    public let numberOfTasksSucceeded: Int
    /// <p></p>
    public let totalNumberOfTasks: Int

    public init (
        numberOfTasksFailed: Int = 0,
        numberOfTasksSucceeded: Int = 0,
        totalNumberOfTasks: Int = 0
    )
    {
        self.numberOfTasksFailed = numberOfTasksFailed
        self.numberOfTasksSucceeded = numberOfTasksSucceeded
        self.totalNumberOfTasks = totalNumberOfTasks
    }
}

extension JobReport: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case enabled = "Enabled"
        case format = "Format"
        case prefix = "Prefix"
        case reportScope = "ReportScope"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: Key("bucket"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: Key("enabled"))
        }
        if let format = format {
            try container.encode(format, forKey: Key("format"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
        if let reportScope = reportScope {
            try container.encode(reportScope, forKey: Key("reportScope"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let formatDecoded = try containerValues.decodeIfPresent(JobReportFormat.self, forKey: .format)
        format = formatDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let reportScopeDecoded = try containerValues.decodeIfPresent(JobReportScope.self, forKey: .reportScope)
        reportScope = reportScopeDecoded
    }
}

extension JobReport: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobReport(bucket: \(String(describing: bucket)), enabled: \(String(describing: enabled)), format: \(String(describing: format)), prefix: \(String(describing: prefix)), reportScope: \(String(describing: reportScope)))"}
}

extension JobReport: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the configuration parameters for a job-completion report.</p>
public struct JobReport: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the bucket where specified job-completion report will be stored.</p>
    public let bucket: String?
    /// <p>Indicates whether the specified job will generate a job-completion report.</p>
    public let enabled: Bool
    /// <p>The format of the specified job-completion report.</p>
    public let format: JobReportFormat?
    /// <p>An optional prefix to describe where in the specified bucket the job-completion report
    ///          will be stored. Amazon S3 stores the job-completion report at
    ///             <code><prefix>/job-<job-id>/report.json</code>.</p>
    public let prefix: String?
    /// <p>Indicates whether the job-completion report will include details of all tasks or only failed tasks.</p>
    public let reportScope: JobReportScope?

    public init (
        bucket: String? = nil,
        enabled: Bool = false,
        format: JobReportFormat? = nil,
        prefix: String? = nil,
        reportScope: JobReportScope? = nil
    )
    {
        self.bucket = bucket
        self.enabled = enabled
        self.format = format
        self.prefix = prefix
        self.reportScope = reportScope
    }
}

public enum JobReportFormat {
    case reportCsv20180820
    case sdkUnknown(String)
}

extension JobReportFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobReportFormat] {
        return [
            .reportCsv20180820,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .reportCsv20180820: return "Report_CSV_20180820"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobReportFormat(rawValue: rawValue) ?? JobReportFormat.sdkUnknown(rawValue)
    }
}

public enum JobReportScope {
    case alltasks
    case failedtasksonly
    case sdkUnknown(String)
}

extension JobReportScope : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobReportScope] {
        return [
            .alltasks,
            .failedtasksonly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .alltasks: return "AllTasks"
        case .failedtasksonly: return "FailedTasksOnly"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobReportScope(rawValue: rawValue) ?? JobReportScope.sdkUnknown(rawValue)
    }
}

public enum JobStatus {
    case active
    case cancelled
    case cancelling
    case complete
    case completing
    case failed
    case failing
    case new
    case paused
    case pausing
    case preparing
    case ready
    case suspended
    case sdkUnknown(String)
}

extension JobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobStatus] {
        return [
            .active,
            .cancelled,
            .cancelling,
            .complete,
            .completing,
            .failed,
            .failing,
            .new,
            .paused,
            .pausing,
            .preparing,
            .ready,
            .suspended,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .cancelled: return "Cancelled"
        case .cancelling: return "Cancelling"
        case .complete: return "Complete"
        case .completing: return "Completing"
        case .failed: return "Failed"
        case .failing: return "Failing"
        case .new: return "New"
        case .paused: return "Paused"
        case .pausing: return "Pausing"
        case .preparing: return "Preparing"
        case .ready: return "Ready"
        case .suspended: return "Suspended"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
    }
}

extension JobStatusException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobStatusException(message: \(String(describing: message)))"}
}

extension JobStatusException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<JobStatusExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct JobStatusException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct JobStatusExceptionBody: Equatable {
    public let message: String?
}

extension JobStatusExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaInvokeOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case functionArn = "FunctionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let functionArn = functionArn {
            try container.encode(functionArn, forKey: Key("functionArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
    }
}

extension LambdaInvokeOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaInvokeOperation(functionArn: \(String(describing: functionArn)))"}
}

extension LambdaInvokeOperation: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the configuration parameters for a <code>Lambda Invoke</code> operation.</p>
public struct LambdaInvokeOperation: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the AWS Lambda function that the specified job will invoke on every object in the manifest.</p>
    public let functionArn: String?

    public init (
        functionArn: String? = nil
    )
    {
        self.functionArn = functionArn
    }
}

extension LifecycleConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rules = "Rules"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let rules = rules {
            var rulesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("rules"))
            for lifecyclerule0 in rules {
                try rulesContainer.encode(lifecyclerule0, forKey: Key("Rule"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.rules) {
            struct KeyVal0{struct Rule{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Rule>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([LifecycleRule].self, forKey: .member)
                var rulesBuffer:[LifecycleRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [LifecycleRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension LifecycleConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecycleConfiguration(rules: \(String(describing: rules)))"}
}

extension LifecycleConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container for the Outposts bucket lifecycle configuration.</p>
public struct LifecycleConfiguration: Equatable {
    /// <p>A lifecycle rule for individual objects in an Outposts bucket. </p>
    public let rules: [LifecycleRule]?

    public init (
        rules: [LifecycleRule]? = nil
    )
    {
        self.rules = rules
    }
}

extension LifecycleExpiration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case date = "Date"
        case days = "Days"
        case expiredObjectDeleteMarker = "ExpiredObjectDeleteMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let date = date {
            try container.encode(TimestampWrapper(date, format: .dateTime), forKey: Key("date"))
        }
        if days != 0 {
            try container.encode(days, forKey: Key("days"))
        }
        if expiredObjectDeleteMarker != false {
            try container.encode(expiredObjectDeleteMarker, forKey: Key("expiredObjectDeleteMarker"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .date)
        var dateBuffer:Date? = nil
        if let dateDecoded = dateDecoded {
            dateBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateDecoded, format: .dateTime)
        }
        date = dateBuffer
        let daysDecoded = try containerValues.decode(Int.self, forKey: .days)
        days = daysDecoded
        let expiredObjectDeleteMarkerDecoded = try containerValues.decode(Bool.self, forKey: .expiredObjectDeleteMarker)
        expiredObjectDeleteMarker = expiredObjectDeleteMarkerDecoded
    }
}

extension LifecycleExpiration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecycleExpiration(date: \(String(describing: date)), days: \(String(describing: days)), expiredObjectDeleteMarker: \(String(describing: expiredObjectDeleteMarker)))"}
}

extension LifecycleExpiration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container of the Outposts bucket lifecycle expiration.</p>
public struct LifecycleExpiration: Equatable {
    /// <p>Indicates at what date the object is to be deleted. Should be in GMT ISO 8601
    ///          format.</p>
    public let date: Date?
    /// <p>Indicates the lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.</p>
    public let days: Int
    /// <p>Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set
    ///          to true, the delete marker will be expired. If set to false, the policy takes no action.
    ///          This cannot be specified with Days or Date in a Lifecycle Expiration Policy.</p>
    public let expiredObjectDeleteMarker: Bool

    public init (
        date: Date? = nil,
        days: Int = 0,
        expiredObjectDeleteMarker: Bool = false
    )
    {
        self.date = date
        self.days = days
        self.expiredObjectDeleteMarker = expiredObjectDeleteMarker
    }
}

extension LifecycleRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case abortIncompleteMultipartUpload = "AbortIncompleteMultipartUpload"
        case expiration = "Expiration"
        case filter = "Filter"
        case iD = "ID"
        case noncurrentVersionExpiration = "NoncurrentVersionExpiration"
        case noncurrentVersionTransitions = "NoncurrentVersionTransitions"
        case status = "Status"
        case transitions = "Transitions"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let abortIncompleteMultipartUpload = abortIncompleteMultipartUpload {
            try container.encode(abortIncompleteMultipartUpload, forKey: Key("abortIncompleteMultipartUpload"))
        }
        if let expiration = expiration {
            try container.encode(expiration, forKey: Key("expiration"))
        }
        if let filter = filter {
            try container.encode(filter, forKey: Key("filter"))
        }
        if let iD = iD {
            try container.encode(iD, forKey: Key("iD"))
        }
        if let noncurrentVersionExpiration = noncurrentVersionExpiration {
            try container.encode(noncurrentVersionExpiration, forKey: Key("noncurrentVersionExpiration"))
        }
        if let noncurrentVersionTransitions = noncurrentVersionTransitions {
            var noncurrentVersionTransitionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("noncurrentVersionTransitions"))
            for noncurrentversiontransition0 in noncurrentVersionTransitions {
                try noncurrentVersionTransitionsContainer.encode(noncurrentversiontransition0, forKey: Key("NoncurrentVersionTransition"))
            }
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
        if let transitions = transitions {
            var transitionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("transitions"))
            for transition0 in transitions {
                try transitionsContainer.encode(transition0, forKey: Key("Transition"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expirationDecoded = try containerValues.decodeIfPresent(LifecycleExpiration.self, forKey: .expiration)
        expiration = expirationDecoded
        let iDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iD)
        iD = iDDecoded
        let filterDecoded = try containerValues.decodeIfPresent(LifecycleRuleFilter.self, forKey: .filter)
        filter = filterDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ExpirationStatus.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.transitions) {
            struct KeyVal0{struct Transition{}}
            let transitionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Transition>.CodingKeys.self, forKey: .transitions)
            if let transitionsWrappedContainer = transitionsWrappedContainer {
                let transitionsContainer = try transitionsWrappedContainer.decodeIfPresent([Transition].self, forKey: .member)
                var transitionsBuffer:[Transition]? = nil
                if let transitionsContainer = transitionsContainer {
                    transitionsBuffer = [Transition]()
                    for structureContainer0 in transitionsContainer {
                        transitionsBuffer?.append(structureContainer0)
                    }
                }
                transitions = transitionsBuffer
            } else {
                transitions = []
            }
        } else {
            transitions = nil
        }
        if containerValues.contains(.noncurrentVersionTransitions) {
            struct KeyVal0{struct NoncurrentVersionTransition{}}
            let noncurrentVersionTransitionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.NoncurrentVersionTransition>.CodingKeys.self, forKey: .noncurrentVersionTransitions)
            if let noncurrentVersionTransitionsWrappedContainer = noncurrentVersionTransitionsWrappedContainer {
                let noncurrentVersionTransitionsContainer = try noncurrentVersionTransitionsWrappedContainer.decodeIfPresent([NoncurrentVersionTransition].self, forKey: .member)
                var noncurrentVersionTransitionsBuffer:[NoncurrentVersionTransition]? = nil
                if let noncurrentVersionTransitionsContainer = noncurrentVersionTransitionsContainer {
                    noncurrentVersionTransitionsBuffer = [NoncurrentVersionTransition]()
                    for structureContainer0 in noncurrentVersionTransitionsContainer {
                        noncurrentVersionTransitionsBuffer?.append(structureContainer0)
                    }
                }
                noncurrentVersionTransitions = noncurrentVersionTransitionsBuffer
            } else {
                noncurrentVersionTransitions = []
            }
        } else {
            noncurrentVersionTransitions = nil
        }
        let noncurrentVersionExpirationDecoded = try containerValues.decodeIfPresent(NoncurrentVersionExpiration.self, forKey: .noncurrentVersionExpiration)
        noncurrentVersionExpiration = noncurrentVersionExpirationDecoded
        let abortIncompleteMultipartUploadDecoded = try containerValues.decodeIfPresent(AbortIncompleteMultipartUpload.self, forKey: .abortIncompleteMultipartUpload)
        abortIncompleteMultipartUpload = abortIncompleteMultipartUploadDecoded
    }
}

extension LifecycleRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecycleRule(abortIncompleteMultipartUpload: \(String(describing: abortIncompleteMultipartUpload)), expiration: \(String(describing: expiration)), filter: \(String(describing: filter)), iD: \(String(describing: iD)), noncurrentVersionExpiration: \(String(describing: noncurrentVersionExpiration)), noncurrentVersionTransitions: \(String(describing: noncurrentVersionTransitions)), status: \(String(describing: status)), transitions: \(String(describing: transitions)))"}
}

extension LifecycleRule: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container for the Outposts bucket lifecycle rule.</p>
public struct LifecycleRule: Equatable {
    /// <p>Specifies the days since the initiation of an incomplete multipart upload that Amazon S3
    ///          waits before permanently removing all parts of the upload. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config">
    ///             Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Policy</a> in the
    ///             <i>Amazon S3 User Guide</i>.</p>
    public let abortIncompleteMultipartUpload: AbortIncompleteMultipartUpload?
    /// <p>Specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object
    ///          has a delete marker.</p>
    public let expiration: LifecycleExpiration?
    /// <p>The container for the filter of lifecycle rule.</p>
    public let filter: LifecycleRuleFilter?
    /// <p>Unique identifier for the rule. The value cannot be longer than 255 characters.</p>
    public let iD: String?
    /// <p>The noncurrent version expiration of the lifecycle rule.</p>
    ///          <note>
    ///             <p>This is not supported by Amazon S3 on Outposts buckets.</p>
    ///          </note>
    public let noncurrentVersionExpiration: NoncurrentVersionExpiration?
    /// <p> Specifies the transition rule for the lifecycle rule that describes when noncurrent
    ///          objects transition to a specific storage class. If your bucket is versioning-enabled (or
    ///          versioning is suspended), you can set this action to request that Amazon S3 transition
    ///          noncurrent object versions to a specific storage class at a set period in the object's
    ///          lifetime. </p>
    ///          <note>
    ///             <p>This is not supported by Amazon S3 on Outposts buckets.</p>
    ///          </note>
    public let noncurrentVersionTransitions: [NoncurrentVersionTransition]?
    /// <p>If 'Enabled', the rule is currently being applied. If 'Disabled', the rule is not currently being applied.</p>
    public let status: ExpirationStatus?
    /// <p>Specifies when an Amazon S3 object transitions to a specified storage class.</p>
    ///          <note>
    ///             <p>This is not supported by Amazon S3 on Outposts buckets.</p>
    ///          </note>
    public let transitions: [Transition]?

    public init (
        abortIncompleteMultipartUpload: AbortIncompleteMultipartUpload? = nil,
        expiration: LifecycleExpiration? = nil,
        filter: LifecycleRuleFilter? = nil,
        iD: String? = nil,
        noncurrentVersionExpiration: NoncurrentVersionExpiration? = nil,
        noncurrentVersionTransitions: [NoncurrentVersionTransition]? = nil,
        status: ExpirationStatus? = nil,
        transitions: [Transition]? = nil
    )
    {
        self.abortIncompleteMultipartUpload = abortIncompleteMultipartUpload
        self.expiration = expiration
        self.filter = filter
        self.iD = iD
        self.noncurrentVersionExpiration = noncurrentVersionExpiration
        self.noncurrentVersionTransitions = noncurrentVersionTransitions
        self.status = status
        self.transitions = transitions
    }
}

extension LifecycleRuleAndOperator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case prefix = "Prefix"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("tags"))
            for s3tag0 in tags {
                try tagsContainer.encode(s3tag0, forKey: Key("member"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3Tag].self, forKey: .member)
                var tagsBuffer:[S3Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension LifecycleRuleAndOperator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecycleRuleAndOperator(prefix: \(String(describing: prefix)), tags: \(String(describing: tags)))"}
}

extension LifecycleRuleAndOperator: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container for the Outposts bucket lifecycle rule and operator.</p>
public struct LifecycleRuleAndOperator: Equatable {
    /// <p>Prefix identifying one or more objects to which the rule applies.</p>
    public let prefix: String?
    /// <p>All of these tags must exist in the object's tag set in order for the rule to apply.</p>
    public let tags: [S3Tag]?

    public init (
        prefix: String? = nil,
        tags: [S3Tag]? = nil
    )
    {
        self.prefix = prefix
        self.tags = tags
    }
}

extension LifecycleRuleFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case and = "And"
        case prefix = "Prefix"
        case tag = "Tag"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let and = and {
            try container.encode(and, forKey: Key("and"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
        if let tag = tag {
            try container.encode(tag, forKey: Key("tag"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let tagDecoded = try containerValues.decodeIfPresent(S3Tag.self, forKey: .tag)
        tag = tagDecoded
        let andDecoded = try containerValues.decodeIfPresent(LifecycleRuleAndOperator.self, forKey: .and)
        and = andDecoded
    }
}

extension LifecycleRuleFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecycleRuleFilter(and: \(String(describing: and)), prefix: \(String(describing: prefix)), tag: \(String(describing: tag)))"}
}

extension LifecycleRuleFilter: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container for the filter of the lifecycle rule.</p>
public struct LifecycleRuleFilter: Equatable {
    /// <p>The container for the <code>AND</code> condition for the lifecycle rule.</p>
    public let and: LifecycleRuleAndOperator?
    /// <p>Prefix identifying one or more objects to which the rule applies.</p>
    ///          <important>
    ///             <p>Replacement must be made for object keys containing special characters (such as carriage returns) when using
    ///          XML requests. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints">
    ///             XML related object key constraints</a>.</p>
    ///          </important>
    public let prefix: String?
    /// <p></p>
    public let tag: S3Tag?

    public init (
        and: LifecycleRuleAndOperator? = nil,
        prefix: String? = nil,
        tag: S3Tag? = nil
    )
    {
        self.and = and
        self.prefix = prefix
        self.tag = tag
    }
}

extension ListAccessPointsForObjectLambdaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccessPointsForObjectLambdaInput(accountId: \(String(describing: accountId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccessPointsForObjectLambdaInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAccessPointsForObjectLambdaInputHeadersMiddleware: Middleware {
    public let id: String = "ListAccessPointsForObjectLambdaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessPointsForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessPointsForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessPointsForObjectLambdaInput>
    public typealias MOutput = OperationOutput<ListAccessPointsForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessPointsForObjectLambdaOutputError>
}

public struct ListAccessPointsForObjectLambdaInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAccessPointsForObjectLambdaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessPointsForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessPointsForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessPointsForObjectLambdaInput>
    public typealias MOutput = OperationOutput<ListAccessPointsForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessPointsForObjectLambdaOutputError>
}

public struct ListAccessPointsForObjectLambdaInput: Equatable {
    /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
    public let accountId: String?
    /// <p>The maximum number of access points that you want to include in the list. If there are more than this number of access points, then the response will include a continuation token in the <code>NextToken</code> field that you can use to retrieve the next page of access points.</p>
    public let maxResults: Int
    /// <p>If the list has more access points than can be returned in one call to this
    ///          API, this field contains a continuation token that you can provide in subsequent calls to
    ///          this API to retrieve additional access points.</p>
    public let nextToken: String?

    public init (
        accountId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccessPointsForObjectLambdaInputBody: Equatable {
}

extension ListAccessPointsForObjectLambdaInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAccessPointsForObjectLambdaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListAccessPointsForObjectLambdaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccessPointsForObjectLambdaOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessPointsForObjectLambdaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccessPointsForObjectLambdaOutputResponse(nextToken: \(String(describing: nextToken)), objectLambdaAccessPointList: \(String(describing: objectLambdaAccessPointList)))"}
}

extension ListAccessPointsForObjectLambdaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAccessPointsForObjectLambdaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.objectLambdaAccessPointList = output.objectLambdaAccessPointList
        } else {
            self.nextToken = nil
            self.objectLambdaAccessPointList = nil
        }
    }
}

public struct ListAccessPointsForObjectLambdaOutputResponse: Equatable {
    /// <p>If the list has more access points than can be returned in one call to this
    ///          API, this field contains a continuation token that you can provide in subsequent calls to
    ///          this API to retrieve additional access points.</p>
    public let nextToken: String?
    /// <p>Returns list of Object Lambda Access Points.</p>
    public let objectLambdaAccessPointList: [ObjectLambdaAccessPoint]?

    public init (
        nextToken: String? = nil,
        objectLambdaAccessPointList: [ObjectLambdaAccessPoint]? = nil
    )
    {
        self.nextToken = nextToken
        self.objectLambdaAccessPointList = objectLambdaAccessPointList
    }
}

struct ListAccessPointsForObjectLambdaOutputResponseBody: Equatable {
    public let objectLambdaAccessPointList: [ObjectLambdaAccessPoint]?
    public let nextToken: String?
}

extension ListAccessPointsForObjectLambdaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case objectLambdaAccessPointList = "ObjectLambdaAccessPointList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.objectLambdaAccessPointList) {
            struct KeyVal0{struct ObjectLambdaAccessPoint{}}
            let objectLambdaAccessPointListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ObjectLambdaAccessPoint>.CodingKeys.self, forKey: .objectLambdaAccessPointList)
            if let objectLambdaAccessPointListWrappedContainer = objectLambdaAccessPointListWrappedContainer {
                let objectLambdaAccessPointListContainer = try objectLambdaAccessPointListWrappedContainer.decodeIfPresent([ObjectLambdaAccessPoint].self, forKey: .member)
                var objectLambdaAccessPointListBuffer:[ObjectLambdaAccessPoint]? = nil
                if let objectLambdaAccessPointListContainer = objectLambdaAccessPointListContainer {
                    objectLambdaAccessPointListBuffer = [ObjectLambdaAccessPoint]()
                    for structureContainer0 in objectLambdaAccessPointListContainer {
                        objectLambdaAccessPointListBuffer?.append(structureContainer0)
                    }
                }
                objectLambdaAccessPointList = objectLambdaAccessPointListBuffer
            } else {
                objectLambdaAccessPointList = []
            }
        } else {
            objectLambdaAccessPointList = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccessPointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccessPointsInput(accountId: \(String(describing: accountId)), bucket: \(String(describing: bucket)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccessPointsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAccessPointsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAccessPointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessPointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessPointsInput>
    public typealias MOutput = OperationOutput<ListAccessPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessPointsOutputError>
}

public struct ListAccessPointsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAccessPointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessPointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let bucket = input.operationInput.bucket {
            let bucketQueryItem = URLQueryItem(name: "bucket".urlPercentEncoding(), value: String(bucket).urlPercentEncoding())
            input.builder.withQueryItem(bucketQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessPointsInput>
    public typealias MOutput = OperationOutput<ListAccessPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessPointsOutputError>
}

public struct ListAccessPointsInput: Equatable {
    /// <p>The AWS account ID for owner of the bucket whose access points you want to list.</p>
    public let accountId: String?
    /// <p>The name of the bucket whose associated access points you want to list.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
    public let bucket: String?
    /// <p>The maximum number of access points that you want to include in the list. If the specified
    ///          bucket has more than this number of access points, then the response will include a
    ///          continuation token in the <code>NextToken</code> field that you can use to retrieve the
    ///          next page of access points.</p>
    public let maxResults: Int
    /// <p>A continuation token. If a previous call to <code>ListAccessPoints</code> returned a continuation token in the <code>NextToken</code> field, then providing that value here causes Amazon S3 to retrieve the next page of results.</p>
    public let nextToken: String?

    public init (
        accountId: String? = nil,
        bucket: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccessPointsInputBody: Equatable {
}

extension ListAccessPointsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAccessPointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListAccessPointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccessPointsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessPointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccessPointsOutputResponse(accessPointList: \(String(describing: accessPointList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccessPointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAccessPointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessPointList = output.accessPointList
            self.nextToken = output.nextToken
        } else {
            self.accessPointList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessPointsOutputResponse: Equatable {
    /// <p>Contains identification and configuration information for one or more access points
    ///          associated with the specified bucket.</p>
    public let accessPointList: [AccessPoint]?
    /// <p>If the specified bucket has more access points than can be returned in one call to this
    ///          API, this field contains a continuation token that you can provide in subsequent calls to
    ///          this API to retrieve additional access points.</p>
    public let nextToken: String?

    public init (
        accessPointList: [AccessPoint]? = nil,
        nextToken: String? = nil
    )
    {
        self.accessPointList = accessPointList
        self.nextToken = nextToken
    }
}

struct ListAccessPointsOutputResponseBody: Equatable {
    public let accessPointList: [AccessPoint]?
    public let nextToken: String?
}

extension ListAccessPointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessPointList = "AccessPointList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.accessPointList) {
            struct KeyVal0{struct AccessPoint{}}
            let accessPointListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccessPoint>.CodingKeys.self, forKey: .accessPointList)
            if let accessPointListWrappedContainer = accessPointListWrappedContainer {
                let accessPointListContainer = try accessPointListWrappedContainer.decodeIfPresent([AccessPoint].self, forKey: .member)
                var accessPointListBuffer:[AccessPoint]? = nil
                if let accessPointListContainer = accessPointListContainer {
                    accessPointListBuffer = [AccessPoint]()
                    for structureContainer0 in accessPointListContainer {
                        accessPointListBuffer?.append(structureContainer0)
                    }
                }
                accessPointList = accessPointListBuffer
            } else {
                accessPointList = []
            }
        } else {
            accessPointList = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsInput(accountId: \(String(describing: accountId)), jobStatuses: \(String(describing: jobStatuses)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

public struct ListJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let jobStatuses = input.operationInput.jobStatuses {
            jobStatuses.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "jobStatuses".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

public struct ListJobsInput: Equatable {
    /// <p>The AWS account ID associated with the S3 Batch Operations job.</p>
    public let accountId: String?
    /// <p>The <code>List Jobs</code> request returns jobs that match the statuses listed in this element.</p>
    public let jobStatuses: [JobStatus]?
    /// <p>The maximum number of jobs that Amazon S3 will include in the <code>List Jobs</code> response. If there are more jobs than this number, the response will include a pagination token in the <code>NextToken</code> field to enable you to retrieve the next page of results.</p>
    public let maxResults: Int
    /// <p>A pagination token to request the next page of results. Use the token that Amazon S3 returned in the <code>NextToken</code> element of the <code>ListJobsResult</code> from the previous <code>List Jobs</code> request.</p>
    public let nextToken: String?

    public init (
        accountId: String? = nil,
        jobStatuses: [JobStatus]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.accountId = accountId
        self.jobStatuses = jobStatuses
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListJobsInputBody: Equatable {
}

extension ListJobsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsOutputResponse(jobs: \(String(describing: jobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobsOutputResponse: Equatable {
    /// <p>The list of current jobs and jobs that have ended within the last 30 days.</p>
    public let jobs: [JobListDescriptor]?
    /// <p>If the <code>List Jobs</code> request produced more than the maximum number of results, you can pass this value into a subsequent <code>List Jobs</code> request in order to retrieve
    ///             the next page of results.</p>
    public let nextToken: String?

    public init (
        jobs: [JobListDescriptor]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListJobsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let jobs: [JobListDescriptor]?
}

extension ListJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobs = "Jobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        if containerValues.contains(.jobs) {
            struct KeyVal0{struct member{}}
            let jobsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .jobs)
            if let jobsWrappedContainer = jobsWrappedContainer {
                let jobsContainer = try jobsWrappedContainer.decodeIfPresent([JobListDescriptor].self, forKey: .member)
                var jobsBuffer:[JobListDescriptor]? = nil
                if let jobsContainer = jobsContainer {
                    jobsBuffer = [JobListDescriptor]()
                    for structureContainer0 in jobsContainer {
                        jobsBuffer?.append(structureContainer0)
                    }
                }
                jobs = jobsBuffer
            } else {
                jobs = []
            }
        } else {
            jobs = nil
        }
    }
}

extension ListRegionalBucketsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRegionalBucketsInput(accountId: \(String(describing: accountId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), outpostId: \(String(describing: outpostId)))"}
}

extension ListRegionalBucketsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRegionalBucketsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRegionalBucketsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRegionalBucketsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRegionalBucketsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        if let outpostId = input.operationInput.outpostId {
            input.builder.withHeader(name: "x-amz-outpost-id", value: String(outpostId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRegionalBucketsInput>
    public typealias MOutput = OperationOutput<ListRegionalBucketsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRegionalBucketsOutputError>
}

public struct ListRegionalBucketsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRegionalBucketsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRegionalBucketsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRegionalBucketsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRegionalBucketsInput>
    public typealias MOutput = OperationOutput<ListRegionalBucketsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRegionalBucketsOutputError>
}

public struct ListRegionalBucketsInput: Equatable {
    /// <p>The AWS account ID of the Outposts bucket.</p>
    public let accountId: String?
    /// <p></p>
    public let maxResults: Int
    /// <p></p>
    public let nextToken: String?
    /// <p>The ID of the AWS Outposts.</p>
    ///          <note>
    ///             <p>This is required by Amazon S3 on Outposts buckets.</p>
    ///          </note>
    public let outpostId: String?

    public init (
        accountId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        outpostId: String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outpostId = outpostId
    }
}

struct ListRegionalBucketsInputBody: Equatable {
}

extension ListRegionalBucketsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRegionalBucketsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListRegionalBucketsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRegionalBucketsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRegionalBucketsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRegionalBucketsOutputResponse(nextToken: \(String(describing: nextToken)), regionalBucketList: \(String(describing: regionalBucketList)))"}
}

extension ListRegionalBucketsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRegionalBucketsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.regionalBucketList = output.regionalBucketList
        } else {
            self.nextToken = nil
            self.regionalBucketList = nil
        }
    }
}

public struct ListRegionalBucketsOutputResponse: Equatable {
    /// <p>
    ///             <code>NextToken</code> is sent when <code>isTruncated</code> is true, which means
    ///       there are more buckets that can be listed. The next list requests to Amazon S3
    ///       can be continued with this <code>NextToken</code>.
    ///       <code>NextToken</code> is obfuscated and is not a real key.</p>
    public let nextToken: String?
    /// <p></p>
    public let regionalBucketList: [RegionalBucket]?

    public init (
        nextToken: String? = nil,
        regionalBucketList: [RegionalBucket]? = nil
    )
    {
        self.nextToken = nextToken
        self.regionalBucketList = regionalBucketList
    }
}

struct ListRegionalBucketsOutputResponseBody: Equatable {
    public let regionalBucketList: [RegionalBucket]?
    public let nextToken: String?
}

extension ListRegionalBucketsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case regionalBucketList = "RegionalBucketList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.regionalBucketList) {
            struct KeyVal0{struct RegionalBucket{}}
            let regionalBucketListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RegionalBucket>.CodingKeys.self, forKey: .regionalBucketList)
            if let regionalBucketListWrappedContainer = regionalBucketListWrappedContainer {
                let regionalBucketListContainer = try regionalBucketListWrappedContainer.decodeIfPresent([RegionalBucket].self, forKey: .member)
                var regionalBucketListBuffer:[RegionalBucket]? = nil
                if let regionalBucketListContainer = regionalBucketListContainer {
                    regionalBucketListBuffer = [RegionalBucket]()
                    for structureContainer0 in regionalBucketListContainer {
                        regionalBucketListBuffer?.append(structureContainer0)
                    }
                }
                regionalBucketList = regionalBucketListBuffer
            } else {
                regionalBucketList = []
            }
        } else {
            regionalBucketList = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStorageLensConfigurationEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case homeRegion = "HomeRegion"
        case id = "Id"
        case isEnabled = "IsEnabled"
        case storageLensArn = "StorageLensArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let homeRegion = homeRegion {
            try container.encode(homeRegion, forKey: Key("homeRegion"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if isEnabled != false {
            try container.encode(isEnabled, forKey: Key("isEnabled"))
        }
        if let storageLensArn = storageLensArn {
            try container.encode(storageLensArn, forKey: Key("storageLensArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let storageLensArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageLensArn)
        storageLensArn = storageLensArnDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let isEnabledDecoded = try containerValues.decode(Bool.self, forKey: .isEnabled)
        isEnabled = isEnabledDecoded
    }
}

extension ListStorageLensConfigurationEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStorageLensConfigurationEntry(homeRegion: \(String(describing: homeRegion)), id: \(String(describing: id)), isEnabled: \(String(describing: isEnabled)), storageLensArn: \(String(describing: storageLensArn)))"}
}

extension ListStorageLensConfigurationEntry: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Part of <code>ListStorageLensConfigurationResult</code>. Each entry includes the
///          description of the S3 Storage Lens configuration, its home Region, whether it is enabled, its
///          Amazon Resource Name (ARN), and config ID.</p>
public struct ListStorageLensConfigurationEntry: Equatable {
    /// <p>A container for the S3 Storage Lens home Region. Your metrics data is stored and retained in
    ///          your designated S3 Storage Lens home Region.</p>
    public let homeRegion: String?
    /// <p>A container for the S3 Storage Lens configuration ID.</p>
    public let id: String?
    /// <p>A container for whether the S3 Storage Lens configuration is enabled. This property is required.</p>
    public let isEnabled: Bool
    /// <p>The ARN of the S3 Storage Lens configuration. This property is read-only.</p>
    public let storageLensArn: String?

    public init (
        homeRegion: String? = nil,
        id: String? = nil,
        isEnabled: Bool = false,
        storageLensArn: String? = nil
    )
    {
        self.homeRegion = homeRegion
        self.id = id
        self.isEnabled = isEnabled
        self.storageLensArn = storageLensArn
    }
}

extension ListStorageLensConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStorageLensConfigurationsInput(accountId: \(String(describing: accountId)), nextToken: \(String(describing: nextToken)))"}
}

extension ListStorageLensConfigurationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListStorageLensConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListStorageLensConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStorageLensConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStorageLensConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStorageLensConfigurationsInput>
    public typealias MOutput = OperationOutput<ListStorageLensConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStorageLensConfigurationsOutputError>
}

public struct ListStorageLensConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStorageLensConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStorageLensConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStorageLensConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStorageLensConfigurationsInput>
    public typealias MOutput = OperationOutput<ListStorageLensConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStorageLensConfigurationsOutputError>
}

public struct ListStorageLensConfigurationsInput: Equatable {
    /// <p>The account ID of the requester.</p>
    public let accountId: String?
    /// <p>A pagination token to request the next page of results.</p>
    public let nextToken: String?

    public init (
        accountId: String? = nil,
        nextToken: String? = nil
    )
    {
        self.accountId = accountId
        self.nextToken = nextToken
    }
}

struct ListStorageLensConfigurationsInputBody: Equatable {
}

extension ListStorageLensConfigurationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListStorageLensConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListStorageLensConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStorageLensConfigurationsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStorageLensConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStorageLensConfigurationsOutputResponse(nextToken: \(String(describing: nextToken)), storageLensConfigurationList: \(String(describing: storageLensConfigurationList)))"}
}

extension ListStorageLensConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStorageLensConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.storageLensConfigurationList = output.storageLensConfigurationList
        } else {
            self.nextToken = nil
            self.storageLensConfigurationList = nil
        }
    }
}

public struct ListStorageLensConfigurationsOutputResponse: Equatable {
    /// <p>If the request produced more than the maximum number of S3 Storage Lens configuration results,
    ///          you can pass this value into a subsequent request to retrieve the next page of
    ///          results.</p>
    public let nextToken: String?
    /// <p>A list of S3 Storage Lens configurations.</p>
    public let storageLensConfigurationList: [ListStorageLensConfigurationEntry]?

    public init (
        nextToken: String? = nil,
        storageLensConfigurationList: [ListStorageLensConfigurationEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageLensConfigurationList = storageLensConfigurationList
    }
}

struct ListStorageLensConfigurationsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let storageLensConfigurationList: [ListStorageLensConfigurationEntry]?
}

extension ListStorageLensConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case storageLensConfigurationList = "StorageLensConfigurationList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        if containerValues.contains(.storageLensConfigurationList) {
            let storageLensConfigurationListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .storageLensConfigurationList)
            if storageLensConfigurationListWrappedContainer != nil {
                let storageLensConfigurationListContainer = try containerValues.decodeIfPresent([ListStorageLensConfigurationEntry].self, forKey: .storageLensConfigurationList)
                var storageLensConfigurationListBuffer:[ListStorageLensConfigurationEntry]? = nil
                if let storageLensConfigurationListContainer = storageLensConfigurationListContainer {
                    storageLensConfigurationListBuffer = [ListStorageLensConfigurationEntry]()
                    for structureContainer0 in storageLensConfigurationListContainer {
                        storageLensConfigurationListBuffer?.append(structureContainer0)
                    }
                }
                storageLensConfigurationList = storageLensConfigurationListBuffer
            } else {
                storageLensConfigurationList = []
            }
        } else {
            storageLensConfigurationList = nil
        }
    }
}

public enum NetworkOrigin {
    case internet
    case vpc
    case sdkUnknown(String)
}

extension NetworkOrigin : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NetworkOrigin] {
        return [
            .internet,
            .vpc,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internet: return "Internet"
        case .vpc: return "VPC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NetworkOrigin(rawValue: rawValue) ?? NetworkOrigin.sdkUnknown(rawValue)
    }
}

extension NoSuchPublicAccessBlockConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchPublicAccessBlockConfiguration(message: \(String(describing: message)))"}
}

extension NoSuchPublicAccessBlockConfiguration: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NoSuchPublicAccessBlockConfigurationBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon S3 throws this exception if you make a <code>GetPublicAccessBlock</code> request
///       against an account that doesn't have a <code>PublicAccessBlockConfiguration</code> set.</p>
public struct NoSuchPublicAccessBlockConfiguration: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchPublicAccessBlockConfigurationBody: Equatable {
    public let message: String?
}

extension NoSuchPublicAccessBlockConfigurationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoncurrentVersionExpiration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case noncurrentDays = "NoncurrentDays"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if noncurrentDays != 0 {
            try container.encode(noncurrentDays, forKey: Key("noncurrentDays"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noncurrentDaysDecoded = try containerValues.decode(Int.self, forKey: .noncurrentDays)
        noncurrentDays = noncurrentDaysDecoded
    }
}

extension NoncurrentVersionExpiration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoncurrentVersionExpiration(noncurrentDays: \(String(describing: noncurrentDays)))"}
}

extension NoncurrentVersionExpiration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container of the noncurrent version expiration.</p>
public struct NoncurrentVersionExpiration: Equatable {
    /// <p>Specifies the number of days an object is noncurrent before Amazon S3 can perform the
    ///          associated action. For information about the noncurrent days calculations, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations">How
    ///             Amazon S3 Calculates When an Object Became Noncurrent</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let noncurrentDays: Int

    public init (
        noncurrentDays: Int = 0
    )
    {
        self.noncurrentDays = noncurrentDays
    }
}

extension NoncurrentVersionTransition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case noncurrentDays = "NoncurrentDays"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if noncurrentDays != 0 {
            try container.encode(noncurrentDays, forKey: Key("noncurrentDays"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: Key("storageClass"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noncurrentDaysDecoded = try containerValues.decode(Int.self, forKey: .noncurrentDays)
        noncurrentDays = noncurrentDaysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(TransitionStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension NoncurrentVersionTransition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoncurrentVersionTransition(noncurrentDays: \(String(describing: noncurrentDays)), storageClass: \(String(describing: storageClass)))"}
}

extension NoncurrentVersionTransition: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container for the noncurrent version transition.</p>
public struct NoncurrentVersionTransition: Equatable {
    /// <p>Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action.
    ///          For information about the noncurrent days calculations, see
    ///          <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations">
    ///             How Amazon S3 Calculates How Long an Object Has Been Noncurrent</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let noncurrentDays: Int
    /// <p>The class of storage used to store the object.</p>
    public let storageClass: TransitionStorageClass?

    public init (
        noncurrentDays: Int = 0,
        storageClass: TransitionStorageClass? = nil
    )
    {
        self.noncurrentDays = noncurrentDays
        self.storageClass = storageClass
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ObjectLambdaAccessPoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case objectLambdaAccessPointArn = "ObjectLambdaAccessPointArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
        if let objectLambdaAccessPointArn = objectLambdaAccessPointArn {
            try container.encode(objectLambdaAccessPointArn, forKey: Key("objectLambdaAccessPointArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let objectLambdaAccessPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectLambdaAccessPointArn)
        objectLambdaAccessPointArn = objectLambdaAccessPointArnDecoded
    }
}

extension ObjectLambdaAccessPoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectLambdaAccessPoint(name: \(String(describing: name)), objectLambdaAccessPointArn: \(String(describing: objectLambdaAccessPointArn)))"}
}

extension ObjectLambdaAccessPoint: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>An access point with an attached AWS Lambda function used to access transformed data from an Amazon S3 bucket.</p>
public struct ObjectLambdaAccessPoint: Equatable {
    /// <p>The name of the Object Lambda Access Point.</p>
    public let name: String?
    /// <p>Specifies the ARN for the Object Lambda Access Point.</p>
    public let objectLambdaAccessPointArn: String?

    public init (
        name: String? = nil,
        objectLambdaAccessPointArn: String? = nil
    )
    {
        self.name = name
        self.objectLambdaAccessPointArn = objectLambdaAccessPointArn
    }
}

public enum ObjectLambdaAllowedFeature {
    case getobjectpartnumber
    case getobjectrange
    case sdkUnknown(String)
}

extension ObjectLambdaAllowedFeature : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObjectLambdaAllowedFeature] {
        return [
            .getobjectpartnumber,
            .getobjectrange,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .getobjectpartnumber: return "GetObject-PartNumber"
        case .getobjectrange: return "GetObject-Range"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObjectLambdaAllowedFeature(rawValue: rawValue) ?? ObjectLambdaAllowedFeature.sdkUnknown(rawValue)
    }
}

extension ObjectLambdaConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedFeatures = "AllowedFeatures"
        case cloudWatchMetricsEnabled = "CloudWatchMetricsEnabled"
        case supportingAccessPoint = "SupportingAccessPoint"
        case transformationConfigurations = "TransformationConfigurations"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let allowedFeatures = allowedFeatures {
            var allowedFeaturesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("allowedFeatures"))
            for objectlambdaallowedfeature0 in allowedFeatures {
                try allowedFeaturesContainer.encode(objectlambdaallowedfeature0, forKey: Key("AllowedFeature"))
            }
        }
        if cloudWatchMetricsEnabled != false {
            try container.encode(cloudWatchMetricsEnabled, forKey: Key("cloudWatchMetricsEnabled"))
        }
        if let supportingAccessPoint = supportingAccessPoint {
            try container.encode(supportingAccessPoint, forKey: Key("supportingAccessPoint"))
        }
        if let transformationConfigurations = transformationConfigurations {
            var transformationConfigurationsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("transformationConfigurations"))
            for objectlambdatransformationconfiguration0 in transformationConfigurations {
                try transformationConfigurationsContainer.encode(objectlambdatransformationconfiguration0, forKey: Key("TransformationConfiguration"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let supportingAccessPointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .supportingAccessPoint)
        supportingAccessPoint = supportingAccessPointDecoded
        let cloudWatchMetricsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .cloudWatchMetricsEnabled)
        cloudWatchMetricsEnabled = cloudWatchMetricsEnabledDecoded
        if containerValues.contains(.allowedFeatures) {
            struct KeyVal0{struct AllowedFeature{}}
            let allowedFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AllowedFeature>.CodingKeys.self, forKey: .allowedFeatures)
            if let allowedFeaturesWrappedContainer = allowedFeaturesWrappedContainer {
                let allowedFeaturesContainer = try allowedFeaturesWrappedContainer.decodeIfPresent([ObjectLambdaAllowedFeature].self, forKey: .member)
                var allowedFeaturesBuffer:[ObjectLambdaAllowedFeature]? = nil
                if let allowedFeaturesContainer = allowedFeaturesContainer {
                    allowedFeaturesBuffer = [ObjectLambdaAllowedFeature]()
                    for stringContainer0 in allowedFeaturesContainer {
                        allowedFeaturesBuffer?.append(stringContainer0)
                    }
                }
                allowedFeatures = allowedFeaturesBuffer
            } else {
                allowedFeatures = []
            }
        } else {
            allowedFeatures = nil
        }
        if containerValues.contains(.transformationConfigurations) {
            struct KeyVal0{struct TransformationConfiguration{}}
            let transformationConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.TransformationConfiguration>.CodingKeys.self, forKey: .transformationConfigurations)
            if let transformationConfigurationsWrappedContainer = transformationConfigurationsWrappedContainer {
                let transformationConfigurationsContainer = try transformationConfigurationsWrappedContainer.decodeIfPresent([ObjectLambdaTransformationConfiguration].self, forKey: .member)
                var transformationConfigurationsBuffer:[ObjectLambdaTransformationConfiguration]? = nil
                if let transformationConfigurationsContainer = transformationConfigurationsContainer {
                    transformationConfigurationsBuffer = [ObjectLambdaTransformationConfiguration]()
                    for structureContainer0 in transformationConfigurationsContainer {
                        transformationConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                transformationConfigurations = transformationConfigurationsBuffer
            } else {
                transformationConfigurations = []
            }
        } else {
            transformationConfigurations = nil
        }
    }
}

extension ObjectLambdaConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectLambdaConfiguration(allowedFeatures: \(String(describing: allowedFeatures)), cloudWatchMetricsEnabled: \(String(describing: cloudWatchMetricsEnabled)), supportingAccessPoint: \(String(describing: supportingAccessPoint)), transformationConfigurations: \(String(describing: transformationConfigurations)))"}
}

extension ObjectLambdaConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A configuration used when creating an Object Lambda Access Point.</p>
public struct ObjectLambdaConfiguration: Equatable {
    /// <p>A container for allowed features. Valid inputs are <code>GetObject-Range</code>
    ///            and <code>GetObject-PartNumber</code>.</p>
    public let allowedFeatures: [ObjectLambdaAllowedFeature]?
    /// <p>A container for whether the CloudWatch metrics configuration is enabled.</p>
    public let cloudWatchMetricsEnabled: Bool
    /// <p>Standard access point associated with the Object Lambda Access Point.</p>
    public let supportingAccessPoint: String?
    /// <p>A container for transformation configurations for an Object Lambda Access Point.</p>
    public let transformationConfigurations: [ObjectLambdaTransformationConfiguration]?

    public init (
        allowedFeatures: [ObjectLambdaAllowedFeature]? = nil,
        cloudWatchMetricsEnabled: Bool = false,
        supportingAccessPoint: String? = nil,
        transformationConfigurations: [ObjectLambdaTransformationConfiguration]? = nil
    )
    {
        self.allowedFeatures = allowedFeatures
        self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
        self.supportingAccessPoint = supportingAccessPoint
        self.transformationConfigurations = transformationConfigurations
    }
}

extension ObjectLambdaContentTransformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsLambda = "AwsLambda"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        switch self {
            case let .awsLambda(awsLambda):
                if let awsLambda = awsLambda {
                    try container.encode(awsLambda, forKey: Key("awsLambda"))
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: Key("sdkUnknown"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsLambdaDecoded = try containerValues.decodeIfPresent(AwsLambdaTransformation.self, forKey: .awsLambda)
        if let awsLambda = awsLambdaDecoded {
            self = .awsLambda(awsLambda)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>A container for AwsLambdaTransformation.</p>
public enum ObjectLambdaContentTransformation: Equatable {
    /// <p>A container for an AWS Lambda function.</p>
    case awsLambda(AwsLambdaTransformation?)
    case sdkUnknown(String?)
}

extension ObjectLambdaTransformationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case contentTransformation = "ContentTransformation"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let actions = actions {
            var actionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("actions"))
            for objectlambdatransformationconfigurationaction0 in actions {
                try actionsContainer.encode(objectlambdatransformationconfigurationaction0, forKey: Key("Action"))
            }
        }
        if let contentTransformation = contentTransformation {
            try container.encode(contentTransformation, forKey: Key("contentTransformation"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.actions) {
            struct KeyVal0{struct Action{}}
            let actionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Action>.CodingKeys.self, forKey: .actions)
            if let actionsWrappedContainer = actionsWrappedContainer {
                let actionsContainer = try actionsWrappedContainer.decodeIfPresent([ObjectLambdaTransformationConfigurationAction].self, forKey: .member)
                var actionsBuffer:[ObjectLambdaTransformationConfigurationAction]? = nil
                if let actionsContainer = actionsContainer {
                    actionsBuffer = [ObjectLambdaTransformationConfigurationAction]()
                    for stringContainer0 in actionsContainer {
                        actionsBuffer?.append(stringContainer0)
                    }
                }
                actions = actionsBuffer
            } else {
                actions = []
            }
        } else {
            actions = nil
        }
        let contentTransformationDecoded = try containerValues.decodeIfPresent(ObjectLambdaContentTransformation.self, forKey: .contentTransformation)
        contentTransformation = contentTransformationDecoded
    }
}

extension ObjectLambdaTransformationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectLambdaTransformationConfiguration(actions: \(String(describing: actions)), contentTransformation: \(String(describing: contentTransformation)))"}
}

extension ObjectLambdaTransformationConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A configuration used when creating an Object Lambda Access Point transformation.</p>
public struct ObjectLambdaTransformationConfiguration: Equatable {
    /// <p>A container for the action of an Object Lambda Access Point configuration. Valid input is <code>GetObject</code>.</p>
    public let actions: [ObjectLambdaTransformationConfigurationAction]?
    /// <p>A container for the content transformation of an Object Lambda Access Point configuration.</p>
    public let contentTransformation: ObjectLambdaContentTransformation?

    public init (
        actions: [ObjectLambdaTransformationConfigurationAction]? = nil,
        contentTransformation: ObjectLambdaContentTransformation? = nil
    )
    {
        self.actions = actions
        self.contentTransformation = contentTransformation
    }
}

public enum ObjectLambdaTransformationConfigurationAction {
    case getobject
    case sdkUnknown(String)
}

extension ObjectLambdaTransformationConfigurationAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObjectLambdaTransformationConfigurationAction] {
        return [
            .getobject,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .getobject: return "GetObject"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObjectLambdaTransformationConfigurationAction(rawValue: rawValue) ?? ObjectLambdaTransformationConfigurationAction.sdkUnknown(rawValue)
    }
}

public enum OperationName {
    case lambdainvoke
    case s3deleteobjecttagging
    case s3initiaterestoreobject
    case s3putobjectacl
    case s3putobjectcopy
    case s3putobjectlegalhold
    case s3putobjectretention
    case s3putobjecttagging
    case sdkUnknown(String)
}

extension OperationName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperationName] {
        return [
            .lambdainvoke,
            .s3deleteobjecttagging,
            .s3initiaterestoreobject,
            .s3putobjectacl,
            .s3putobjectcopy,
            .s3putobjectlegalhold,
            .s3putobjectretention,
            .s3putobjecttagging,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lambdainvoke: return "LambdaInvoke"
        case .s3deleteobjecttagging: return "S3DeleteObjectTagging"
        case .s3initiaterestoreobject: return "S3InitiateRestoreObject"
        case .s3putobjectacl: return "S3PutObjectAcl"
        case .s3putobjectcopy: return "S3PutObjectCopy"
        case .s3putobjectlegalhold: return "S3PutObjectLegalHold"
        case .s3putobjectretention: return "S3PutObjectRetention"
        case .s3putobjecttagging: return "S3PutObjectTagging"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperationName(rawValue: rawValue) ?? OperationName.sdkUnknown(rawValue)
    }
}

public enum OutputSchemaVersion {
    case v1
    case sdkUnknown(String)
}

extension OutputSchemaVersion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OutputSchemaVersion] {
        return [
            .v1,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .v1: return "V_1"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OutputSchemaVersion(rawValue: rawValue) ?? OutputSchemaVersion.sdkUnknown(rawValue)
    }
}

extension PolicyStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isPublic = "IsPublic"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if isPublic != false {
            try container.encode(isPublic, forKey: Key("IsPublic"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isPublicDecoded = try containerValues.decode(Bool.self, forKey: .isPublic)
        isPublic = isPublicDecoded
    }
}

extension PolicyStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyStatus(isPublic: \(String(describing: isPublic)))"}
}

extension PolicyStatus: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Indicates whether this access point policy is public. For more information about how Amazon S3 evaluates policies to determine whether they are public, see
///          <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status">The Meaning of "Public"</a> in the
/// 	 <i>Amazon S3 User Guide</i>.
///       </p>
public struct PolicyStatus: Equatable {
    /// <p></p>
    public let isPublic: Bool

    public init (
        isPublic: Bool = false
    )
    {
        self.isPublic = isPublic
    }
}

extension PrefixLevel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case storageMetrics = "StorageMetrics"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let storageMetrics = storageMetrics {
            try container.encode(storageMetrics, forKey: Key("storageMetrics"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageMetricsDecoded = try containerValues.decodeIfPresent(PrefixLevelStorageMetrics.self, forKey: .storageMetrics)
        storageMetrics = storageMetricsDecoded
    }
}

extension PrefixLevel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PrefixLevel(storageMetrics: \(String(describing: storageMetrics)))"}
}

extension PrefixLevel: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for the prefix-level configuration.</p>
public struct PrefixLevel: Equatable {
    /// <p>A container for the prefix-level storage metrics for S3 Storage Lens.</p>
    public let storageMetrics: PrefixLevelStorageMetrics?

    public init (
        storageMetrics: PrefixLevelStorageMetrics? = nil
    )
    {
        self.storageMetrics = storageMetrics
    }
}

extension PrefixLevelStorageMetrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isEnabled = "IsEnabled"
        case selectionCriteria = "SelectionCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if isEnabled != false {
            try container.encode(isEnabled, forKey: Key("isEnabled"))
        }
        if let selectionCriteria = selectionCriteria {
            try container.encode(selectionCriteria, forKey: Key("selectionCriteria"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isEnabledDecoded = try containerValues.decode(Bool.self, forKey: .isEnabled)
        isEnabled = isEnabledDecoded
        let selectionCriteriaDecoded = try containerValues.decodeIfPresent(SelectionCriteria.self, forKey: .selectionCriteria)
        selectionCriteria = selectionCriteriaDecoded
    }
}

extension PrefixLevelStorageMetrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PrefixLevelStorageMetrics(isEnabled: \(String(describing: isEnabled)), selectionCriteria: \(String(describing: selectionCriteria)))"}
}

extension PrefixLevelStorageMetrics: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for the prefix-level storage metrics for S3 Storage Lens.</p>
public struct PrefixLevelStorageMetrics: Equatable {
    /// <p>A container for whether prefix-level storage metrics are enabled.</p>
    public let isEnabled: Bool
    /// <p></p>
    public let selectionCriteria: SelectionCriteria?

    public init (
        isEnabled: Bool = false,
        selectionCriteria: SelectionCriteria? = nil
    )
    {
        self.isEnabled = isEnabled
        self.selectionCriteria = selectionCriteria
    }
}

extension PublicAccessBlockConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockPublicAcls = "BlockPublicAcls"
        case blockPublicPolicy = "BlockPublicPolicy"
        case ignorePublicAcls = "IgnorePublicAcls"
        case restrictPublicBuckets = "RestrictPublicBuckets"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if blockPublicAcls != false {
            try container.encode(blockPublicAcls, forKey: Key("BlockPublicAcls"))
        }
        if blockPublicPolicy != false {
            try container.encode(blockPublicPolicy, forKey: Key("BlockPublicPolicy"))
        }
        if ignorePublicAcls != false {
            try container.encode(ignorePublicAcls, forKey: Key("IgnorePublicAcls"))
        }
        if restrictPublicBuckets != false {
            try container.encode(restrictPublicBuckets, forKey: Key("RestrictPublicBuckets"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockPublicAclsDecoded = try containerValues.decode(Bool.self, forKey: .blockPublicAcls)
        blockPublicAcls = blockPublicAclsDecoded
        let ignorePublicAclsDecoded = try containerValues.decode(Bool.self, forKey: .ignorePublicAcls)
        ignorePublicAcls = ignorePublicAclsDecoded
        let blockPublicPolicyDecoded = try containerValues.decode(Bool.self, forKey: .blockPublicPolicy)
        blockPublicPolicy = blockPublicPolicyDecoded
        let restrictPublicBucketsDecoded = try containerValues.decode(Bool.self, forKey: .restrictPublicBuckets)
        restrictPublicBuckets = restrictPublicBucketsDecoded
    }
}

extension PublicAccessBlockConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublicAccessBlockConfiguration(blockPublicAcls: \(String(describing: blockPublicAcls)), blockPublicPolicy: \(String(describing: blockPublicPolicy)), ignorePublicAcls: \(String(describing: ignorePublicAcls)), restrictPublicBuckets: \(String(describing: restrictPublicBuckets)))"}
}

extension PublicAccessBlockConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The <code>PublicAccessBlock</code> configuration that you want to apply to this Amazon S3 account.
///          You can enable the configuration options in any combination. For more information about
///          when Amazon S3 considers a bucket or object public, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status">The Meaning of "Public"</a> in the <i>Amazon S3 User Guide</i>.</p>
///          <p>This is not supported for Amazon S3 on Outposts.</p>
public struct PublicAccessBlockConfiguration: Equatable {
    /// <p>Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in
    ///       this account. Setting this element to <code>TRUE</code> causes the following behavior:</p>
    ///          <ul>
    ///             <li>
    ///                <p>PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.</p>
    ///             </li>
    ///             <li>
    ///                <p>PUT Object calls fail if the request includes a public ACL.</p>
    ///             </li>
    ///             <li>
    ///                <p>PUT Bucket calls fail if the request includes a public ACL.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Enabling this setting doesn't affect existing policies or ACLs.</p>
    ///          <p>This is not supported for Amazon S3 on Outposts.</p>
    public let blockPublicAcls: Bool
    /// <p>Specifies whether Amazon S3 should block public bucket policies for buckets in this account.
    ///          Setting this element to <code>TRUE</code> causes Amazon S3 to reject calls to PUT Bucket
    ///          policy if the specified bucket policy allows public access. </p>
    ///          <p>Enabling this setting doesn't affect existing bucket policies.</p>
    ///          <p>This is not supported for Amazon S3 on Outposts.</p>
    public let blockPublicPolicy: Bool
    /// <p>Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this
    ///          element to <code>TRUE</code> causes Amazon S3 to ignore all public ACLs on buckets in this
    ///          account and any objects that they contain. </p>
    ///          <p>Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't
    ///          prevent new public ACLs from being set.</p>
    ///          <p>This is not supported for Amazon S3 on Outposts.</p>
    public let ignorePublicAcls: Bool
    /// <p>Specifies whether Amazon S3 should restrict public bucket policies for buckets in this account.
    ///          Setting this element to <code>TRUE</code> restricts access to buckets with public policies
    ///          to only AWS service principals and authorized users within this account.</p>
    ///          <p>Enabling this setting doesn't affect previously stored bucket policies, except that public
    ///          and cross-account access within any public bucket policy, including non-public delegation to
    ///          specific accounts, is blocked.</p>
    ///          <p>This is not supported for Amazon S3 on Outposts.</p>
    public let restrictPublicBuckets: Bool

    public init (
        blockPublicAcls: Bool = false,
        blockPublicPolicy: Bool = false,
        ignorePublicAcls: Bool = false,
        restrictPublicBuckets: Bool = false
    )
    {
        self.blockPublicAcls = blockPublicAcls
        self.blockPublicPolicy = blockPublicPolicy
        self.ignorePublicAcls = ignorePublicAcls
        self.restrictPublicBuckets = restrictPublicBuckets
    }
}

public struct PutAccessPointConfigurationForObjectLambdaInputBodyMiddleware: Middleware {
    public let id: String = "PutAccessPointConfigurationForObjectLambdaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccessPointConfigurationForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccessPointConfigurationForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccessPointConfigurationForObjectLambdaInput>
    public typealias MOutput = OperationOutput<PutAccessPointConfigurationForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccessPointConfigurationForObjectLambdaOutputError>
}

extension PutAccessPointConfigurationForObjectLambdaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccessPointConfigurationForObjectLambdaInput(accountId: \(String(describing: accountId)), configuration: \(String(describing: configuration)), name: \(String(describing: name)))"}
}

extension PutAccessPointConfigurationForObjectLambdaInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutAccessPointConfigurationForObjectLambdaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let configuration = configuration {
            try container.encode(configuration, forKey: Key("configuration"))
        }
    }
}

public struct PutAccessPointConfigurationForObjectLambdaInputHeadersMiddleware: Middleware {
    public let id: String = "PutAccessPointConfigurationForObjectLambdaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccessPointConfigurationForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccessPointConfigurationForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccessPointConfigurationForObjectLambdaInput>
    public typealias MOutput = OperationOutput<PutAccessPointConfigurationForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccessPointConfigurationForObjectLambdaOutputError>
}

public struct PutAccessPointConfigurationForObjectLambdaInputQueryItemMiddleware: Middleware {
    public let id: String = "PutAccessPointConfigurationForObjectLambdaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccessPointConfigurationForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccessPointConfigurationForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccessPointConfigurationForObjectLambdaInput>
    public typealias MOutput = OperationOutput<PutAccessPointConfigurationForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccessPointConfigurationForObjectLambdaOutputError>
}

public struct PutAccessPointConfigurationForObjectLambdaInput: Equatable {
    /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
    public let accountId: String?
    /// <p>Object Lambda Access Point configuration document.</p>
    public let configuration: ObjectLambdaConfiguration?
    /// <p>The name of the Object Lambda Access Point.</p>
    public let name: String?

    public init (
        accountId: String? = nil,
        configuration: ObjectLambdaConfiguration? = nil,
        name: String? = nil
    )
    {
        self.accountId = accountId
        self.configuration = configuration
        self.name = name
    }
}

struct PutAccessPointConfigurationForObjectLambdaInputBody: Equatable {
    public let configuration: ObjectLambdaConfiguration?
}

extension PutAccessPointConfigurationForObjectLambdaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(ObjectLambdaConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension PutAccessPointConfigurationForObjectLambdaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutAccessPointConfigurationForObjectLambdaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAccessPointConfigurationForObjectLambdaOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccessPointConfigurationForObjectLambdaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccessPointConfigurationForObjectLambdaOutputResponse()"}
}

extension PutAccessPointConfigurationForObjectLambdaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutAccessPointConfigurationForObjectLambdaOutputResponse: Equatable {

    public init() {}
}

struct PutAccessPointConfigurationForObjectLambdaOutputResponseBody: Equatable {
}

extension PutAccessPointConfigurationForObjectLambdaOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutAccessPointPolicyForObjectLambdaInputBodyMiddleware: Middleware {
    public let id: String = "PutAccessPointPolicyForObjectLambdaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccessPointPolicyForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccessPointPolicyForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccessPointPolicyForObjectLambdaInput>
    public typealias MOutput = OperationOutput<PutAccessPointPolicyForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccessPointPolicyForObjectLambdaOutputError>
}

extension PutAccessPointPolicyForObjectLambdaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccessPointPolicyForObjectLambdaInput(accountId: \(String(describing: accountId)), name: \(String(describing: name)), policy: \(String(describing: policy)))"}
}

extension PutAccessPointPolicyForObjectLambdaInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutAccessPointPolicyForObjectLambdaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: Key("policy"))
        }
    }
}

public struct PutAccessPointPolicyForObjectLambdaInputHeadersMiddleware: Middleware {
    public let id: String = "PutAccessPointPolicyForObjectLambdaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccessPointPolicyForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccessPointPolicyForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccessPointPolicyForObjectLambdaInput>
    public typealias MOutput = OperationOutput<PutAccessPointPolicyForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccessPointPolicyForObjectLambdaOutputError>
}

public struct PutAccessPointPolicyForObjectLambdaInputQueryItemMiddleware: Middleware {
    public let id: String = "PutAccessPointPolicyForObjectLambdaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccessPointPolicyForObjectLambdaInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccessPointPolicyForObjectLambdaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccessPointPolicyForObjectLambdaInput>
    public typealias MOutput = OperationOutput<PutAccessPointPolicyForObjectLambdaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccessPointPolicyForObjectLambdaOutputError>
}

public struct PutAccessPointPolicyForObjectLambdaInput: Equatable {
    /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
    public let accountId: String?
    /// <p>The name of the Object Lambda Access Point.</p>
    public let name: String?
    /// <p>Object Lambda Access Point resource policy document.</p>
    public let policy: String?

    public init (
        accountId: String? = nil,
        name: String? = nil,
        policy: String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
        self.policy = policy
    }
}

struct PutAccessPointPolicyForObjectLambdaInputBody: Equatable {
    public let policy: String?
}

extension PutAccessPointPolicyForObjectLambdaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutAccessPointPolicyForObjectLambdaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutAccessPointPolicyForObjectLambdaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAccessPointPolicyForObjectLambdaOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccessPointPolicyForObjectLambdaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccessPointPolicyForObjectLambdaOutputResponse()"}
}

extension PutAccessPointPolicyForObjectLambdaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutAccessPointPolicyForObjectLambdaOutputResponse: Equatable {

    public init() {}
}

struct PutAccessPointPolicyForObjectLambdaOutputResponseBody: Equatable {
}

extension PutAccessPointPolicyForObjectLambdaOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutAccessPointPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutAccessPointPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccessPointPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccessPointPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccessPointPolicyInput>
    public typealias MOutput = OperationOutput<PutAccessPointPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccessPointPolicyOutputError>
}

extension PutAccessPointPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccessPointPolicyInput(accountId: \(String(describing: accountId)), name: \(String(describing: name)), policy: \(String(describing: policy)))"}
}

extension PutAccessPointPolicyInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutAccessPointPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: Key("policy"))
        }
    }
}

public struct PutAccessPointPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutAccessPointPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccessPointPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccessPointPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccessPointPolicyInput>
    public typealias MOutput = OperationOutput<PutAccessPointPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccessPointPolicyOutputError>
}

public struct PutAccessPointPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutAccessPointPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccessPointPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccessPointPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccessPointPolicyInput>
    public typealias MOutput = OperationOutput<PutAccessPointPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccessPointPolicyOutputError>
}

public struct PutAccessPointPolicyInput: Equatable {
    /// <p>The AWS account ID for owner of the bucket associated with the specified access point.</p>
    public let accountId: String?
    /// <p>The name of the access point that you want to associate with the specified policy.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the access point accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/accesspoint/<my-accesspoint-name></code>. For example, to access the access point <code>reports-ap</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap</code>. The value must be URL encoded. </p>
    public let name: String?
    /// <p>The policy that you want to apply to the specified access point. For more information about access point policies, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html">Managing data access with Amazon S3 access points</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let policy: String?

    public init (
        accountId: String? = nil,
        name: String? = nil,
        policy: String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
        self.policy = policy
    }
}

struct PutAccessPointPolicyInputBody: Equatable {
    public let policy: String?
}

extension PutAccessPointPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutAccessPointPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutAccessPointPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAccessPointPolicyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccessPointPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccessPointPolicyOutputResponse()"}
}

extension PutAccessPointPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutAccessPointPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutAccessPointPolicyOutputResponseBody: Equatable {
}

extension PutAccessPointPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketLifecycleConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketLifecycleConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let lifecycleConfiguration = input.operationInput.lifecycleConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(lifecycleConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketLifecycleConfigurationOutputError>
}

extension PutBucketLifecycleConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketLifecycleConfigurationInput(accountId: \(String(describing: accountId)), bucket: \(String(describing: bucket)), lifecycleConfiguration: \(String(describing: lifecycleConfiguration)))"}
}

extension PutBucketLifecycleConfigurationInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketLifecycleConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lifecycleConfiguration = "LifecycleConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let lifecycleConfiguration = lifecycleConfiguration {
            try container.encode(lifecycleConfiguration, forKey: Key("LifecycleConfiguration"))
        }
    }
}

public struct PutBucketLifecycleConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketLifecycleConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketLifecycleConfigurationOutputError>
}

public struct PutBucketLifecycleConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketLifecycleConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketLifecycleConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketLifecycleConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketLifecycleConfigurationInput>
    public typealias MOutput = OperationOutput<PutBucketLifecycleConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketLifecycleConfigurationOutputError>
}

public struct PutBucketLifecycleConfigurationInput: Equatable {
    /// <p>The AWS account ID of the Outposts bucket.</p>
    public let accountId: String?
    /// <p>The name of the bucket for which to set the configuration.</p>
    public let bucket: String?
    /// <p>Container for lifecycle rules. You can add as many as 1,000 rules.</p>
    public let lifecycleConfiguration: LifecycleConfiguration?

    public init (
        accountId: String? = nil,
        bucket: String? = nil,
        lifecycleConfiguration: LifecycleConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.lifecycleConfiguration = lifecycleConfiguration
    }
}

struct PutBucketLifecycleConfigurationInputBody: Equatable {
    public let lifecycleConfiguration: LifecycleConfiguration?
}

extension PutBucketLifecycleConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lifecycleConfiguration = "LifecycleConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleConfigurationDecoded = try containerValues.decodeIfPresent(LifecycleConfiguration.self, forKey: .lifecycleConfiguration)
        lifecycleConfiguration = lifecycleConfigurationDecoded
    }
}

extension PutBucketLifecycleConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketLifecycleConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketLifecycleConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketLifecycleConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketLifecycleConfigurationOutputResponse()"}
}

extension PutBucketLifecycleConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketLifecycleConfigurationOutputResponse: Equatable {

    public init() {}
}

struct PutBucketLifecycleConfigurationOutputResponseBody: Equatable {
}

extension PutBucketLifecycleConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketPolicyInput>
    public typealias MOutput = OperationOutput<PutBucketPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketPolicyOutputError>
}

extension PutBucketPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketPolicyInput(accountId: \(String(describing: accountId)), bucket: \(String(describing: bucket)), confirmRemoveSelfBucketAccess: \(String(describing: confirmRemoveSelfBucketAccess)), policy: \(String(describing: policy)))"}
}

extension PutBucketPolicyInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: Key("policy"))
        }
    }
}

public struct PutBucketPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        input.builder.withHeader(name: "x-amz-confirm-remove-self-bucket-access", value: String(input.operationInput.confirmRemoveSelfBucketAccess))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketPolicyInput>
    public typealias MOutput = OperationOutput<PutBucketPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketPolicyOutputError>
}

public struct PutBucketPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketPolicyInput>
    public typealias MOutput = OperationOutput<PutBucketPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketPolicyOutputError>
}

public struct PutBucketPolicyInput: Equatable {
    /// <p>The AWS account ID of the Outposts bucket.</p>
    public let accountId: String?
    /// <p>Specifies the bucket.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
    public let bucket: String?
    /// <p>Set this parameter to true to confirm that you want to remove your permissions to change this bucket policy in the future.</p>
    ///          <note>
    ///             <p>This is not supported by Amazon S3 on Outposts buckets.</p>
    ///          </note>
    public let confirmRemoveSelfBucketAccess: Bool
    /// <p>The bucket policy as a JSON document.</p>
    public let policy: String?

    public init (
        accountId: String? = nil,
        bucket: String? = nil,
        confirmRemoveSelfBucketAccess: Bool = false,
        policy: String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.confirmRemoveSelfBucketAccess = confirmRemoveSelfBucketAccess
        self.policy = policy
    }
}

struct PutBucketPolicyInputBody: Equatable {
    public let policy: String?
}

extension PutBucketPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutBucketPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketPolicyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketPolicyOutputResponse()"}
}

extension PutBucketPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutBucketPolicyOutputResponseBody: Equatable {
}

extension PutBucketPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutBucketTaggingInputBodyMiddleware: Middleware {
    public let id: String = "PutBucketTaggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagging = input.operationInput.tagging {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(tagging)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketTaggingInput>
    public typealias MOutput = OperationOutput<PutBucketTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketTaggingOutputError>
}

extension PutBucketTaggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketTaggingInput(accountId: \(String(describing: accountId)), bucket: \(String(describing: bucket)), tagging: \(String(describing: tagging)))"}
}

extension PutBucketTaggingInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketTaggingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagging = "Tagging"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let tagging = tagging {
            try container.encode(tagging, forKey: Key("Tagging"))
        }
    }
}

public struct PutBucketTaggingInputHeadersMiddleware: Middleware {
    public let id: String = "PutBucketTaggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketTaggingInput>
    public typealias MOutput = OperationOutput<PutBucketTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketTaggingOutputError>
}

public struct PutBucketTaggingInputQueryItemMiddleware: Middleware {
    public let id: String = "PutBucketTaggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutBucketTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutBucketTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutBucketTaggingInput>
    public typealias MOutput = OperationOutput<PutBucketTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutBucketTaggingOutputError>
}

public struct PutBucketTaggingInput: Equatable {
    /// <p>The AWS account ID of the Outposts bucket.</p>
    public let accountId: String?
    /// <p>The Amazon Resource Name (ARN) of the bucket.</p>
    ///          <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
    ///          <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
    public let bucket: String?
    /// <p></p>
    public let tagging: Tagging?

    public init (
        accountId: String? = nil,
        bucket: String? = nil,
        tagging: Tagging? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.tagging = tagging
    }
}

struct PutBucketTaggingInputBody: Equatable {
    public let tagging: Tagging?
}

extension PutBucketTaggingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagging = "Tagging"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taggingDecoded = try containerValues.decodeIfPresent(Tagging.self, forKey: .tagging)
        tagging = taggingDecoded
    }
}

extension PutBucketTaggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutBucketTaggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBucketTaggingOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBucketTaggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutBucketTaggingOutputResponse()"}
}

extension PutBucketTaggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutBucketTaggingOutputResponse: Equatable {

    public init() {}
}

struct PutBucketTaggingOutputResponseBody: Equatable {
}

extension PutBucketTaggingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutJobTaggingInputBodyMiddleware: Middleware {
    public let id: String = "PutJobTaggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutJobTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutJobTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutJobTaggingInput>
    public typealias MOutput = OperationOutput<PutJobTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutJobTaggingOutputError>
}

extension PutJobTaggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutJobTaggingInput(accountId: \(String(describing: accountId)), jobId: \(String(describing: jobId)), tags: \(String(describing: tags)))"}
}

extension PutJobTaggingInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutJobTaggingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("tags"))
            for s3tag0 in tags {
                try tagsContainer.encode(s3tag0, forKey: Key("member"))
            }
        }
    }
}

public struct PutJobTaggingInputHeadersMiddleware: Middleware {
    public let id: String = "PutJobTaggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutJobTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutJobTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutJobTaggingInput>
    public typealias MOutput = OperationOutput<PutJobTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutJobTaggingOutputError>
}

public struct PutJobTaggingInputQueryItemMiddleware: Middleware {
    public let id: String = "PutJobTaggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutJobTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutJobTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutJobTaggingInput>
    public typealias MOutput = OperationOutput<PutJobTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutJobTaggingOutputError>
}

public struct PutJobTaggingInput: Equatable {
    /// <p>The AWS account ID associated with the S3 Batch Operations job.</p>
    public let accountId: String?
    /// <p>The ID for the S3 Batch Operations job whose tags you want to replace.</p>
    public let jobId: String?
    /// <p>The set of tags to associate with the S3 Batch Operations job.</p>
    public let tags: [S3Tag]?

    public init (
        accountId: String? = nil,
        jobId: String? = nil,
        tags: [S3Tag]? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.tags = tags
    }
}

struct PutJobTaggingInputBody: Equatable {
    public let tags: [S3Tag]?
}

extension PutJobTaggingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3Tag].self, forKey: .member)
                var tagsBuffer:[S3Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension PutJobTaggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutJobTaggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutJobTaggingOutputError: Equatable {
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutJobTaggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutJobTaggingOutputResponse()"}
}

extension PutJobTaggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutJobTaggingOutputResponse: Equatable {

    public init() {}
}

struct PutJobTaggingOutputResponseBody: Equatable {
}

extension PutJobTaggingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutPublicAccessBlockInputBodyMiddleware: Middleware {
    public let id: String = "PutPublicAccessBlockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPublicAccessBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPublicAccessBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let publicAccessBlockConfiguration = input.operationInput.publicAccessBlockConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(publicAccessBlockConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPublicAccessBlockInput>
    public typealias MOutput = OperationOutput<PutPublicAccessBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPublicAccessBlockOutputError>
}

extension PutPublicAccessBlockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPublicAccessBlockInput(accountId: \(String(describing: accountId)), publicAccessBlockConfiguration: \(String(describing: publicAccessBlockConfiguration)))"}
}

extension PutPublicAccessBlockInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutPublicAccessBlockInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let publicAccessBlockConfiguration = publicAccessBlockConfiguration {
            try container.encode(publicAccessBlockConfiguration, forKey: Key("PublicAccessBlockConfiguration"))
        }
    }
}

public struct PutPublicAccessBlockInputHeadersMiddleware: Middleware {
    public let id: String = "PutPublicAccessBlockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPublicAccessBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPublicAccessBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPublicAccessBlockInput>
    public typealias MOutput = OperationOutput<PutPublicAccessBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPublicAccessBlockOutputError>
}

public struct PutPublicAccessBlockInputQueryItemMiddleware: Middleware {
    public let id: String = "PutPublicAccessBlockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPublicAccessBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPublicAccessBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPublicAccessBlockInput>
    public typealias MOutput = OperationOutput<PutPublicAccessBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPublicAccessBlockOutputError>
}

public struct PutPublicAccessBlockInput: Equatable {
    /// <p>The account ID for the AWS account whose <code>PublicAccessBlock</code> configuration you want
    ///          to set.</p>
    public let accountId: String?
    /// <p>The <code>PublicAccessBlock</code> configuration that you want to apply to the specified AWS
    ///          account.</p>
    public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?

    public init (
        accountId: String? = nil,
        publicAccessBlockConfiguration: PublicAccessBlockConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
    }
}

struct PutPublicAccessBlockInputBody: Equatable {
    public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?
}

extension PutPublicAccessBlockInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
    }
}

extension PutPublicAccessBlockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutPublicAccessBlockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPublicAccessBlockOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPublicAccessBlockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPublicAccessBlockOutputResponse()"}
}

extension PutPublicAccessBlockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutPublicAccessBlockOutputResponse: Equatable {

    public init() {}
}

struct PutPublicAccessBlockOutputResponseBody: Equatable {
}

extension PutPublicAccessBlockOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutStorageLensConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutStorageLensConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutStorageLensConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutStorageLensConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutStorageLensConfigurationInput>
    public typealias MOutput = OperationOutput<PutStorageLensConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutStorageLensConfigurationOutputError>
}

extension PutStorageLensConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutStorageLensConfigurationInput(accountId: \(String(describing: accountId)), configId: \(String(describing: configId)), storageLensConfiguration: \(String(describing: storageLensConfiguration)), tags: \(String(describing: tags)))"}
}

extension PutStorageLensConfigurationInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutStorageLensConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case storageLensConfiguration = "StorageLensConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let storageLensConfiguration = storageLensConfiguration {
            try container.encode(storageLensConfiguration, forKey: Key("storageLensConfiguration"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("tags"))
            for storagelenstag0 in tags {
                try tagsContainer.encode(storagelenstag0, forKey: Key("Tag"))
            }
        }
    }
}

public struct PutStorageLensConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutStorageLensConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutStorageLensConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutStorageLensConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutStorageLensConfigurationInput>
    public typealias MOutput = OperationOutput<PutStorageLensConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutStorageLensConfigurationOutputError>
}

public struct PutStorageLensConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutStorageLensConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutStorageLensConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutStorageLensConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutStorageLensConfigurationInput>
    public typealias MOutput = OperationOutput<PutStorageLensConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutStorageLensConfigurationOutputError>
}

public struct PutStorageLensConfigurationInput: Equatable {
    /// <p>The account ID of the requester.</p>
    public let accountId: String?
    /// <p>The ID of the S3 Storage Lens configuration.</p>
    public let configId: String?
    /// <p>The S3 Storage Lens configuration.</p>
    public let storageLensConfiguration: StorageLensConfiguration?
    /// <p>The tag set of the S3 Storage Lens configuration.</p>
    ///          <note>
    ///             <p>You can set up to a maximum of 50 tags.</p>
    ///          </note>
    public let tags: [StorageLensTag]?

    public init (
        accountId: String? = nil,
        configId: String? = nil,
        storageLensConfiguration: StorageLensConfiguration? = nil,
        tags: [StorageLensTag]? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
        self.storageLensConfiguration = storageLensConfiguration
        self.tags = tags
    }
}

struct PutStorageLensConfigurationInputBody: Equatable {
    public let storageLensConfiguration: StorageLensConfiguration?
    public let tags: [StorageLensTag]?
}

extension PutStorageLensConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case storageLensConfiguration = "StorageLensConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageLensConfigurationDecoded = try containerValues.decodeIfPresent(StorageLensConfiguration.self, forKey: .storageLensConfiguration)
        storageLensConfiguration = storageLensConfigurationDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([StorageLensTag].self, forKey: .member)
                var tagsBuffer:[StorageLensTag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [StorageLensTag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension PutStorageLensConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutStorageLensConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutStorageLensConfigurationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutStorageLensConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutStorageLensConfigurationOutputResponse()"}
}

extension PutStorageLensConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutStorageLensConfigurationOutputResponse: Equatable {

    public init() {}
}

struct PutStorageLensConfigurationOutputResponseBody: Equatable {
}

extension PutStorageLensConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutStorageLensConfigurationTaggingInputBodyMiddleware: Middleware {
    public let id: String = "PutStorageLensConfigurationTaggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutStorageLensConfigurationTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutStorageLensConfigurationTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutStorageLensConfigurationTaggingInput>
    public typealias MOutput = OperationOutput<PutStorageLensConfigurationTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutStorageLensConfigurationTaggingOutputError>
}

extension PutStorageLensConfigurationTaggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutStorageLensConfigurationTaggingInput(accountId: \(String(describing: accountId)), configId: \(String(describing: configId)), tags: \(String(describing: tags)))"}
}

extension PutStorageLensConfigurationTaggingInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutStorageLensConfigurationTaggingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("tags"))
            for storagelenstag0 in tags {
                try tagsContainer.encode(storagelenstag0, forKey: Key("Tag"))
            }
        }
    }
}

public struct PutStorageLensConfigurationTaggingInputHeadersMiddleware: Middleware {
    public let id: String = "PutStorageLensConfigurationTaggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutStorageLensConfigurationTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutStorageLensConfigurationTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutStorageLensConfigurationTaggingInput>
    public typealias MOutput = OperationOutput<PutStorageLensConfigurationTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutStorageLensConfigurationTaggingOutputError>
}

public struct PutStorageLensConfigurationTaggingInputQueryItemMiddleware: Middleware {
    public let id: String = "PutStorageLensConfigurationTaggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutStorageLensConfigurationTaggingInput>,
                  next: H) -> Swift.Result<OperationOutput<PutStorageLensConfigurationTaggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutStorageLensConfigurationTaggingInput>
    public typealias MOutput = OperationOutput<PutStorageLensConfigurationTaggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutStorageLensConfigurationTaggingOutputError>
}

public struct PutStorageLensConfigurationTaggingInput: Equatable {
    /// <p>The account ID of the requester.</p>
    public let accountId: String?
    /// <p>The ID of the S3 Storage Lens configuration.</p>
    public let configId: String?
    /// <p>The tag set of the S3 Storage Lens configuration.</p>
    ///          <note>
    ///             <p>You can set up to a maximum of 50 tags.</p>
    ///          </note>
    public let tags: [StorageLensTag]?

    public init (
        accountId: String? = nil,
        configId: String? = nil,
        tags: [StorageLensTag]? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
        self.tags = tags
    }
}

struct PutStorageLensConfigurationTaggingInputBody: Equatable {
    public let tags: [StorageLensTag]?
}

extension PutStorageLensConfigurationTaggingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([StorageLensTag].self, forKey: .member)
                var tagsBuffer:[StorageLensTag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [StorageLensTag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension PutStorageLensConfigurationTaggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutStorageLensConfigurationTaggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutStorageLensConfigurationTaggingOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutStorageLensConfigurationTaggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutStorageLensConfigurationTaggingOutputResponse()"}
}

extension PutStorageLensConfigurationTaggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutStorageLensConfigurationTaggingOutputResponse: Equatable {

    public init() {}
}

struct PutStorageLensConfigurationTaggingOutputResponseBody: Equatable {
}

extension PutStorageLensConfigurationTaggingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RegionalBucket: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case bucketArn = "BucketArn"
        case creationDate = "CreationDate"
        case outpostId = "OutpostId"
        case publicAccessBlockEnabled = "PublicAccessBlockEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: Key("bucket"))
        }
        if let bucketArn = bucketArn {
            try container.encode(bucketArn, forKey: Key("bucketArn"))
        }
        if let creationDate = creationDate {
            try container.encode(TimestampWrapper(creationDate, format: .dateTime), forKey: Key("creationDate"))
        }
        if let outpostId = outpostId {
            try container.encode(outpostId, forKey: Key("outpostId"))
        }
        if publicAccessBlockEnabled != false {
            try container.encode(publicAccessBlockEnabled, forKey: Key("publicAccessBlockEnabled"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let bucketArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let publicAccessBlockEnabledDecoded = try containerValues.decode(Bool.self, forKey: .publicAccessBlockEnabled)
        publicAccessBlockEnabled = publicAccessBlockEnabledDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        var creationDateBuffer:Date? = nil
        if let creationDateDecoded = creationDateDecoded {
            creationDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationDateDecoded, format: .dateTime)
        }
        creationDate = creationDateBuffer
        let outpostIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outpostId)
        outpostId = outpostIdDecoded
    }
}

extension RegionalBucket: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegionalBucket(bucket: \(String(describing: bucket)), bucketArn: \(String(describing: bucketArn)), creationDate: \(String(describing: creationDate)), outpostId: \(String(describing: outpostId)), publicAccessBlockEnabled: \(String(describing: publicAccessBlockEnabled)))"}
}

extension RegionalBucket: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The container for the regional bucket.</p>
public struct RegionalBucket: Equatable {
    /// <p></p>
    public let bucket: String?
    /// <p>The Amazon Resource Name (ARN) for the regional bucket.</p>
    public let bucketArn: String?
    /// <p>The creation date of the regional bucket</p>
    public let creationDate: Date?
    /// <p>The AWS Outposts ID of the regional bucket.</p>
    public let outpostId: String?
    /// <p></p>
    public let publicAccessBlockEnabled: Bool

    public init (
        bucket: String? = nil,
        bucketArn: String? = nil,
        creationDate: Date? = nil,
        outpostId: String? = nil,
        publicAccessBlockEnabled: Bool = false
    )
    {
        self.bucket = bucket
        self.bucketArn = bucketArn
        self.creationDate = creationDate
        self.outpostId = outpostId
        self.publicAccessBlockEnabled = publicAccessBlockEnabled
    }
}

public enum RequestedJobStatus {
    case cancelled
    case ready
    case sdkUnknown(String)
}

extension RequestedJobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RequestedJobStatus] {
        return [
            .cancelled,
            .ready,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "Cancelled"
        case .ready: return "Ready"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RequestedJobStatus(rawValue: rawValue) ?? RequestedJobStatus.sdkUnknown(rawValue)
    }
}

extension S3AccessControlList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grants = "Grants"
        case owner = "Owner"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let grants = grants {
            var grantsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("grants"))
            for s3grant0 in grants {
                try grantsContainer.encode(s3grant0, forKey: Key("member"))
            }
        }
        if let owner = owner {
            try container.encode(owner, forKey: Key("owner"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(S3ObjectOwner.self, forKey: .owner)
        owner = ownerDecoded
        if containerValues.contains(.grants) {
            struct KeyVal0{struct member{}}
            let grantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .grants)
            if let grantsWrappedContainer = grantsWrappedContainer {
                let grantsContainer = try grantsWrappedContainer.decodeIfPresent([S3Grant].self, forKey: .member)
                var grantsBuffer:[S3Grant]? = nil
                if let grantsContainer = grantsContainer {
                    grantsBuffer = [S3Grant]()
                    for structureContainer0 in grantsContainer {
                        grantsBuffer?.append(structureContainer0)
                    }
                }
                grants = grantsBuffer
            } else {
                grants = []
            }
        } else {
            grants = nil
        }
    }
}

extension S3AccessControlList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3AccessControlList(grants: \(String(describing: grants)), owner: \(String(describing: owner)))"}
}

extension S3AccessControlList: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p></p>
public struct S3AccessControlList: Equatable {
    /// <p></p>
    public let grants: [S3Grant]?
    /// <p></p>
    public let owner: S3ObjectOwner?

    public init (
        grants: [S3Grant]? = nil,
        owner: S3ObjectOwner? = nil
    )
    {
        self.grants = grants
        self.owner = owner
    }
}

extension S3AccessControlPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessControlList = "AccessControlList"
        case cannedAccessControlList = "CannedAccessControlList"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let accessControlList = accessControlList {
            try container.encode(accessControlList, forKey: Key("accessControlList"))
        }
        if let cannedAccessControlList = cannedAccessControlList {
            try container.encode(cannedAccessControlList, forKey: Key("cannedAccessControlList"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlListDecoded = try containerValues.decodeIfPresent(S3AccessControlList.self, forKey: .accessControlList)
        accessControlList = accessControlListDecoded
        let cannedAccessControlListDecoded = try containerValues.decodeIfPresent(S3CannedAccessControlList.self, forKey: .cannedAccessControlList)
        cannedAccessControlList = cannedAccessControlListDecoded
    }
}

extension S3AccessControlPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3AccessControlPolicy(accessControlList: \(String(describing: accessControlList)), cannedAccessControlList: \(String(describing: cannedAccessControlList)))"}
}

extension S3AccessControlPolicy: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p></p>
public struct S3AccessControlPolicy: Equatable {
    /// <p></p>
    public let accessControlList: S3AccessControlList?
    /// <p></p>
    public let cannedAccessControlList: S3CannedAccessControlList?

    public init (
        accessControlList: S3AccessControlList? = nil,
        cannedAccessControlList: S3CannedAccessControlList? = nil
    )
    {
        self.accessControlList = accessControlList
        self.cannedAccessControlList = cannedAccessControlList
    }
}

extension S3BucketDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case arn = "Arn"
        case encryption = "Encryption"
        case format = "Format"
        case outputSchemaVersion = "OutputSchemaVersion"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let accountId = accountId {
            try container.encode(accountId, forKey: Key("accountId"))
        }
        if let arn = arn {
            try container.encode(arn, forKey: Key("arn"))
        }
        if let encryption = encryption {
            try container.encode(encryption, forKey: Key("encryption"))
        }
        if let format = format {
            try container.encode(format, forKey: Key("format"))
        }
        if let outputSchemaVersion = outputSchemaVersion {
            try container.encode(outputSchemaVersion, forKey: Key("outputSchemaVersion"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Format.self, forKey: .format)
        format = formatDecoded
        let outputSchemaVersionDecoded = try containerValues.decodeIfPresent(OutputSchemaVersion.self, forKey: .outputSchemaVersion)
        outputSchemaVersion = outputSchemaVersionDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(StorageLensDataExportEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension S3BucketDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3BucketDestination(accountId: \(String(describing: accountId)), arn: \(String(describing: arn)), encryption: \(String(describing: encryption)), format: \(String(describing: format)), outputSchemaVersion: \(String(describing: outputSchemaVersion)), prefix: \(String(describing: prefix)))"}
}

extension S3BucketDestination: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for the bucket where the Amazon S3 Storage Lens metrics export files are located.</p>
public struct S3BucketDestination: Equatable {
    /// <p>The account ID of the owner of the S3 Storage Lens metrics export bucket.</p>
    public let accountId: String?
    /// <p>The Amazon Resource Name (ARN) of the bucket.
    ///          This property is read-only and follows the following format:
    ///          <code> arn:aws:s3:<i>us-east-1</i>:<i>example-account-id</i>:bucket/<i>your-destination-bucket-name</i>
    ///             </code>
    ///          </p>
    public let arn: String?
    /// <p>The container for the type encryption of the metrics exports in this bucket.</p>
    public let encryption: StorageLensDataExportEncryption?
    /// <p></p>
    public let format: Format?
    /// <p>The schema version of the export file.</p>
    public let outputSchemaVersion: OutputSchemaVersion?
    /// <p>The prefix of the destination bucket where the metrics export will be delivered.</p>
    public let prefix: String?

    public init (
        accountId: String? = nil,
        arn: String? = nil,
        encryption: StorageLensDataExportEncryption? = nil,
        format: Format? = nil,
        outputSchemaVersion: OutputSchemaVersion? = nil,
        prefix: String? = nil
    )
    {
        self.accountId = accountId
        self.arn = arn
        self.encryption = encryption
        self.format = format
        self.outputSchemaVersion = outputSchemaVersion
        self.prefix = prefix
    }
}

public enum S3CannedAccessControlList {
    case authenticatedRead
    case awsExecRead
    case bucketOwnerFullControl
    case bucketOwnerRead
    case `private`
    case publicRead
    case publicReadWrite
    case sdkUnknown(String)
}

extension S3CannedAccessControlList : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3CannedAccessControlList] {
        return [
            .authenticatedRead,
            .awsExecRead,
            .bucketOwnerFullControl,
            .bucketOwnerRead,
            .private,
            .publicRead,
            .publicReadWrite,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .authenticatedRead: return "authenticated-read"
        case .awsExecRead: return "aws-exec-read"
        case .bucketOwnerFullControl: return "bucket-owner-full-control"
        case .bucketOwnerRead: return "bucket-owner-read"
        case .private: return "private"
        case .publicRead: return "public-read"
        case .publicReadWrite: return "public-read-write"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3CannedAccessControlList(rawValue: rawValue) ?? S3CannedAccessControlList.sdkUnknown(rawValue)
    }
}

extension S3CopyObjectOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessControlGrants = "AccessControlGrants"
        case bucketKeyEnabled = "BucketKeyEnabled"
        case cannedAccessControlList = "CannedAccessControlList"
        case metadataDirective = "MetadataDirective"
        case modifiedSinceConstraint = "ModifiedSinceConstraint"
        case newObjectMetadata = "NewObjectMetadata"
        case newObjectTagging = "NewObjectTagging"
        case objectLockLegalHoldStatus = "ObjectLockLegalHoldStatus"
        case objectLockMode = "ObjectLockMode"
        case objectLockRetainUntilDate = "ObjectLockRetainUntilDate"
        case redirectLocation = "RedirectLocation"
        case requesterPays = "RequesterPays"
        case sSEAwsKmsKeyId = "SSEAwsKmsKeyId"
        case storageClass = "StorageClass"
        case targetKeyPrefix = "TargetKeyPrefix"
        case targetResource = "TargetResource"
        case unModifiedSinceConstraint = "UnModifiedSinceConstraint"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let accessControlGrants = accessControlGrants {
            var accessControlGrantsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("accessControlGrants"))
            for s3grant0 in accessControlGrants {
                try accessControlGrantsContainer.encode(s3grant0, forKey: Key("member"))
            }
        }
        if bucketKeyEnabled != false {
            try container.encode(bucketKeyEnabled, forKey: Key("bucketKeyEnabled"))
        }
        if let cannedAccessControlList = cannedAccessControlList {
            try container.encode(cannedAccessControlList, forKey: Key("cannedAccessControlList"))
        }
        if let metadataDirective = metadataDirective {
            try container.encode(metadataDirective, forKey: Key("metadataDirective"))
        }
        if let modifiedSinceConstraint = modifiedSinceConstraint {
            try container.encode(TimestampWrapper(modifiedSinceConstraint, format: .dateTime), forKey: Key("modifiedSinceConstraint"))
        }
        if let newObjectMetadata = newObjectMetadata {
            try container.encode(newObjectMetadata, forKey: Key("newObjectMetadata"))
        }
        if let newObjectTagging = newObjectTagging {
            var newObjectTaggingContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("newObjectTagging"))
            for s3tag0 in newObjectTagging {
                try newObjectTaggingContainer.encode(s3tag0, forKey: Key("member"))
            }
        }
        if let objectLockLegalHoldStatus = objectLockLegalHoldStatus {
            try container.encode(objectLockLegalHoldStatus, forKey: Key("objectLockLegalHoldStatus"))
        }
        if let objectLockMode = objectLockMode {
            try container.encode(objectLockMode, forKey: Key("objectLockMode"))
        }
        if let objectLockRetainUntilDate = objectLockRetainUntilDate {
            try container.encode(TimestampWrapper(objectLockRetainUntilDate, format: .dateTime), forKey: Key("objectLockRetainUntilDate"))
        }
        if let redirectLocation = redirectLocation {
            try container.encode(redirectLocation, forKey: Key("redirectLocation"))
        }
        if requesterPays != false {
            try container.encode(requesterPays, forKey: Key("requesterPays"))
        }
        if let sSEAwsKmsKeyId = sSEAwsKmsKeyId {
            try container.encode(sSEAwsKmsKeyId, forKey: Key("sSEAwsKmsKeyId"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: Key("storageClass"))
        }
        if let targetKeyPrefix = targetKeyPrefix {
            try container.encode(targetKeyPrefix, forKey: Key("targetKeyPrefix"))
        }
        if let targetResource = targetResource {
            try container.encode(targetResource, forKey: Key("targetResource"))
        }
        if let unModifiedSinceConstraint = unModifiedSinceConstraint {
            try container.encode(TimestampWrapper(unModifiedSinceConstraint, format: .dateTime), forKey: Key("unModifiedSinceConstraint"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetResourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetResource)
        targetResource = targetResourceDecoded
        let cannedAccessControlListDecoded = try containerValues.decodeIfPresent(S3CannedAccessControlList.self, forKey: .cannedAccessControlList)
        cannedAccessControlList = cannedAccessControlListDecoded
        if containerValues.contains(.accessControlGrants) {
            struct KeyVal0{struct member{}}
            let accessControlGrantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accessControlGrants)
            if let accessControlGrantsWrappedContainer = accessControlGrantsWrappedContainer {
                let accessControlGrantsContainer = try accessControlGrantsWrappedContainer.decodeIfPresent([S3Grant].self, forKey: .member)
                var accessControlGrantsBuffer:[S3Grant]? = nil
                if let accessControlGrantsContainer = accessControlGrantsContainer {
                    accessControlGrantsBuffer = [S3Grant]()
                    for structureContainer0 in accessControlGrantsContainer {
                        accessControlGrantsBuffer?.append(structureContainer0)
                    }
                }
                accessControlGrants = accessControlGrantsBuffer
            } else {
                accessControlGrants = []
            }
        } else {
            accessControlGrants = nil
        }
        let metadataDirectiveDecoded = try containerValues.decodeIfPresent(S3MetadataDirective.self, forKey: .metadataDirective)
        metadataDirective = metadataDirectiveDecoded
        let modifiedSinceConstraintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modifiedSinceConstraint)
        var modifiedSinceConstraintBuffer:Date? = nil
        if let modifiedSinceConstraintDecoded = modifiedSinceConstraintDecoded {
            modifiedSinceConstraintBuffer = try TimestampWrapperDecoder.parseDateStringValue(modifiedSinceConstraintDecoded, format: .dateTime)
        }
        modifiedSinceConstraint = modifiedSinceConstraintBuffer
        let newObjectMetadataDecoded = try containerValues.decodeIfPresent(S3ObjectMetadata.self, forKey: .newObjectMetadata)
        newObjectMetadata = newObjectMetadataDecoded
        if containerValues.contains(.newObjectTagging) {
            struct KeyVal0{struct member{}}
            let newObjectTaggingWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .newObjectTagging)
            if let newObjectTaggingWrappedContainer = newObjectTaggingWrappedContainer {
                let newObjectTaggingContainer = try newObjectTaggingWrappedContainer.decodeIfPresent([S3Tag].self, forKey: .member)
                var newObjectTaggingBuffer:[S3Tag]? = nil
                if let newObjectTaggingContainer = newObjectTaggingContainer {
                    newObjectTaggingBuffer = [S3Tag]()
                    for structureContainer0 in newObjectTaggingContainer {
                        newObjectTaggingBuffer?.append(structureContainer0)
                    }
                }
                newObjectTagging = newObjectTaggingBuffer
            } else {
                newObjectTagging = []
            }
        } else {
            newObjectTagging = nil
        }
        let redirectLocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .redirectLocation)
        redirectLocation = redirectLocationDecoded
        let requesterPaysDecoded = try containerValues.decode(Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let unModifiedSinceConstraintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unModifiedSinceConstraint)
        var unModifiedSinceConstraintBuffer:Date? = nil
        if let unModifiedSinceConstraintDecoded = unModifiedSinceConstraintDecoded {
            unModifiedSinceConstraintBuffer = try TimestampWrapperDecoder.parseDateStringValue(unModifiedSinceConstraintDecoded, format: .dateTime)
        }
        unModifiedSinceConstraint = unModifiedSinceConstraintBuffer
        let sSEAwsKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sSEAwsKmsKeyId)
        sSEAwsKmsKeyId = sSEAwsKmsKeyIdDecoded
        let targetKeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetKeyPrefix)
        targetKeyPrefix = targetKeyPrefixDecoded
        let objectLockLegalHoldStatusDecoded = try containerValues.decodeIfPresent(S3ObjectLockLegalHoldStatus.self, forKey: .objectLockLegalHoldStatus)
        objectLockLegalHoldStatus = objectLockLegalHoldStatusDecoded
        let objectLockModeDecoded = try containerValues.decodeIfPresent(S3ObjectLockMode.self, forKey: .objectLockMode)
        objectLockMode = objectLockModeDecoded
        let objectLockRetainUntilDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectLockRetainUntilDate)
        var objectLockRetainUntilDateBuffer:Date? = nil
        if let objectLockRetainUntilDateDecoded = objectLockRetainUntilDateDecoded {
            objectLockRetainUntilDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(objectLockRetainUntilDateDecoded, format: .dateTime)
        }
        objectLockRetainUntilDate = objectLockRetainUntilDateBuffer
        let bucketKeyEnabledDecoded = try containerValues.decode(Bool.self, forKey: .bucketKeyEnabled)
        bucketKeyEnabled = bucketKeyEnabledDecoded
    }
}

extension S3CopyObjectOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3CopyObjectOperation(accessControlGrants: \(String(describing: accessControlGrants)), bucketKeyEnabled: \(String(describing: bucketKeyEnabled)), cannedAccessControlList: \(String(describing: cannedAccessControlList)), metadataDirective: \(String(describing: metadataDirective)), modifiedSinceConstraint: \(String(describing: modifiedSinceConstraint)), newObjectMetadata: \(String(describing: newObjectMetadata)), newObjectTagging: \(String(describing: newObjectTagging)), objectLockLegalHoldStatus: \(String(describing: objectLockLegalHoldStatus)), objectLockMode: \(String(describing: objectLockMode)), objectLockRetainUntilDate: \(String(describing: objectLockRetainUntilDate)), redirectLocation: \(String(describing: redirectLocation)), requesterPays: \(String(describing: requesterPays)), sSEAwsKmsKeyId: \(String(describing: sSEAwsKmsKeyId)), storageClass: \(String(describing: storageClass)), targetKeyPrefix: \(String(describing: targetKeyPrefix)), targetResource: \(String(describing: targetResource)), unModifiedSinceConstraint: \(String(describing: unModifiedSinceConstraint)))"}
}

extension S3CopyObjectOperation: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the configuration parameters for a PUT Copy object operation. S3 Batch Operations passes every object to the underlying PUT Copy object
///          API. For more information about the parameters for this operation, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectCOPY.html">PUT Object - Copy</a>.</p>
public struct S3CopyObjectOperation: Equatable {
    /// <p></p>
    public let accessControlGrants: [S3Grant]?
    /// <p>Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with
    ///          server-side encryption using AWS KMS (SSE-KMS). Setting this header to <code>true</code>
    ///          causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS.</p>
    ///          <p>Specifying this header with an <i>object</i> action doesn’t affect
    ///          <i>bucket-level</i> settings for S3 Bucket Key.</p>
    public let bucketKeyEnabled: Bool
    /// <p></p>
    public let cannedAccessControlList: S3CannedAccessControlList?
    /// <p></p>
    public let metadataDirective: S3MetadataDirective?
    /// <p></p>
    public let modifiedSinceConstraint: Date?
    /// <p></p>
    public let newObjectMetadata: S3ObjectMetadata?
    /// <p></p>
    public let newObjectTagging: [S3Tag]?
    /// <p>The legal hold status to be applied to all objects in the Batch Operations job.</p>
    public let objectLockLegalHoldStatus: S3ObjectLockLegalHoldStatus?
    /// <p>The retention mode to be applied to all objects in the Batch Operations job.</p>
    public let objectLockMode: S3ObjectLockMode?
    /// <p>The date when the applied object retention configuration expires on all objects in
    ///          the Batch Operations job.</p>
    public let objectLockRetainUntilDate: Date?
    /// <p>Specifies an optional metadata property for website redirects,
    ///             <code>x-amz-website-redirect-location</code>. Allows webpage redirects if the object is
    ///          accessed through a website endpoint.</p>
    public let redirectLocation: String?
    /// <p></p>
    public let requesterPays: Bool
    /// <p></p>
    public let sSEAwsKmsKeyId: String?
    /// <p></p>
    public let storageClass: S3StorageClass?
    /// <p>Specifies the folder prefix into which you would like the objects to be copied. For
    ///          example, to copy objects into a folder named "Folder1" in the destination bucket, set the
    ///          TargetKeyPrefix to "Folder1/".</p>
    public let targetKeyPrefix: String?
    /// <p>Specifies the destination bucket ARN for the batch copy operation.
    ///          For example, to copy objects to a bucket named "destinationBucket",
    ///          set the TargetResource to "arn:aws:s3:::destinationBucket".</p>
    public let targetResource: String?
    /// <p></p>
    public let unModifiedSinceConstraint: Date?

    public init (
        accessControlGrants: [S3Grant]? = nil,
        bucketKeyEnabled: Bool = false,
        cannedAccessControlList: S3CannedAccessControlList? = nil,
        metadataDirective: S3MetadataDirective? = nil,
        modifiedSinceConstraint: Date? = nil,
        newObjectMetadata: S3ObjectMetadata? = nil,
        newObjectTagging: [S3Tag]? = nil,
        objectLockLegalHoldStatus: S3ObjectLockLegalHoldStatus? = nil,
        objectLockMode: S3ObjectLockMode? = nil,
        objectLockRetainUntilDate: Date? = nil,
        redirectLocation: String? = nil,
        requesterPays: Bool = false,
        sSEAwsKmsKeyId: String? = nil,
        storageClass: S3StorageClass? = nil,
        targetKeyPrefix: String? = nil,
        targetResource: String? = nil,
        unModifiedSinceConstraint: Date? = nil
    )
    {
        self.accessControlGrants = accessControlGrants
        self.bucketKeyEnabled = bucketKeyEnabled
        self.cannedAccessControlList = cannedAccessControlList
        self.metadataDirective = metadataDirective
        self.modifiedSinceConstraint = modifiedSinceConstraint
        self.newObjectMetadata = newObjectMetadata
        self.newObjectTagging = newObjectTagging
        self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
        self.objectLockMode = objectLockMode
        self.objectLockRetainUntilDate = objectLockRetainUntilDate
        self.redirectLocation = redirectLocation
        self.requesterPays = requesterPays
        self.sSEAwsKmsKeyId = sSEAwsKmsKeyId
        self.storageClass = storageClass
        self.targetKeyPrefix = targetKeyPrefix
        self.targetResource = targetResource
        self.unModifiedSinceConstraint = unModifiedSinceConstraint
    }
}

extension S3DeleteObjectTaggingOperation: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension S3DeleteObjectTaggingOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3DeleteObjectTaggingOperation()"}
}

/// <p>Contains no configuration parameters because the DELETE Object tagging API only accepts the bucket name and key name as parameters, which are defined in the job's manifest.</p>
public struct S3DeleteObjectTaggingOperation: Equatable {

    public init() {}
}

public enum S3GlacierJobTier {
    case bulk
    case standard
    case sdkUnknown(String)
}

extension S3GlacierJobTier : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3GlacierJobTier] {
        return [
            .bulk,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bulk: return "BULK"
        case .standard: return "STANDARD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3GlacierJobTier(rawValue: rawValue) ?? S3GlacierJobTier.sdkUnknown(rawValue)
    }
}

extension S3Grant: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantee = "Grantee"
        case permission = "Permission"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let grantee = grantee {
            try container.encode(grantee, forKey: Key("grantee"))
        }
        if let permission = permission {
            try container.encode(permission, forKey: Key("permission"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeDecoded = try containerValues.decodeIfPresent(S3Grantee.self, forKey: .grantee)
        grantee = granteeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(S3Permission.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension S3Grant: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Grant(grantee: \(String(describing: grantee)), permission: \(String(describing: permission)))"}
}

extension S3Grant: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p></p>
public struct S3Grant: Equatable {
    /// <p></p>
    public let grantee: S3Grantee?
    /// <p></p>
    public let permission: S3Permission?

    public init (
        grantee: S3Grantee? = nil,
        permission: S3Permission? = nil
    )
    {
        self.grantee = grantee
        self.permission = permission
    }
}

extension S3Grantee: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName = "DisplayName"
        case identifier = "Identifier"
        case typeIdentifier = "TypeIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let displayName = displayName {
            try container.encode(displayName, forKey: Key("displayName"))
        }
        if let identifier = identifier {
            try container.encode(identifier, forKey: Key("identifier"))
        }
        if let typeIdentifier = typeIdentifier {
            try container.encode(typeIdentifier, forKey: Key("typeIdentifier"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeIdentifierDecoded = try containerValues.decodeIfPresent(S3GranteeTypeIdentifier.self, forKey: .typeIdentifier)
        typeIdentifier = typeIdentifierDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension S3Grantee: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Grantee(displayName: \(String(describing: displayName)), identifier: \(String(describing: identifier)), typeIdentifier: \(String(describing: typeIdentifier)))"}
}

extension S3Grantee: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p></p>
public struct S3Grantee: Equatable {
    /// <p></p>
    public let displayName: String?
    /// <p></p>
    public let identifier: String?
    /// <p></p>
    public let typeIdentifier: S3GranteeTypeIdentifier?

    public init (
        displayName: String? = nil,
        identifier: String? = nil,
        typeIdentifier: S3GranteeTypeIdentifier? = nil
    )
    {
        self.displayName = displayName
        self.identifier = identifier
        self.typeIdentifier = typeIdentifier
    }
}

public enum S3GranteeTypeIdentifier {
    case canonical
    case emailAddress
    case group
    case sdkUnknown(String)
}

extension S3GranteeTypeIdentifier : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3GranteeTypeIdentifier] {
        return [
            .canonical,
            .emailAddress,
            .group,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canonical: return "id"
        case .emailAddress: return "emailAddress"
        case .group: return "uri"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3GranteeTypeIdentifier(rawValue: rawValue) ?? S3GranteeTypeIdentifier.sdkUnknown(rawValue)
    }
}

extension S3InitiateRestoreObjectOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expirationInDays = "ExpirationInDays"
        case glacierJobTier = "GlacierJobTier"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if expirationInDays != 0 {
            try container.encode(expirationInDays, forKey: Key("expirationInDays"))
        }
        if let glacierJobTier = glacierJobTier {
            try container.encode(glacierJobTier, forKey: Key("glacierJobTier"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expirationInDaysDecoded = try containerValues.decode(Int.self, forKey: .expirationInDays)
        expirationInDays = expirationInDaysDecoded
        let glacierJobTierDecoded = try containerValues.decodeIfPresent(S3GlacierJobTier.self, forKey: .glacierJobTier)
        glacierJobTier = glacierJobTierDecoded
    }
}

extension S3InitiateRestoreObjectOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3InitiateRestoreObjectOperation(expirationInDays: \(String(describing: expirationInDays)), glacierJobTier: \(String(describing: glacierJobTier)))"}
}

extension S3InitiateRestoreObjectOperation: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the configuration parameters for an S3 Initiate Restore Object job.
///          S3 Batch Operations passes every object to the underlying POST Object restore API. For
///          more information about the parameters for this operation, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPOSTrestore.html#RESTObjectPOSTrestore-restore-request">RestoreObject</a>.</p>
public struct S3InitiateRestoreObjectOperation: Equatable {
    /// <p>This argument specifies how long the S3 Glacier or S3 Glacier Deep Archive object remains available in Amazon S3.
    ///          S3 Initiate Restore Object jobs that
    ///          target S3 Glacier and S3 Glacier Deep Archive objects require <code>ExpirationInDays</code> set to 1
    ///          or greater.</p>
    ///          <p>Conversely, do <i>not</i> set <code>ExpirationInDays</code> when
    ///          creating S3 Initiate Restore Object jobs that target
    ///          S3 Intelligent-Tiering Archive Access and Deep Archive Access tier objects. Objects in
    ///          S3 Intelligent-Tiering archive access tiers are not subject to restore expiry, so
    ///          specifying <code>ExpirationInDays</code> results in restore request failure.</p>
    ///          <p>S3 Batch Operations jobs can operate either on S3 Glacier and S3 Glacier Deep Archive storage class
    ///          objects or on S3 Intelligent-Tiering Archive Access and Deep Archive Access storage tier
    ///          objects, but not both types in the same job. If you need to restore objects of both types
    ///          you <i>must</i> create separate Batch Operations jobs. </p>
    public let expirationInDays: Int
    /// <p>S3 Batch Operations supports <code>STANDARD</code> and <code>BULK</code> retrieval tiers,
    ///          but not the <code>EXPEDITED</code> retrieval tier.</p>
    public let glacierJobTier: S3GlacierJobTier?

    public init (
        expirationInDays: Int = 0,
        glacierJobTier: S3GlacierJobTier? = nil
    )
    {
        self.expirationInDays = expirationInDays
        self.glacierJobTier = glacierJobTier
    }
}

public enum S3MetadataDirective {
    case copy
    case replace
    case sdkUnknown(String)
}

extension S3MetadataDirective : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3MetadataDirective] {
        return [
            .copy,
            .replace,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .copy: return "COPY"
        case .replace: return "REPLACE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3MetadataDirective(rawValue: rawValue) ?? S3MetadataDirective.sdkUnknown(rawValue)
    }
}

extension S3ObjectLockLegalHold: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ObjectLockLegalHoldStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ObjectLockLegalHold: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ObjectLockLegalHold(status: \(String(describing: status)))"}
}

extension S3ObjectLockLegalHold: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Whether S3 Object Lock legal hold will be applied to objects in an S3 Batch Operations
///          job.</p>
public struct S3ObjectLockLegalHold: Equatable {
    /// <p>The Object Lock legal hold status to be applied to all objects in the Batch Operations job.</p>
    public let status: S3ObjectLockLegalHoldStatus?

    public init (
        status: S3ObjectLockLegalHoldStatus? = nil
    )
    {
        self.status = status
    }
}

public enum S3ObjectLockLegalHoldStatus {
    case off
    case on
    case sdkUnknown(String)
}

extension S3ObjectLockLegalHoldStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3ObjectLockLegalHoldStatus] {
        return [
            .off,
            .on,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .off: return "OFF"
        case .on: return "ON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3ObjectLockLegalHoldStatus(rawValue: rawValue) ?? S3ObjectLockLegalHoldStatus.sdkUnknown(rawValue)
    }
}

public enum S3ObjectLockMode {
    case compliance
    case governance
    case sdkUnknown(String)
}

extension S3ObjectLockMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3ObjectLockMode] {
        return [
            .compliance,
            .governance,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .compliance: return "COMPLIANCE"
        case .governance: return "GOVERNANCE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3ObjectLockMode(rawValue: rawValue) ?? S3ObjectLockMode.sdkUnknown(rawValue)
    }
}

public enum S3ObjectLockRetentionMode {
    case compliance
    case governance
    case sdkUnknown(String)
}

extension S3ObjectLockRetentionMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3ObjectLockRetentionMode] {
        return [
            .compliance,
            .governance,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .compliance: return "COMPLIANCE"
        case .governance: return "GOVERNANCE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3ObjectLockRetentionMode(rawValue: rawValue) ?? S3ObjectLockRetentionMode.sdkUnknown(rawValue)
    }
}

extension S3ObjectMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cacheControl = "CacheControl"
        case contentDisposition = "ContentDisposition"
        case contentEncoding = "ContentEncoding"
        case contentLanguage = "ContentLanguage"
        case contentLength = "ContentLength"
        case contentMD5 = "ContentMD5"
        case contentType = "ContentType"
        case httpExpiresDate = "HttpExpiresDate"
        case requesterCharged = "RequesterCharged"
        case sSEAlgorithm = "SSEAlgorithm"
        case userMetadata = "UserMetadata"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let cacheControl = cacheControl {
            try container.encode(cacheControl, forKey: Key("cacheControl"))
        }
        if let contentDisposition = contentDisposition {
            try container.encode(contentDisposition, forKey: Key("contentDisposition"))
        }
        if let contentEncoding = contentEncoding {
            try container.encode(contentEncoding, forKey: Key("contentEncoding"))
        }
        if let contentLanguage = contentLanguage {
            try container.encode(contentLanguage, forKey: Key("contentLanguage"))
        }
        if contentLength != 0 {
            try container.encode(contentLength, forKey: Key("contentLength"))
        }
        if let contentMD5 = contentMD5 {
            try container.encode(contentMD5, forKey: Key("contentMD5"))
        }
        if let contentType = contentType {
            try container.encode(contentType, forKey: Key("contentType"))
        }
        if let httpExpiresDate = httpExpiresDate {
            try container.encode(TimestampWrapper(httpExpiresDate, format: .dateTime), forKey: Key("httpExpiresDate"))
        }
        if requesterCharged != false {
            try container.encode(requesterCharged, forKey: Key("requesterCharged"))
        }
        if let sSEAlgorithm = sSEAlgorithm {
            try container.encode(sSEAlgorithm, forKey: Key("sSEAlgorithm"))
        }
        if let userMetadata = userMetadata {
            var userMetadataContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("userMetadata"))
            for (nonemptymaxlength1024stringKey0, maxlength1024stringValue0) in userMetadata {
                var entryContainer0 = userMetadataContainer.nestedContainer(keyedBy: Key.self, forKey: Key("entry"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("key"))
                try keyContainer0.encode(nonemptymaxlength1024stringKey0, forKey: Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("value"))
                try valueContainer0.encode(maxlength1024stringValue0, forKey: Key(""))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cacheControlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cacheControl)
        cacheControl = cacheControlDecoded
        let contentDispositionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentDisposition)
        contentDisposition = contentDispositionDecoded
        let contentEncodingDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentEncoding)
        contentEncoding = contentEncodingDecoded
        let contentLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentLanguage)
        contentLanguage = contentLanguageDecoded
        if containerValues.contains(.userMetadata) {
            struct KeyVal0{struct key{}; struct value{}}
            let userMetadataWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .userMetadata)
            if let userMetadataWrappedContainer = userMetadataWrappedContainer {
                let userMetadataContainer = try userMetadataWrappedContainer.decodeIfPresent([MapKeyValue<String, String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var userMetadataBuffer: [String:String]? = nil
                if let userMetadataContainer = userMetadataContainer {
                    userMetadataBuffer = [String:String]()
                    for stringContainer0 in userMetadataContainer {
                        userMetadataBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                userMetadata = userMetadataBuffer
            } else {
                userMetadata = [:]
            }
        } else {
            userMetadata = nil
        }
        let contentLengthDecoded = try containerValues.decode(Int.self, forKey: .contentLength)
        contentLength = contentLengthDecoded
        let contentMD5Decoded = try containerValues.decodeIfPresent(String.self, forKey: .contentMD5)
        contentMD5 = contentMD5Decoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let httpExpiresDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpExpiresDate)
        var httpExpiresDateBuffer:Date? = nil
        if let httpExpiresDateDecoded = httpExpiresDateDecoded {
            httpExpiresDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(httpExpiresDateDecoded, format: .dateTime)
        }
        httpExpiresDate = httpExpiresDateBuffer
        let requesterChargedDecoded = try containerValues.decode(Bool.self, forKey: .requesterCharged)
        requesterCharged = requesterChargedDecoded
        let sSEAlgorithmDecoded = try containerValues.decodeIfPresent(S3SSEAlgorithm.self, forKey: .sSEAlgorithm)
        sSEAlgorithm = sSEAlgorithmDecoded
    }
}

extension S3ObjectMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ObjectMetadata(cacheControl: \(String(describing: cacheControl)), contentDisposition: \(String(describing: contentDisposition)), contentEncoding: \(String(describing: contentEncoding)), contentLanguage: \(String(describing: contentLanguage)), contentLength: \(String(describing: contentLength)), contentMD5: \(String(describing: contentMD5)), contentType: \(String(describing: contentType)), httpExpiresDate: \(String(describing: httpExpiresDate)), requesterCharged: \(String(describing: requesterCharged)), sSEAlgorithm: \(String(describing: sSEAlgorithm)), userMetadata: \(String(describing: userMetadata)))"}
}

extension S3ObjectMetadata: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p></p>
public struct S3ObjectMetadata: Equatable {
    /// <p></p>
    public let cacheControl: String?
    /// <p></p>
    public let contentDisposition: String?
    /// <p></p>
    public let contentEncoding: String?
    /// <p></p>
    public let contentLanguage: String?
    /// <p></p>
    public let contentLength: Int
    /// <p></p>
    public let contentMD5: String?
    /// <p></p>
    public let contentType: String?
    /// <p></p>
    public let httpExpiresDate: Date?
    /// <p></p>
    public let requesterCharged: Bool
    /// <p></p>
    public let sSEAlgorithm: S3SSEAlgorithm?
    /// <p></p>
    public let userMetadata: [String:String]?

    public init (
        cacheControl: String? = nil,
        contentDisposition: String? = nil,
        contentEncoding: String? = nil,
        contentLanguage: String? = nil,
        contentLength: Int = 0,
        contentMD5: String? = nil,
        contentType: String? = nil,
        httpExpiresDate: Date? = nil,
        requesterCharged: Bool = false,
        sSEAlgorithm: S3SSEAlgorithm? = nil,
        userMetadata: [String:String]? = nil
    )
    {
        self.cacheControl = cacheControl
        self.contentDisposition = contentDisposition
        self.contentEncoding = contentEncoding
        self.contentLanguage = contentLanguage
        self.contentLength = contentLength
        self.contentMD5 = contentMD5
        self.contentType = contentType
        self.httpExpiresDate = httpExpiresDate
        self.requesterCharged = requesterCharged
        self.sSEAlgorithm = sSEAlgorithm
        self.userMetadata = userMetadata
    }
}

extension S3ObjectOwner: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName = "DisplayName"
        case iD = "ID"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let displayName = displayName {
            try container.encode(displayName, forKey: Key("displayName"))
        }
        if let iD = iD {
            try container.encode(iD, forKey: Key("iD"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iD)
        iD = iDDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension S3ObjectOwner: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ObjectOwner(displayName: \(String(describing: displayName)), iD: \(String(describing: iD)))"}
}

extension S3ObjectOwner: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p></p>
public struct S3ObjectOwner: Equatable {
    /// <p></p>
    public let displayName: String?
    /// <p></p>
    public let iD: String?

    public init (
        displayName: String? = nil,
        iD: String? = nil
    )
    {
        self.displayName = displayName
        self.iD = iD
    }
}

public enum S3Permission {
    case fullControl
    case read
    case readAcp
    case write
    case writeAcp
    case sdkUnknown(String)
}

extension S3Permission : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3Permission] {
        return [
            .fullControl,
            .read,
            .readAcp,
            .write,
            .writeAcp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fullControl: return "FULL_CONTROL"
        case .read: return "READ"
        case .readAcp: return "READ_ACP"
        case .write: return "WRITE"
        case .writeAcp: return "WRITE_ACP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3Permission(rawValue: rawValue) ?? S3Permission.sdkUnknown(rawValue)
    }
}

extension S3Retention: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mode = "Mode"
        case retainUntilDate = "RetainUntilDate"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let mode = mode {
            try container.encode(mode, forKey: Key("mode"))
        }
        if let retainUntilDate = retainUntilDate {
            try container.encode(TimestampWrapper(retainUntilDate, format: .dateTime), forKey: Key("retainUntilDate"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retainUntilDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .retainUntilDate)
        var retainUntilDateBuffer:Date? = nil
        if let retainUntilDateDecoded = retainUntilDateDecoded {
            retainUntilDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(retainUntilDateDecoded, format: .dateTime)
        }
        retainUntilDate = retainUntilDateBuffer
        let modeDecoded = try containerValues.decodeIfPresent(S3ObjectLockRetentionMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension S3Retention: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Retention(mode: \(String(describing: mode)), retainUntilDate: \(String(describing: retainUntilDate)))"}
}

extension S3Retention: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the S3 Object Lock retention mode to be applied to all objects in the
///          S3 Batch Operations job. If you don't provide <code>Mode</code> and <code>RetainUntilDate</code>
///          data types in your operation, you will remove the retention from your objects. For more
///          information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-retention-date.html">Using S3 Object Lock retention
///             with S3 Batch Operations</a> in the <i>Amazon S3 User Guide</i>.</p>
public struct S3Retention: Equatable {
    /// <p>The Object Lock retention mode to be applied to all objects in the Batch Operations job.</p>
    public let mode: S3ObjectLockRetentionMode?
    /// <p>The date when the applied Object Lock retention will expire on all objects set by the Batch Operations job.</p>
    public let retainUntilDate: Date?

    public init (
        mode: S3ObjectLockRetentionMode? = nil,
        retainUntilDate: Date? = nil
    )
    {
        self.mode = mode
        self.retainUntilDate = retainUntilDate
    }
}

public enum S3SSEAlgorithm {
    case aes256
    case kms
    case sdkUnknown(String)
}

extension S3SSEAlgorithm : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3SSEAlgorithm] {
        return [
            .aes256,
            .kms,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aes256: return "AES256"
        case .kms: return "KMS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3SSEAlgorithm(rawValue: rawValue) ?? S3SSEAlgorithm.sdkUnknown(rawValue)
    }
}

extension S3SetObjectAclOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessControlPolicy = "AccessControlPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let accessControlPolicy = accessControlPolicy {
            try container.encode(accessControlPolicy, forKey: Key("accessControlPolicy"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlPolicyDecoded = try containerValues.decodeIfPresent(S3AccessControlPolicy.self, forKey: .accessControlPolicy)
        accessControlPolicy = accessControlPolicyDecoded
    }
}

extension S3SetObjectAclOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3SetObjectAclOperation(accessControlPolicy: \(String(describing: accessControlPolicy)))"}
}

extension S3SetObjectAclOperation: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the configuration parameters for a Set Object ACL operation. S3 Batch Operations passes every object to the underlying PUT Object acl API.
///          For more information about the parameters for this operation, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPUTacl.html">PUT Object acl</a>.</p>
public struct S3SetObjectAclOperation: Equatable {
    /// <p></p>
    public let accessControlPolicy: S3AccessControlPolicy?

    public init (
        accessControlPolicy: S3AccessControlPolicy? = nil
    )
    {
        self.accessControlPolicy = accessControlPolicy
    }
}

extension S3SetObjectLegalHoldOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case legalHold = "LegalHold"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let legalHold = legalHold {
            try container.encode(legalHold, forKey: Key("legalHold"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let legalHoldDecoded = try containerValues.decodeIfPresent(S3ObjectLockLegalHold.self, forKey: .legalHold)
        legalHold = legalHoldDecoded
    }
}

extension S3SetObjectLegalHoldOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3SetObjectLegalHoldOperation(legalHold: \(String(describing: legalHold)))"}
}

extension S3SetObjectLegalHoldOperation: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the configuration for an S3 Object Lock legal hold operation that an
///          S3 Batch Operations job passes every object to the underlying
///             <code>PutObjectLegalHold</code> API. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-legal-hold.html">Using
///             S3 Object Lock legal hold with S3 Batch Operations</a> in the
///             <i>Amazon S3 User Guide</i>.</p>
public struct S3SetObjectLegalHoldOperation: Equatable {
    /// <p>Contains the Object Lock legal hold status to be applied to all objects in the Batch Operations job.</p>
    public let legalHold: S3ObjectLockLegalHold?

    public init (
        legalHold: S3ObjectLockLegalHold? = nil
    )
    {
        self.legalHold = legalHold
    }
}

extension S3SetObjectRetentionOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case retention = "Retention"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if bypassGovernanceRetention != false {
            try container.encode(bypassGovernanceRetention, forKey: Key("bypassGovernanceRetention"))
        }
        if let retention = retention {
            try container.encode(retention, forKey: Key("retention"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bypassGovernanceRetentionDecoded = try containerValues.decode(Bool.self, forKey: .bypassGovernanceRetention)
        bypassGovernanceRetention = bypassGovernanceRetentionDecoded
        let retentionDecoded = try containerValues.decodeIfPresent(S3Retention.self, forKey: .retention)
        retention = retentionDecoded
    }
}

extension S3SetObjectRetentionOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3SetObjectRetentionOperation(bypassGovernanceRetention: \(String(describing: bypassGovernanceRetention)), retention: \(String(describing: retention)))"}
}

extension S3SetObjectRetentionOperation: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the configuration parameters for the Object Lock retention action for an
///          S3 Batch Operations job. Batch Operations passes every object to the underlying
///             <code>PutObjectRetention</code> API. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-retention-date.html">Using
///             S3 Object Lock retention with S3 Batch Operations</a> in the
///             <i>Amazon S3 User Guide</i>.</p>
public struct S3SetObjectRetentionOperation: Equatable {
    /// <p>Indicates if the action should be applied to objects in the Batch Operations job even if they have Object Lock <code>
    ///          GOVERNANCE</code> type in place.</p>
    public let bypassGovernanceRetention: Bool
    /// <p>Contains the Object Lock retention mode to be applied to all objects in the Batch Operations
    ///          job. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-retention-date.html">Using S3 Object Lock retention
    ///             with S3 Batch Operations</a> in the <i>Amazon S3 User Guide</i>.</p>
    public let retention: S3Retention?

    public init (
        bypassGovernanceRetention: Bool = false,
        retention: S3Retention? = nil
    )
    {
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.retention = retention
    }
}

extension S3SetObjectTaggingOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagSet = "TagSet"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let tagSet = tagSet {
            var tagSetContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("tagSet"))
            for s3tag0 in tagSet {
                try tagSetContainer.encode(s3tag0, forKey: Key("member"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tagSet) {
            struct KeyVal0{struct member{}}
            let tagSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagSet)
            if let tagSetWrappedContainer = tagSetWrappedContainer {
                let tagSetContainer = try tagSetWrappedContainer.decodeIfPresent([S3Tag].self, forKey: .member)
                var tagSetBuffer:[S3Tag]? = nil
                if let tagSetContainer = tagSetContainer {
                    tagSetBuffer = [S3Tag]()
                    for structureContainer0 in tagSetContainer {
                        tagSetBuffer?.append(structureContainer0)
                    }
                }
                tagSet = tagSetBuffer
            } else {
                tagSet = []
            }
        } else {
            tagSet = nil
        }
    }
}

extension S3SetObjectTaggingOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3SetObjectTaggingOperation(tagSet: \(String(describing: tagSet)))"}
}

extension S3SetObjectTaggingOperation: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the configuration parameters for a Set Object Tagging operation. S3 Batch Operations passes every object to the underlying PUT Object tagging API.
///          For more information about the parameters for this operation, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPUTtagging.html">PUT Object tagging</a>.</p>
public struct S3SetObjectTaggingOperation: Equatable {
    /// <p></p>
    public let tagSet: [S3Tag]?

    public init (
        tagSet: [S3Tag]? = nil
    )
    {
        self.tagSet = tagSet
    }
}

public enum S3StorageClass {
    case deepArchive
    case glacier
    case intelligentTiering
    case onezoneIa
    case standard
    case standardIa
    case sdkUnknown(String)
}

extension S3StorageClass : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [S3StorageClass] {
        return [
            .deepArchive,
            .glacier,
            .intelligentTiering,
            .onezoneIa,
            .standard,
            .standardIa,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deepArchive: return "DEEP_ARCHIVE"
        case .glacier: return "GLACIER"
        case .intelligentTiering: return "INTELLIGENT_TIERING"
        case .onezoneIa: return "ONEZONE_IA"
        case .standard: return "STANDARD"
        case .standardIa: return "STANDARD_IA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = S3StorageClass(rawValue: rawValue) ?? S3StorageClass.sdkUnknown(rawValue)
    }
}

extension S3Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: Key("key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension S3Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

extension S3Tag: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p></p>
public struct S3Tag: Equatable {
    /// <p></p>
    public let key: String?
    /// <p></p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension SSEKMS: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let keyId = keyId {
            try container.encode(keyId, forKey: Key("keyId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension SSEKMS: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SSEKMS(keyId: \(String(describing: keyId)))"}
}

extension SSEKMS: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p></p>
public struct SSEKMS: Equatable {
    /// <p>A container for the ARN of the SSE-KMS encryption.
    ///          This property is read-only and follows the following format:
    ///          <code> arn:aws:kms:<i>us-east-1</i>:<i>example-account-id</i>:key/<i>example-9a73-4afc-8d29-8f5900cef44e</i>
    ///             </code>
    ///          </p>
    public let keyId: String?

    public init (
        keyId: String? = nil
    )
    {
        self.keyId = keyId
    }
}

extension SSES3: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension SSES3: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SSES3()"}
}

/// <p></p>
public struct SSES3: Equatable {

    public init() {}
}

extension SelectionCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case delimiter = "Delimiter"
        case maxDepth = "MaxDepth"
        case minStorageBytesPercentage = "MinStorageBytesPercentage"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let delimiter = delimiter {
            try container.encode(delimiter, forKey: Key("delimiter"))
        }
        if maxDepth != 0 {
            try container.encode(maxDepth, forKey: Key("maxDepth"))
        }
        if minStorageBytesPercentage != 0.0 {
            try container.encode(minStorageBytesPercentage, forKey: Key("minStorageBytesPercentage"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let maxDepthDecoded = try containerValues.decode(Int.self, forKey: .maxDepth)
        maxDepth = maxDepthDecoded
        let minStorageBytesPercentageDecoded = try containerValues.decode(Double.self, forKey: .minStorageBytesPercentage)
        minStorageBytesPercentage = minStorageBytesPercentageDecoded
    }
}

extension SelectionCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SelectionCriteria(delimiter: \(String(describing: delimiter)), maxDepth: \(String(describing: maxDepth)), minStorageBytesPercentage: \(String(describing: minStorageBytesPercentage)))"}
}

extension SelectionCriteria: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p></p>
public struct SelectionCriteria: Equatable {
    /// <p>A container for the delimiter of the selection criteria being used.</p>
    public let delimiter: String?
    /// <p>The max depth of the selection criteria</p>
    public let maxDepth: Int
    /// <p>The minimum number of storage bytes percentage whose metrics will be selected.</p>
    ///          <note>
    ///             <p>You must choose a value greater than or equal to <code>1.0</code>.</p>
    ///          </note>
    public let minStorageBytesPercentage: Double

    public init (
        delimiter: String? = nil,
        maxDepth: Int = 0,
        minStorageBytesPercentage: Double = 0.0
    )
    {
        self.delimiter = delimiter
        self.maxDepth = maxDepth
        self.minStorageBytesPercentage = minStorageBytesPercentage
    }
}

extension StorageLensAwsOrg: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let arn = arn {
            try container.encode(arn, forKey: Key("arn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StorageLensAwsOrg: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageLensAwsOrg(arn: \(String(describing: arn)))"}
}

extension StorageLensAwsOrg: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The AWS organization for your S3 Storage Lens.</p>
public struct StorageLensAwsOrg: Equatable {
    /// <p>A container for the Amazon Resource Name (ARN) of the AWS organization.
    ///          This property is read-only and follows the following format:
    ///          <code> arn:aws:organizations:<i>us-east-1</i>:<i>example-account-id</i>:organization/<i>o-ex2l495dck</i>
    ///             </code>
    ///          </p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

extension StorageLensConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountLevel = "AccountLevel"
        case awsOrg = "AwsOrg"
        case dataExport = "DataExport"
        case exclude = "Exclude"
        case id = "Id"
        case include = "Include"
        case isEnabled = "IsEnabled"
        case storageLensArn = "StorageLensArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let accountLevel = accountLevel {
            try container.encode(accountLevel, forKey: Key("accountLevel"))
        }
        if let awsOrg = awsOrg {
            try container.encode(awsOrg, forKey: Key("awsOrg"))
        }
        if let dataExport = dataExport {
            try container.encode(dataExport, forKey: Key("dataExport"))
        }
        if let exclude = exclude {
            try container.encode(exclude, forKey: Key("exclude"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let include = include {
            try container.encode(include, forKey: Key("include"))
        }
        if isEnabled != false {
            try container.encode(isEnabled, forKey: Key("isEnabled"))
        }
        if let storageLensArn = storageLensArn {
            try container.encode(storageLensArn, forKey: Key("storageLensArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let accountLevelDecoded = try containerValues.decodeIfPresent(AccountLevel.self, forKey: .accountLevel)
        accountLevel = accountLevelDecoded
        let includeDecoded = try containerValues.decodeIfPresent(Include.self, forKey: .include)
        include = includeDecoded
        let excludeDecoded = try containerValues.decodeIfPresent(Exclude.self, forKey: .exclude)
        exclude = excludeDecoded
        let dataExportDecoded = try containerValues.decodeIfPresent(StorageLensDataExport.self, forKey: .dataExport)
        dataExport = dataExportDecoded
        let isEnabledDecoded = try containerValues.decode(Bool.self, forKey: .isEnabled)
        isEnabled = isEnabledDecoded
        let awsOrgDecoded = try containerValues.decodeIfPresent(StorageLensAwsOrg.self, forKey: .awsOrg)
        awsOrg = awsOrgDecoded
        let storageLensArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageLensArn)
        storageLensArn = storageLensArnDecoded
    }
}

extension StorageLensConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageLensConfiguration(accountLevel: \(String(describing: accountLevel)), awsOrg: \(String(describing: awsOrg)), dataExport: \(String(describing: dataExport)), exclude: \(String(describing: exclude)), id: \(String(describing: id)), include: \(String(describing: include)), isEnabled: \(String(describing: isEnabled)), storageLensArn: \(String(describing: storageLensArn)))"}
}

extension StorageLensConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for the Amazon S3 Storage Lens configuration.</p>
public struct StorageLensConfiguration: Equatable {
    /// <p>A container for all the account-level configurations of your S3 Storage Lens
    ///          configuration.</p>
    public let accountLevel: AccountLevel?
    /// <p>A container for the AWS organization for this S3 Storage Lens configuration.</p>
    public let awsOrg: StorageLensAwsOrg?
    /// <p>A container to specify the properties of your S3 Storage Lens metrics export including, the destination, schema and
    ///          format.</p>
    public let dataExport: StorageLensDataExport?
    /// <p>A container for what is excluded in this configuration. This container can only be valid
    ///          if there is no <code>Include</code> container submitted, and it's not empty. </p>
    public let exclude: Exclude?
    /// <p>A container for the Amazon S3 Storage Lens configuration ID.</p>
    public let id: String?
    /// <p>A container for what is included in this configuration. This container can only be valid
    ///          if there is no <code>Exclude</code> container submitted, and it's not empty. </p>
    public let include: Include?
    /// <p>A container for whether the S3 Storage Lens configuration is enabled.</p>
    public let isEnabled: Bool
    /// <p>The Amazon Resource Name (ARN) of the S3 Storage Lens configuration. This property is
    ///          read-only and follows the following format:
    ///          <code> arn:aws:s3:<i>us-east-1</i>:<i>example-account-id</i>:storage-lens/<i>your-dashboard-name</i>
    ///             </code>
    ///          </p>
    public let storageLensArn: String?

    public init (
        accountLevel: AccountLevel? = nil,
        awsOrg: StorageLensAwsOrg? = nil,
        dataExport: StorageLensDataExport? = nil,
        exclude: Exclude? = nil,
        id: String? = nil,
        include: Include? = nil,
        isEnabled: Bool = false,
        storageLensArn: String? = nil
    )
    {
        self.accountLevel = accountLevel
        self.awsOrg = awsOrg
        self.dataExport = dataExport
        self.exclude = exclude
        self.id = id
        self.include = include
        self.isEnabled = isEnabled
        self.storageLensArn = storageLensArn
    }
}

extension StorageLensDataExport: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3BucketDestination = "S3BucketDestination"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let s3BucketDestination = s3BucketDestination {
            try container.encode(s3BucketDestination, forKey: Key("s3BucketDestination"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDestinationDecoded = try containerValues.decodeIfPresent(S3BucketDestination.self, forKey: .s3BucketDestination)
        s3BucketDestination = s3BucketDestinationDecoded
    }
}

extension StorageLensDataExport: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageLensDataExport(s3BucketDestination: \(String(describing: s3BucketDestination)))"}
}

extension StorageLensDataExport: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container to specify the properties of your S3 Storage Lens metrics export, including the
///          destination, schema, and format.</p>
public struct StorageLensDataExport: Equatable {
    /// <p>A container for the bucket where the S3 Storage Lens metrics export will be located.</p>
    ///          <note>
    ///             <p>This bucket must be located in the same Region as the storage lens configuration. </p>
    ///          </note>
    public let s3BucketDestination: S3BucketDestination?

    public init (
        s3BucketDestination: S3BucketDestination? = nil
    )
    {
        self.s3BucketDestination = s3BucketDestination
    }
}

extension StorageLensDataExportEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sSEKMS = "SSE-KMS"
        case sSES3 = "SSE-S3"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let sSEKMS = sSEKMS {
            try container.encode(sSEKMS, forKey: Key("SSE-KMS"))
        }
        if let sSES3 = sSES3 {
            try container.encode(sSES3, forKey: Key("SSE-S3"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sSES3Decoded = try containerValues.decodeIfPresent(SSES3.self, forKey: .sSES3)
        sSES3 = sSES3Decoded
        let sSEKMSDecoded = try containerValues.decodeIfPresent(SSEKMS.self, forKey: .sSEKMS)
        sSEKMS = sSEKMSDecoded
    }
}

extension StorageLensDataExportEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageLensDataExportEncryption(sSEKMS: \(String(describing: sSEKMS)), sSES3: \(String(describing: sSES3)))"}
}

extension StorageLensDataExportEncryption: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A container for the encryption of the S3 Storage Lens metrics exports.</p>
public struct StorageLensDataExportEncryption: Equatable {
    /// <p></p>
    public let sSEKMS: SSEKMS?
    /// <p></p>
    public let sSES3: SSES3?

    public init (
        sSEKMS: SSEKMS? = nil,
        sSES3: SSES3? = nil
    )
    {
        self.sSEKMS = sSEKMS
        self.sSES3 = sSES3
    }
}

extension StorageLensTag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: Key("key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension StorageLensTag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageLensTag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

extension StorageLensTag: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p></p>
public struct StorageLensTag: Equatable {
    /// <p></p>
    public let key: String?
    /// <p></p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension Tagging: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagSet = "TagSet"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let tagSet = tagSet {
            var tagSetContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("tagSet"))
            for s3tag0 in tagSet {
                try tagSetContainer.encode(s3tag0, forKey: Key("member"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tagSet) {
            struct KeyVal0{struct member{}}
            let tagSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagSet)
            if let tagSetWrappedContainer = tagSetWrappedContainer {
                let tagSetContainer = try tagSetWrappedContainer.decodeIfPresent([S3Tag].self, forKey: .member)
                var tagSetBuffer:[S3Tag]? = nil
                if let tagSetContainer = tagSetContainer {
                    tagSetBuffer = [S3Tag]()
                    for structureContainer0 in tagSetContainer {
                        tagSetBuffer?.append(structureContainer0)
                    }
                }
                tagSet = tagSetBuffer
            } else {
                tagSet = []
            }
        } else {
            tagSet = nil
        }
    }
}

extension Tagging: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tagging(tagSet: \(String(describing: tagSet)))"}
}

extension Tagging: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p></p>
public struct Tagging: Equatable {
    /// <p>A collection for a set of tags.</p>
    public let tagSet: [S3Tag]?

    public init (
        tagSet: [S3Tag]? = nil
    )
    {
        self.tagSet = tagSet
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyRequestsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyTagsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon S3 throws this exception if you have too many tags in your tag set.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Transition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case date = "Date"
        case days = "Days"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let date = date {
            try container.encode(TimestampWrapper(date, format: .dateTime), forKey: Key("date"))
        }
        if days != 0 {
            try container.encode(days, forKey: Key("days"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: Key("storageClass"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .date)
        var dateBuffer:Date? = nil
        if let dateDecoded = dateDecoded {
            dateBuffer = try TimestampWrapperDecoder.parseDateStringValue(dateDecoded, format: .dateTime)
        }
        date = dateBuffer
        let daysDecoded = try containerValues.decode(Int.self, forKey: .days)
        days = daysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(TransitionStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension Transition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Transition(date: \(String(describing: date)), days: \(String(describing: days)), storageClass: \(String(describing: storageClass)))"}
}

extension Transition: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Specifies when an object transitions to a specified storage class. For more information
///          about Amazon S3 Lifecycle configuration rules, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/lifecycle-transition-general-considerations.html">
///             Transitioning objects using Amazon S3 Lifecycle</a> in the
///             <i>Amazon S3 User Guide</i>.</p>
public struct Transition: Equatable {
    /// <p>Indicates when objects are transitioned to the specified storage class.
    ///          The date value must be in ISO 8601 format. The time is always midnight UTC.</p>
    public let date: Date?
    /// <p>Indicates the number of days after creation when objects are transitioned to the specified storage class.
    ///          The value must be a positive integer.</p>
    public let days: Int
    /// <p>The storage class to which you want the object to transition.</p>
    public let storageClass: TransitionStorageClass?

    public init (
        date: Date? = nil,
        days: Int = 0,
        storageClass: TransitionStorageClass? = nil
    )
    {
        self.date = date
        self.days = days
        self.storageClass = storageClass
    }
}

public enum TransitionStorageClass {
    case deepArchive
    case glacier
    case intelligentTiering
    case onezoneIa
    case standardIa
    case sdkUnknown(String)
}

extension TransitionStorageClass : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TransitionStorageClass] {
        return [
            .deepArchive,
            .glacier,
            .intelligentTiering,
            .onezoneIa,
            .standardIa,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deepArchive: return "DEEP_ARCHIVE"
        case .glacier: return "GLACIER"
        case .intelligentTiering: return "INTELLIGENT_TIERING"
        case .onezoneIa: return "ONEZONE_IA"
        case .standardIa: return "STANDARD_IA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TransitionStorageClass(rawValue: rawValue) ?? TransitionStorageClass.sdkUnknown(rawValue)
    }
}

extension UpdateJobPriorityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJobPriorityInput(accountId: \(String(describing: accountId)), jobId: \(String(describing: jobId)), priority: \(String(describing: priority)))"}
}

extension UpdateJobPriorityInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UpdateJobPriorityInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateJobPriorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobPriorityInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobPriorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobPriorityInput>
    public typealias MOutput = OperationOutput<UpdateJobPriorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobPriorityOutputError>
}

public struct UpdateJobPriorityInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateJobPriorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobPriorityInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobPriorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let priorityQueryItem = URLQueryItem(name: "priority".urlPercentEncoding(), value: String(input.operationInput.priority).urlPercentEncoding())
        input.builder.withQueryItem(priorityQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobPriorityInput>
    public typealias MOutput = OperationOutput<UpdateJobPriorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobPriorityOutputError>
}

public struct UpdateJobPriorityInput: Equatable {
    /// <p>The AWS account ID associated with the S3 Batch Operations job.</p>
    public let accountId: String?
    /// <p>The ID for the job whose priority you want to update.</p>
    public let jobId: String?
    /// <p>The priority you want to assign to this job.</p>
    public let priority: Int

    public init (
        accountId: String? = nil,
        jobId: String? = nil,
        priority: Int = 0
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.priority = priority
    }
}

struct UpdateJobPriorityInputBody: Equatable {
}

extension UpdateJobPriorityInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateJobPriorityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateJobPriorityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateJobPriorityOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateJobPriorityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJobPriorityOutputResponse(jobId: \(String(describing: jobId)), priority: \(String(describing: priority)))"}
}

extension UpdateJobPriorityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateJobPriorityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.priority = output.priority
        } else {
            self.jobId = nil
            self.priority = 0
        }
    }
}

public struct UpdateJobPriorityOutputResponse: Equatable {
    /// <p>The ID for the job whose priority Amazon S3 updated.</p>
    public let jobId: String?
    /// <p>The new priority assigned to the specified job.</p>
    public let priority: Int

    public init (
        jobId: String? = nil,
        priority: Int = 0
    )
    {
        self.jobId = jobId
        self.priority = priority
    }
}

struct UpdateJobPriorityOutputResponseBody: Equatable {
    public let jobId: String?
    public let priority: Int
}

extension UpdateJobPriorityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case priority = "Priority"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension UpdateJobStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJobStatusInput(accountId: \(String(describing: accountId)), jobId: \(String(describing: jobId)), requestedJobStatus: \(String(describing: requestedJobStatus)), statusUpdateReason: \(String(describing: statusUpdateReason)))"}
}

extension UpdateJobStatusInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UpdateJobStatusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateJobStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accountId = input.operationInput.accountId {
            input.builder.withHeader(name: "x-amz-account-id", value: String(accountId))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobStatusInput>
    public typealias MOutput = OperationOutput<UpdateJobStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobStatusOutputError>
}

public struct UpdateJobStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateJobStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let statusUpdateReason = input.operationInput.statusUpdateReason {
            let statusUpdateReasonQueryItem = URLQueryItem(name: "statusUpdateReason".urlPercentEncoding(), value: String(statusUpdateReason).urlPercentEncoding())
            input.builder.withQueryItem(statusUpdateReasonQueryItem)
        }
        if let requestedJobStatus = input.operationInput.requestedJobStatus {
            let requestedJobStatusQueryItem = URLQueryItem(name: "requestedJobStatus".urlPercentEncoding(), value: String(requestedJobStatus.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(requestedJobStatusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobStatusInput>
    public typealias MOutput = OperationOutput<UpdateJobStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobStatusOutputError>
}

public struct UpdateJobStatusInput: Equatable {
    /// <p>The AWS account ID associated with the S3 Batch Operations job.</p>
    public let accountId: String?
    /// <p>The ID of the job whose status you want to update.</p>
    public let jobId: String?
    /// <p>The status that you want to move the specified job to.</p>
    public let requestedJobStatus: RequestedJobStatus?
    /// <p>A description of the reason why you want to change the specified job's status. This field can be any string up to the maximum length.</p>
    public let statusUpdateReason: String?

    public init (
        accountId: String? = nil,
        jobId: String? = nil,
        requestedJobStatus: RequestedJobStatus? = nil,
        statusUpdateReason: String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.requestedJobStatus = requestedJobStatus
        self.statusUpdateReason = statusUpdateReason
    }
}

struct UpdateJobStatusInputBody: Equatable {
}

extension UpdateJobStatusInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateJobStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateJobStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobStatusException" : self = .jobStatusException(try JobStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateJobStatusOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalServiceException(InternalServiceException)
    case jobStatusException(JobStatusException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateJobStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJobStatusOutputResponse(jobId: \(String(describing: jobId)), status: \(String(describing: status)), statusUpdateReason: \(String(describing: statusUpdateReason)))"}
}

extension UpdateJobStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateJobStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.status = output.status
            self.statusUpdateReason = output.statusUpdateReason
        } else {
            self.jobId = nil
            self.status = nil
            self.statusUpdateReason = nil
        }
    }
}

public struct UpdateJobStatusOutputResponse: Equatable {
    /// <p>The ID for the job whose status was updated.</p>
    public let jobId: String?
    /// <p>The current status for the specified job.</p>
    public let status: JobStatus?
    /// <p>The reason that the specified job's status was updated.</p>
    public let statusUpdateReason: String?

    public init (
        jobId: String? = nil,
        status: JobStatus? = nil,
        statusUpdateReason: String? = nil
    )
    {
        self.jobId = jobId
        self.status = status
        self.statusUpdateReason = statusUpdateReason
    }
}

struct UpdateJobStatusOutputResponseBody: Equatable {
    public let jobId: String?
    public let status: JobStatus?
    public let statusUpdateReason: String?
}

extension UpdateJobStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case status = "Status"
        case statusUpdateReason = "StatusUpdateReason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .status)
        status = statusDecoded
        let statusUpdateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusUpdateReason)
        statusUpdateReason = statusUpdateReasonDecoded
    }
}

extension VpcConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("vpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension VpcConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcConfiguration(vpcId: \(String(describing: vpcId)))"}
}

extension VpcConfiguration: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The virtual private cloud (VPC) configuration for an access point.</p>
public struct VpcConfiguration: Equatable {
    /// <p>If this field is specified, this access point will only allow connections from the specified VPC ID.</p>
    public let vpcId: String?

    public init (
        vpcId: String? = nil
    )
    {
        self.vpcId = vpcId
    }
}
