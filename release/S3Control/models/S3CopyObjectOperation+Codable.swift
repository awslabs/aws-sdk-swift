// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension S3CopyObjectOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessControlGrants = "AccessControlGrants"
        case bucketKeyEnabled = "BucketKeyEnabled"
        case cannedAccessControlList = "CannedAccessControlList"
        case metadataDirective = "MetadataDirective"
        case modifiedSinceConstraint = "ModifiedSinceConstraint"
        case newObjectMetadata = "NewObjectMetadata"
        case newObjectTagging = "NewObjectTagging"
        case objectLockLegalHoldStatus = "ObjectLockLegalHoldStatus"
        case objectLockMode = "ObjectLockMode"
        case objectLockRetainUntilDate = "ObjectLockRetainUntilDate"
        case redirectLocation = "RedirectLocation"
        case requesterPays = "RequesterPays"
        case sSEAwsKmsKeyId = "SSEAwsKmsKeyId"
        case storageClass = "StorageClass"
        case targetKeyPrefix = "TargetKeyPrefix"
        case targetResource = "TargetResource"
        case unModifiedSinceConstraint = "UnModifiedSinceConstraint"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: Key("xmlns"))
        }
        if let accessControlGrants = accessControlGrants {
            var accessControlGrantsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("accessControlGrants"))
            for s3grant0 in accessControlGrants {
                try accessControlGrantsContainer.encode(s3grant0, forKey: Key("member"))
            }
        }
        if bucketKeyEnabled != false {
            try container.encode(bucketKeyEnabled, forKey: Key("bucketKeyEnabled"))
        }
        if let cannedAccessControlList = cannedAccessControlList {
            try container.encode(cannedAccessControlList, forKey: Key("cannedAccessControlList"))
        }
        if let metadataDirective = metadataDirective {
            try container.encode(metadataDirective, forKey: Key("metadataDirective"))
        }
        if let modifiedSinceConstraint = modifiedSinceConstraint {
            try container.encode(TimestampWrapper(modifiedSinceConstraint, format: .dateTime), forKey: Key("modifiedSinceConstraint"))
        }
        if let newObjectMetadata = newObjectMetadata {
            try container.encode(newObjectMetadata, forKey: Key("newObjectMetadata"))
        }
        if let newObjectTagging = newObjectTagging {
            var newObjectTaggingContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("newObjectTagging"))
            for s3tag0 in newObjectTagging {
                try newObjectTaggingContainer.encode(s3tag0, forKey: Key("member"))
            }
        }
        if let objectLockLegalHoldStatus = objectLockLegalHoldStatus {
            try container.encode(objectLockLegalHoldStatus, forKey: Key("objectLockLegalHoldStatus"))
        }
        if let objectLockMode = objectLockMode {
            try container.encode(objectLockMode, forKey: Key("objectLockMode"))
        }
        if let objectLockRetainUntilDate = objectLockRetainUntilDate {
            try container.encode(TimestampWrapper(objectLockRetainUntilDate, format: .dateTime), forKey: Key("objectLockRetainUntilDate"))
        }
        if let redirectLocation = redirectLocation {
            try container.encode(redirectLocation, forKey: Key("redirectLocation"))
        }
        if requesterPays != false {
            try container.encode(requesterPays, forKey: Key("requesterPays"))
        }
        if let sSEAwsKmsKeyId = sSEAwsKmsKeyId {
            try container.encode(sSEAwsKmsKeyId, forKey: Key("sSEAwsKmsKeyId"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: Key("storageClass"))
        }
        if let targetKeyPrefix = targetKeyPrefix {
            try container.encode(targetKeyPrefix, forKey: Key("targetKeyPrefix"))
        }
        if let targetResource = targetResource {
            try container.encode(targetResource, forKey: Key("targetResource"))
        }
        if let unModifiedSinceConstraint = unModifiedSinceConstraint {
            try container.encode(TimestampWrapper(unModifiedSinceConstraint, format: .dateTime), forKey: Key("unModifiedSinceConstraint"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetResourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetResource)
        targetResource = targetResourceDecoded
        let cannedAccessControlListDecoded = try containerValues.decodeIfPresent(S3CannedAccessControlList.self, forKey: .cannedAccessControlList)
        cannedAccessControlList = cannedAccessControlListDecoded
        if containerValues.contains(.accessControlGrants) {
            struct KeyVal0{struct member{}}
            let accessControlGrantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accessControlGrants)
            if let accessControlGrantsWrappedContainer = accessControlGrantsWrappedContainer {
                let accessControlGrantsContainer = try accessControlGrantsWrappedContainer.decodeIfPresent([S3Grant].self, forKey: .member)
                var accessControlGrantsBuffer:[S3Grant]? = nil
                if let accessControlGrantsContainer = accessControlGrantsContainer {
                    accessControlGrantsBuffer = [S3Grant]()
                    for structureContainer0 in accessControlGrantsContainer {
                        accessControlGrantsBuffer?.append(structureContainer0)
                    }
                }
                accessControlGrants = accessControlGrantsBuffer
            } else {
                accessControlGrants = []
            }
        } else {
            accessControlGrants = nil
        }
        let metadataDirectiveDecoded = try containerValues.decodeIfPresent(S3MetadataDirective.self, forKey: .metadataDirective)
        metadataDirective = metadataDirectiveDecoded
        let modifiedSinceConstraintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modifiedSinceConstraint)
        var modifiedSinceConstraintBuffer:Date? = nil
        if let modifiedSinceConstraintDecoded = modifiedSinceConstraintDecoded {
            modifiedSinceConstraintBuffer = try TimestampWrapperDecoder.parseDateStringValue(modifiedSinceConstraintDecoded, format: .dateTime)
        }
        modifiedSinceConstraint = modifiedSinceConstraintBuffer
        let newObjectMetadataDecoded = try containerValues.decodeIfPresent(S3ObjectMetadata.self, forKey: .newObjectMetadata)
        newObjectMetadata = newObjectMetadataDecoded
        if containerValues.contains(.newObjectTagging) {
            struct KeyVal0{struct member{}}
            let newObjectTaggingWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .newObjectTagging)
            if let newObjectTaggingWrappedContainer = newObjectTaggingWrappedContainer {
                let newObjectTaggingContainer = try newObjectTaggingWrappedContainer.decodeIfPresent([S3Tag].self, forKey: .member)
                var newObjectTaggingBuffer:[S3Tag]? = nil
                if let newObjectTaggingContainer = newObjectTaggingContainer {
                    newObjectTaggingBuffer = [S3Tag]()
                    for structureContainer0 in newObjectTaggingContainer {
                        newObjectTaggingBuffer?.append(structureContainer0)
                    }
                }
                newObjectTagging = newObjectTaggingBuffer
            } else {
                newObjectTagging = []
            }
        } else {
            newObjectTagging = nil
        }
        let redirectLocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .redirectLocation)
        redirectLocation = redirectLocationDecoded
        let requesterPaysDecoded = try containerValues.decode(Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let unModifiedSinceConstraintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unModifiedSinceConstraint)
        var unModifiedSinceConstraintBuffer:Date? = nil
        if let unModifiedSinceConstraintDecoded = unModifiedSinceConstraintDecoded {
            unModifiedSinceConstraintBuffer = try TimestampWrapperDecoder.parseDateStringValue(unModifiedSinceConstraintDecoded, format: .dateTime)
        }
        unModifiedSinceConstraint = unModifiedSinceConstraintBuffer
        let sSEAwsKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sSEAwsKmsKeyId)
        sSEAwsKmsKeyId = sSEAwsKmsKeyIdDecoded
        let targetKeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetKeyPrefix)
        targetKeyPrefix = targetKeyPrefixDecoded
        let objectLockLegalHoldStatusDecoded = try containerValues.decodeIfPresent(S3ObjectLockLegalHoldStatus.self, forKey: .objectLockLegalHoldStatus)
        objectLockLegalHoldStatus = objectLockLegalHoldStatusDecoded
        let objectLockModeDecoded = try containerValues.decodeIfPresent(S3ObjectLockMode.self, forKey: .objectLockMode)
        objectLockMode = objectLockModeDecoded
        let objectLockRetainUntilDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectLockRetainUntilDate)
        var objectLockRetainUntilDateBuffer:Date? = nil
        if let objectLockRetainUntilDateDecoded = objectLockRetainUntilDateDecoded {
            objectLockRetainUntilDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(objectLockRetainUntilDateDecoded, format: .dateTime)
        }
        objectLockRetainUntilDate = objectLockRetainUntilDateBuffer
        let bucketKeyEnabledDecoded = try containerValues.decode(Bool.self, forKey: .bucketKeyEnabled)
        bucketKeyEnabled = bucketKeyEnabledDecoded
    }
}
