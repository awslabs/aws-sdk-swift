// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[GetWorkflowExecutionHistoryOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetWorkflowExecutionHistoryInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetWorkflowExecutionHistoryOutputResponse`
extension SwfClient {
    public func getWorkflowExecutionHistoryPaginated(input: GetWorkflowExecutionHistoryInput) -> ClientRuntime.PaginatorSequence<GetWorkflowExecutionHistoryInput, GetWorkflowExecutionHistoryOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetWorkflowExecutionHistoryInput, GetWorkflowExecutionHistoryOutputResponse>(input: input, inputKey: \GetWorkflowExecutionHistoryInput.nextPageToken, outputKey: \GetWorkflowExecutionHistoryOutputResponse.nextPageToken, paginationFunction: self.getWorkflowExecutionHistory(input:))
    }
}

extension GetWorkflowExecutionHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetWorkflowExecutionHistoryInput {
        return GetWorkflowExecutionHistoryInput(
            domain: self.domain,
            execution: self.execution,
            maximumPageSize: self.maximumPageSize,
            nextPageToken: token,
            reverseOrder: self.reverseOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getWorkflowExecutionHistoryPaginated`
/// to access the nested member `[SwfClientTypes.HistoryEvent]`
/// - Returns: `[SwfClientTypes.HistoryEvent]`
extension PaginatorSequence where Input == GetWorkflowExecutionHistoryInput, Output == GetWorkflowExecutionHistoryOutputResponse {
    func events() async throws -> [SwfClientTypes.HistoryEvent] {
        return try await self.asyncCompactMap { item in item.events }
    }
}

/// Paginate over `[ListActivityTypesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListActivityTypesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListActivityTypesOutputResponse`
extension SwfClient {
    public func listActivityTypesPaginated(input: ListActivityTypesInput) -> ClientRuntime.PaginatorSequence<ListActivityTypesInput, ListActivityTypesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListActivityTypesInput, ListActivityTypesOutputResponse>(input: input, inputKey: \ListActivityTypesInput.nextPageToken, outputKey: \ListActivityTypesOutputResponse.nextPageToken, paginationFunction: self.listActivityTypes(input:))
    }
}

extension ListActivityTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListActivityTypesInput {
        return ListActivityTypesInput(
            domain: self.domain,
            maximumPageSize: self.maximumPageSize,
            name: self.name,
            nextPageToken: token,
            registrationStatus: self.registrationStatus,
            reverseOrder: self.reverseOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listActivityTypesPaginated`
/// to access the nested member `[SwfClientTypes.ActivityTypeInfo]`
/// - Returns: `[SwfClientTypes.ActivityTypeInfo]`
extension PaginatorSequence where Input == ListActivityTypesInput, Output == ListActivityTypesOutputResponse {
    func typeInfos() async throws -> [SwfClientTypes.ActivityTypeInfo] {
        return try await self.asyncCompactMap { item in item.typeInfos }
    }
}

/// Paginate over `[ListClosedWorkflowExecutionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListClosedWorkflowExecutionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListClosedWorkflowExecutionsOutputResponse`
extension SwfClient {
    public func listClosedWorkflowExecutionsPaginated(input: ListClosedWorkflowExecutionsInput) -> ClientRuntime.PaginatorSequence<ListClosedWorkflowExecutionsInput, ListClosedWorkflowExecutionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListClosedWorkflowExecutionsInput, ListClosedWorkflowExecutionsOutputResponse>(input: input, inputKey: \ListClosedWorkflowExecutionsInput.nextPageToken, outputKey: \ListClosedWorkflowExecutionsOutputResponse.nextPageToken, paginationFunction: self.listClosedWorkflowExecutions(input:))
    }
}

extension ListClosedWorkflowExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListClosedWorkflowExecutionsInput {
        return ListClosedWorkflowExecutionsInput(
            closeStatusFilter: self.closeStatusFilter,
            closeTimeFilter: self.closeTimeFilter,
            domain: self.domain,
            executionFilter: self.executionFilter,
            maximumPageSize: self.maximumPageSize,
            nextPageToken: token,
            reverseOrder: self.reverseOrder,
            startTimeFilter: self.startTimeFilter,
            tagFilter: self.tagFilter,
            typeFilter: self.typeFilter
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listClosedWorkflowExecutionsPaginated`
/// to access the nested member `[SwfClientTypes.WorkflowExecutionInfo]`
/// - Returns: `[SwfClientTypes.WorkflowExecutionInfo]`
extension PaginatorSequence where Input == ListClosedWorkflowExecutionsInput, Output == ListClosedWorkflowExecutionsOutputResponse {
    func executionInfos() async throws -> [SwfClientTypes.WorkflowExecutionInfo] {
        return try await self.asyncCompactMap { item in item.executionInfos }
    }
}

/// Paginate over `[ListDomainsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDomainsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDomainsOutputResponse`
extension SwfClient {
    public func listDomainsPaginated(input: ListDomainsInput) -> ClientRuntime.PaginatorSequence<ListDomainsInput, ListDomainsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDomainsInput, ListDomainsOutputResponse>(input: input, inputKey: \ListDomainsInput.nextPageToken, outputKey: \ListDomainsOutputResponse.nextPageToken, paginationFunction: self.listDomains(input:))
    }
}

extension ListDomainsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDomainsInput {
        return ListDomainsInput(
            maximumPageSize: self.maximumPageSize,
            nextPageToken: token,
            registrationStatus: self.registrationStatus,
            reverseOrder: self.reverseOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDomainsPaginated`
/// to access the nested member `[SwfClientTypes.DomainInfo]`
/// - Returns: `[SwfClientTypes.DomainInfo]`
extension PaginatorSequence where Input == ListDomainsInput, Output == ListDomainsOutputResponse {
    func domainInfos() async throws -> [SwfClientTypes.DomainInfo] {
        return try await self.asyncCompactMap { item in item.domainInfos }
    }
}

/// Paginate over `[ListOpenWorkflowExecutionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListOpenWorkflowExecutionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListOpenWorkflowExecutionsOutputResponse`
extension SwfClient {
    public func listOpenWorkflowExecutionsPaginated(input: ListOpenWorkflowExecutionsInput) -> ClientRuntime.PaginatorSequence<ListOpenWorkflowExecutionsInput, ListOpenWorkflowExecutionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListOpenWorkflowExecutionsInput, ListOpenWorkflowExecutionsOutputResponse>(input: input, inputKey: \ListOpenWorkflowExecutionsInput.nextPageToken, outputKey: \ListOpenWorkflowExecutionsOutputResponse.nextPageToken, paginationFunction: self.listOpenWorkflowExecutions(input:))
    }
}

extension ListOpenWorkflowExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOpenWorkflowExecutionsInput {
        return ListOpenWorkflowExecutionsInput(
            domain: self.domain,
            executionFilter: self.executionFilter,
            maximumPageSize: self.maximumPageSize,
            nextPageToken: token,
            reverseOrder: self.reverseOrder,
            startTimeFilter: self.startTimeFilter,
            tagFilter: self.tagFilter,
            typeFilter: self.typeFilter
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listOpenWorkflowExecutionsPaginated`
/// to access the nested member `[SwfClientTypes.WorkflowExecutionInfo]`
/// - Returns: `[SwfClientTypes.WorkflowExecutionInfo]`
extension PaginatorSequence where Input == ListOpenWorkflowExecutionsInput, Output == ListOpenWorkflowExecutionsOutputResponse {
    func executionInfos() async throws -> [SwfClientTypes.WorkflowExecutionInfo] {
        return try await self.asyncCompactMap { item in item.executionInfos }
    }
}

/// Paginate over `[ListWorkflowTypesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListWorkflowTypesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListWorkflowTypesOutputResponse`
extension SwfClient {
    public func listWorkflowTypesPaginated(input: ListWorkflowTypesInput) -> ClientRuntime.PaginatorSequence<ListWorkflowTypesInput, ListWorkflowTypesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListWorkflowTypesInput, ListWorkflowTypesOutputResponse>(input: input, inputKey: \ListWorkflowTypesInput.nextPageToken, outputKey: \ListWorkflowTypesOutputResponse.nextPageToken, paginationFunction: self.listWorkflowTypes(input:))
    }
}

extension ListWorkflowTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkflowTypesInput {
        return ListWorkflowTypesInput(
            domain: self.domain,
            maximumPageSize: self.maximumPageSize,
            name: self.name,
            nextPageToken: token,
            registrationStatus: self.registrationStatus,
            reverseOrder: self.reverseOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listWorkflowTypesPaginated`
/// to access the nested member `[SwfClientTypes.WorkflowTypeInfo]`
/// - Returns: `[SwfClientTypes.WorkflowTypeInfo]`
extension PaginatorSequence where Input == ListWorkflowTypesInput, Output == ListWorkflowTypesOutputResponse {
    func typeInfos() async throws -> [SwfClientTypes.WorkflowTypeInfo] {
        return try await self.asyncCompactMap { item in item.typeInfos }
    }
}

/// Paginate over `[PollForDecisionTaskOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[PollForDecisionTaskInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `PollForDecisionTaskOutputResponse`
extension SwfClient {
    public func pollForDecisionTaskPaginated(input: PollForDecisionTaskInput) -> ClientRuntime.PaginatorSequence<PollForDecisionTaskInput, PollForDecisionTaskOutputResponse> {
        return ClientRuntime.PaginatorSequence<PollForDecisionTaskInput, PollForDecisionTaskOutputResponse>(input: input, inputKey: \PollForDecisionTaskInput.nextPageToken, outputKey: \PollForDecisionTaskOutputResponse.nextPageToken, paginationFunction: self.pollForDecisionTask(input:))
    }
}

extension PollForDecisionTaskInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> PollForDecisionTaskInput {
        return PollForDecisionTaskInput(
            domain: self.domain,
            identity: self.identity,
            maximumPageSize: self.maximumPageSize,
            nextPageToken: token,
            reverseOrder: self.reverseOrder,
            taskList: self.taskList
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `pollForDecisionTaskPaginated`
/// to access the nested member `[SwfClientTypes.HistoryEvent]`
/// - Returns: `[SwfClientTypes.HistoryEvent]`
extension PaginatorSequence where Input == PollForDecisionTaskInput, Output == PollForDecisionTaskOutputResponse {
    func events() async throws -> [SwfClientTypes.HistoryEvent] {
        return try await self.asyncCompactMap { item in item.events }
    }
}
