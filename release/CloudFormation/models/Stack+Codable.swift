// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Stack: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case capabilities = "Capabilities"
        case changeSetId = "ChangeSetId"
        case creationTime = "CreationTime"
        case deletionTime = "DeletionTime"
        case description = "Description"
        case disableRollback = "DisableRollback"
        case driftInformation = "DriftInformation"
        case enableTerminationProtection = "EnableTerminationProtection"
        case lastUpdatedTime = "LastUpdatedTime"
        case notificationARNs = "NotificationARNs"
        case outputs = "Outputs"
        case parameters = "Parameters"
        case parentId = "ParentId"
        case roleARN = "RoleARN"
        case rollbackConfiguration = "RollbackConfiguration"
        case rootId = "RootId"
        case stackId = "StackId"
        case stackName = "StackName"
        case stackStatus = "StackStatus"
        case stackStatusReason = "StackStatusReason"
        case tags = "Tags"
        case timeoutInMinutes = "TimeoutInMinutes"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Capabilities"))
            for (index0, capability0) in capabilities.enumerated() {
                try capabilitiesContainer.encode(capability0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let changeSetId = changeSetId {
            try container.encode(changeSetId, forKey: Key("ChangeSetId"))
        }
        if let creationTime = creationTime {
            try container.encode(TimestampWrapper(creationTime, format: .dateTime), forKey: Key("creationTime"))
        }
        if let deletionTime = deletionTime {
            try container.encode(TimestampWrapper(deletionTime, format: .dateTime), forKey: Key("deletionTime"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let disableRollback = disableRollback {
            try container.encode(disableRollback, forKey: Key("DisableRollback"))
        }
        if let driftInformation = driftInformation {
            try container.encode(driftInformation, forKey: Key("DriftInformation"))
        }
        if let enableTerminationProtection = enableTerminationProtection {
            try container.encode(enableTerminationProtection, forKey: Key("EnableTerminationProtection"))
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try container.encode(TimestampWrapper(lastUpdatedTime, format: .dateTime), forKey: Key("lastUpdatedTime"))
        }
        if let notificationARNs = notificationARNs {
            var notificationARNsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("NotificationARNs"))
            for (index0, notificationarn0) in notificationARNs.enumerated() {
                try notificationARNsContainer.encode(notificationarn0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let outputs = outputs {
            var outputsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Outputs"))
            for (index0, output0) in outputs.enumerated() {
                try outputsContainer.encode(output0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let parentId = parentId {
            try container.encode(parentId, forKey: Key("ParentId"))
        }
        if let roleARN = roleARN {
            try container.encode(roleARN, forKey: Key("RoleARN"))
        }
        if let rollbackConfiguration = rollbackConfiguration {
            try container.encode(rollbackConfiguration, forKey: Key("RollbackConfiguration"))
        }
        if let rootId = rootId {
            try container.encode(rootId, forKey: Key("RootId"))
        }
        if let stackId = stackId {
            try container.encode(stackId, forKey: Key("StackId"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        if let stackStatus = stackStatus {
            try container.encode(stackStatus, forKey: Key("StackStatus"))
        }
        if let stackStatusReason = stackStatusReason {
            try container.encode(stackStatusReason, forKey: Key("StackStatusReason"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let timeoutInMinutes = timeoutInMinutes {
            try container.encode(timeoutInMinutes, forKey: Key("TimeoutInMinutes"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let changeSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct member{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([Parameter].self, forKey: .member)
                var parametersBuffer:[Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        var creationTimeBuffer:Date? = nil
        if let creationTimeDecoded = creationTimeDecoded {
            creationTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationTimeDecoded, format: .dateTime)
        }
        creationTime = creationTimeBuffer
        let deletionTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deletionTime)
        var deletionTimeBuffer:Date? = nil
        if let deletionTimeDecoded = deletionTimeDecoded {
            deletionTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(deletionTimeDecoded, format: .dateTime)
        }
        deletionTime = deletionTimeBuffer
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTime)
        var lastUpdatedTimeBuffer:Date? = nil
        if let lastUpdatedTimeDecoded = lastUpdatedTimeDecoded {
            lastUpdatedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastUpdatedTimeDecoded, format: .dateTime)
        }
        lastUpdatedTime = lastUpdatedTimeBuffer
        let rollbackConfigurationDecoded = try containerValues.decodeIfPresent(RollbackConfiguration.self, forKey: .rollbackConfiguration)
        rollbackConfiguration = rollbackConfigurationDecoded
        let stackStatusDecoded = try containerValues.decodeIfPresent(StackStatus.self, forKey: .stackStatus)
        stackStatus = stackStatusDecoded
        let stackStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackStatusReason)
        stackStatusReason = stackStatusReasonDecoded
        let disableRollbackDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disableRollback)
        disableRollback = disableRollbackDecoded
        if containerValues.contains(.notificationARNs) {
            struct KeyVal0{struct member{}}
            let notificationARNsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .notificationARNs)
            if let notificationARNsWrappedContainer = notificationARNsWrappedContainer {
                let notificationARNsContainer = try notificationARNsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var notificationARNsBuffer:[String]? = nil
                if let notificationARNsContainer = notificationARNsContainer {
                    notificationARNsBuffer = [String]()
                    for stringContainer0 in notificationARNsContainer {
                        notificationARNsBuffer?.append(stringContainer0)
                    }
                }
                notificationARNs = notificationARNsBuffer
            } else {
                notificationARNs = []
            }
        } else {
            notificationARNs = nil
        }
        let timeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutInMinutes)
        timeoutInMinutes = timeoutInMinutesDecoded
        if containerValues.contains(.capabilities) {
            struct KeyVal0{struct member{}}
            let capabilitiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .capabilities)
            if let capabilitiesWrappedContainer = capabilitiesWrappedContainer {
                let capabilitiesContainer = try capabilitiesWrappedContainer.decodeIfPresent([Capability].self, forKey: .member)
                var capabilitiesBuffer:[Capability]? = nil
                if let capabilitiesContainer = capabilitiesContainer {
                    capabilitiesBuffer = [Capability]()
                    for stringContainer0 in capabilitiesContainer {
                        capabilitiesBuffer?.append(stringContainer0)
                    }
                }
                capabilities = capabilitiesBuffer
            } else {
                capabilities = []
            }
        } else {
            capabilities = nil
        }
        if containerValues.contains(.outputs) {
            struct KeyVal0{struct member{}}
            let outputsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .outputs)
            if let outputsWrappedContainer = outputsWrappedContainer {
                let outputsContainer = try outputsWrappedContainer.decodeIfPresent([Output].self, forKey: .member)
                var outputsBuffer:[Output]? = nil
                if let outputsContainer = outputsContainer {
                    outputsBuffer = [Output]()
                    for structureContainer0 in outputsContainer {
                        outputsBuffer?.append(structureContainer0)
                    }
                }
                outputs = outputsBuffer
            } else {
                outputs = []
            }
        } else {
            outputs = nil
        }
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let enableTerminationProtectionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableTerminationProtection)
        enableTerminationProtection = enableTerminationProtectionDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let rootIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rootId)
        rootId = rootIdDecoded
        let driftInformationDecoded = try containerValues.decodeIfPresent(StackDriftInformation.self, forKey: .driftInformation)
        driftInformation = driftInformationDecoded
    }
}
