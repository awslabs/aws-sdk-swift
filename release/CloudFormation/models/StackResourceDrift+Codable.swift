// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension StackResourceDrift: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actualProperties = "ActualProperties"
        case expectedProperties = "ExpectedProperties"
        case logicalResourceId = "LogicalResourceId"
        case moduleInfo = "ModuleInfo"
        case physicalResourceId = "PhysicalResourceId"
        case physicalResourceIdContext = "PhysicalResourceIdContext"
        case propertyDifferences = "PropertyDifferences"
        case resourceType = "ResourceType"
        case stackId = "StackId"
        case stackResourceDriftStatus = "StackResourceDriftStatus"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actualProperties = actualProperties {
            try container.encode(actualProperties, forKey: Key("ActualProperties"))
        }
        if let expectedProperties = expectedProperties {
            try container.encode(expectedProperties, forKey: Key("ExpectedProperties"))
        }
        if let logicalResourceId = logicalResourceId {
            try container.encode(logicalResourceId, forKey: Key("LogicalResourceId"))
        }
        if let moduleInfo = moduleInfo {
            try container.encode(moduleInfo, forKey: Key("ModuleInfo"))
        }
        if let physicalResourceId = physicalResourceId {
            try container.encode(physicalResourceId, forKey: Key("PhysicalResourceId"))
        }
        if let physicalResourceIdContext = physicalResourceIdContext {
            var physicalResourceIdContextContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PhysicalResourceIdContext"))
            for (index0, physicalresourceidcontextkeyvaluepair0) in physicalResourceIdContext.enumerated() {
                try physicalResourceIdContextContainer.encode(physicalresourceidcontextkeyvaluepair0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let propertyDifferences = propertyDifferences {
            var propertyDifferencesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PropertyDifferences"))
            for (index0, propertydifference0) in propertyDifferences.enumerated() {
                try propertyDifferencesContainer.encode(propertydifference0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceType = resourceType {
            try container.encode(resourceType, forKey: Key("ResourceType"))
        }
        if let stackId = stackId {
            try container.encode(stackId, forKey: Key("StackId"))
        }
        if let stackResourceDriftStatus = stackResourceDriftStatus {
            try container.encode(stackResourceDriftStatus, forKey: Key("StackResourceDriftStatus"))
        }
        if let timestamp = timestamp {
            try container.encode(TimestampWrapper(timestamp, format: .dateTime), forKey: Key("timestamp"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        if containerValues.contains(.physicalResourceIdContext) {
            struct KeyVal0{struct member{}}
            let physicalResourceIdContextWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .physicalResourceIdContext)
            if let physicalResourceIdContextWrappedContainer = physicalResourceIdContextWrappedContainer {
                let physicalResourceIdContextContainer = try physicalResourceIdContextWrappedContainer.decodeIfPresent([PhysicalResourceIdContextKeyValuePair].self, forKey: .member)
                var physicalResourceIdContextBuffer:[PhysicalResourceIdContextKeyValuePair]? = nil
                if let physicalResourceIdContextContainer = physicalResourceIdContextContainer {
                    physicalResourceIdContextBuffer = [PhysicalResourceIdContextKeyValuePair]()
                    for structureContainer0 in physicalResourceIdContextContainer {
                        physicalResourceIdContextBuffer?.append(structureContainer0)
                    }
                }
                physicalResourceIdContext = physicalResourceIdContextBuffer
            } else {
                physicalResourceIdContext = []
            }
        } else {
            physicalResourceIdContext = nil
        }
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let expectedPropertiesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expectedProperties)
        expectedProperties = expectedPropertiesDecoded
        let actualPropertiesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actualProperties)
        actualProperties = actualPropertiesDecoded
        if containerValues.contains(.propertyDifferences) {
            struct KeyVal0{struct member{}}
            let propertyDifferencesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .propertyDifferences)
            if let propertyDifferencesWrappedContainer = propertyDifferencesWrappedContainer {
                let propertyDifferencesContainer = try propertyDifferencesWrappedContainer.decodeIfPresent([PropertyDifference].self, forKey: .member)
                var propertyDifferencesBuffer:[PropertyDifference]? = nil
                if let propertyDifferencesContainer = propertyDifferencesContainer {
                    propertyDifferencesBuffer = [PropertyDifference]()
                    for structureContainer0 in propertyDifferencesContainer {
                        propertyDifferencesBuffer?.append(structureContainer0)
                    }
                }
                propertyDifferences = propertyDifferencesBuffer
            } else {
                propertyDifferences = []
            }
        } else {
            propertyDifferences = nil
        }
        let stackResourceDriftStatusDecoded = try containerValues.decodeIfPresent(StackResourceDriftStatus.self, forKey: .stackResourceDriftStatus)
        stackResourceDriftStatus = stackResourceDriftStatusDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestamp)
        var timestampBuffer:Date? = nil
        if let timestampDecoded = timestampDecoded {
            timestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(timestampDecoded, format: .dateTime)
        }
        timestamp = timestampBuffer
        let moduleInfoDecoded = try containerValues.decodeIfPresent(ModuleInfo.self, forKey: .moduleInfo)
        moduleInfo = moduleInfoDecoded
    }
}
