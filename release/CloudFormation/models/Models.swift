// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountGateResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let statusReason = statusReason {
            try container.encode(statusReason, forKey: Key("StatusReason"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AccountGateStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension AccountGateResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountGateResult(status: \(String(describing: status)), statusReason: \(String(describing: statusReason)))"}
}

/// <p>Structure that contains the results of the account gate function which AWS
///          CloudFormation invokes, if present, before proceeding with a stack set operation in an
///          account and Region.</p>
///          <p>For each account and Region, AWS CloudFormation lets you specify a Lamdba function
///          that encapsulates any requirements that must be met before CloudFormation can proceed with
///          a stack set operation in that account and Region. CloudFormation invokes the function each
///          time a stack set operation is requested for that account and Region; if the function
///          returns <code>FAILED</code>, CloudFormation cancels the operation in that account and
///          Region, and sets the stack set operation result status for that account and Region to
///             <code>FAILED</code>. </p>
///          <p>For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-account-gating.html">Configuring a
///             target account gate</a>.</p>
public struct AccountGateResult: Equatable {
    /// <p>The status of the account gate function.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SUCCEEDED</code>: The account gate function has determined that the
    ///                account and Region passes any requirements for a stack set operation to occur. AWS
    ///                CloudFormation proceeds with the stack operation in that account and Region.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code>: The account gate function has determined that the account
    ///                and Region does not meet the requirements for a stack set operation to occur. AWS
    ///                CloudFormation cancels the stack set operation in that account and Region, and sets
    ///                the stack set operation result status for that account and Region to
    ///                   <code>FAILED</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SKIPPED</code>: AWS CloudFormation has skipped calling the account gate
    ///                function for this account and Region, for one of the following reasons:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>An account gate function has not been specified for the account and
    ///                      Region. AWS CloudFormation proceeds with the stack set operation in this
    ///                      account and Region.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>The <code>AWSCloudFormationStackSetExecutionRole</code> of the stack set
    ///                      adminstration account lacks permissions to invoke the function. AWS
    ///                      CloudFormation proceeds with the stack set operation in this account and
    ///                      Region.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Either no action is necessary, or no action is possible, on the stack.
    ///                      AWS CloudFormation skips the stack set operation in this account and
    ///                      Region.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let status: AccountGateStatus?
    /// <p>The reason for the account gate status assigned to this account and Region for the
    ///          stack set operation.</p>
    public let statusReason: String?

    public init (
        status: AccountGateStatus? = nil,
        statusReason: String? = nil
    )
    {
        self.status = status
        self.statusReason = statusReason
    }
}

public enum AccountGateStatus {
    case failed
    case skipped
    case succeeded
    case sdkUnknown(String)
}

extension AccountGateStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccountGateStatus] {
        return [
            .failed,
            .skipped,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .skipped: return "SKIPPED"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccountGateStatus(rawValue: rawValue) ?? AccountGateStatus.sdkUnknown(rawValue)
    }
}

extension AccountLimit: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .value)
        value = valueDecoded
    }
}

extension AccountLimit: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountLimit(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>The AccountLimit data type. </p>
///          <p>CloudFormation has the following limits per account:</p>
///          <ul>
///             <li>
///                <p>Number of concurrent resources</p>
///             </li>
///             <li>
///                <p>Number of stacks</p>
///             </li>
///             <li>
///                <p>Number of stack outputs</p>
///             </li>
///          </ul>
///          <p>For more information about these account limits, and other CloudFormation limits, see
///             <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cloudformation-limits.html">AWS CloudFormation
///             Limits</a> in the <i>AWS CloudFormation User Guide</i>.</p>
public struct AccountLimit: Equatable {
    /// <p>The name of the account limit.</p>
    ///          <p>Values: <code>ConcurrentResourcesLimit</code> | <code>StackLimit</code> |
    ///             <code>StackOutputsLimit</code>
    ///          </p>
    public let name: String?
    /// <p>The value that is associated with the account limit name.</p>
    public let value: Int?

    public init (
        name: String? = nil,
        value: Int? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension AlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlreadyExistsException(message: \(String(describing: message)))"}
}

extension AlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AlreadyExistsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource with the name requested already exists.</p>
public struct AlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension AlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AutoDeployment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case retainStacksOnAccountRemoval = "RetainStacksOnAccountRemoval"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let retainStacksOnAccountRemoval = retainStacksOnAccountRemoval {
            try container.encode(retainStacksOnAccountRemoval, forKey: Key("RetainStacksOnAccountRemoval"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let retainStacksOnAccountRemovalDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .retainStacksOnAccountRemoval)
        retainStacksOnAccountRemoval = retainStacksOnAccountRemovalDecoded
    }
}

extension AutoDeployment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutoDeployment(enabled: \(String(describing: enabled)), retainStacksOnAccountRemoval: \(String(describing: retainStacksOnAccountRemoval)))"}
}

/// <p>[Service-managed permissions] Describes whether StackSets automatically deploys to AWS Organizations accounts that are added to a target organization or organizational unit (OU).</p>
public struct AutoDeployment: Equatable {
    /// <p>If set to <code>true</code>, StackSets automatically deploys additional stack instances to AWS Organizations accounts that are added to a target organization or organizational unit (OU) in the specified Regions. If an account is removed from a target organization or OU, StackSets deletes stack instances from the account in the specified Regions.</p>
    public let enabled: Bool?
    /// <p>If set to <code>true</code>, stack resources are retained when an account is removed from a target organization or OU. If set to <code>false</code>, stack resources are deleted. Specify only if <code>Enabled</code> is set to <code>True</code>.</p>
    public let retainStacksOnAccountRemoval: Bool?

    public init (
        enabled: Bool? = nil,
        retainStacksOnAccountRemoval: Bool? = nil
    )
    {
        self.enabled = enabled
        self.retainStacksOnAccountRemoval = retainStacksOnAccountRemoval
    }
}

extension CFNRegistryException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CFNRegistryException(message: \(String(describing: message)))"}
}

extension CFNRegistryException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CFNRegistryExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error occurred during a CloudFormation registry operation.</p>
public struct CFNRegistryException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CFNRegistryExceptionBody: Equatable {
    public let message: String?
}

extension CFNRegistryExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum CallAs {
    case delegatedAdmin
    case `self`
    case sdkUnknown(String)
}

extension CallAs : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CallAs] {
        return [
            .delegatedAdmin,
            .self,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .delegatedAdmin: return "DELEGATED_ADMIN"
        case .self: return "SELF"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CallAs(rawValue: rawValue) ?? CallAs.sdkUnknown(rawValue)
    }
}

public struct CancelUpdateStackInputBodyMiddleware: Middleware {
    public let id: String = "CancelUpdateStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelUpdateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelUpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelUpdateStackInput>
    public typealias MOutput = OperationOutput<CancelUpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelUpdateStackOutputError>
}

extension CancelUpdateStackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelUpdateStackInput(clientRequestToken: \(String(describing: clientRequestToken)), stackName: \(String(describing: stackName)))"}
}

extension CancelUpdateStackInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clientRequestToken = clientRequestToken {
            try container.encode(clientRequestToken, forKey: Key("ClientRequestToken"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        try container.encode("CancelUpdateStack", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct CancelUpdateStackInputHeadersMiddleware: Middleware {
    public let id: String = "CancelUpdateStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelUpdateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelUpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelUpdateStackInput>
    public typealias MOutput = OperationOutput<CancelUpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelUpdateStackOutputError>
}

public struct CancelUpdateStackInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelUpdateStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelUpdateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelUpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelUpdateStackInput>
    public typealias MOutput = OperationOutput<CancelUpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelUpdateStackOutputError>
}

/// <p>The input for the <a>CancelUpdateStack</a> action.</p>
public struct CancelUpdateStackInput: Equatable {
    /// <p>A unique identifier for this <code>CancelUpdateStack</code> request. Specify this
    ///          token if you plan to retry requests so that AWS CloudFormation knows that you're not
    ///          attempting to cancel an update on a stack with the same name. You might retry
    ///          <code>CancelUpdateStack</code> requests to ensure that AWS CloudFormation successfully
    ///          received them.</p>
    public let clientRequestToken: String?
    /// <p>The name or the unique stack ID that is associated with the stack.</p>
    public let stackName: String?

    public init (
        clientRequestToken: String? = nil,
        stackName: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.stackName = stackName
    }
}

extension CancelUpdateStackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CancelUpdateStackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "TokenAlreadyExistsException" : self = .tokenAlreadyExistsException(try TokenAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelUpdateStackOutputError: Equatable {
    case tokenAlreadyExistsException(TokenAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelUpdateStackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelUpdateStackOutputResponse()"}
}

extension CancelUpdateStackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelUpdateStackOutputResponse: Equatable {

    public init() {}
}

struct CancelUpdateStackOutputResponseBody: Equatable {
}

extension CancelUpdateStackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum Capability {
    case capabilityAutoExpand
    case capabilityIam
    case capabilityNamedIam
    case sdkUnknown(String)
}

extension Capability : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Capability] {
        return [
            .capabilityAutoExpand,
            .capabilityIam,
            .capabilityNamedIam,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .capabilityAutoExpand: return "CAPABILITY_AUTO_EXPAND"
        case .capabilityIam: return "CAPABILITY_IAM"
        case .capabilityNamedIam: return "CAPABILITY_NAMED_IAM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Capability(rawValue: rawValue) ?? Capability.sdkUnknown(rawValue)
    }
}

extension Change: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceChange = "ResourceChange"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceChange = resourceChange {
            try container.encode(resourceChange, forKey: Key("ResourceChange"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChangeType.self, forKey: .type)
        type = typeDecoded
        let resourceChangeDecoded = try containerValues.decodeIfPresent(ResourceChange.self, forKey: .resourceChange)
        resourceChange = resourceChangeDecoded
    }
}

extension Change: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Change(resourceChange: \(String(describing: resourceChange)), type: \(String(describing: type)))"}
}

/// <p>The <code>Change</code> structure describes the changes AWS CloudFormation will
///          perform if you execute the change set.</p>
public struct Change: Equatable {
    /// <p>A <code>ResourceChange</code> structure that describes the resource and action that
    ///          AWS CloudFormation will perform.</p>
    public let resourceChange: ResourceChange?
    /// <p>The type of entity that AWS CloudFormation changes. Currently, the only entity type
    ///          is <code>Resource</code>.</p>
    public let type: ChangeType?

    public init (
        resourceChange: ResourceChange? = nil,
        type: ChangeType? = nil
    )
    {
        self.resourceChange = resourceChange
        self.type = type
    }
}

public enum ChangeAction {
    case add
    case `dynamic`
    case `import`
    case modify
    case remove
    case sdkUnknown(String)
}

extension ChangeAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChangeAction] {
        return [
            .add,
            .dynamic,
            .import,
            .modify,
            .remove,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .add: return "Add"
        case .dynamic: return "Dynamic"
        case .import: return "Import"
        case .modify: return "Modify"
        case .remove: return "Remove"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChangeAction(rawValue: rawValue) ?? ChangeAction.sdkUnknown(rawValue)
    }
}

extension ChangeSetNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChangeSetNotFoundException(message: \(String(describing: message)))"}
}

extension ChangeSetNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ChangeSetNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified change set name or ID doesn't exit. To view valid change sets for a
///          stack, use the <code>ListChangeSets</code> action.</p>
public struct ChangeSetNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ChangeSetNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ChangeSetNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ChangeSetStatus {
    case createComplete
    case createInProgress
    case createPending
    case deleteComplete
    case deleteFailed
    case deleteInProgress
    case deletePending
    case failed
    case sdkUnknown(String)
}

extension ChangeSetStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChangeSetStatus] {
        return [
            .createComplete,
            .createInProgress,
            .createPending,
            .deleteComplete,
            .deleteFailed,
            .deleteInProgress,
            .deletePending,
            .failed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createComplete: return "CREATE_COMPLETE"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .createPending: return "CREATE_PENDING"
        case .deleteComplete: return "DELETE_COMPLETE"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .deletePending: return "DELETE_PENDING"
        case .failed: return "FAILED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChangeSetStatus(rawValue: rawValue) ?? ChangeSetStatus.sdkUnknown(rawValue)
    }
}

extension ChangeSetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeSetId = "ChangeSetId"
        case changeSetName = "ChangeSetName"
        case creationTime = "CreationTime"
        case description = "Description"
        case executionStatus = "ExecutionStatus"
        case includeNestedStacks = "IncludeNestedStacks"
        case parentChangeSetId = "ParentChangeSetId"
        case rootChangeSetId = "RootChangeSetId"
        case stackId = "StackId"
        case stackName = "StackName"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let changeSetId = changeSetId {
            try container.encode(changeSetId, forKey: Key("ChangeSetId"))
        }
        if let changeSetName = changeSetName {
            try container.encode(changeSetName, forKey: Key("ChangeSetName"))
        }
        if let creationTime = creationTime {
            try container.encode(TimestampWrapper(creationTime, format: .dateTime), forKey: Key("creationTime"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let executionStatus = executionStatus {
            try container.encode(executionStatus, forKey: Key("ExecutionStatus"))
        }
        if let includeNestedStacks = includeNestedStacks {
            try container.encode(includeNestedStacks, forKey: Key("IncludeNestedStacks"))
        }
        if let parentChangeSetId = parentChangeSetId {
            try container.encode(parentChangeSetId, forKey: Key("ParentChangeSetId"))
        }
        if let rootChangeSetId = rootChangeSetId {
            try container.encode(rootChangeSetId, forKey: Key("RootChangeSetId"))
        }
        if let stackId = stackId {
            try container.encode(stackId, forKey: Key("StackId"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let statusReason = statusReason {
            try container.encode(statusReason, forKey: Key("StatusReason"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let changeSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let changeSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetName)
        changeSetName = changeSetNameDecoded
        let executionStatusDecoded = try containerValues.decodeIfPresent(ExecutionStatus.self, forKey: .executionStatus)
        executionStatus = executionStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChangeSetStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        var creationTimeBuffer:Date? = nil
        if let creationTimeDecoded = creationTimeDecoded {
            creationTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationTimeDecoded, format: .dateTime)
        }
        creationTime = creationTimeBuffer
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let includeNestedStacksDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeNestedStacks)
        includeNestedStacks = includeNestedStacksDecoded
        let parentChangeSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentChangeSetId)
        parentChangeSetId = parentChangeSetIdDecoded
        let rootChangeSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rootChangeSetId)
        rootChangeSetId = rootChangeSetIdDecoded
    }
}

extension ChangeSetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChangeSetSummary(changeSetId: \(String(describing: changeSetId)), changeSetName: \(String(describing: changeSetName)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), executionStatus: \(String(describing: executionStatus)), includeNestedStacks: \(String(describing: includeNestedStacks)), parentChangeSetId: \(String(describing: parentChangeSetId)), rootChangeSetId: \(String(describing: rootChangeSetId)), stackId: \(String(describing: stackId)), stackName: \(String(describing: stackName)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)))"}
}

/// <p>The <code>ChangeSetSummary</code> structure describes a change set, its status, and
///          the stack with which it's associated.</p>
public struct ChangeSetSummary: Equatable {
    /// <p>The ID of the change set.</p>
    public let changeSetId: String?
    /// <p>The name of the change set.</p>
    public let changeSetName: String?
    /// <p>The start time when the change set was created, in UTC.</p>
    public let creationTime: Date?
    /// <p>Descriptive information about the change set.</p>
    public let description: String?
    /// <p>If the change set execution status is <code>AVAILABLE</code>, you can execute the
    ///          change set. If you can’t execute the change set, the status indicates why. For example, a
    ///          change set might be in an <code>UNAVAILABLE</code> state because AWS CloudFormation is
    ///          still creating it or in an <code>OBSOLETE</code> state because the stack was already
    ///          updated.</p>
    public let executionStatus: ExecutionStatus?
    /// <p>Specifies the current setting of <code>IncludeNestedStacks</code> for the change
    ///          set.</p>
    public let includeNestedStacks: Bool?
    /// <p>The parent change set ID.</p>
    public let parentChangeSetId: String?
    /// <p>The root change set ID.</p>
    public let rootChangeSetId: String?
    /// <p>The ID of the stack with which the change set is associated.</p>
    public let stackId: String?
    /// <p>The name of the stack with which the change set is associated.</p>
    public let stackName: String?
    /// <p>The state of the change set, such as <code>CREATE_IN_PROGRESS</code>,
    ///             <code>CREATE_COMPLETE</code>, or <code>FAILED</code>.</p>
    public let status: ChangeSetStatus?
    /// <p>A description of the change set's status. For example, if your change set is in the
    ///             <code>FAILED</code> state, AWS CloudFormation shows the error message.</p>
    public let statusReason: String?

    public init (
        changeSetId: String? = nil,
        changeSetName: String? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        executionStatus: ExecutionStatus? = nil,
        includeNestedStacks: Bool? = nil,
        parentChangeSetId: String? = nil,
        rootChangeSetId: String? = nil,
        stackId: String? = nil,
        stackName: String? = nil,
        status: ChangeSetStatus? = nil,
        statusReason: String? = nil
    )
    {
        self.changeSetId = changeSetId
        self.changeSetName = changeSetName
        self.creationTime = creationTime
        self.description = description
        self.executionStatus = executionStatus
        self.includeNestedStacks = includeNestedStacks
        self.parentChangeSetId = parentChangeSetId
        self.rootChangeSetId = rootChangeSetId
        self.stackId = stackId
        self.stackName = stackName
        self.status = status
        self.statusReason = statusReason
    }
}

public enum ChangeSetType {
    case create
    case `import`
    case update
    case sdkUnknown(String)
}

extension ChangeSetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChangeSetType] {
        return [
            .create,
            .import,
            .update,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .create: return "CREATE"
        case .import: return "IMPORT"
        case .update: return "UPDATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChangeSetType(rawValue: rawValue) ?? ChangeSetType.sdkUnknown(rawValue)
    }
}

public enum ChangeSource {
    case automatic
    case directmodification
    case parameterreference
    case resourceattribute
    case resourcereference
    case sdkUnknown(String)
}

extension ChangeSource : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChangeSource] {
        return [
            .automatic,
            .directmodification,
            .parameterreference,
            .resourceattribute,
            .resourcereference,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .automatic: return "Automatic"
        case .directmodification: return "DirectModification"
        case .parameterreference: return "ParameterReference"
        case .resourceattribute: return "ResourceAttribute"
        case .resourcereference: return "ResourceReference"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChangeSource(rawValue: rawValue) ?? ChangeSource.sdkUnknown(rawValue)
    }
}

public enum ChangeType {
    case resource
    case sdkUnknown(String)
}

extension ChangeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChangeType] {
        return [
            .resource,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .resource: return "Resource"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
    }
}

public struct ContinueUpdateRollbackInputBodyMiddleware: Middleware {
    public let id: String = "ContinueUpdateRollbackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ContinueUpdateRollbackInput>,
                  next: H) -> Swift.Result<OperationOutput<ContinueUpdateRollbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ContinueUpdateRollbackInput>
    public typealias MOutput = OperationOutput<ContinueUpdateRollbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ContinueUpdateRollbackOutputError>
}

extension ContinueUpdateRollbackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContinueUpdateRollbackInput(clientRequestToken: \(String(describing: clientRequestToken)), resourcesToSkip: \(String(describing: resourcesToSkip)), roleARN: \(String(describing: roleARN)), stackName: \(String(describing: stackName)))"}
}

extension ContinueUpdateRollbackInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clientRequestToken = clientRequestToken {
            try container.encode(clientRequestToken, forKey: Key("ClientRequestToken"))
        }
        if let resourcesToSkip = resourcesToSkip {
            var resourcesToSkipContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ResourcesToSkip"))
            for (index0, resourcetoskip0) in resourcesToSkip.enumerated() {
                try resourcesToSkipContainer.encode(resourcetoskip0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let roleARN = roleARN {
            try container.encode(roleARN, forKey: Key("RoleARN"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        try container.encode("ContinueUpdateRollback", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct ContinueUpdateRollbackInputHeadersMiddleware: Middleware {
    public let id: String = "ContinueUpdateRollbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ContinueUpdateRollbackInput>,
                  next: H) -> Swift.Result<OperationOutput<ContinueUpdateRollbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ContinueUpdateRollbackInput>
    public typealias MOutput = OperationOutput<ContinueUpdateRollbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ContinueUpdateRollbackOutputError>
}

public struct ContinueUpdateRollbackInputQueryItemMiddleware: Middleware {
    public let id: String = "ContinueUpdateRollbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ContinueUpdateRollbackInput>,
                  next: H) -> Swift.Result<OperationOutput<ContinueUpdateRollbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ContinueUpdateRollbackInput>
    public typealias MOutput = OperationOutput<ContinueUpdateRollbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ContinueUpdateRollbackOutputError>
}

/// <p>The input for the <a>ContinueUpdateRollback</a> action.</p>
public struct ContinueUpdateRollbackInput: Equatable {
    /// <p>A unique identifier for this <code>ContinueUpdateRollback</code> request. Specify
    ///          this token if you plan to retry requests so that AWS CloudFormation knows that you're not
    ///          attempting to continue the rollback to a stack with the same name. You might retry
    ///          <code>ContinueUpdateRollback</code> requests to ensure that AWS CloudFormation
    ///          successfully received them.</p>
    public let clientRequestToken: String?
    /// <p>A list of the logical IDs of the resources that AWS CloudFormation skips during the
    ///          continue update rollback operation. You can specify only resources that are in the
    ///             <code>UPDATE_FAILED</code> state because a rollback failed. You can't specify resources
    ///          that are in the <code>UPDATE_FAILED</code> state for other reasons, for example, because an
    ///          update was cancelled. To check why a resource update failed, use the <a>DescribeStackResources</a> action, and view the resource status reason. </p>
    ///          <important>
    ///             <p>Specify this property to skip rolling back resources that AWS CloudFormation can't
    ///             successfully roll back. We recommend that you <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/troubleshooting.html#troubleshooting-errors-update-rollback-failed"> troubleshoot</a> resources before skipping them. AWS CloudFormation sets the
    ///             status of the specified resources to <code>UPDATE_COMPLETE</code> and continues to roll
    ///             back the stack. After the rollback is complete, the state of the skipped resources will
    ///             be inconsistent with the state of the resources in the stack template. Before performing
    ///             another stack update, you must update the stack or resources to be consistent with each
    ///             other. If you don't, subsequent stack updates might fail, and the stack will become
    ///             unrecoverable. </p>
    ///          </important>
    ///          <p>Specify the minimum number of resources required to successfully roll back your
    ///          stack. For example, a failed resource update might cause dependent resources to fail. In
    ///          this case, it might not be necessary to skip the dependent resources. </p>
    ///          <p>To skip resources that are part of nested stacks, use the following format:
    ///             <code>NestedStackName.ResourceLogicalID</code>. If you want to specify the logical ID of
    ///          a stack resource (<code>Type: AWS::CloudFormation::Stack</code>) in the
    ///             <code>ResourcesToSkip</code> list, then its corresponding embedded stack must be in one
    ///          of the following states: <code>DELETE_IN_PROGRESS</code>, <code>DELETE_COMPLETE</code>, or
    ///             <code>DELETE_FAILED</code>. </p>
    ///          <note>
    ///             <p>Don't confuse a child stack's name with its corresponding logical ID defined in
    ///             the parent stack. For an example of a continue update rollback operation with nested
    ///             stacks, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-continueupdaterollback.html#nested-stacks">Using ResourcesToSkip to recover a nested stacks hierarchy</a>. </p>
    ///          </note>
    public let resourcesToSkip: [String]?
    /// <p>The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role
    ///          that AWS CloudFormation assumes to roll back the stack. AWS CloudFormation uses the role's
    ///          credentials to make calls on your behalf. AWS CloudFormation always uses this role for all
    ///          future operations on the stack. As long as users have permission to operate on the stack,
    ///          AWS CloudFormation uses this role even if the users don't have permission to pass it.
    ///          Ensure that the role grants least privilege.</p>
    ///          <p>If you don't specify a value, AWS CloudFormation uses the role that was previously
    ///          associated with the stack. If no role is available, AWS CloudFormation uses a temporary
    ///          session that is generated from your user credentials.</p>
    public let roleARN: String?
    /// <p>The name or the unique ID of the stack that you want to continue rolling
    ///          back.</p>
    ///          <note>
    ///             <p>Don't specify the name of a nested stack (a stack that was created by using the
    ///                <code>AWS::CloudFormation::Stack</code> resource). Instead, use this operation on the
    ///             parent stack (the stack that contains the <code>AWS::CloudFormation::Stack</code>
    ///             resource).</p>
    ///          </note>
    public let stackName: String?

    public init (
        clientRequestToken: String? = nil,
        resourcesToSkip: [String]? = nil,
        roleARN: String? = nil,
        stackName: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.resourcesToSkip = resourcesToSkip
        self.roleARN = roleARN
        self.stackName = stackName
    }
}

extension ContinueUpdateRollbackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ContinueUpdateRollbackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "TokenAlreadyExistsException" : self = .tokenAlreadyExistsException(try TokenAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ContinueUpdateRollbackOutputError: Equatable {
    case tokenAlreadyExistsException(TokenAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ContinueUpdateRollbackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContinueUpdateRollbackOutputResponse()"}
}

extension ContinueUpdateRollbackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The output for a <a>ContinueUpdateRollback</a> action.</p>
public struct ContinueUpdateRollbackOutputResponse: Equatable {

    public init() {}
}

struct ContinueUpdateRollbackOutputResponseBody: Equatable {
}

extension ContinueUpdateRollbackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateChangeSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateChangeSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChangeSetInput>
    public typealias MOutput = OperationOutput<CreateChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChangeSetOutputError>
}

extension CreateChangeSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateChangeSetInput(capabilities: \(String(describing: capabilities)), changeSetName: \(String(describing: changeSetName)), changeSetType: \(String(describing: changeSetType)), clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), includeNestedStacks: \(String(describing: includeNestedStacks)), notificationARNs: \(String(describing: notificationARNs)), parameters: \(String(describing: parameters)), resourceTypes: \(String(describing: resourceTypes)), resourcesToImport: \(String(describing: resourcesToImport)), roleARN: \(String(describing: roleARN)), rollbackConfiguration: \(String(describing: rollbackConfiguration)), stackName: \(String(describing: stackName)), tags: \(String(describing: tags)), templateBody: \(String(describing: templateBody)), templateURL: \(String(describing: templateURL)), usePreviousTemplate: \(String(describing: usePreviousTemplate)))"}
}

extension CreateChangeSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Capabilities"))
            for (index0, capability0) in capabilities.enumerated() {
                try capabilitiesContainer.encode(capability0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let changeSetName = changeSetName {
            try container.encode(changeSetName, forKey: Key("ChangeSetName"))
        }
        if let changeSetType = changeSetType {
            try container.encode(changeSetType, forKey: Key("ChangeSetType"))
        }
        if let clientToken = clientToken {
            try container.encode(clientToken, forKey: Key("ClientToken"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let includeNestedStacks = includeNestedStacks {
            try container.encode(includeNestedStacks, forKey: Key("IncludeNestedStacks"))
        }
        if let notificationARNs = notificationARNs {
            var notificationARNsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("NotificationARNs"))
            for (index0, notificationarn0) in notificationARNs.enumerated() {
                try notificationARNsContainer.encode(notificationarn0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ResourceTypes"))
            for (index0, resourcetype0) in resourceTypes.enumerated() {
                try resourceTypesContainer.encode(resourcetype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let resourcesToImport = resourcesToImport {
            var resourcesToImportContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ResourcesToImport"))
            for (index0, resourcetoimport0) in resourcesToImport.enumerated() {
                try resourcesToImportContainer.encode(resourcetoimport0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let roleARN = roleARN {
            try container.encode(roleARN, forKey: Key("RoleARN"))
        }
        if let rollbackConfiguration = rollbackConfiguration {
            try container.encode(rollbackConfiguration, forKey: Key("RollbackConfiguration"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let templateBody = templateBody {
            try container.encode(templateBody, forKey: Key("TemplateBody"))
        }
        if let templateURL = templateURL {
            try container.encode(templateURL, forKey: Key("TemplateURL"))
        }
        if let usePreviousTemplate = usePreviousTemplate {
            try container.encode(usePreviousTemplate, forKey: Key("UsePreviousTemplate"))
        }
        try container.encode("CreateChangeSet", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct CreateChangeSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateChangeSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChangeSetInput>
    public typealias MOutput = OperationOutput<CreateChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChangeSetOutputError>
}

public struct CreateChangeSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateChangeSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChangeSetInput>
    public typealias MOutput = OperationOutput<CreateChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChangeSetOutputError>
}

/// <p>The input for the <a>CreateChangeSet</a> action.</p>
public struct CreateChangeSetInput: Equatable {
    /// <p>In some cases, you must explicitly acknowledge that your stack template contains certain
    ///          capabilities in order for AWS CloudFormation to create the stack.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CAPABILITY_IAM</code> and <code>CAPABILITY_NAMED_IAM</code>
    ///                </p>
    ///                <p>Some stack templates might include resources that can affect permissions in
    ///                your AWS account; for example, by creating new AWS Identity and Access Management
    ///                (IAM) users. For those stacks, you must explicitly acknowledge this by specifying one
    ///                of these capabilities.</p>
    ///                <p>The following IAM resources require you to specify either the
    ///                   <code>CAPABILITY_IAM</code> or <code>CAPABILITY_NAMED_IAM</code>
    ///                capability.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>If you have IAM resources, you can specify either capability. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If you have IAM resources with custom names, you <i>must</i>
    ///                      specify <code>CAPABILITY_NAMED_IAM</code>. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If you don't specify either of these capabilities, AWS CloudFormation returns an
    ///                         <code>InsufficientCapabilities</code> error.</p>
    ///                   </li>
    ///                </ul>
    ///                <p>If your stack template contains these resources, we recommend that you review
    ///                all permissions associated with them and edit their permissions if
    ///                necessary.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-accesskey.html">
    ///                         AWS::IAM::AccessKey</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html">
    ///                         AWS::IAM::Group</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html"> AWS::IAM::InstanceProfile</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-policy.html">
    ///                         AWS::IAM::Policy</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html">
    ///                         AWS::IAM::Role</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-user.html">
    ///                         AWS::IAM::User</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-addusertogroup.html"> AWS::IAM::UserToGroupAddition</a>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///                <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#capabilities">Acknowledging IAM
    ///                   Resources in AWS CloudFormation Templates</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CAPABILITY_AUTO_EXPAND</code>
    ///                </p>
    ///                <p>Some template contain macros. Macros perform custom processing on templates; this
    ///                can include simple actions like find-and-replace operations, all the way to extensive
    ///                transformations of entire templates. Because of this, users typically create a change
    ///                set from the processed template, so that they can review the changes resulting from
    ///                the macros before actually creating the stack. If your stack template contains one or
    ///                more macros, and you choose to create a stack directly from the processed template,
    ///                without first reviewing the resulting changes in a change set, you must acknowledge
    ///                this capability. This includes the <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/create-reusable-transform-function-snippets-and-add-to-your-template-with-aws-include-transform.html">AWS::Include</a> and <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/transform-aws-serverless.html">AWS::Serverless</a> transforms, which are macros hosted by AWS CloudFormation.</p>
    ///                <note>
    ///                   <p>This capacity does not apply to creating change sets, and specifying it when
    ///                   creating change sets has no effect.</p>
    ///                   <p>If you want to create
    ///                   a stack from a stack template that contains macros <i>and</i> nested
    ///                   stacks, you must create or update the stack directly from the template using the
    ///                      <a>CreateStack</a> or <a>UpdateStack</a> action, and
    ///                   specifying this capability.</p>
    ///                </note>
    ///                <p>For more information on macros, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-macros.html">Using AWS CloudFormation Macros to
    ///                   Perform Custom Processing on Templates</a>.</p>
    ///             </li>
    ///          </ul>
    public let capabilities: [Capability]?
    /// <p>The name of the change set. The name must be unique among all change sets that are
    ///          associated with the specified stack.</p>
    ///          <p>A change set name can contain only alphanumeric, case sensitive characters and
    ///          hyphens. It must start with an alphabetic character and cannot exceed 128
    ///          characters.</p>
    public let changeSetName: String?
    /// <p>The type of change set operation. To create a change set for a new stack, specify
    ///             <code>CREATE</code>. To create a change set for an existing stack, specify
    ///             <code>UPDATE</code>. To create a change set for an import operation, specify
    ///             <code>IMPORT</code>.</p>
    ///          <p>If you create a change set for a new stack, AWS Cloudformation creates a stack with a
    ///          unique stack ID, but no template or resources. The stack will be in the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-describing-stacks.html#d0e11995">
    ///                <code>REVIEW_IN_PROGRESS</code>
    ///             </a> state until you execute the change
    ///          set.</p>
    ///          <p>By default, AWS CloudFormation specifies <code>UPDATE</code>. You can't use the
    ///             <code>UPDATE</code> type to create a change set for a new stack or the
    ///             <code>CREATE</code> type to create a change set for an existing stack.</p>
    public let changeSetType: ChangeSetType?
    /// <p>A unique identifier for this <code>CreateChangeSet</code> request. Specify this token
    ///          if you plan to retry requests so that AWS CloudFormation knows that you're not attempting
    ///          to create another change set with the same name. You might retry
    ///             <code>CreateChangeSet</code> requests to ensure that AWS CloudFormation successfully
    ///          received them.</p>
    public let clientToken: String?
    /// <p>A description to help you identify this change set.</p>
    public let description: String?
    /// <p>Creates a change set for the all nested stacks specified in the template. The default
    ///          behavior of this action is set to <code>False</code>. To include nested sets in a change
    ///          set, specify <code>True</code>.</p>
    public let includeNestedStacks: Bool?
    /// <p>The Amazon Resource Names (ARNs) of Amazon Simple Notification Service (Amazon SNS)
    ///          topics that AWS CloudFormation associates with the stack. To remove all associated
    ///          notification topics, specify an empty list.</p>
    public let notificationARNs: [String]?
    /// <p>A list of <code>Parameter</code> structures that specify input parameters for the
    ///          change set. For more information, see the <a>Parameter</a> data type.</p>
    public let parameters: [Parameter]?
    /// <p>The template resource types that you have permissions to work with if you execute
    ///          this change set, such as <code>AWS::EC2::Instance</code>, <code>AWS::EC2::*</code>, or
    ///             <code>Custom::MyCustomInstance</code>.</p>
    ///          <p>If the list of resource types doesn't include a resource type that you're updating,
    ///          the stack update fails. By default, AWS CloudFormation grants permissions to all resource
    ///          types. AWS Identity and Access Management (IAM) uses this parameter for condition keys in
    ///          IAM policies for AWS CloudFormation. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html">Controlling Access with
    ///             AWS Identity and Access Management</a> in the AWS CloudFormation User
    ///          Guide.</p>
    public let resourceTypes: [String]?
    /// <p>The resources to import into your stack.</p>
    public let resourcesToImport: [ResourceToImport]?
    /// <p>The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role
    ///          that AWS CloudFormation assumes when executing the change set. AWS CloudFormation uses the
    ///          role's credentials to make calls on your behalf. AWS CloudFormation uses this role for all
    ///          future operations on the stack. As long as users have permission to operate on the stack,
    ///          AWS CloudFormation uses this role even if the users don't have permission to pass it.
    ///          Ensure that the role grants least privilege.</p>
    ///          <p>If you don't specify a value, AWS CloudFormation uses the role that was previously
    ///          associated with the stack. If no role is available, AWS CloudFormation uses a temporary
    ///          session that is generated from your user credentials.</p>
    public let roleARN: String?
    /// <p>The rollback triggers for AWS CloudFormation to monitor during stack creation and
    ///          updating operations, and for the specified monitoring period afterwards.</p>
    public let rollbackConfiguration: RollbackConfiguration?
    /// <p>The name or the unique ID of the stack for which you are creating a change set. AWS
    ///          CloudFormation generates the change set by comparing this stack's information with the
    ///          information that you submit, such as a modified template or different parameter input
    ///          values.</p>
    public let stackName: String?
    /// <p>Key-value pairs to associate with this stack. AWS CloudFormation also propagates
    ///          these tags to resources in the stack. You can specify a maximum of 50 tags.</p>
    public let tags: [Tag]?
    /// <p>A structure that contains the body of the revised template, with a minimum length of
    ///          1 byte and a maximum length of 51,200 bytes. AWS CloudFormation generates the change set by
    ///          comparing this template with the template of the stack that you specified.</p>
    ///          <p>Conditional: You must specify only <code>TemplateBody</code> or
    ///             <code>TemplateURL</code>.</p>
    public let templateBody: String?
    /// <p>The location of the file that contains the revised template. The URL must point to a
    ///          template (max size: 460,800 bytes) that is located in an S3 bucket or a Systems Manager
    ///          document. AWS CloudFormation generates the change set by comparing this template with the
    ///          stack that you specified.</p>
    ///          <p>Conditional: You must specify only <code>TemplateBody</code> or
    ///             <code>TemplateURL</code>.</p>
    public let templateURL: String?
    /// <p>Whether to reuse the template that is associated with the stack to create the change
    ///          set.</p>
    public let usePreviousTemplate: Bool?

    public init (
        capabilities: [Capability]? = nil,
        changeSetName: String? = nil,
        changeSetType: ChangeSetType? = nil,
        clientToken: String? = nil,
        description: String? = nil,
        includeNestedStacks: Bool? = nil,
        notificationARNs: [String]? = nil,
        parameters: [Parameter]? = nil,
        resourceTypes: [String]? = nil,
        resourcesToImport: [ResourceToImport]? = nil,
        roleARN: String? = nil,
        rollbackConfiguration: RollbackConfiguration? = nil,
        stackName: String? = nil,
        tags: [Tag]? = nil,
        templateBody: String? = nil,
        templateURL: String? = nil,
        usePreviousTemplate: Bool? = nil
    )
    {
        self.capabilities = capabilities
        self.changeSetName = changeSetName
        self.changeSetType = changeSetType
        self.clientToken = clientToken
        self.description = description
        self.includeNestedStacks = includeNestedStacks
        self.notificationARNs = notificationARNs
        self.parameters = parameters
        self.resourceTypes = resourceTypes
        self.resourcesToImport = resourcesToImport
        self.roleARN = roleARN
        self.rollbackConfiguration = rollbackConfiguration
        self.stackName = stackName
        self.tags = tags
        self.templateBody = templateBody
        self.templateURL = templateURL
        self.usePreviousTemplate = usePreviousTemplate
    }
}

extension CreateChangeSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateChangeSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientCapabilitiesException" : self = .insufficientCapabilitiesException(try InsufficientCapabilitiesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChangeSetOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case insufficientCapabilitiesException(InsufficientCapabilitiesException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChangeSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateChangeSetOutputResponse(id: \(String(describing: id)), stackId: \(String(describing: stackId)))"}
}

extension CreateChangeSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateChangeSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
            self.stackId = output.stackId
        } else {
            self.id = nil
            self.stackId = nil
        }
    }
}

/// <p>The output for the <a>CreateChangeSet</a> action.</p>
public struct CreateChangeSetOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the change set.</p>
    public let id: String?
    /// <p>The unique ID of the stack.</p>
    public let stackId: String?

    public init (
        id: String? = nil,
        stackId: String? = nil
    )
    {
        self.id = id
        self.stackId = stackId
    }
}

struct CreateChangeSetOutputResponseBody: Equatable {
    public let id: String?
    public let stackId: String?
}

extension CreateChangeSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateChangeSetResult"))
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

public struct CreateStackInputBodyMiddleware: Middleware {
    public let id: String = "CreateStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStackInput>
    public typealias MOutput = OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStackOutputError>
}

extension CreateStackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStackInput(capabilities: \(String(describing: capabilities)), clientRequestToken: \(String(describing: clientRequestToken)), disableRollback: \(String(describing: disableRollback)), enableTerminationProtection: \(String(describing: enableTerminationProtection)), notificationARNs: \(String(describing: notificationARNs)), onFailure: \(String(describing: onFailure)), parameters: \(String(describing: parameters)), resourceTypes: \(String(describing: resourceTypes)), roleARN: \(String(describing: roleARN)), rollbackConfiguration: \(String(describing: rollbackConfiguration)), stackName: \(String(describing: stackName)), stackPolicyBody: \(String(describing: stackPolicyBody)), stackPolicyURL: \(String(describing: stackPolicyURL)), tags: \(String(describing: tags)), templateBody: \(String(describing: templateBody)), templateURL: \(String(describing: templateURL)), timeoutInMinutes: \(String(describing: timeoutInMinutes)))"}
}

extension CreateStackInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Capabilities"))
            for (index0, capability0) in capabilities.enumerated() {
                try capabilitiesContainer.encode(capability0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let clientRequestToken = clientRequestToken {
            try container.encode(clientRequestToken, forKey: Key("ClientRequestToken"))
        }
        if let disableRollback = disableRollback {
            try container.encode(disableRollback, forKey: Key("DisableRollback"))
        }
        if let enableTerminationProtection = enableTerminationProtection {
            try container.encode(enableTerminationProtection, forKey: Key("EnableTerminationProtection"))
        }
        if let notificationARNs = notificationARNs {
            var notificationARNsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("NotificationARNs"))
            for (index0, notificationarn0) in notificationARNs.enumerated() {
                try notificationARNsContainer.encode(notificationarn0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let onFailure = onFailure {
            try container.encode(onFailure, forKey: Key("OnFailure"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ResourceTypes"))
            for (index0, resourcetype0) in resourceTypes.enumerated() {
                try resourceTypesContainer.encode(resourcetype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let roleARN = roleARN {
            try container.encode(roleARN, forKey: Key("RoleARN"))
        }
        if let rollbackConfiguration = rollbackConfiguration {
            try container.encode(rollbackConfiguration, forKey: Key("RollbackConfiguration"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        if let stackPolicyBody = stackPolicyBody {
            try container.encode(stackPolicyBody, forKey: Key("StackPolicyBody"))
        }
        if let stackPolicyURL = stackPolicyURL {
            try container.encode(stackPolicyURL, forKey: Key("StackPolicyURL"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let templateBody = templateBody {
            try container.encode(templateBody, forKey: Key("TemplateBody"))
        }
        if let templateURL = templateURL {
            try container.encode(templateURL, forKey: Key("TemplateURL"))
        }
        if let timeoutInMinutes = timeoutInMinutes {
            try container.encode(timeoutInMinutes, forKey: Key("TimeoutInMinutes"))
        }
        try container.encode("CreateStack", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct CreateStackInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStackInput>
    public typealias MOutput = OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStackOutputError>
}

public struct CreateStackInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStackInput>
    public typealias MOutput = OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStackOutputError>
}

/// <p>The input for <a>CreateStack</a> action.</p>
public struct CreateStackInput: Equatable {
    /// <p>In some cases, you must explicitly acknowledge that your stack template contains certain
    ///          capabilities in order for AWS CloudFormation to create the stack.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CAPABILITY_IAM</code> and <code>CAPABILITY_NAMED_IAM</code>
    ///                </p>
    ///                <p>Some stack templates might include resources that can affect permissions in
    ///                your AWS account; for example, by creating new AWS Identity and Access Management
    ///                (IAM) users. For those stacks, you must explicitly acknowledge this by specifying one
    ///                of these capabilities.</p>
    ///                <p>The following IAM resources require you to specify either the
    ///                   <code>CAPABILITY_IAM</code> or <code>CAPABILITY_NAMED_IAM</code>
    ///                capability.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>If you have IAM resources, you can specify either capability. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If you have IAM resources with custom names, you <i>must</i>
    ///                      specify <code>CAPABILITY_NAMED_IAM</code>. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If you don't specify either of these capabilities, AWS CloudFormation returns an
    ///                         <code>InsufficientCapabilities</code> error.</p>
    ///                   </li>
    ///                </ul>
    ///                <p>If your stack template contains these resources, we recommend that you review
    ///                all permissions associated with them and edit their permissions if
    ///                necessary.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-accesskey.html">
    ///                         AWS::IAM::AccessKey</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html">
    ///                         AWS::IAM::Group</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html"> AWS::IAM::InstanceProfile</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-policy.html">
    ///                         AWS::IAM::Policy</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html">
    ///                         AWS::IAM::Role</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-user.html">
    ///                         AWS::IAM::User</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-addusertogroup.html"> AWS::IAM::UserToGroupAddition</a>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///                <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#capabilities">Acknowledging IAM
    ///                   Resources in AWS CloudFormation Templates</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CAPABILITY_AUTO_EXPAND</code>
    ///                </p>
    ///                <p>Some template contain macros. Macros perform custom processing on templates; this
    ///                can include simple actions like find-and-replace operations, all the way to extensive
    ///                transformations of entire templates. Because of this, users typically create a change
    ///                set from the processed template, so that they can review the changes resulting from
    ///                the macros before actually creating the stack. If your stack template contains one or
    ///                more macros, and you choose to create a stack directly from the processed template,
    ///                without first reviewing the resulting changes in a change set, you must acknowledge
    ///                this capability. This includes the <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/create-reusable-transform-function-snippets-and-add-to-your-template-with-aws-include-transform.html">AWS::Include</a> and <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/transform-aws-serverless.html">AWS::Serverless</a> transforms, which are macros hosted by AWS CloudFormation.</p>
    ///                <p>If you want to create a stack
    ///                from a stack template that contains macros <i>and</i> nested stacks,
    ///                you must create the stack directly from the template using this capability.</p>
    ///                <important>
    ///                   <p>You should only create stacks directly from a stack template that contains
    ///                   macros if you know what processing the macro performs.</p>
    ///                   <p>Each macro relies on an underlying Lambda service function for processing stack
    ///                   templates. Be aware that the Lambda function owner can update the function
    ///                   operation without AWS CloudFormation being notified.</p>
    ///                </important>
    ///                <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-macros.html">Using
    ///                   AWS CloudFormation Macros to Perform Custom Processing on
    ///                Templates</a>.</p>
    ///             </li>
    ///          </ul>
    public let capabilities: [Capability]?
    /// <p>A unique identifier for this <code>CreateStack</code> request. Specify this token if
    ///          you plan to retry requests so that AWS CloudFormation knows that you're not attempting to
    ///          create a stack with the same name. You might retry <code>CreateStack</code> requests to
    ///          ensure that AWS CloudFormation successfully received them.</p>
    ///          <p>All events triggered by a given stack operation are assigned the same client request
    ///          token, which you can use to track operations. For example, if you execute a
    ///          <code>CreateStack</code> operation with the token <code>token1</code>, then all the
    ///          <code>StackEvents</code> generated by that operation will have
    ///          <code>ClientRequestToken</code> set as <code>token1</code>.</p>
    ///          <p>In the console, stack operations display the client request token on the Events tab.
    ///          Stack operations that are initiated from the console use the token format
    ///          <i>Console-StackOperation-ID</i>, which helps you easily identify the
    ///          stack operation . For example, if you create a stack using the console, each stack event
    ///          would be assigned the same token in the following format:
    ///          <code>Console-CreateStack-7f59c3cf-00d2-40c7-b2ff-e75db0987002</code>. </p>
    public let clientRequestToken: String?
    /// <p>Set to <code>true</code> to disable rollback of the stack if stack creation failed.
    ///          You can specify either <code>DisableRollback</code> or <code>OnFailure</code>, but not
    ///          both.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let disableRollback: Bool?
    /// <p>Whether to enable termination protection on the specified stack. If a user attempts
    ///          to delete a stack with termination protection enabled, the operation fails and the stack
    ///          remains unchanged. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-protect-stacks.html">Protecting a Stack From Being
    ///             Deleted</a> in the <i>AWS CloudFormation User Guide</i>. Termination protection is
    ///          disabled on stacks by default. </p>
    ///          <p> For <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">nested stacks</a>,
    ///          termination protection is set on the root stack and cannot be changed directly on the
    ///          nested stack.</p>
    public let enableTerminationProtection: Bool?
    /// <p>The Simple Notification Service (SNS) topic ARNs to publish stack related events. You
    ///          can find your SNS topic ARNs using the SNS console or your Command Line Interface
    ///          (CLI).</p>
    public let notificationARNs: [String]?
    /// <p>Determines what action will be taken if stack creation fails. This must be one of:
    ///          DO_NOTHING, ROLLBACK, or DELETE. You can specify either <code>OnFailure</code> or
    ///             <code>DisableRollback</code>, but not both.</p>
    ///          <p>Default: <code>ROLLBACK</code>
    ///          </p>
    public let onFailure: OnFailure?
    /// <p>A list of <code>Parameter</code> structures that specify input parameters for the
    ///          stack. For more information, see the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_Parameter.html">Parameter</a> data
    ///          type.</p>
    public let parameters: [Parameter]?
    /// <p>The template resource types that you have permissions to work with for this create
    ///          stack action, such as <code>AWS::EC2::Instance</code>, <code>AWS::EC2::*</code>, or
    ///             <code>Custom::MyCustomInstance</code>. Use the following syntax to describe template
    ///          resource types: <code>AWS::*</code> (for all AWS resource), <code>Custom::*</code> (for all
    ///          custom resources), <code>Custom::<i>logical_ID</i>
    ///             </code> (for a specific custom resource),
    ///             <code>AWS::<i>service_name</i>::*</code> (for all resources of a
    ///          particular AWS service), and
    ///                <code>AWS::<i>service_name</i>::<i>resource_logical_ID</i>
    ///             </code> (for a specific AWS resource).</p>
    ///          <p>If the list of resource types doesn't include a resource that you're creating, the
    ///          stack creation fails. By default, AWS CloudFormation grants permissions to all resource
    ///          types. AWS Identity and Access Management (IAM) uses this parameter for AWS
    ///          CloudFormation-specific condition keys in IAM policies. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html">Controlling Access with AWS Identity and Access Management</a>.</p>
    public let resourceTypes: [String]?
    /// <p>The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role
    ///          that AWS CloudFormation assumes to create the stack. AWS CloudFormation uses the role's
    ///          credentials to make calls on your behalf. AWS CloudFormation always uses this role for all
    ///          future operations on the stack. As long as users have permission to operate on the stack,
    ///          AWS CloudFormation uses this role even if the users don't have permission to pass it.
    ///          Ensure that the role grants least privilege.</p>
    ///          <p>If you don't specify a value, AWS CloudFormation uses the role that was previously
    ///          associated with the stack. If no role is available, AWS CloudFormation uses a temporary
    ///          session that is generated from your user credentials.</p>
    public let roleARN: String?
    /// <p>The rollback triggers for AWS CloudFormation to monitor during stack creation and
    ///          updating operations, and for the specified monitoring period afterwards.</p>
    public let rollbackConfiguration: RollbackConfiguration?
    /// <p>The name that is associated with the stack. The name must be unique in the Region in
    ///          which you are creating the stack.</p>
    ///          <note>
    ///             <p>A stack name can contain only alphanumeric characters (case sensitive) and
    ///             hyphens. It must start with an alphabetic character and cannot be longer than 128
    ///             characters.</p>
    ///          </note>
    public let stackName: String?
    /// <p>Structure containing the stack policy body. For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/protect-stack-resources.html"> Prevent Updates
    ///             to Stack Resources</a> in the <i>AWS CloudFormation User Guide</i>.
    ///          You can specify either the <code>StackPolicyBody</code> or the <code>StackPolicyURL</code>
    ///          parameter, but not both.</p>
    public let stackPolicyBody: String?
    /// <p>Location of a file containing the stack policy. The URL must point to a policy
    ///          (maximum size: 16 KB) located in an S3 bucket in the same
    ///          Region as the stack. You can specify either the <code>StackPolicyBody</code> or the
    ///             <code>StackPolicyURL</code> parameter, but not both.</p>
    public let stackPolicyURL: String?
    /// <p>Key-value pairs to associate with this stack. AWS CloudFormation also propagates
    ///          these tags to the resources created in the stack. A maximum number of 50 tags can be
    ///          specified.</p>
    public let tags: [Tag]?
    /// <p>Structure containing the template body with a minimum length of 1 byte and a maximum
    ///          length of 51,200 bytes. For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html">Template Anatomy</a>
    ///          in the AWS CloudFormation User Guide.</p>
    ///          <p>Conditional: You must specify either the <code>TemplateBody</code> or the
    ///             <code>TemplateURL</code> parameter, but not both.</p>
    public let templateBody: String?
    /// <p>Location of file containing the template body. The URL must point to a template (max
    ///          size: 460,800 bytes) that is located in an Amazon S3 bucket or a Systems Manager document.
    ///          For more information, go to the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html">Template Anatomy</a>
    ///          in the AWS CloudFormation User Guide.</p>
    ///          <p>Conditional: You must specify either the <code>TemplateBody</code> or the
    ///             <code>TemplateURL</code> parameter, but not both.</p>
    public let templateURL: String?
    /// <p>The amount of time that can pass before the stack status becomes CREATE_FAILED; if
    ///             <code>DisableRollback</code> is not set or is set to <code>false</code>, the stack will
    ///          be rolled back.</p>
    public let timeoutInMinutes: Int?

    public init (
        capabilities: [Capability]? = nil,
        clientRequestToken: String? = nil,
        disableRollback: Bool? = nil,
        enableTerminationProtection: Bool? = nil,
        notificationARNs: [String]? = nil,
        onFailure: OnFailure? = nil,
        parameters: [Parameter]? = nil,
        resourceTypes: [String]? = nil,
        roleARN: String? = nil,
        rollbackConfiguration: RollbackConfiguration? = nil,
        stackName: String? = nil,
        stackPolicyBody: String? = nil,
        stackPolicyURL: String? = nil,
        tags: [Tag]? = nil,
        templateBody: String? = nil,
        templateURL: String? = nil,
        timeoutInMinutes: Int? = nil
    )
    {
        self.capabilities = capabilities
        self.clientRequestToken = clientRequestToken
        self.disableRollback = disableRollback
        self.enableTerminationProtection = enableTerminationProtection
        self.notificationARNs = notificationARNs
        self.onFailure = onFailure
        self.parameters = parameters
        self.resourceTypes = resourceTypes
        self.roleARN = roleARN
        self.rollbackConfiguration = rollbackConfiguration
        self.stackName = stackName
        self.stackPolicyBody = stackPolicyBody
        self.stackPolicyURL = stackPolicyURL
        self.tags = tags
        self.templateBody = templateBody
        self.templateURL = templateURL
        self.timeoutInMinutes = timeoutInMinutes
    }
}

public struct CreateStackInstancesInputBodyMiddleware: Middleware {
    public let id: String = "CreateStackInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStackInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStackInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStackInstancesInput>
    public typealias MOutput = OperationOutput<CreateStackInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStackInstancesOutputError>
}

extension CreateStackInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStackInstancesInput(accounts: \(String(describing: accounts)), callAs: \(String(describing: callAs)), deploymentTargets: \(String(describing: deploymentTargets)), operationId: \(String(describing: operationId)), operationPreferences: \(String(describing: operationPreferences)), parameterOverrides: \(String(describing: parameterOverrides)), regions: \(String(describing: regions)), stackSetName: \(String(describing: stackSetName)))"}
}

extension CreateStackInstancesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accounts = accounts {
            var accountsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Accounts"))
            for (index0, account0) in accounts.enumerated() {
                try accountsContainer.encode(account0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let callAs = callAs {
            try container.encode(callAs, forKey: Key("CallAs"))
        }
        if let deploymentTargets = deploymentTargets {
            try container.encode(deploymentTargets, forKey: Key("DeploymentTargets"))
        }
        if let operationId = operationId {
            try container.encode(operationId, forKey: Key("OperationId"))
        }
        if let operationPreferences = operationPreferences {
            try container.encode(operationPreferences, forKey: Key("OperationPreferences"))
        }
        if let parameterOverrides = parameterOverrides {
            var parameterOverridesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ParameterOverrides"))
            for (index0, parameter0) in parameterOverrides.enumerated() {
                try parameterOverridesContainer.encode(parameter0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let regions = regions {
            var regionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Regions"))
            for (index0, region0) in regions.enumerated() {
                try regionsContainer.encode(region0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        try container.encode("CreateStackInstances", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct CreateStackInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStackInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStackInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStackInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStackInstancesInput>
    public typealias MOutput = OperationOutput<CreateStackInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStackInstancesOutputError>
}

public struct CreateStackInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStackInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStackInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStackInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStackInstancesInput>
    public typealias MOutput = OperationOutput<CreateStackInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStackInstancesOutputError>
}

public struct CreateStackInstancesInput: Equatable {
    /// <p>[Self-managed permissions] The names of one or more AWS accounts that you want to create stack instances in the
    ///          specified Region(s) for.</p>
    ///          <p>You can specify <code>Accounts</code> or <code>DeploymentTargets</code>, but not both.</p>
    public let accounts: [String]?
    /// <p>[Service-managed permissions] Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account.</p>
    ///          <p>By default, <code>SELF</code> is specified. Use <code>SELF</code> for stack sets with self-managed permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you are signed in to the management account, specify <code>SELF</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you are signed in to a delegated administrator account, specify <code>DELEGATED_ADMIN</code>.</p>
    ///                <p>Your AWS account must be registered as a delegated administrator in the management account. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-orgs-delegated-admin.html">Register a delegated administrator</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let callAs: CallAs?
    /// <p>[Service-managed permissions] The AWS Organizations accounts for which to create stack instances in the specified Regions.</p>
    ///          <p>You can specify <code>Accounts</code> or <code>DeploymentTargets</code>, but not both.</p>
    public let deploymentTargets: DeploymentTargets?
    /// <p>The unique identifier for this stack set operation. </p>
    ///          <p>The operation ID also functions as an idempotency token, to ensure that AWS
    ///          CloudFormation performs the stack set operation only once, even if you retry the request
    ///          multiple times. You might retry stack set operation requests to ensure that AWS
    ///          CloudFormation successfully received them.</p>
    ///          <p>If you don't specify an operation ID, the SDK generates one automatically. </p>
    ///          <p>Repeating this stack set operation with a new operation ID retries all stack
    ///          instances whose status is <code>OUTDATED</code>. </p>
    public var operationId: String?
    /// <p>Preferences for how AWS CloudFormation performs this stack set operation.</p>
    public let operationPreferences: StackSetOperationPreferences?
    /// <p>A list of stack set parameters whose values you want to override in the selected
    ///          stack instances.</p>
    ///          <p>Any overridden parameter values will be applied to all stack instances in the
    ///          specified accounts and Regions. When specifying parameters and their values, be aware of
    ///          how AWS CloudFormation sets parameter values during stack instance operations:</p>
    ///          <ul>
    ///             <li>
    ///                <p>To override the current value for a parameter, include the parameter and
    ///                specify its value.</p>
    ///             </li>
    ///             <li>
    ///                <p>To leave a parameter set to its present value, you can do one of the
    ///                following:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>Do not include the parameter in the list.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Include the parameter and specify <code>UsePreviousValue</code> as
    ///                         <code>true</code>. (You cannot specify both a value and set
    ///                         <code>UsePreviousValue</code> to <code>true</code>.)</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>To set all overridden parameter back to the values specified in the stack set,
    ///                specify a parameter list but do not include any parameters.</p>
    ///             </li>
    ///             <li>
    ///                <p>To leave all parameters set to their present values, do not specify this
    ///                property at all.</p>
    ///             </li>
    ///          </ul>
    ///          <p>During stack set updates, any parameter values overridden for a stack instance are
    ///          not updated, but retain their overridden value.</p>
    ///          <p>You can only override the parameter <i>values</i> that are specified in
    ///          the stack set; to add or delete a parameter itself, use <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_UpdateStackSet.html">UpdateStackSet</a> to update the stack set template.</p>
    public let parameterOverrides: [Parameter]?
    /// <p>The names of one or more Regions where you want to create stack instances using the
    ///          specified AWS account(s). </p>
    public let regions: [String]?
    /// <p>The name or unique ID of the stack set that you want to create stack instances
    ///          from.</p>
    public let stackSetName: String?

    public init (
        accounts: [String]? = nil,
        callAs: CallAs? = nil,
        deploymentTargets: DeploymentTargets? = nil,
        operationId: String? = nil,
        operationPreferences: StackSetOperationPreferences? = nil,
        parameterOverrides: [Parameter]? = nil,
        regions: [String]? = nil,
        stackSetName: String? = nil
    )
    {
        self.accounts = accounts
        self.callAs = callAs
        self.deploymentTargets = deploymentTargets
        self.operationId = operationId
        self.operationPreferences = operationPreferences
        self.parameterOverrides = parameterOverrides
        self.regions = regions
        self.stackSetName = stackSetName
    }
}

extension CreateStackInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateStackInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationIdAlreadyExistsException" : self = .operationIdAlreadyExistsException(try OperationIdAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StackSetNotFoundException" : self = .stackSetNotFoundException(try StackSetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StaleRequestException" : self = .staleRequestException(try StaleRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStackInstancesOutputError: Equatable {
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case operationIdAlreadyExistsException(OperationIdAlreadyExistsException)
    case operationInProgressException(OperationInProgressException)
    case stackSetNotFoundException(StackSetNotFoundException)
    case staleRequestException(StaleRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStackInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStackInstancesOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension CreateStackInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateStackInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct CreateStackInstancesOutputResponse: Equatable {
    /// <p>The unique identifier for this stack set operation.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct CreateStackInstancesOutputResponseBody: Equatable {
    public let operationId: String?
}

extension CreateStackInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateStackInstancesResult"))
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension CreateStackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateStackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientCapabilitiesException" : self = .insufficientCapabilitiesException(try InsufficientCapabilitiesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TokenAlreadyExistsException" : self = .tokenAlreadyExistsException(try TokenAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStackOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case insufficientCapabilitiesException(InsufficientCapabilitiesException)
    case limitExceededException(LimitExceededException)
    case tokenAlreadyExistsException(TokenAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStackOutputResponse(stackId: \(String(describing: stackId)))"}
}

extension CreateStackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateStackOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stackId = output.stackId
        } else {
            self.stackId = nil
        }
    }
}

/// <p>The output for a <a>CreateStack</a> action.</p>
public struct CreateStackOutputResponse: Equatable {
    /// <p>Unique identifier of the stack.</p>
    public let stackId: String?

    public init (
        stackId: String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct CreateStackOutputResponseBody: Equatable {
    public let stackId: String?
}

extension CreateStackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateStackResult"))
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

public struct CreateStackSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateStackSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStackSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStackSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStackSetInput>
    public typealias MOutput = OperationOutput<CreateStackSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStackSetOutputError>
}

extension CreateStackSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStackSetInput(administrationRoleARN: \(String(describing: administrationRoleARN)), autoDeployment: \(String(describing: autoDeployment)), callAs: \(String(describing: callAs)), capabilities: \(String(describing: capabilities)), clientRequestToken: \(String(describing: clientRequestToken)), description: \(String(describing: description)), executionRoleName: \(String(describing: executionRoleName)), parameters: \(String(describing: parameters)), permissionModel: \(String(describing: permissionModel)), stackSetName: \(String(describing: stackSetName)), tags: \(String(describing: tags)), templateBody: \(String(describing: templateBody)), templateURL: \(String(describing: templateURL)))"}
}

extension CreateStackSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let administrationRoleARN = administrationRoleARN {
            try container.encode(administrationRoleARN, forKey: Key("AdministrationRoleARN"))
        }
        if let autoDeployment = autoDeployment {
            try container.encode(autoDeployment, forKey: Key("AutoDeployment"))
        }
        if let callAs = callAs {
            try container.encode(callAs, forKey: Key("CallAs"))
        }
        if let capabilities = capabilities {
            var capabilitiesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Capabilities"))
            for (index0, capability0) in capabilities.enumerated() {
                try capabilitiesContainer.encode(capability0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let clientRequestToken = clientRequestToken {
            try container.encode(clientRequestToken, forKey: Key("ClientRequestToken"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let executionRoleName = executionRoleName {
            try container.encode(executionRoleName, forKey: Key("ExecutionRoleName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let permissionModel = permissionModel {
            try container.encode(permissionModel, forKey: Key("PermissionModel"))
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let templateBody = templateBody {
            try container.encode(templateBody, forKey: Key("TemplateBody"))
        }
        if let templateURL = templateURL {
            try container.encode(templateURL, forKey: Key("TemplateURL"))
        }
        try container.encode("CreateStackSet", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct CreateStackSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStackSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStackSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStackSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStackSetInput>
    public typealias MOutput = OperationOutput<CreateStackSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStackSetOutputError>
}

public struct CreateStackSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStackSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStackSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStackSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStackSetInput>
    public typealias MOutput = OperationOutput<CreateStackSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStackSetOutputError>
}

public struct CreateStackSetInput: Equatable {
    /// <p>The Amazon Resource Number (ARN) of the IAM role to use to create this stack set. </p>
    ///          <p>Specify an IAM role only if you are using customized administrator roles to control
    ///          which users or groups can manage specific stack sets within the same administrator account.
    ///          For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs.html">Prerequisites:
    ///             Granting Permissions for Stack Set Operations</a> in the
    ///             <i>AWS CloudFormation User Guide</i>.</p>
    public let administrationRoleARN: String?
    /// <p>Describes whether StackSets automatically deploys to AWS Organizations accounts that are added to the target organization or organizational unit (OU). Specify only if <code>PermissionModel</code> is <code>SERVICE_MANAGED</code>.</p>
    public let autoDeployment: AutoDeployment?
    /// <p>[Service-managed permissions] Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account.</p>
    ///          <p>By default, <code>SELF</code> is specified. Use <code>SELF</code> for stack sets with self-managed permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>To create a stack set with service-managed permissions while signed in to the management account, specify <code>SELF</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To create a stack set with service-managed permissions while signed in to a delegated administrator account, specify <code>DELEGATED_ADMIN</code>.</p>
    ///                <p>Your AWS account must be registered as a delegated admin in the management account. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-orgs-delegated-admin.html">Register a delegated administrator</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Stack sets with service-managed permissions are created in the management account, including stack sets that are created by delegated administrators.</p>
    public let callAs: CallAs?
    /// <p>In some cases, you must explicitly acknowledge that your stack set template contains
    ///          certain capabilities in order for AWS CloudFormation to create the stack set and related stack
    ///          instances.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CAPABILITY_IAM</code> and <code>CAPABILITY_NAMED_IAM</code>
    ///                </p>
    ///                <p>Some stack templates might include resources that can affect permissions in
    ///                your AWS account; for example, by creating new AWS Identity and Access Management
    ///                (IAM) users. For those stack sets, you must explicitly acknowledge this by specifying
    ///                one of these capabilities.</p>
    ///                <p>The following IAM resources require you to specify either the
    ///                   <code>CAPABILITY_IAM</code> or <code>CAPABILITY_NAMED_IAM</code>
    ///                capability.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>If you have IAM resources, you can specify either capability. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If you have IAM resources with custom names, you <i>must</i>
    ///                      specify <code>CAPABILITY_NAMED_IAM</code>. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If you don't specify either of these capabilities, AWS CloudFormation returns an
    ///                         <code>InsufficientCapabilities</code> error.</p>
    ///                   </li>
    ///                </ul>
    ///                <p>If your stack template contains these resources, we recommend that you review
    ///                all permissions associated with them and edit their permissions if
    ///                necessary.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-accesskey.html">
    ///                         AWS::IAM::AccessKey</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html">
    ///                         AWS::IAM::Group</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html"> AWS::IAM::InstanceProfile</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-policy.html">
    ///                         AWS::IAM::Policy</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html">
    ///                         AWS::IAM::Role</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-user.html">
    ///                         AWS::IAM::User</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-addusertogroup.html"> AWS::IAM::UserToGroupAddition</a>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///                <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#capabilities">Acknowledging IAM
    ///                   Resources in AWS CloudFormation Templates</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CAPABILITY_AUTO_EXPAND</code>
    ///                </p>
    ///                <p>Some templates reference macros. If your stack set template references one or more macros,
    ///                you must create the stack set directly from the processed template, without first
    ///                reviewing the resulting changes in a change set. To create the stack set directly, you must acknowledge this
    ///                capability. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-macros.html">Using AWS CloudFormation Macros to Perform Custom Processing on
    ///                Templates</a>.</p>
    ///                <important>
    ///                   <p>Stack sets with service-managed permissions
    ///                      do not currently support the use of macros in templates. (This includes
    ///                      the <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/create-reusable-transform-function-snippets-and-add-to-your-template-with-aws-include-transform.html">AWS::Include</a> and <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/transform-aws-serverless.html">AWS::Serverless</a>
    ///                      transforms, which are macros hosted by AWS CloudFormation.) Even if you specify this
    ///                      capability for a stack set with service-managed permissions, if you reference a macro in your template the stack set operation will
    ///                      fail.</p>
    ///                </important>
    ///             </li>
    ///          </ul>
    public let capabilities: [Capability]?
    /// <p>A unique identifier for this <code>CreateStackSet</code> request. Specify this token
    ///          if you plan to retry requests so that AWS CloudFormation knows that you're not attempting
    ///          to create another stack set with the same name. You might retry <code>CreateStackSet</code>
    ///          requests to ensure that AWS CloudFormation successfully received them.</p>
    ///          <p>If you don't specify an operation ID, the SDK generates one automatically.
    ///       </p>
    public var clientRequestToken: String?
    /// <p>A description of the stack set. You can use the description to identify the stack
    ///          set's purpose or other important information.</p>
    public let description: String?
    /// <p>The name of the IAM execution role to use to create the stack set. If you do not specify
    ///          an execution role, AWS CloudFormation uses the <code>AWSCloudFormationStackSetExecutionRole</code> role
    ///          for the stack set operation.</p>
    ///          <p>Specify an IAM role only if you are using customized execution roles to control which
    ///          stack resources users and groups can include in their stack sets.
    ///
    ///       </p>
    public let executionRoleName: String?
    /// <p>The input parameters for the stack set template. </p>
    public let parameters: [Parameter]?
    /// <p>Describes how the IAM roles required for stack set operations are created. By default, <code>SELF-MANAGED</code> is specified.</p>
    ///          <ul>
    ///             <li>
    ///                <p>With <code>self-managed</code> permissions, you must create the administrator and execution roles required to deploy to target accounts. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-self-managed.html">Grant Self-Managed Stack Set Permissions</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>With <code>service-managed</code> permissions, StackSets automatically creates the IAM roles required to deploy to accounts managed by AWS Organizations. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-service-managed.html">Grant Service-Managed Stack Set Permissions</a>.</p>
    ///             </li>
    ///          </ul>
    public let permissionModel: PermissionModels?
    /// <p>The name to associate with the stack set. The name must be unique in the Region where
    ///          you create your stack set.</p>
    ///          <note>
    ///             <p>A stack name can contain only alphanumeric characters (case-sensitive) and
    ///             hyphens. It must start with an alphabetic character and can't be longer than 128
    ///             characters.</p>
    ///          </note>
    public let stackSetName: String?
    /// <p>The key-value pairs to associate with this stack set and the stacks created from it.
    ///          AWS CloudFormation also propagates these tags to supported resources that are created in
    ///          the stacks. A maximum number of 50 tags can be specified.</p>
    ///          <p>If you specify tags as part of a <code>CreateStackSet</code> action, AWS
    ///          CloudFormation checks to see if you have the required IAM permission to tag resources. If
    ///          you don't, the entire <code>CreateStackSet</code> action fails with an <code>access
    ///             denied</code> error, and the stack set is not created.</p>
    public let tags: [Tag]?
    /// <p>The structure that contains the template body, with a minimum length of 1 byte and a
    ///          maximum length of 51,200 bytes. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html">Template Anatomy</a>
    ///          in the AWS CloudFormation User Guide.</p>
    ///          <p>Conditional: You must specify either the TemplateBody or the TemplateURL parameter,
    ///          but not both.</p>
    public let templateBody: String?
    /// <p>The location of the file that contains the template body. The URL must point to a
    ///          template (maximum size: 460,800 bytes) that's located in an Amazon S3 bucket or a Systems
    ///          Manager document. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html">Template Anatomy</a>
    ///          in the AWS CloudFormation User Guide.</p>
    ///          <p>Conditional: You must specify either the TemplateBody or the TemplateURL parameter,
    ///          but not both.</p>
    public let templateURL: String?

    public init (
        administrationRoleARN: String? = nil,
        autoDeployment: AutoDeployment? = nil,
        callAs: CallAs? = nil,
        capabilities: [Capability]? = nil,
        clientRequestToken: String? = nil,
        description: String? = nil,
        executionRoleName: String? = nil,
        parameters: [Parameter]? = nil,
        permissionModel: PermissionModels? = nil,
        stackSetName: String? = nil,
        tags: [Tag]? = nil,
        templateBody: String? = nil,
        templateURL: String? = nil
    )
    {
        self.administrationRoleARN = administrationRoleARN
        self.autoDeployment = autoDeployment
        self.callAs = callAs
        self.capabilities = capabilities
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.executionRoleName = executionRoleName
        self.parameters = parameters
        self.permissionModel = permissionModel
        self.stackSetName = stackSetName
        self.tags = tags
        self.templateBody = templateBody
        self.templateURL = templateURL
    }
}

extension CreateStackSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateStackSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CreatedButModifiedException" : self = .createdButModifiedException(try CreatedButModifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAlreadyExistsException" : self = .nameAlreadyExistsException(try NameAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStackSetOutputError: Equatable {
    case createdButModifiedException(CreatedButModifiedException)
    case limitExceededException(LimitExceededException)
    case nameAlreadyExistsException(NameAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStackSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStackSetOutputResponse(stackSetId: \(String(describing: stackSetId)))"}
}

extension CreateStackSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateStackSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stackSetId = output.stackSetId
        } else {
            self.stackSetId = nil
        }
    }
}

public struct CreateStackSetOutputResponse: Equatable {
    /// <p>The ID of the stack set that you're creating.</p>
    public let stackSetId: String?

    public init (
        stackSetId: String? = nil
    )
    {
        self.stackSetId = stackSetId
    }
}

struct CreateStackSetOutputResponseBody: Equatable {
    public let stackSetId: String?
}

extension CreateStackSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackSetId = "StackSetId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateStackSetResult"))
        let stackSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackSetId)
        stackSetId = stackSetIdDecoded
    }
}

extension CreatedButModifiedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatedButModifiedException(message: \(String(describing: message)))"}
}

extension CreatedButModifiedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CreatedButModifiedExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource exists, but has been changed.</p>
public struct CreatedButModifiedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CreatedButModifiedExceptionBody: Equatable {
    public let message: String?
}

extension CreatedButModifiedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteChangeSetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteChangeSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChangeSetInput>
    public typealias MOutput = OperationOutput<DeleteChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChangeSetOutputError>
}

extension DeleteChangeSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteChangeSetInput(changeSetName: \(String(describing: changeSetName)), stackName: \(String(describing: stackName)))"}
}

extension DeleteChangeSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let changeSetName = changeSetName {
            try container.encode(changeSetName, forKey: Key("ChangeSetName"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        try container.encode("DeleteChangeSet", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DeleteChangeSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteChangeSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChangeSetInput>
    public typealias MOutput = OperationOutput<DeleteChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChangeSetOutputError>
}

public struct DeleteChangeSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteChangeSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChangeSetInput>
    public typealias MOutput = OperationOutput<DeleteChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChangeSetOutputError>
}

/// <p>The input for the <a>DeleteChangeSet</a> action.</p>
public struct DeleteChangeSetInput: Equatable {
    /// <p>The name or Amazon Resource Name (ARN) of the change set that you want to
    ///          delete.</p>
    public let changeSetName: String?
    /// <p>If you specified the name of a change set to delete, specify the stack name or ID
    ///          (ARN) that is associated with it.</p>
    public let stackName: String?

    public init (
        changeSetName: String? = nil,
        stackName: String? = nil
    )
    {
        self.changeSetName = changeSetName
        self.stackName = stackName
    }
}

extension DeleteChangeSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteChangeSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidChangeSetStatusException" : self = .invalidChangeSetStatusException(try InvalidChangeSetStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChangeSetOutputError: Equatable {
    case invalidChangeSetStatusException(InvalidChangeSetStatusException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChangeSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteChangeSetOutputResponse()"}
}

extension DeleteChangeSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The output for the <a>DeleteChangeSet</a> action.</p>
public struct DeleteChangeSetOutputResponse: Equatable {

    public init() {}
}

struct DeleteChangeSetOutputResponseBody: Equatable {
}

extension DeleteChangeSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteStackInputBodyMiddleware: Middleware {
    public let id: String = "DeleteStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStackInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStackInput>
    public typealias MOutput = OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStackOutputError>
}

extension DeleteStackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStackInput(clientRequestToken: \(String(describing: clientRequestToken)), retainResources: \(String(describing: retainResources)), roleARN: \(String(describing: roleARN)), stackName: \(String(describing: stackName)))"}
}

extension DeleteStackInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clientRequestToken = clientRequestToken {
            try container.encode(clientRequestToken, forKey: Key("ClientRequestToken"))
        }
        if let retainResources = retainResources {
            var retainResourcesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("RetainResources"))
            for (index0, logicalresourceid0) in retainResources.enumerated() {
                try retainResourcesContainer.encode(logicalresourceid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let roleARN = roleARN {
            try container.encode(roleARN, forKey: Key("RoleARN"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        try container.encode("DeleteStack", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DeleteStackInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStackInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStackInput>
    public typealias MOutput = OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStackOutputError>
}

public struct DeleteStackInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStackInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStackInput>
    public typealias MOutput = OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStackOutputError>
}

/// <p>The input for <a>DeleteStack</a> action.</p>
public struct DeleteStackInput: Equatable {
    /// <p>A unique identifier for this <code>DeleteStack</code> request. Specify this token if
    ///          you plan to retry requests so that AWS CloudFormation knows that you're not attempting to
    ///          delete a stack with the same name. You might retry <code>DeleteStack</code> requests to
    ///          ensure that AWS CloudFormation successfully received them.</p>
    ///          <p>All events triggered by a given stack operation are assigned the same client request
    ///          token, which you can use to track operations. For example, if you execute a
    ///          <code>CreateStack</code> operation with the token <code>token1</code>, then all the
    ///          <code>StackEvents</code> generated by that operation will have
    ///          <code>ClientRequestToken</code> set as <code>token1</code>.</p>
    ///          <p>In the console, stack operations display the client request token on the Events tab.
    ///          Stack operations that are initiated from the console use the token format
    ///          <i>Console-StackOperation-ID</i>, which helps you easily identify the
    ///          stack operation . For example, if you create a stack using the console, each stack event
    ///          would be assigned the same token in the following format:
    ///          <code>Console-CreateStack-7f59c3cf-00d2-40c7-b2ff-e75db0987002</code>. </p>
    public let clientRequestToken: String?
    /// <p>For stacks in the <code>DELETE_FAILED</code> state, a list of resource logical IDs
    ///          that are associated with the resources you want to retain. During deletion, AWS
    ///          CloudFormation deletes the stack but does not delete the retained resources.</p>
    ///          <p>Retaining resources is useful when you cannot delete a resource, such as a non-empty
    ///          S3 bucket, but you want to delete the stack.</p>
    public let retainResources: [String]?
    /// <p>The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role
    ///          that AWS CloudFormation assumes to delete the stack. AWS CloudFormation uses the role's
    ///          credentials to make calls on your behalf.</p>
    ///          <p>If you don't specify a value, AWS CloudFormation uses the role that was previously
    ///          associated with the stack. If no role is available, AWS CloudFormation uses a temporary
    ///          session that is generated from your user credentials.</p>
    public let roleARN: String?
    /// <p>The name or the unique stack ID that is associated with the stack.</p>
    public let stackName: String?

    public init (
        clientRequestToken: String? = nil,
        retainResources: [String]? = nil,
        roleARN: String? = nil,
        stackName: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.retainResources = retainResources
        self.roleARN = roleARN
        self.stackName = stackName
    }
}

public struct DeleteStackInstancesInputBodyMiddleware: Middleware {
    public let id: String = "DeleteStackInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStackInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStackInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStackInstancesInput>
    public typealias MOutput = OperationOutput<DeleteStackInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStackInstancesOutputError>
}

extension DeleteStackInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStackInstancesInput(accounts: \(String(describing: accounts)), callAs: \(String(describing: callAs)), deploymentTargets: \(String(describing: deploymentTargets)), operationId: \(String(describing: operationId)), operationPreferences: \(String(describing: operationPreferences)), regions: \(String(describing: regions)), retainStacks: \(String(describing: retainStacks)), stackSetName: \(String(describing: stackSetName)))"}
}

extension DeleteStackInstancesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accounts = accounts {
            var accountsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Accounts"))
            for (index0, account0) in accounts.enumerated() {
                try accountsContainer.encode(account0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let callAs = callAs {
            try container.encode(callAs, forKey: Key("CallAs"))
        }
        if let deploymentTargets = deploymentTargets {
            try container.encode(deploymentTargets, forKey: Key("DeploymentTargets"))
        }
        if let operationId = operationId {
            try container.encode(operationId, forKey: Key("OperationId"))
        }
        if let operationPreferences = operationPreferences {
            try container.encode(operationPreferences, forKey: Key("OperationPreferences"))
        }
        if let regions = regions {
            var regionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Regions"))
            for (index0, region0) in regions.enumerated() {
                try regionsContainer.encode(region0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if retainStacks != false {
            try container.encode(retainStacks, forKey: Key("RetainStacks"))
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        try container.encode("DeleteStackInstances", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DeleteStackInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStackInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStackInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStackInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStackInstancesInput>
    public typealias MOutput = OperationOutput<DeleteStackInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStackInstancesOutputError>
}

public struct DeleteStackInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStackInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStackInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStackInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStackInstancesInput>
    public typealias MOutput = OperationOutput<DeleteStackInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStackInstancesOutputError>
}

public struct DeleteStackInstancesInput: Equatable {
    /// <p>[Self-managed permissions] The names of the AWS accounts that you want to delete stack instances for.</p>
    ///          <p>You can specify <code>Accounts</code> or <code>DeploymentTargets</code>, but not both.</p>
    public let accounts: [String]?
    /// <p>[Service-managed permissions] Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account.</p>
    ///          <p>By default, <code>SELF</code> is specified. Use <code>SELF</code> for stack sets with self-managed permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you are signed in to the management account, specify <code>SELF</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you are signed in to a delegated administrator account, specify <code>DELEGATED_ADMIN</code>.</p>
    ///                <p>Your AWS account must be registered as a delegated administrator in the management account. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-orgs-delegated-admin.html">Register a delegated administrator</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let callAs: CallAs?
    /// <p>[Service-managed permissions] The AWS Organizations accounts from which to delete stack instances.</p>
    ///          <p>You can specify <code>Accounts</code> or <code>DeploymentTargets</code>, but not both.</p>
    public let deploymentTargets: DeploymentTargets?
    /// <p>The unique identifier for this stack set operation. </p>
    ///          <p>If you don't specify an operation ID, the SDK generates one automatically. </p>
    ///          <p>The operation ID also functions as an idempotency token, to ensure that AWS
    ///          CloudFormation performs the stack set operation only once, even if you retry the request
    ///          multiple times. You can retry stack set operation requests to ensure that AWS
    ///          CloudFormation successfully received them.</p>
    ///          <p>Repeating this stack set operation with a new operation ID retries all stack
    ///          instances whose status is <code>OUTDATED</code>. </p>
    public var operationId: String?
    /// <p>Preferences for how AWS CloudFormation performs this stack set operation.</p>
    public let operationPreferences: StackSetOperationPreferences?
    /// <p>The Regions where you want to delete stack set instances. </p>
    public let regions: [String]?
    /// <p>Removes the stack instances from the specified stack set, but doesn't delete the
    ///          stacks. You can't reassociate a retained stack or add an existing, saved stack to a new
    ///          stack set.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-concepts.html#stackset-ops-options">Stack set operation options</a>.</p>
    public let retainStacks: Bool
    /// <p>The name or unique ID of the stack set that you want to delete stack instances
    ///          for.</p>
    public let stackSetName: String?

    public init (
        accounts: [String]? = nil,
        callAs: CallAs? = nil,
        deploymentTargets: DeploymentTargets? = nil,
        operationId: String? = nil,
        operationPreferences: StackSetOperationPreferences? = nil,
        regions: [String]? = nil,
        retainStacks: Bool = false,
        stackSetName: String? = nil
    )
    {
        self.accounts = accounts
        self.callAs = callAs
        self.deploymentTargets = deploymentTargets
        self.operationId = operationId
        self.operationPreferences = operationPreferences
        self.regions = regions
        self.retainStacks = retainStacks
        self.stackSetName = stackSetName
    }
}

extension DeleteStackInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteStackInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationIdAlreadyExistsException" : self = .operationIdAlreadyExistsException(try OperationIdAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StackSetNotFoundException" : self = .stackSetNotFoundException(try StackSetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StaleRequestException" : self = .staleRequestException(try StaleRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStackInstancesOutputError: Equatable {
    case invalidOperationException(InvalidOperationException)
    case operationIdAlreadyExistsException(OperationIdAlreadyExistsException)
    case operationInProgressException(OperationInProgressException)
    case stackSetNotFoundException(StackSetNotFoundException)
    case staleRequestException(StaleRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStackInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStackInstancesOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension DeleteStackInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteStackInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct DeleteStackInstancesOutputResponse: Equatable {
    /// <p>The unique identifier for this stack set operation.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct DeleteStackInstancesOutputResponseBody: Equatable {
    public let operationId: String?
}

extension DeleteStackInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DeleteStackInstancesResult"))
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension DeleteStackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteStackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "TokenAlreadyExistsException" : self = .tokenAlreadyExistsException(try TokenAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStackOutputError: Equatable {
    case tokenAlreadyExistsException(TokenAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStackOutputResponse()"}
}

extension DeleteStackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStackOutputResponse: Equatable {

    public init() {}
}

struct DeleteStackOutputResponseBody: Equatable {
}

extension DeleteStackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteStackSetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteStackSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStackSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStackSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStackSetInput>
    public typealias MOutput = OperationOutput<DeleteStackSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStackSetOutputError>
}

extension DeleteStackSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStackSetInput(callAs: \(String(describing: callAs)), stackSetName: \(String(describing: stackSetName)))"}
}

extension DeleteStackSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let callAs = callAs {
            try container.encode(callAs, forKey: Key("CallAs"))
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        try container.encode("DeleteStackSet", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DeleteStackSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStackSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStackSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStackSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStackSetInput>
    public typealias MOutput = OperationOutput<DeleteStackSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStackSetOutputError>
}

public struct DeleteStackSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStackSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStackSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStackSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStackSetInput>
    public typealias MOutput = OperationOutput<DeleteStackSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStackSetOutputError>
}

public struct DeleteStackSetInput: Equatable {
    /// <p>[Service-managed permissions] Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account.</p>
    ///          <p>By default, <code>SELF</code> is specified. Use <code>SELF</code> for stack sets with self-managed permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you are signed in to the management account, specify <code>SELF</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you are signed in to a delegated administrator account, specify <code>DELEGATED_ADMIN</code>.</p>
    ///                <p>Your AWS account must be registered as a delegated administrator in the management account. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-orgs-delegated-admin.html">Register a delegated administrator</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let callAs: CallAs?
    /// <p>The name or unique ID of the stack set that you're deleting. You can obtain this
    ///          value by running <a>ListStackSets</a>.</p>
    public let stackSetName: String?

    public init (
        callAs: CallAs? = nil,
        stackSetName: String? = nil
    )
    {
        self.callAs = callAs
        self.stackSetName = stackSetName
    }
}

extension DeleteStackSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteStackSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StackSetNotEmptyException" : self = .stackSetNotEmptyException(try StackSetNotEmptyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStackSetOutputError: Equatable {
    case operationInProgressException(OperationInProgressException)
    case stackSetNotEmptyException(StackSetNotEmptyException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStackSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStackSetOutputResponse()"}
}

extension DeleteStackSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStackSetOutputResponse: Equatable {

    public init() {}
}

struct DeleteStackSetOutputResponseBody: Equatable {
}

extension DeleteStackSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeploymentTargets: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accounts = "Accounts"
        case accountsUrl = "AccountsUrl"
        case organizationalUnitIds = "OrganizationalUnitIds"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accounts = accounts {
            var accountsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Accounts"))
            for (index0, account0) in accounts.enumerated() {
                try accountsContainer.encode(account0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let accountsUrl = accountsUrl {
            try container.encode(accountsUrl, forKey: Key("AccountsUrl"))
        }
        if let organizationalUnitIds = organizationalUnitIds {
            var organizationalUnitIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OrganizationalUnitIds"))
            for (index0, organizationalunitid0) in organizationalUnitIds.enumerated() {
                try organizationalUnitIdsContainer.encode(organizationalunitid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.accounts) {
            struct KeyVal0{struct member{}}
            let accountsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accounts)
            if let accountsWrappedContainer = accountsWrappedContainer {
                let accountsContainer = try accountsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var accountsBuffer:[String]? = nil
                if let accountsContainer = accountsContainer {
                    accountsBuffer = [String]()
                    for stringContainer0 in accountsContainer {
                        accountsBuffer?.append(stringContainer0)
                    }
                }
                accounts = accountsBuffer
            } else {
                accounts = []
            }
        } else {
            accounts = nil
        }
        let accountsUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountsUrl)
        accountsUrl = accountsUrlDecoded
        if containerValues.contains(.organizationalUnitIds) {
            struct KeyVal0{struct member{}}
            let organizationalUnitIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .organizationalUnitIds)
            if let organizationalUnitIdsWrappedContainer = organizationalUnitIdsWrappedContainer {
                let organizationalUnitIdsContainer = try organizationalUnitIdsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var organizationalUnitIdsBuffer:[String]? = nil
                if let organizationalUnitIdsContainer = organizationalUnitIdsContainer {
                    organizationalUnitIdsBuffer = [String]()
                    for stringContainer0 in organizationalUnitIdsContainer {
                        organizationalUnitIdsBuffer?.append(stringContainer0)
                    }
                }
                organizationalUnitIds = organizationalUnitIdsBuffer
            } else {
                organizationalUnitIds = []
            }
        } else {
            organizationalUnitIds = nil
        }
    }
}

extension DeploymentTargets: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeploymentTargets(accounts: \(String(describing: accounts)), accountsUrl: \(String(describing: accountsUrl)), organizationalUnitIds: \(String(describing: organizationalUnitIds)))"}
}

/// <p>[Service-managed permissions] The AWS Organizations accounts to which StackSets deploys. StackSets does not deploy stack instances to the organization management account, even if the organization management account is in your organization or in an OU in your organization.</p>
///          <p>For update operations, you can specify either <code>Accounts</code> or <code>OrganizationalUnitIds</code>. For create and delete operations, specify <code>OrganizationalUnitIds</code>.</p>
public struct DeploymentTargets: Equatable {
    /// <p>The names of one or more AWS accounts for which you want to deploy stack set updates.</p>
    public let accounts: [String]?
    /// <p>Returns the value of the AccountsUrl property.</p>
    public let accountsUrl: String?
    /// <p>The organization root ID or organizational unit (OU) IDs to which StackSets deploys.</p>
    public let organizationalUnitIds: [String]?

    public init (
        accounts: [String]? = nil,
        accountsUrl: String? = nil,
        organizationalUnitIds: [String]? = nil
    )
    {
        self.accounts = accounts
        self.accountsUrl = accountsUrl
        self.organizationalUnitIds = organizationalUnitIds
    }
}

public enum DeprecatedStatus {
    case deprecated
    case live
    case sdkUnknown(String)
}

extension DeprecatedStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeprecatedStatus] {
        return [
            .deprecated,
            .live,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deprecated: return "DEPRECATED"
        case .live: return "LIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeprecatedStatus(rawValue: rawValue) ?? DeprecatedStatus.sdkUnknown(rawValue)
    }
}

public struct DeregisterTypeInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterTypeInput>
    public typealias MOutput = OperationOutput<DeregisterTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterTypeOutputError>
}

extension DeregisterTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterTypeInput(arn: \(String(describing: arn)), type: \(String(describing: type)), typeName: \(String(describing: typeName)), versionId: \(String(describing: versionId)))"}
}

extension DeregisterTypeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
        if let typeName = typeName {
            try container.encode(typeName, forKey: Key("TypeName"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: Key("VersionId"))
        }
        try container.encode("DeregisterType", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DeregisterTypeInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterTypeInput>
    public typealias MOutput = OperationOutput<DeregisterTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterTypeOutputError>
}

public struct DeregisterTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterTypeInput>
    public typealias MOutput = OperationOutput<DeregisterTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterTypeOutputError>
}

public struct DeregisterTypeInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the extension.</p>
    ///          <p>Conditional: You must specify either <code>TypeName</code> and <code>Type</code>, or <code>Arn</code>.</p>
    public let arn: String?
    /// <p>The kind of extension.</p>
    ///          <p>Conditional: You must specify either <code>TypeName</code> and <code>Type</code>, or <code>Arn</code>.</p>
    public let type: RegistryType?
    /// <p>The name of the extension.</p>
    ///          <p>Conditional: You must specify either <code>TypeName</code> and <code>Type</code>, or <code>Arn</code>.</p>
    public let typeName: String?
    /// <p>The ID of a specific version of the extension. The version ID is the value at the end of the Amazon Resource Name (ARN) assigned to the extension version when it is registered.</p>
    public let versionId: String?

    public init (
        arn: String? = nil,
        type: RegistryType? = nil,
        typeName: String? = nil,
        versionId: String? = nil
    )
    {
        self.arn = arn
        self.type = type
        self.typeName = typeName
        self.versionId = versionId
    }
}

extension DeregisterTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeregisterTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CFNRegistryException" : self = .cFNRegistryException(try CFNRegistryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TypeNotFoundException" : self = .typeNotFoundException(try TypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterTypeOutputError: Equatable {
    case cFNRegistryException(CFNRegistryException)
    case typeNotFoundException(TypeNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterTypeOutputResponse()"}
}

extension DeregisterTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterTypeOutputResponse: Equatable {

    public init() {}
}

struct DeregisterTypeOutputResponseBody: Equatable {
}

extension DeregisterTypeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeAccountLimitsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAccountLimitsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountLimitsInput>
    public typealias MOutput = OperationOutput<DescribeAccountLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountLimitsOutputError>
}

extension DescribeAccountLimitsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountLimitsInput(nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAccountLimitsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("DescribeAccountLimits", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DescribeAccountLimitsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountLimitsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountLimitsInput>
    public typealias MOutput = OperationOutput<DescribeAccountLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountLimitsOutputError>
}

public struct DescribeAccountLimitsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountLimitsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountLimitsInput>
    public typealias MOutput = OperationOutput<DescribeAccountLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountLimitsOutputError>
}

/// <p>The input for the <a>DescribeAccountLimits</a> action.</p>
public struct DescribeAccountLimitsInput: Equatable {
    /// <p>A string that identifies the next page of limits that you want to retrieve.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension DescribeAccountLimitsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAccountLimitsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountLimitsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountLimitsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountLimitsOutputResponse(accountLimits: \(String(describing: accountLimits)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAccountLimitsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountLimitsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountLimits = output.accountLimits
            self.nextToken = output.nextToken
        } else {
            self.accountLimits = nil
            self.nextToken = nil
        }
    }
}

/// <p>The output for the <a>DescribeAccountLimits</a> action.</p>
public struct DescribeAccountLimitsOutputResponse: Equatable {
    /// <p>An account limit structure that contain a list of AWS CloudFormation account limits
    ///          and their values.</p>
    public let accountLimits: [AccountLimit]?
    /// <p>If the output exceeds 1 MB in size, a string that identifies the next page of limits.
    ///          If no additional page exists, this value is null.</p>
    public let nextToken: String?

    public init (
        accountLimits: [AccountLimit]? = nil,
        nextToken: String? = nil
    )
    {
        self.accountLimits = accountLimits
        self.nextToken = nextToken
    }
}

struct DescribeAccountLimitsOutputResponseBody: Equatable {
    public let accountLimits: [AccountLimit]?
    public let nextToken: String?
}

extension DescribeAccountLimitsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountLimits = "AccountLimits"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeAccountLimitsResult"))
        if containerValues.contains(.accountLimits) {
            struct KeyVal0{struct member{}}
            let accountLimitsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accountLimits)
            if let accountLimitsWrappedContainer = accountLimitsWrappedContainer {
                let accountLimitsContainer = try accountLimitsWrappedContainer.decodeIfPresent([AccountLimit].self, forKey: .member)
                var accountLimitsBuffer:[AccountLimit]? = nil
                if let accountLimitsContainer = accountLimitsContainer {
                    accountLimitsBuffer = [AccountLimit]()
                    for structureContainer0 in accountLimitsContainer {
                        accountLimitsBuffer?.append(structureContainer0)
                    }
                }
                accountLimits = accountLimitsBuffer
            } else {
                accountLimits = []
            }
        } else {
            accountLimits = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeChangeSetInputBodyMiddleware: Middleware {
    public let id: String = "DescribeChangeSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeChangeSetInput>
    public typealias MOutput = OperationOutput<DescribeChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeChangeSetOutputError>
}

extension DescribeChangeSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeChangeSetInput(changeSetName: \(String(describing: changeSetName)), nextToken: \(String(describing: nextToken)), stackName: \(String(describing: stackName)))"}
}

extension DescribeChangeSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let changeSetName = changeSetName {
            try container.encode(changeSetName, forKey: Key("ChangeSetName"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        try container.encode("DescribeChangeSet", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DescribeChangeSetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeChangeSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeChangeSetInput>
    public typealias MOutput = OperationOutput<DescribeChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeChangeSetOutputError>
}

public struct DescribeChangeSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeChangeSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeChangeSetInput>
    public typealias MOutput = OperationOutput<DescribeChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeChangeSetOutputError>
}

/// <p>The input for the <a>DescribeChangeSet</a> action.</p>
public struct DescribeChangeSetInput: Equatable {
    /// <p>The name or Amazon Resource Name (ARN) of the change set that you want to
    ///          describe.</p>
    public let changeSetName: String?
    /// <p>A string (provided by the <a>DescribeChangeSet</a> response output) that
    ///          identifies the next page of information that you want to retrieve.</p>
    public let nextToken: String?
    /// <p>If you specified the name of a change set, specify the stack name or ID (ARN) of the
    ///          change set you want to describe.</p>
    public let stackName: String?

    public init (
        changeSetName: String? = nil,
        nextToken: String? = nil,
        stackName: String? = nil
    )
    {
        self.changeSetName = changeSetName
        self.nextToken = nextToken
        self.stackName = stackName
    }
}

extension DescribeChangeSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeChangeSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ChangeSetNotFoundException" : self = .changeSetNotFoundException(try ChangeSetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChangeSetOutputError: Equatable {
    case changeSetNotFoundException(ChangeSetNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChangeSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeChangeSetOutputResponse(capabilities: \(String(describing: capabilities)), changeSetId: \(String(describing: changeSetId)), changeSetName: \(String(describing: changeSetName)), changes: \(String(describing: changes)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), executionStatus: \(String(describing: executionStatus)), includeNestedStacks: \(String(describing: includeNestedStacks)), nextToken: \(String(describing: nextToken)), notificationARNs: \(String(describing: notificationARNs)), parameters: \(String(describing: parameters)), parentChangeSetId: \(String(describing: parentChangeSetId)), rollbackConfiguration: \(String(describing: rollbackConfiguration)), rootChangeSetId: \(String(describing: rootChangeSetId)), stackId: \(String(describing: stackId)), stackName: \(String(describing: stackName)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)), tags: \(String(describing: tags)))"}
}

extension DescribeChangeSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeChangeSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.capabilities = output.capabilities
            self.changeSetId = output.changeSetId
            self.changeSetName = output.changeSetName
            self.changes = output.changes
            self.creationTime = output.creationTime
            self.description = output.description
            self.executionStatus = output.executionStatus
            self.includeNestedStacks = output.includeNestedStacks
            self.nextToken = output.nextToken
            self.notificationARNs = output.notificationARNs
            self.parameters = output.parameters
            self.parentChangeSetId = output.parentChangeSetId
            self.rollbackConfiguration = output.rollbackConfiguration
            self.rootChangeSetId = output.rootChangeSetId
            self.stackId = output.stackId
            self.stackName = output.stackName
            self.status = output.status
            self.statusReason = output.statusReason
            self.tags = output.tags
        } else {
            self.capabilities = nil
            self.changeSetId = nil
            self.changeSetName = nil
            self.changes = nil
            self.creationTime = nil
            self.description = nil
            self.executionStatus = nil
            self.includeNestedStacks = nil
            self.nextToken = nil
            self.notificationARNs = nil
            self.parameters = nil
            self.parentChangeSetId = nil
            self.rollbackConfiguration = nil
            self.rootChangeSetId = nil
            self.stackId = nil
            self.stackName = nil
            self.status = nil
            self.statusReason = nil
            self.tags = nil
        }
    }
}

/// <p>The output for the <a>DescribeChangeSet</a> action.</p>
public struct DescribeChangeSetOutputResponse: Equatable {
    /// <p>If you execute the change set, the list of capabilities that were explicitly
    ///          acknowledged when the change set was created.</p>
    public let capabilities: [Capability]?
    /// <p>The ARN of the change set.</p>
    public let changeSetId: String?
    /// <p>The name of the change set.</p>
    public let changeSetName: String?
    /// <p>A list of <code>Change</code> structures that describes the resources AWS
    ///          CloudFormation changes if you execute the change set.</p>
    public let changes: [Change]?
    /// <p>The start time when the change set was created, in UTC.</p>
    public let creationTime: Date?
    /// <p>Information about the change set.</p>
    public let description: String?
    /// <p>If the change set execution status is <code>AVAILABLE</code>, you can execute the
    ///          change set. If you can’t execute the change set, the status indicates why. For example, a
    ///          change set might be in an <code>UNAVAILABLE</code> state because AWS CloudFormation is
    ///          still creating it or in an <code>OBSOLETE</code> state because the stack was already
    ///          updated.</p>
    public let executionStatus: ExecutionStatus?
    /// <p>Verifies if <code>IncludeNestedStacks</code> is set to <code>True</code>.</p>
    public let includeNestedStacks: Bool?
    /// <p>If the output exceeds 1 MB, a string that identifies the next page of changes. If
    ///          there is no additional page, this value is null.</p>
    public let nextToken: String?
    /// <p>The ARNs of the Amazon Simple Notification Service (Amazon SNS) topics that will be
    ///          associated with the stack if you execute the change set.</p>
    public let notificationARNs: [String]?
    /// <p>A list of <code>Parameter</code> structures that describes the input parameters and
    ///          their values used to create the change set. For more information, see the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_Parameter.html">Parameter</a> data type.</p>
    public let parameters: [Parameter]?
    /// <p>Specifies the change set ID of the parent change set in the current nested change set hierarchy.</p>
    public let parentChangeSetId: String?
    /// <p>The rollback triggers for AWS CloudFormation to monitor during stack creation and
    ///          updating operations, and for the specified monitoring period afterwards.</p>
    public let rollbackConfiguration: RollbackConfiguration?
    /// <p>Specifies the change set ID of the root change set in the current nested change set hierarchy.</p>
    public let rootChangeSetId: String?
    /// <p>The ARN of the stack that is associated with the change set.</p>
    public let stackId: String?
    /// <p>The name of the stack that is associated with the change set.</p>
    public let stackName: String?
    /// <p>The current status of the change set, such as <code>CREATE_IN_PROGRESS</code>,
    ///             <code>CREATE_COMPLETE</code>, or <code>FAILED</code>.</p>
    public let status: ChangeSetStatus?
    /// <p>A description of the change set's status. For example, if your attempt to create a
    ///          change set failed, AWS CloudFormation shows the error message.</p>
    public let statusReason: String?
    /// <p>If you execute the change set, the tags that will be associated with the
    ///          stack.</p>
    public let tags: [Tag]?

    public init (
        capabilities: [Capability]? = nil,
        changeSetId: String? = nil,
        changeSetName: String? = nil,
        changes: [Change]? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        executionStatus: ExecutionStatus? = nil,
        includeNestedStacks: Bool? = nil,
        nextToken: String? = nil,
        notificationARNs: [String]? = nil,
        parameters: [Parameter]? = nil,
        parentChangeSetId: String? = nil,
        rollbackConfiguration: RollbackConfiguration? = nil,
        rootChangeSetId: String? = nil,
        stackId: String? = nil,
        stackName: String? = nil,
        status: ChangeSetStatus? = nil,
        statusReason: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.capabilities = capabilities
        self.changeSetId = changeSetId
        self.changeSetName = changeSetName
        self.changes = changes
        self.creationTime = creationTime
        self.description = description
        self.executionStatus = executionStatus
        self.includeNestedStacks = includeNestedStacks
        self.nextToken = nextToken
        self.notificationARNs = notificationARNs
        self.parameters = parameters
        self.parentChangeSetId = parentChangeSetId
        self.rollbackConfiguration = rollbackConfiguration
        self.rootChangeSetId = rootChangeSetId
        self.stackId = stackId
        self.stackName = stackName
        self.status = status
        self.statusReason = statusReason
        self.tags = tags
    }
}

struct DescribeChangeSetOutputResponseBody: Equatable {
    public let changeSetName: String?
    public let changeSetId: String?
    public let stackId: String?
    public let stackName: String?
    public let description: String?
    public let parameters: [Parameter]?
    public let creationTime: Date?
    public let executionStatus: ExecutionStatus?
    public let status: ChangeSetStatus?
    public let statusReason: String?
    public let notificationARNs: [String]?
    public let rollbackConfiguration: RollbackConfiguration?
    public let capabilities: [Capability]?
    public let tags: [Tag]?
    public let changes: [Change]?
    public let nextToken: String?
    public let includeNestedStacks: Bool?
    public let parentChangeSetId: String?
    public let rootChangeSetId: String?
}

extension DescribeChangeSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case capabilities = "Capabilities"
        case changeSetId = "ChangeSetId"
        case changeSetName = "ChangeSetName"
        case changes = "Changes"
        case creationTime = "CreationTime"
        case description = "Description"
        case executionStatus = "ExecutionStatus"
        case includeNestedStacks = "IncludeNestedStacks"
        case nextToken = "NextToken"
        case notificationARNs = "NotificationARNs"
        case parameters = "Parameters"
        case parentChangeSetId = "ParentChangeSetId"
        case rollbackConfiguration = "RollbackConfiguration"
        case rootChangeSetId = "RootChangeSetId"
        case stackId = "StackId"
        case stackName = "StackName"
        case status = "Status"
        case statusReason = "StatusReason"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeChangeSetResult"))
        let changeSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetName)
        changeSetName = changeSetNameDecoded
        let changeSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct member{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([Parameter].self, forKey: .member)
                var parametersBuffer:[Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        var creationTimeBuffer:Date? = nil
        if let creationTimeDecoded = creationTimeDecoded {
            creationTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationTimeDecoded, format: .dateTime)
        }
        creationTime = creationTimeBuffer
        let executionStatusDecoded = try containerValues.decodeIfPresent(ExecutionStatus.self, forKey: .executionStatus)
        executionStatus = executionStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChangeSetStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        if containerValues.contains(.notificationARNs) {
            struct KeyVal0{struct member{}}
            let notificationARNsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .notificationARNs)
            if let notificationARNsWrappedContainer = notificationARNsWrappedContainer {
                let notificationARNsContainer = try notificationARNsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var notificationARNsBuffer:[String]? = nil
                if let notificationARNsContainer = notificationARNsContainer {
                    notificationARNsBuffer = [String]()
                    for stringContainer0 in notificationARNsContainer {
                        notificationARNsBuffer?.append(stringContainer0)
                    }
                }
                notificationARNs = notificationARNsBuffer
            } else {
                notificationARNs = []
            }
        } else {
            notificationARNs = nil
        }
        let rollbackConfigurationDecoded = try containerValues.decodeIfPresent(RollbackConfiguration.self, forKey: .rollbackConfiguration)
        rollbackConfiguration = rollbackConfigurationDecoded
        if containerValues.contains(.capabilities) {
            struct KeyVal0{struct member{}}
            let capabilitiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .capabilities)
            if let capabilitiesWrappedContainer = capabilitiesWrappedContainer {
                let capabilitiesContainer = try capabilitiesWrappedContainer.decodeIfPresent([Capability].self, forKey: .member)
                var capabilitiesBuffer:[Capability]? = nil
                if let capabilitiesContainer = capabilitiesContainer {
                    capabilitiesBuffer = [Capability]()
                    for stringContainer0 in capabilitiesContainer {
                        capabilitiesBuffer?.append(stringContainer0)
                    }
                }
                capabilities = capabilitiesBuffer
            } else {
                capabilities = []
            }
        } else {
            capabilities = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        if containerValues.contains(.changes) {
            struct KeyVal0{struct member{}}
            let changesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .changes)
            if let changesWrappedContainer = changesWrappedContainer {
                let changesContainer = try changesWrappedContainer.decodeIfPresent([Change].self, forKey: .member)
                var changesBuffer:[Change]? = nil
                if let changesContainer = changesContainer {
                    changesBuffer = [Change]()
                    for structureContainer0 in changesContainer {
                        changesBuffer?.append(structureContainer0)
                    }
                }
                changes = changesBuffer
            } else {
                changes = []
            }
        } else {
            changes = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let includeNestedStacksDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeNestedStacks)
        includeNestedStacks = includeNestedStacksDecoded
        let parentChangeSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentChangeSetId)
        parentChangeSetId = parentChangeSetIdDecoded
        let rootChangeSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rootChangeSetId)
        rootChangeSetId = rootChangeSetIdDecoded
    }
}

public struct DescribeStackDriftDetectionStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStackDriftDetectionStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackDriftDetectionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackDriftDetectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackDriftDetectionStatusInput>
    public typealias MOutput = OperationOutput<DescribeStackDriftDetectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackDriftDetectionStatusOutputError>
}

extension DescribeStackDriftDetectionStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackDriftDetectionStatusInput(stackDriftDetectionId: \(String(describing: stackDriftDetectionId)))"}
}

extension DescribeStackDriftDetectionStatusInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let stackDriftDetectionId = stackDriftDetectionId {
            try container.encode(stackDriftDetectionId, forKey: Key("StackDriftDetectionId"))
        }
        try container.encode("DescribeStackDriftDetectionStatus", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DescribeStackDriftDetectionStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStackDriftDetectionStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackDriftDetectionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackDriftDetectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackDriftDetectionStatusInput>
    public typealias MOutput = OperationOutput<DescribeStackDriftDetectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackDriftDetectionStatusOutputError>
}

public struct DescribeStackDriftDetectionStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStackDriftDetectionStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackDriftDetectionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackDriftDetectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackDriftDetectionStatusInput>
    public typealias MOutput = OperationOutput<DescribeStackDriftDetectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackDriftDetectionStatusOutputError>
}

public struct DescribeStackDriftDetectionStatusInput: Equatable {
    /// <p>The ID of the drift detection results of this operation. </p>
    ///          <p>AWS CloudFormation generates new results, with a new drift detection ID, each time this operation
    ///          is run. However, the number of drift results AWS CloudFormation retains for any given stack, and for how
    ///          long, may vary. </p>
    public let stackDriftDetectionId: String?

    public init (
        stackDriftDetectionId: String? = nil
    )
    {
        self.stackDriftDetectionId = stackDriftDetectionId
    }
}

extension DescribeStackDriftDetectionStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeStackDriftDetectionStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStackDriftDetectionStatusOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStackDriftDetectionStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackDriftDetectionStatusOutputResponse(detectionStatus: \(String(describing: detectionStatus)), detectionStatusReason: \(String(describing: detectionStatusReason)), driftedStackResourceCount: \(String(describing: driftedStackResourceCount)), stackDriftDetectionId: \(String(describing: stackDriftDetectionId)), stackDriftStatus: \(String(describing: stackDriftStatus)), stackId: \(String(describing: stackId)), timestamp: \(String(describing: timestamp)))"}
}

extension DescribeStackDriftDetectionStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStackDriftDetectionStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.detectionStatus = output.detectionStatus
            self.detectionStatusReason = output.detectionStatusReason
            self.driftedStackResourceCount = output.driftedStackResourceCount
            self.stackDriftDetectionId = output.stackDriftDetectionId
            self.stackDriftStatus = output.stackDriftStatus
            self.stackId = output.stackId
            self.timestamp = output.timestamp
        } else {
            self.detectionStatus = nil
            self.detectionStatusReason = nil
            self.driftedStackResourceCount = nil
            self.stackDriftDetectionId = nil
            self.stackDriftStatus = nil
            self.stackId = nil
            self.timestamp = nil
        }
    }
}

public struct DescribeStackDriftDetectionStatusOutputResponse: Equatable {
    /// <p>The status of the stack drift detection operation.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DETECTION_COMPLETE</code>: The stack drift detection operation has
    ///                successfully completed for all resources in the stack that support drift detection.
    ///                (Resources that do not currently support stack detection remain unchecked.)</p>
    ///                <p>If you specified logical resource IDs for AWS CloudFormation to use as a filter for the
    ///                stack drift detection operation, only the resources with those logical IDs are
    ///                checked for drift.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DETECTION_FAILED</code>: The stack drift detection operation has failed
    ///                for at least one resource in the stack. Results will be available for resources on
    ///                which AWS CloudFormation successfully completed drift detection.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DETECTION_IN_PROGRESS</code>: The stack drift detection operation is
    ///                currently in progress.</p>
    ///             </li>
    ///          </ul>
    public let detectionStatus: StackDriftDetectionStatus?
    /// <p>The reason the stack drift detection operation has its current status.</p>
    public let detectionStatusReason: String?
    /// <p>Total number of stack resources that have drifted. This is NULL until the drift
    ///          detection operation reaches a status of <code>DETECTION_COMPLETE</code>. This value will be
    ///          0 for stacks whose drift status is <code>IN_SYNC</code>.</p>
    public let driftedStackResourceCount: Int?
    /// <p>The ID of the drift detection results of this operation. </p>
    ///          <p>AWS CloudFormation generates new results, with a new drift detection ID, each time this operation
    ///          is run. However, the number of reports AWS CloudFormation retains for any given stack, and for how long,
    ///          may vary.</p>
    public let stackDriftDetectionId: String?
    /// <p>Status of the stack's actual configuration compared to its expected configuration. </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DRIFTED</code>: The stack differs from its expected template
    ///                configuration. A stack is considered to have drifted if one or more of its resources
    ///                have drifted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the stack differs from its
    ///                expected template configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_SYNC</code>: The stack's actual configuration matches its expected
    ///                template configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UNKNOWN</code>: This value is reserved for future use.</p>
    ///             </li>
    ///          </ul>
    public let stackDriftStatus: StackDriftStatus?
    /// <p>The ID of the stack.</p>
    public let stackId: String?
    /// <p>Time at which the stack drift detection operation was initiated.</p>
    public let timestamp: Date?

    public init (
        detectionStatus: StackDriftDetectionStatus? = nil,
        detectionStatusReason: String? = nil,
        driftedStackResourceCount: Int? = nil,
        stackDriftDetectionId: String? = nil,
        stackDriftStatus: StackDriftStatus? = nil,
        stackId: String? = nil,
        timestamp: Date? = nil
    )
    {
        self.detectionStatus = detectionStatus
        self.detectionStatusReason = detectionStatusReason
        self.driftedStackResourceCount = driftedStackResourceCount
        self.stackDriftDetectionId = stackDriftDetectionId
        self.stackDriftStatus = stackDriftStatus
        self.stackId = stackId
        self.timestamp = timestamp
    }
}

struct DescribeStackDriftDetectionStatusOutputResponseBody: Equatable {
    public let stackId: String?
    public let stackDriftDetectionId: String?
    public let stackDriftStatus: StackDriftStatus?
    public let detectionStatus: StackDriftDetectionStatus?
    public let detectionStatusReason: String?
    public let driftedStackResourceCount: Int?
    public let timestamp: Date?
}

extension DescribeStackDriftDetectionStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectionStatus = "DetectionStatus"
        case detectionStatusReason = "DetectionStatusReason"
        case driftedStackResourceCount = "DriftedStackResourceCount"
        case stackDriftDetectionId = "StackDriftDetectionId"
        case stackDriftStatus = "StackDriftStatus"
        case stackId = "StackId"
        case timestamp = "Timestamp"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeStackDriftDetectionStatusResult"))
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let stackDriftDetectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackDriftDetectionId)
        stackDriftDetectionId = stackDriftDetectionIdDecoded
        let stackDriftStatusDecoded = try containerValues.decodeIfPresent(StackDriftStatus.self, forKey: .stackDriftStatus)
        stackDriftStatus = stackDriftStatusDecoded
        let detectionStatusDecoded = try containerValues.decodeIfPresent(StackDriftDetectionStatus.self, forKey: .detectionStatus)
        detectionStatus = detectionStatusDecoded
        let detectionStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectionStatusReason)
        detectionStatusReason = detectionStatusReasonDecoded
        let driftedStackResourceCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .driftedStackResourceCount)
        driftedStackResourceCount = driftedStackResourceCountDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestamp)
        var timestampBuffer:Date? = nil
        if let timestampDecoded = timestampDecoded {
            timestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(timestampDecoded, format: .dateTime)
        }
        timestamp = timestampBuffer
    }
}

public struct DescribeStackEventsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStackEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackEventsInput>
    public typealias MOutput = OperationOutput<DescribeStackEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackEventsOutputError>
}

extension DescribeStackEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackEventsInput(nextToken: \(String(describing: nextToken)), stackName: \(String(describing: stackName)))"}
}

extension DescribeStackEventsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        try container.encode("DescribeStackEvents", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DescribeStackEventsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStackEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackEventsInput>
    public typealias MOutput = OperationOutput<DescribeStackEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackEventsOutputError>
}

public struct DescribeStackEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStackEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackEventsInput>
    public typealias MOutput = OperationOutput<DescribeStackEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackEventsOutputError>
}

/// <p>The input for <a>DescribeStackEvents</a> action.</p>
public struct DescribeStackEventsInput: Equatable {
    /// <p>A string that identifies the next page of events that you want to retrieve.</p>
    public let nextToken: String?
    /// <p>The name or the unique stack ID that is associated with the stack, which are not
    ///          always interchangeable:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Running stacks: You can specify either the stack's name or its unique stack
    ///                ID.</p>
    ///             </li>
    ///             <li>
    ///                <p>Deleted stacks: You must specify the unique stack ID.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Default: There is no default value.</p>
    public let stackName: String?

    public init (
        nextToken: String? = nil,
        stackName: String? = nil
    )
    {
        self.nextToken = nextToken
        self.stackName = stackName
    }
}

extension DescribeStackEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeStackEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStackEventsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStackEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackEventsOutputResponse(nextToken: \(String(describing: nextToken)), stackEvents: \(String(describing: stackEvents)))"}
}

extension DescribeStackEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStackEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.stackEvents = output.stackEvents
        } else {
            self.nextToken = nil
            self.stackEvents = nil
        }
    }
}

/// <p>The output for a <a>DescribeStackEvents</a> action.</p>
public struct DescribeStackEventsOutputResponse: Equatable {
    /// <p>If the output exceeds 1 MB in size, a string that identifies the next page of events.
    ///          If no additional page exists, this value is null.</p>
    public let nextToken: String?
    /// <p>A list of <code>StackEvents</code> structures.</p>
    public let stackEvents: [StackEvent]?

    public init (
        nextToken: String? = nil,
        stackEvents: [StackEvent]? = nil
    )
    {
        self.nextToken = nextToken
        self.stackEvents = stackEvents
    }
}

struct DescribeStackEventsOutputResponseBody: Equatable {
    public let stackEvents: [StackEvent]?
    public let nextToken: String?
}

extension DescribeStackEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case stackEvents = "StackEvents"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeStackEventsResult"))
        if containerValues.contains(.stackEvents) {
            struct KeyVal0{struct member{}}
            let stackEventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .stackEvents)
            if let stackEventsWrappedContainer = stackEventsWrappedContainer {
                let stackEventsContainer = try stackEventsWrappedContainer.decodeIfPresent([StackEvent].self, forKey: .member)
                var stackEventsBuffer:[StackEvent]? = nil
                if let stackEventsContainer = stackEventsContainer {
                    stackEventsBuffer = [StackEvent]()
                    for structureContainer0 in stackEventsContainer {
                        stackEventsBuffer?.append(structureContainer0)
                    }
                }
                stackEvents = stackEventsBuffer
            } else {
                stackEvents = []
            }
        } else {
            stackEvents = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeStackInstanceInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStackInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackInstanceInput>
    public typealias MOutput = OperationOutput<DescribeStackInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackInstanceOutputError>
}

extension DescribeStackInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackInstanceInput(callAs: \(String(describing: callAs)), stackInstanceAccount: \(String(describing: stackInstanceAccount)), stackInstanceRegion: \(String(describing: stackInstanceRegion)), stackSetName: \(String(describing: stackSetName)))"}
}

extension DescribeStackInstanceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let callAs = callAs {
            try container.encode(callAs, forKey: Key("CallAs"))
        }
        if let stackInstanceAccount = stackInstanceAccount {
            try container.encode(stackInstanceAccount, forKey: Key("StackInstanceAccount"))
        }
        if let stackInstanceRegion = stackInstanceRegion {
            try container.encode(stackInstanceRegion, forKey: Key("StackInstanceRegion"))
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        try container.encode("DescribeStackInstance", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DescribeStackInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStackInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackInstanceInput>
    public typealias MOutput = OperationOutput<DescribeStackInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackInstanceOutputError>
}

public struct DescribeStackInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStackInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackInstanceInput>
    public typealias MOutput = OperationOutput<DescribeStackInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackInstanceOutputError>
}

public struct DescribeStackInstanceInput: Equatable {
    /// <p>[Service-managed permissions] Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account.</p>
    ///          <p>By default, <code>SELF</code> is specified. Use <code>SELF</code> for stack sets with self-managed permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you are signed in to the management account, specify <code>SELF</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you are signed in to a delegated administrator account, specify <code>DELEGATED_ADMIN</code>.</p>
    ///                <p>Your AWS account must be registered as a delegated administrator in the management account. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-orgs-delegated-admin.html">Register a delegated administrator</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let callAs: CallAs?
    /// <p>The ID of an AWS account that's associated with this stack instance.</p>
    public let stackInstanceAccount: String?
    /// <p>The name of a Region that's associated with this stack instance.</p>
    public let stackInstanceRegion: String?
    /// <p>The name or the unique stack ID of the stack set that you want to get stack instance
    ///          information for.</p>
    public let stackSetName: String?

    public init (
        callAs: CallAs? = nil,
        stackInstanceAccount: String? = nil,
        stackInstanceRegion: String? = nil,
        stackSetName: String? = nil
    )
    {
        self.callAs = callAs
        self.stackInstanceAccount = stackInstanceAccount
        self.stackInstanceRegion = stackInstanceRegion
        self.stackSetName = stackSetName
    }
}

extension DescribeStackInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeStackInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "StackInstanceNotFoundException" : self = .stackInstanceNotFoundException(try StackInstanceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StackSetNotFoundException" : self = .stackSetNotFoundException(try StackSetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStackInstanceOutputError: Equatable {
    case stackInstanceNotFoundException(StackInstanceNotFoundException)
    case stackSetNotFoundException(StackSetNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStackInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackInstanceOutputResponse(stackInstance: \(String(describing: stackInstance)))"}
}

extension DescribeStackInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStackInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stackInstance = output.stackInstance
        } else {
            self.stackInstance = nil
        }
    }
}

public struct DescribeStackInstanceOutputResponse: Equatable {
    /// <p>The stack instance that matches the specified request parameters.</p>
    public let stackInstance: StackInstance?

    public init (
        stackInstance: StackInstance? = nil
    )
    {
        self.stackInstance = stackInstance
    }
}

struct DescribeStackInstanceOutputResponseBody: Equatable {
    public let stackInstance: StackInstance?
}

extension DescribeStackInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackInstance = "StackInstance"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeStackInstanceResult"))
        let stackInstanceDecoded = try containerValues.decodeIfPresent(StackInstance.self, forKey: .stackInstance)
        stackInstance = stackInstanceDecoded
    }
}

public struct DescribeStackResourceDriftsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStackResourceDriftsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackResourceDriftsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackResourceDriftsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackResourceDriftsInput>
    public typealias MOutput = OperationOutput<DescribeStackResourceDriftsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackResourceDriftsOutputError>
}

extension DescribeStackResourceDriftsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackResourceDriftsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), stackName: \(String(describing: stackName)), stackResourceDriftStatusFilters: \(String(describing: stackResourceDriftStatusFilters)))"}
}

extension DescribeStackResourceDriftsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        if let stackResourceDriftStatusFilters = stackResourceDriftStatusFilters {
            var stackResourceDriftStatusFiltersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("StackResourceDriftStatusFilters"))
            for (index0, stackresourcedriftstatus0) in stackResourceDriftStatusFilters.enumerated() {
                try stackResourceDriftStatusFiltersContainer.encode(stackresourcedriftstatus0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeStackResourceDrifts", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DescribeStackResourceDriftsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStackResourceDriftsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackResourceDriftsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackResourceDriftsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackResourceDriftsInput>
    public typealias MOutput = OperationOutput<DescribeStackResourceDriftsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackResourceDriftsOutputError>
}

public struct DescribeStackResourceDriftsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStackResourceDriftsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackResourceDriftsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackResourceDriftsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackResourceDriftsInput>
    public typealias MOutput = OperationOutput<DescribeStackResourceDriftsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackResourceDriftsOutputError>
}

public struct DescribeStackResourceDriftsInput: Equatable {
    /// <p>The maximum number of results to be returned with a single call. If the number of
    ///          available results exceeds this maximum, the response includes a <code>NextToken</code>
    ///          value that you can assign to the <code>NextToken</code> request parameter to get the next
    ///          set of results.</p>
    public let maxResults: Int?
    /// <p>A string that identifies the next page of stack resource drift results.</p>
    public let nextToken: String?
    /// <p>The name of the stack for which you want drift information.</p>
    public let stackName: String?
    /// <p>The resource drift status values to use as filters for the resource drift results
    ///          returned.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DELETED</code>: The resource differs from its expected template
    ///                configuration in that the resource has been deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MODIFIED</code>: One or more resource properties differ from their
    ///                expected template values.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_SYNC</code>: The resources's actual configuration matches its expected
    ///                template configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_CHECKED</code>: AWS CloudFormation does not currently return this value.</p>
    ///             </li>
    ///          </ul>
    public let stackResourceDriftStatusFilters: [StackResourceDriftStatus]?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        stackName: String? = nil,
        stackResourceDriftStatusFilters: [StackResourceDriftStatus]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stackName = stackName
        self.stackResourceDriftStatusFilters = stackResourceDriftStatusFilters
    }
}

extension DescribeStackResourceDriftsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeStackResourceDriftsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStackResourceDriftsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStackResourceDriftsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackResourceDriftsOutputResponse(nextToken: \(String(describing: nextToken)), stackResourceDrifts: \(String(describing: stackResourceDrifts)))"}
}

extension DescribeStackResourceDriftsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStackResourceDriftsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.stackResourceDrifts = output.stackResourceDrifts
        } else {
            self.nextToken = nil
            self.stackResourceDrifts = nil
        }
    }
}

public struct DescribeStackResourceDriftsOutputResponse: Equatable {
    /// <p>If the request doesn't return all of the remaining results, <code>NextToken</code> is
    ///          set to a token. To retrieve the next set of results, call
    ///             <code>DescribeStackResourceDrifts</code> again and assign that token to the request
    ///          object's <code>NextToken</code> parameter. If the request returns all results,
    ///             <code>NextToken</code> is set to <code>null</code>.</p>
    public let nextToken: String?
    /// <p>Drift information for the resources that have been checked for drift in the specified
    ///          stack. This includes actual and expected configuration values for resources where AWS CloudFormation
    ///          detects drift.</p>
    ///          <p>For a given stack, there will be one <code>StackResourceDrift</code> for each stack
    ///          resource that has been checked for drift. Resources that have not yet been checked for
    ///          drift are not included. Resources that do not currently support drift detection are not
    ///          checked, and so not included. For a list of resources that support drift detection, see
    ///             <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift-resource-list.html">Resources that Support Drift Detection</a>.</p>
    public let stackResourceDrifts: [StackResourceDrift]?

    public init (
        nextToken: String? = nil,
        stackResourceDrifts: [StackResourceDrift]? = nil
    )
    {
        self.nextToken = nextToken
        self.stackResourceDrifts = stackResourceDrifts
    }
}

struct DescribeStackResourceDriftsOutputResponseBody: Equatable {
    public let stackResourceDrifts: [StackResourceDrift]?
    public let nextToken: String?
}

extension DescribeStackResourceDriftsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case stackResourceDrifts = "StackResourceDrifts"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeStackResourceDriftsResult"))
        if containerValues.contains(.stackResourceDrifts) {
            struct KeyVal0{struct member{}}
            let stackResourceDriftsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .stackResourceDrifts)
            if let stackResourceDriftsWrappedContainer = stackResourceDriftsWrappedContainer {
                let stackResourceDriftsContainer = try stackResourceDriftsWrappedContainer.decodeIfPresent([StackResourceDrift].self, forKey: .member)
                var stackResourceDriftsBuffer:[StackResourceDrift]? = nil
                if let stackResourceDriftsContainer = stackResourceDriftsContainer {
                    stackResourceDriftsBuffer = [StackResourceDrift]()
                    for structureContainer0 in stackResourceDriftsContainer {
                        stackResourceDriftsBuffer?.append(structureContainer0)
                    }
                }
                stackResourceDrifts = stackResourceDriftsBuffer
            } else {
                stackResourceDrifts = []
            }
        } else {
            stackResourceDrifts = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeStackResourceInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStackResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackResourceInput>
    public typealias MOutput = OperationOutput<DescribeStackResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackResourceOutputError>
}

extension DescribeStackResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackResourceInput(logicalResourceId: \(String(describing: logicalResourceId)), stackName: \(String(describing: stackName)))"}
}

extension DescribeStackResourceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let logicalResourceId = logicalResourceId {
            try container.encode(logicalResourceId, forKey: Key("LogicalResourceId"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        try container.encode("DescribeStackResource", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DescribeStackResourceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStackResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackResourceInput>
    public typealias MOutput = OperationOutput<DescribeStackResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackResourceOutputError>
}

public struct DescribeStackResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStackResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackResourceInput>
    public typealias MOutput = OperationOutput<DescribeStackResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackResourceOutputError>
}

/// <p>The input for <a>DescribeStackResource</a> action.</p>
public struct DescribeStackResourceInput: Equatable {
    /// <p>The logical name of the resource as specified in the template.</p>
    ///          <p>Default: There is no default value.</p>
    public let logicalResourceId: String?
    /// <p>The name or the unique stack ID that is associated with the stack, which are not
    ///          always interchangeable:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Running stacks: You can specify either the stack's name or its unique stack
    ///                ID.</p>
    ///             </li>
    ///             <li>
    ///                <p>Deleted stacks: You must specify the unique stack ID.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Default: There is no default value.</p>
    public let stackName: String?

    public init (
        logicalResourceId: String? = nil,
        stackName: String? = nil
    )
    {
        self.logicalResourceId = logicalResourceId
        self.stackName = stackName
    }
}

extension DescribeStackResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeStackResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStackResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStackResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackResourceOutputResponse(stackResourceDetail: \(String(describing: stackResourceDetail)))"}
}

extension DescribeStackResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStackResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stackResourceDetail = output.stackResourceDetail
        } else {
            self.stackResourceDetail = nil
        }
    }
}

/// <p>The output for a <a>DescribeStackResource</a> action.</p>
public struct DescribeStackResourceOutputResponse: Equatable {
    /// <p>A <code>StackResourceDetail</code> structure containing the description of the
    ///          specified resource in the specified stack.</p>
    public let stackResourceDetail: StackResourceDetail?

    public init (
        stackResourceDetail: StackResourceDetail? = nil
    )
    {
        self.stackResourceDetail = stackResourceDetail
    }
}

struct DescribeStackResourceOutputResponseBody: Equatable {
    public let stackResourceDetail: StackResourceDetail?
}

extension DescribeStackResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackResourceDetail = "StackResourceDetail"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeStackResourceResult"))
        let stackResourceDetailDecoded = try containerValues.decodeIfPresent(StackResourceDetail.self, forKey: .stackResourceDetail)
        stackResourceDetail = stackResourceDetailDecoded
    }
}

public struct DescribeStackResourcesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStackResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackResourcesInput>
    public typealias MOutput = OperationOutput<DescribeStackResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackResourcesOutputError>
}

extension DescribeStackResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackResourcesInput(logicalResourceId: \(String(describing: logicalResourceId)), physicalResourceId: \(String(describing: physicalResourceId)), stackName: \(String(describing: stackName)))"}
}

extension DescribeStackResourcesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let logicalResourceId = logicalResourceId {
            try container.encode(logicalResourceId, forKey: Key("LogicalResourceId"))
        }
        if let physicalResourceId = physicalResourceId {
            try container.encode(physicalResourceId, forKey: Key("PhysicalResourceId"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        try container.encode("DescribeStackResources", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DescribeStackResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStackResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackResourcesInput>
    public typealias MOutput = OperationOutput<DescribeStackResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackResourcesOutputError>
}

public struct DescribeStackResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStackResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackResourcesInput>
    public typealias MOutput = OperationOutput<DescribeStackResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackResourcesOutputError>
}

/// <p>The input for <a>DescribeStackResources</a> action.</p>
public struct DescribeStackResourcesInput: Equatable {
    /// <p>The logical name of the resource as specified in the template.</p>
    ///          <p>Default: There is no default value.</p>
    public let logicalResourceId: String?
    /// <p>The name or unique identifier that corresponds to a physical instance ID of a
    ///          resource supported by AWS CloudFormation.</p>
    ///          <p>For example, for an Amazon Elastic Compute Cloud (EC2) instance,
    ///             <code>PhysicalResourceId</code> corresponds to the <code>InstanceId</code>. You can pass
    ///          the EC2 <code>InstanceId</code> to <code>DescribeStackResources</code> to find which stack
    ///          the instance belongs to and what other resources are part of the stack.</p>
    ///          <p>Required: Conditional. If you do not specify <code>PhysicalResourceId</code>, you
    ///          must specify <code>StackName</code>.</p>
    ///          <p>Default: There is no default value.</p>
    public let physicalResourceId: String?
    /// <p>The name or the unique stack ID that is associated with the stack, which are not
    ///          always interchangeable:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Running stacks: You can specify either the stack's name or its unique stack
    ///                ID.</p>
    ///             </li>
    ///             <li>
    ///                <p>Deleted stacks: You must specify the unique stack ID.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Default: There is no default value.</p>
    ///          <p>Required: Conditional. If you do not specify <code>StackName</code>, you must specify
    ///             <code>PhysicalResourceId</code>.</p>
    public let stackName: String?

    public init (
        logicalResourceId: String? = nil,
        physicalResourceId: String? = nil,
        stackName: String? = nil
    )
    {
        self.logicalResourceId = logicalResourceId
        self.physicalResourceId = physicalResourceId
        self.stackName = stackName
    }
}

extension DescribeStackResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeStackResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStackResourcesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStackResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackResourcesOutputResponse(stackResources: \(String(describing: stackResources)))"}
}

extension DescribeStackResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStackResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stackResources = output.stackResources
        } else {
            self.stackResources = nil
        }
    }
}

/// <p>The output for a <a>DescribeStackResources</a> action.</p>
public struct DescribeStackResourcesOutputResponse: Equatable {
    /// <p>A list of <code>StackResource</code> structures.</p>
    public let stackResources: [StackResource]?

    public init (
        stackResources: [StackResource]? = nil
    )
    {
        self.stackResources = stackResources
    }
}

struct DescribeStackResourcesOutputResponseBody: Equatable {
    public let stackResources: [StackResource]?
}

extension DescribeStackResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackResources = "StackResources"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeStackResourcesResult"))
        if containerValues.contains(.stackResources) {
            struct KeyVal0{struct member{}}
            let stackResourcesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .stackResources)
            if let stackResourcesWrappedContainer = stackResourcesWrappedContainer {
                let stackResourcesContainer = try stackResourcesWrappedContainer.decodeIfPresent([StackResource].self, forKey: .member)
                var stackResourcesBuffer:[StackResource]? = nil
                if let stackResourcesContainer = stackResourcesContainer {
                    stackResourcesBuffer = [StackResource]()
                    for structureContainer0 in stackResourcesContainer {
                        stackResourcesBuffer?.append(structureContainer0)
                    }
                }
                stackResources = stackResourcesBuffer
            } else {
                stackResources = []
            }
        } else {
            stackResources = nil
        }
    }
}

public struct DescribeStackSetInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStackSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackSetInput>
    public typealias MOutput = OperationOutput<DescribeStackSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackSetOutputError>
}

extension DescribeStackSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackSetInput(callAs: \(String(describing: callAs)), stackSetName: \(String(describing: stackSetName)))"}
}

extension DescribeStackSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let callAs = callAs {
            try container.encode(callAs, forKey: Key("CallAs"))
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        try container.encode("DescribeStackSet", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DescribeStackSetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStackSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackSetInput>
    public typealias MOutput = OperationOutput<DescribeStackSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackSetOutputError>
}

public struct DescribeStackSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStackSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackSetInput>
    public typealias MOutput = OperationOutput<DescribeStackSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackSetOutputError>
}

public struct DescribeStackSetInput: Equatable {
    /// <p>[Service-managed permissions] Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account.</p>
    ///          <p>By default, <code>SELF</code> is specified. Use <code>SELF</code> for stack sets with self-managed permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you are signed in to the management account, specify <code>SELF</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you are signed in to a delegated administrator account, specify <code>DELEGATED_ADMIN</code>.</p>
    ///                <p>Your AWS account must be registered as a delegated administrator in the management account. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-orgs-delegated-admin.html">Register a delegated administrator</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let callAs: CallAs?
    /// <p>The name or unique ID of the stack set whose description you want.</p>
    public let stackSetName: String?

    public init (
        callAs: CallAs? = nil,
        stackSetName: String? = nil
    )
    {
        self.callAs = callAs
        self.stackSetName = stackSetName
    }
}

public struct DescribeStackSetOperationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStackSetOperationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackSetOperationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackSetOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackSetOperationInput>
    public typealias MOutput = OperationOutput<DescribeStackSetOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackSetOperationOutputError>
}

extension DescribeStackSetOperationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackSetOperationInput(callAs: \(String(describing: callAs)), operationId: \(String(describing: operationId)), stackSetName: \(String(describing: stackSetName)))"}
}

extension DescribeStackSetOperationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let callAs = callAs {
            try container.encode(callAs, forKey: Key("CallAs"))
        }
        if let operationId = operationId {
            try container.encode(operationId, forKey: Key("OperationId"))
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        try container.encode("DescribeStackSetOperation", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DescribeStackSetOperationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStackSetOperationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackSetOperationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackSetOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackSetOperationInput>
    public typealias MOutput = OperationOutput<DescribeStackSetOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackSetOperationOutputError>
}

public struct DescribeStackSetOperationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStackSetOperationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackSetOperationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackSetOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackSetOperationInput>
    public typealias MOutput = OperationOutput<DescribeStackSetOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackSetOperationOutputError>
}

public struct DescribeStackSetOperationInput: Equatable {
    /// <p>[Service-managed permissions] Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account.</p>
    ///          <p>By default, <code>SELF</code> is specified. Use <code>SELF</code> for stack sets with self-managed permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you are signed in to the management account, specify <code>SELF</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you are signed in to a delegated administrator account, specify <code>DELEGATED_ADMIN</code>.</p>
    ///                <p>Your AWS account must be registered as a delegated administrator in the management account. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-orgs-delegated-admin.html">Register a delegated administrator</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let callAs: CallAs?
    /// <p>The unique ID of the stack set operation. </p>
    public let operationId: String?
    /// <p>The name or the unique stack ID of the stack set for the stack operation.</p>
    public let stackSetName: String?

    public init (
        callAs: CallAs? = nil,
        operationId: String? = nil,
        stackSetName: String? = nil
    )
    {
        self.callAs = callAs
        self.operationId = operationId
        self.stackSetName = stackSetName
    }
}

extension DescribeStackSetOperationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeStackSetOperationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OperationNotFoundException" : self = .operationNotFoundException(try OperationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StackSetNotFoundException" : self = .stackSetNotFoundException(try StackSetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStackSetOperationOutputError: Equatable {
    case operationNotFoundException(OperationNotFoundException)
    case stackSetNotFoundException(StackSetNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStackSetOperationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackSetOperationOutputResponse(stackSetOperation: \(String(describing: stackSetOperation)))"}
}

extension DescribeStackSetOperationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStackSetOperationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stackSetOperation = output.stackSetOperation
        } else {
            self.stackSetOperation = nil
        }
    }
}

public struct DescribeStackSetOperationOutputResponse: Equatable {
    /// <p>The specified stack set operation.</p>
    public let stackSetOperation: StackSetOperation?

    public init (
        stackSetOperation: StackSetOperation? = nil
    )
    {
        self.stackSetOperation = stackSetOperation
    }
}

struct DescribeStackSetOperationOutputResponseBody: Equatable {
    public let stackSetOperation: StackSetOperation?
}

extension DescribeStackSetOperationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackSetOperation = "StackSetOperation"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeStackSetOperationResult"))
        let stackSetOperationDecoded = try containerValues.decodeIfPresent(StackSetOperation.self, forKey: .stackSetOperation)
        stackSetOperation = stackSetOperationDecoded
    }
}

extension DescribeStackSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeStackSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "StackSetNotFoundException" : self = .stackSetNotFoundException(try StackSetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStackSetOutputError: Equatable {
    case stackSetNotFoundException(StackSetNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStackSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackSetOutputResponse(stackSet: \(String(describing: stackSet)))"}
}

extension DescribeStackSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStackSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stackSet = output.stackSet
        } else {
            self.stackSet = nil
        }
    }
}

public struct DescribeStackSetOutputResponse: Equatable {
    /// <p>The specified stack set.</p>
    public let stackSet: StackSet?

    public init (
        stackSet: StackSet? = nil
    )
    {
        self.stackSet = stackSet
    }
}

struct DescribeStackSetOutputResponseBody: Equatable {
    public let stackSet: StackSet?
}

extension DescribeStackSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackSet = "StackSet"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeStackSetResult"))
        let stackSetDecoded = try containerValues.decodeIfPresent(StackSet.self, forKey: .stackSet)
        stackSet = stackSetDecoded
    }
}

public struct DescribeStacksInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStacksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStacksInput>
    public typealias MOutput = OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStacksOutputError>
}

extension DescribeStacksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStacksInput(nextToken: \(String(describing: nextToken)), stackName: \(String(describing: stackName)))"}
}

extension DescribeStacksInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        try container.encode("DescribeStacks", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DescribeStacksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStacksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStacksInput>
    public typealias MOutput = OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStacksOutputError>
}

public struct DescribeStacksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStacksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStacksInput>
    public typealias MOutput = OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStacksOutputError>
}

/// <p>The input for <a>DescribeStacks</a> action.</p>
public struct DescribeStacksInput: Equatable {
    /// <p>A string that identifies the next page of stacks that you want to retrieve.</p>
    public let nextToken: String?
    /// <p>The name or the unique stack ID that is associated with the stack, which are not
    ///          always interchangeable:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Running stacks: You can specify either the stack's name or its unique stack
    ///                ID.</p>
    ///             </li>
    ///             <li>
    ///                <p>Deleted stacks: You must specify the unique stack ID.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Default: There is no default value.</p>
    public let stackName: String?

    public init (
        nextToken: String? = nil,
        stackName: String? = nil
    )
    {
        self.nextToken = nextToken
        self.stackName = stackName
    }
}

extension DescribeStacksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeStacksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStacksOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStacksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStacksOutputResponse(nextToken: \(String(describing: nextToken)), stacks: \(String(describing: stacks)))"}
}

extension DescribeStacksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStacksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.stacks = output.stacks
        } else {
            self.nextToken = nil
            self.stacks = nil
        }
    }
}

/// <p>The output for a <a>DescribeStacks</a> action.</p>
public struct DescribeStacksOutputResponse: Equatable {
    /// <p>If the output exceeds 1 MB in size, a string that identifies the next page of stacks.
    ///          If no additional page exists, this value is null.</p>
    public let nextToken: String?
    /// <p>A list of stack structures.</p>
    public let stacks: [Stack]?

    public init (
        nextToken: String? = nil,
        stacks: [Stack]? = nil
    )
    {
        self.nextToken = nextToken
        self.stacks = stacks
    }
}

struct DescribeStacksOutputResponseBody: Equatable {
    public let stacks: [Stack]?
    public let nextToken: String?
}

extension DescribeStacksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case stacks = "Stacks"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeStacksResult"))
        if containerValues.contains(.stacks) {
            struct KeyVal0{struct member{}}
            let stacksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .stacks)
            if let stacksWrappedContainer = stacksWrappedContainer {
                let stacksContainer = try stacksWrappedContainer.decodeIfPresent([Stack].self, forKey: .member)
                var stacksBuffer:[Stack]? = nil
                if let stacksContainer = stacksContainer {
                    stacksBuffer = [Stack]()
                    for structureContainer0 in stacksContainer {
                        stacksBuffer?.append(structureContainer0)
                    }
                }
                stacks = stacksBuffer
            } else {
                stacks = []
            }
        } else {
            stacks = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeTypeInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTypeInput>
    public typealias MOutput = OperationOutput<DescribeTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTypeOutputError>
}

extension DescribeTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTypeInput(arn: \(String(describing: arn)), type: \(String(describing: type)), typeName: \(String(describing: typeName)), versionId: \(String(describing: versionId)))"}
}

extension DescribeTypeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
        if let typeName = typeName {
            try container.encode(typeName, forKey: Key("TypeName"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: Key("VersionId"))
        }
        try container.encode("DescribeType", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DescribeTypeInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTypeInput>
    public typealias MOutput = OperationOutput<DescribeTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTypeOutputError>
}

public struct DescribeTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTypeInput>
    public typealias MOutput = OperationOutput<DescribeTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTypeOutputError>
}

public struct DescribeTypeInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the extension.</p>
    ///          <p>Conditional: You must specify either <code>TypeName</code> and <code>Type</code>, or <code>Arn</code>.</p>
    public let arn: String?
    /// <p>The kind of extension. </p>
    ///          <p>Conditional: You must specify either <code>TypeName</code> and <code>Type</code>, or <code>Arn</code>.</p>
    public let type: RegistryType?
    /// <p>The name of the extension.</p>
    ///          <p>Conditional: You must specify either <code>TypeName</code> and <code>Type</code>, or <code>Arn</code>.</p>
    public let typeName: String?
    /// <p>The ID of a specific version of the extension. The version ID is the value at the end of the Amazon Resource Name (ARN) assigned to the extension version when it is registered.</p>
    ///          <p>If you specify a <code>VersionId</code>, <code>DescribeType</code> returns information about that specific extension version. Otherwise, it returns information about the default extension version.</p>
    public let versionId: String?

    public init (
        arn: String? = nil,
        type: RegistryType? = nil,
        typeName: String? = nil,
        versionId: String? = nil
    )
    {
        self.arn = arn
        self.type = type
        self.typeName = typeName
        self.versionId = versionId
    }
}

extension DescribeTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CFNRegistryException" : self = .cFNRegistryException(try CFNRegistryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TypeNotFoundException" : self = .typeNotFoundException(try TypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTypeOutputError: Equatable {
    case cFNRegistryException(CFNRegistryException)
    case typeNotFoundException(TypeNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTypeOutputResponse(arn: \(String(describing: arn)), defaultVersionId: \(String(describing: defaultVersionId)), deprecatedStatus: \(String(describing: deprecatedStatus)), description: \(String(describing: description)), documentationUrl: \(String(describing: documentationUrl)), executionRoleArn: \(String(describing: executionRoleArn)), isDefaultVersion: \(String(describing: isDefaultVersion)), lastUpdated: \(String(describing: lastUpdated)), loggingConfig: \(String(describing: loggingConfig)), provisioningType: \(String(describing: provisioningType)), schema: \(String(describing: schema)), sourceUrl: \(String(describing: sourceUrl)), timeCreated: \(String(describing: timeCreated)), type: \(String(describing: type)), typeName: \(String(describing: typeName)), visibility: \(String(describing: visibility)))"}
}

extension DescribeTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.defaultVersionId = output.defaultVersionId
            self.deprecatedStatus = output.deprecatedStatus
            self.description = output.description
            self.documentationUrl = output.documentationUrl
            self.executionRoleArn = output.executionRoleArn
            self.isDefaultVersion = output.isDefaultVersion
            self.lastUpdated = output.lastUpdated
            self.loggingConfig = output.loggingConfig
            self.provisioningType = output.provisioningType
            self.schema = output.schema
            self.sourceUrl = output.sourceUrl
            self.timeCreated = output.timeCreated
            self.type = output.type
            self.typeName = output.typeName
            self.visibility = output.visibility
        } else {
            self.arn = nil
            self.defaultVersionId = nil
            self.deprecatedStatus = nil
            self.description = nil
            self.documentationUrl = nil
            self.executionRoleArn = nil
            self.isDefaultVersion = nil
            self.lastUpdated = nil
            self.loggingConfig = nil
            self.provisioningType = nil
            self.schema = nil
            self.sourceUrl = nil
            self.timeCreated = nil
            self.type = nil
            self.typeName = nil
            self.visibility = nil
        }
    }
}

public struct DescribeTypeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the extension.</p>
    public let arn: String?
    /// <p>The ID of the default version of the extension. The default version is used when the extension version is not specified.</p>
    ///          <p>To set the default version of an extension, use <code>
    ///                <a>SetTypeDefaultVersion</a>
    ///             </code>. </p>
    public let defaultVersionId: String?
    /// <p>The deprecation status of the extension version.</p>
    ///          <p>Valid values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>LIVE</code>: The extension is registered and can be used in CloudFormation operations, dependent on its provisioning behavior and visibility scope.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DEPRECATED</code>: The extension has been deregistered and can no longer be used in CloudFormation operations. </p>
    ///             </li>
    ///          </ul>
    public let deprecatedStatus: DeprecatedStatus?
    /// <p>The description of the registered extension.</p>
    public let description: String?
    /// <p>The URL of a page providing detailed documentation for this extension.</p>
    public let documentationUrl: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM execution role used to register the extension. If your resource type calls AWS APIs in any of its handlers, you must create an
    ///          <i>
    ///                <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html">IAM execution
    ///             role</a>
    ///             </i> that includes the necessary permissions to call those
    ///          AWS APIs, and provision that execution role in your account. CloudFormation then
    ///          assumes that execution role to provide your extension with the appropriate
    ///          credentials.</p>
    public let executionRoleArn: String?
    /// <p>Whether the specified extension version is set as the default version.</p>
    public let isDefaultVersion: Bool?
    /// <p>When the specified extension version was registered.</p>
    public let lastUpdated: Date?
    /// <p>Contains logging configuration information for an extension.</p>
    public let loggingConfig: LoggingConfig?
    /// <p>The provisioning behavior of the extension. AWS CloudFormation determines the provisioning type during registration, based on the types of handlers in the schema handler package submitted.</p>
    ///          <p>Valid values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>FULLY_MUTABLE</code>: The extension includes an update handler to process updates to the extension during stack update operations.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IMMUTABLE</code>: The extension does not include an update handler, so the extension cannot be updated and must instead be replaced during stack update operations.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NON_PROVISIONABLE</code>: The extension does not include all of the following handlers, and therefore cannot actually be provisioned.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>create</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>read</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>delete</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let provisioningType: ProvisioningType?
    /// <p>The schema that defines the extension.</p>
    ///          <p>For more information on extension schemas, see <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-schema.html">Resource Provider Schema</a> in the <i>CloudFormation CLI User Guide</i>.</p>
    public let schema: String?
    /// <p>The URL of the source code for the extension.</p>
    public let sourceUrl: String?
    /// <p>When the specified extension version was registered.</p>
    public let timeCreated: Date?
    /// <p>The kind of extension. </p>
    public let type: RegistryType?
    /// <p>The name of the registered extension.</p>
    public let typeName: String?
    /// <p>The scope at which the extension is visible and usable in CloudFormation operations.</p>
    ///          <p>Valid values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PRIVATE</code>: The extension is only visible and usable within the account in which it is registered. Currently, AWS CloudFormation marks any types you register as <code>PRIVATE</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PUBLIC</code>: The extension is publically visible and usable within any Amazon account.</p>
    ///             </li>
    ///          </ul>
    public let visibility: Visibility?

    public init (
        arn: String? = nil,
        defaultVersionId: String? = nil,
        deprecatedStatus: DeprecatedStatus? = nil,
        description: String? = nil,
        documentationUrl: String? = nil,
        executionRoleArn: String? = nil,
        isDefaultVersion: Bool? = nil,
        lastUpdated: Date? = nil,
        loggingConfig: LoggingConfig? = nil,
        provisioningType: ProvisioningType? = nil,
        schema: String? = nil,
        sourceUrl: String? = nil,
        timeCreated: Date? = nil,
        type: RegistryType? = nil,
        typeName: String? = nil,
        visibility: Visibility? = nil
    )
    {
        self.arn = arn
        self.defaultVersionId = defaultVersionId
        self.deprecatedStatus = deprecatedStatus
        self.description = description
        self.documentationUrl = documentationUrl
        self.executionRoleArn = executionRoleArn
        self.isDefaultVersion = isDefaultVersion
        self.lastUpdated = lastUpdated
        self.loggingConfig = loggingConfig
        self.provisioningType = provisioningType
        self.schema = schema
        self.sourceUrl = sourceUrl
        self.timeCreated = timeCreated
        self.type = type
        self.typeName = typeName
        self.visibility = visibility
    }
}

struct DescribeTypeOutputResponseBody: Equatable {
    public let arn: String?
    public let type: RegistryType?
    public let typeName: String?
    public let defaultVersionId: String?
    public let isDefaultVersion: Bool?
    public let description: String?
    public let schema: String?
    public let provisioningType: ProvisioningType?
    public let deprecatedStatus: DeprecatedStatus?
    public let loggingConfig: LoggingConfig?
    public let executionRoleArn: String?
    public let visibility: Visibility?
    public let sourceUrl: String?
    public let documentationUrl: String?
    public let lastUpdated: Date?
    public let timeCreated: Date?
}

extension DescribeTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case defaultVersionId = "DefaultVersionId"
        case deprecatedStatus = "DeprecatedStatus"
        case description = "Description"
        case documentationUrl = "DocumentationUrl"
        case executionRoleArn = "ExecutionRoleArn"
        case isDefaultVersion = "IsDefaultVersion"
        case lastUpdated = "LastUpdated"
        case loggingConfig = "LoggingConfig"
        case provisioningType = "ProvisioningType"
        case schema = "Schema"
        case sourceUrl = "SourceUrl"
        case timeCreated = "TimeCreated"
        case type = "Type"
        case typeName = "TypeName"
        case visibility = "Visibility"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeTypeResult"))
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(RegistryType.self, forKey: .type)
        type = typeDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
        let isDefaultVersionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isDefaultVersion)
        isDefaultVersion = isDefaultVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
        let provisioningTypeDecoded = try containerValues.decodeIfPresent(ProvisioningType.self, forKey: .provisioningType)
        provisioningType = provisioningTypeDecoded
        let deprecatedStatusDecoded = try containerValues.decodeIfPresent(DeprecatedStatus.self, forKey: .deprecatedStatus)
        deprecatedStatus = deprecatedStatusDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let sourceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceUrl)
        sourceUrl = sourceUrlDecoded
        let documentationUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentationUrl)
        documentationUrl = documentationUrlDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdated)
        var lastUpdatedBuffer:Date? = nil
        if let lastUpdatedDecoded = lastUpdatedDecoded {
            lastUpdatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastUpdatedDecoded, format: .dateTime)
        }
        lastUpdated = lastUpdatedBuffer
        let timeCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeCreated)
        var timeCreatedBuffer:Date? = nil
        if let timeCreatedDecoded = timeCreatedDecoded {
            timeCreatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(timeCreatedDecoded, format: .dateTime)
        }
        timeCreated = timeCreatedBuffer
    }
}

public struct DescribeTypeRegistrationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTypeRegistrationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTypeRegistrationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTypeRegistrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTypeRegistrationInput>
    public typealias MOutput = OperationOutput<DescribeTypeRegistrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTypeRegistrationOutputError>
}

extension DescribeTypeRegistrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTypeRegistrationInput(registrationToken: \(String(describing: registrationToken)))"}
}

extension DescribeTypeRegistrationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let registrationToken = registrationToken {
            try container.encode(registrationToken, forKey: Key("RegistrationToken"))
        }
        try container.encode("DescribeTypeRegistration", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DescribeTypeRegistrationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTypeRegistrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTypeRegistrationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTypeRegistrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTypeRegistrationInput>
    public typealias MOutput = OperationOutput<DescribeTypeRegistrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTypeRegistrationOutputError>
}

public struct DescribeTypeRegistrationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTypeRegistrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTypeRegistrationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTypeRegistrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTypeRegistrationInput>
    public typealias MOutput = OperationOutput<DescribeTypeRegistrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTypeRegistrationOutputError>
}

public struct DescribeTypeRegistrationInput: Equatable {
    /// <p>The identifier for this registration request.</p>
    ///          <p>This registration token is generated by CloudFormation when you initiate a registration request using <code>
    ///                <a>RegisterType</a>
    ///             </code>.</p>
    public let registrationToken: String?

    public init (
        registrationToken: String? = nil
    )
    {
        self.registrationToken = registrationToken
    }
}

extension DescribeTypeRegistrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeTypeRegistrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CFNRegistryException" : self = .cFNRegistryException(try CFNRegistryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTypeRegistrationOutputError: Equatable {
    case cFNRegistryException(CFNRegistryException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTypeRegistrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTypeRegistrationOutputResponse(description: \(String(describing: description)), progressStatus: \(String(describing: progressStatus)), typeArn: \(String(describing: typeArn)), typeVersionArn: \(String(describing: typeVersionArn)))"}
}

extension DescribeTypeRegistrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTypeRegistrationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.progressStatus = output.progressStatus
            self.typeArn = output.typeArn
            self.typeVersionArn = output.typeVersionArn
        } else {
            self.description = nil
            self.progressStatus = nil
            self.typeArn = nil
            self.typeVersionArn = nil
        }
    }
}

public struct DescribeTypeRegistrationOutputResponse: Equatable {
    /// <p>The description of the extension registration request.</p>
    public let description: String?
    /// <p>The current status of the extension registration request.</p>
    public let progressStatus: RegistrationStatus?
    /// <p>The Amazon Resource Name (ARN) of the extension being registered.</p>
    ///          <p>For registration requests with a <code>ProgressStatus</code> of other than <code>COMPLETE</code>, this will be <code>null</code>.</p>
    public let typeArn: String?
    /// <p>The Amazon Resource Name (ARN) of this specific version of the extension being registered.</p>
    ///          <p>For registration requests with a <code>ProgressStatus</code> of other than <code>COMPLETE</code>, this will be <code>null</code>.</p>
    public let typeVersionArn: String?

    public init (
        description: String? = nil,
        progressStatus: RegistrationStatus? = nil,
        typeArn: String? = nil,
        typeVersionArn: String? = nil
    )
    {
        self.description = description
        self.progressStatus = progressStatus
        self.typeArn = typeArn
        self.typeVersionArn = typeVersionArn
    }
}

struct DescribeTypeRegistrationOutputResponseBody: Equatable {
    public let progressStatus: RegistrationStatus?
    public let description: String?
    public let typeArn: String?
    public let typeVersionArn: String?
}

extension DescribeTypeRegistrationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case progressStatus = "ProgressStatus"
        case typeArn = "TypeArn"
        case typeVersionArn = "TypeVersionArn"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeTypeRegistrationResult"))
        let progressStatusDecoded = try containerValues.decodeIfPresent(RegistrationStatus.self, forKey: .progressStatus)
        progressStatus = progressStatusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeArn)
        typeArn = typeArnDecoded
        let typeVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeVersionArn)
        typeVersionArn = typeVersionArnDecoded
    }
}

public struct DetectStackDriftInputBodyMiddleware: Middleware {
    public let id: String = "DetectStackDriftInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectStackDriftInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectStackDriftOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectStackDriftInput>
    public typealias MOutput = OperationOutput<DetectStackDriftOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectStackDriftOutputError>
}

extension DetectStackDriftInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectStackDriftInput(logicalResourceIds: \(String(describing: logicalResourceIds)), stackName: \(String(describing: stackName)))"}
}

extension DetectStackDriftInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let logicalResourceIds = logicalResourceIds {
            var logicalResourceIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LogicalResourceIds"))
            for (index0, logicalresourceid0) in logicalResourceIds.enumerated() {
                try logicalResourceIdsContainer.encode(logicalresourceid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        try container.encode("DetectStackDrift", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DetectStackDriftInputHeadersMiddleware: Middleware {
    public let id: String = "DetectStackDriftInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectStackDriftInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectStackDriftOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectStackDriftInput>
    public typealias MOutput = OperationOutput<DetectStackDriftOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectStackDriftOutputError>
}

public struct DetectStackDriftInputQueryItemMiddleware: Middleware {
    public let id: String = "DetectStackDriftInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectStackDriftInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectStackDriftOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectStackDriftInput>
    public typealias MOutput = OperationOutput<DetectStackDriftOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectStackDriftOutputError>
}

public struct DetectStackDriftInput: Equatable {
    /// <p>The logical names of any resources you want to use as filters.</p>
    public let logicalResourceIds: [String]?
    /// <p>The name of the stack for which you want to detect drift. </p>
    public let stackName: String?

    public init (
        logicalResourceIds: [String]? = nil,
        stackName: String? = nil
    )
    {
        self.logicalResourceIds = logicalResourceIds
        self.stackName = stackName
    }
}

extension DetectStackDriftOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DetectStackDriftOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectStackDriftOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectStackDriftOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectStackDriftOutputResponse(stackDriftDetectionId: \(String(describing: stackDriftDetectionId)))"}
}

extension DetectStackDriftOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetectStackDriftOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stackDriftDetectionId = output.stackDriftDetectionId
        } else {
            self.stackDriftDetectionId = nil
        }
    }
}

public struct DetectStackDriftOutputResponse: Equatable {
    /// <p>The ID of the drift detection results of this operation. </p>
    ///          <p>AWS CloudFormation generates new results, with a new drift detection ID, each time this operation
    ///          is run. However, the number of drift results AWS CloudFormation retains for any given stack, and for how
    ///          long, may vary. </p>
    public let stackDriftDetectionId: String?

    public init (
        stackDriftDetectionId: String? = nil
    )
    {
        self.stackDriftDetectionId = stackDriftDetectionId
    }
}

struct DetectStackDriftOutputResponseBody: Equatable {
    public let stackDriftDetectionId: String?
}

extension DetectStackDriftOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackDriftDetectionId = "StackDriftDetectionId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DetectStackDriftResult"))
        let stackDriftDetectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackDriftDetectionId)
        stackDriftDetectionId = stackDriftDetectionIdDecoded
    }
}

public struct DetectStackResourceDriftInputBodyMiddleware: Middleware {
    public let id: String = "DetectStackResourceDriftInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectStackResourceDriftInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectStackResourceDriftOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectStackResourceDriftInput>
    public typealias MOutput = OperationOutput<DetectStackResourceDriftOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectStackResourceDriftOutputError>
}

extension DetectStackResourceDriftInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectStackResourceDriftInput(logicalResourceId: \(String(describing: logicalResourceId)), stackName: \(String(describing: stackName)))"}
}

extension DetectStackResourceDriftInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let logicalResourceId = logicalResourceId {
            try container.encode(logicalResourceId, forKey: Key("LogicalResourceId"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        try container.encode("DetectStackResourceDrift", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DetectStackResourceDriftInputHeadersMiddleware: Middleware {
    public let id: String = "DetectStackResourceDriftInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectStackResourceDriftInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectStackResourceDriftOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectStackResourceDriftInput>
    public typealias MOutput = OperationOutput<DetectStackResourceDriftOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectStackResourceDriftOutputError>
}

public struct DetectStackResourceDriftInputQueryItemMiddleware: Middleware {
    public let id: String = "DetectStackResourceDriftInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectStackResourceDriftInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectStackResourceDriftOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectStackResourceDriftInput>
    public typealias MOutput = OperationOutput<DetectStackResourceDriftOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectStackResourceDriftOutputError>
}

public struct DetectStackResourceDriftInput: Equatable {
    /// <p>The logical name of the resource for which to return drift information.</p>
    public let logicalResourceId: String?
    /// <p>The name of the stack to which the resource belongs.</p>
    public let stackName: String?

    public init (
        logicalResourceId: String? = nil,
        stackName: String? = nil
    )
    {
        self.logicalResourceId = logicalResourceId
        self.stackName = stackName
    }
}

extension DetectStackResourceDriftOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DetectStackResourceDriftOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectStackResourceDriftOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectStackResourceDriftOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectStackResourceDriftOutputResponse(stackResourceDrift: \(String(describing: stackResourceDrift)))"}
}

extension DetectStackResourceDriftOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetectStackResourceDriftOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stackResourceDrift = output.stackResourceDrift
        } else {
            self.stackResourceDrift = nil
        }
    }
}

public struct DetectStackResourceDriftOutputResponse: Equatable {
    /// <p>Information about whether the resource's actual configuration has drifted from its
    ///          expected template configuration, including actual and expected property values and any
    ///          differences detected.</p>
    public let stackResourceDrift: StackResourceDrift?

    public init (
        stackResourceDrift: StackResourceDrift? = nil
    )
    {
        self.stackResourceDrift = stackResourceDrift
    }
}

struct DetectStackResourceDriftOutputResponseBody: Equatable {
    public let stackResourceDrift: StackResourceDrift?
}

extension DetectStackResourceDriftOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackResourceDrift = "StackResourceDrift"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DetectStackResourceDriftResult"))
        let stackResourceDriftDecoded = try containerValues.decodeIfPresent(StackResourceDrift.self, forKey: .stackResourceDrift)
        stackResourceDrift = stackResourceDriftDecoded
    }
}

public struct DetectStackSetDriftInputBodyMiddleware: Middleware {
    public let id: String = "DetectStackSetDriftInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectStackSetDriftInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectStackSetDriftOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectStackSetDriftInput>
    public typealias MOutput = OperationOutput<DetectStackSetDriftOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectStackSetDriftOutputError>
}

extension DetectStackSetDriftInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectStackSetDriftInput(callAs: \(String(describing: callAs)), operationId: \(String(describing: operationId)), operationPreferences: \(String(describing: operationPreferences)), stackSetName: \(String(describing: stackSetName)))"}
}

extension DetectStackSetDriftInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let callAs = callAs {
            try container.encode(callAs, forKey: Key("CallAs"))
        }
        if let operationId = operationId {
            try container.encode(operationId, forKey: Key("OperationId"))
        }
        if let operationPreferences = operationPreferences {
            try container.encode(operationPreferences, forKey: Key("OperationPreferences"))
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        try container.encode("DetectStackSetDrift", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct DetectStackSetDriftInputHeadersMiddleware: Middleware {
    public let id: String = "DetectStackSetDriftInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectStackSetDriftInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectStackSetDriftOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectStackSetDriftInput>
    public typealias MOutput = OperationOutput<DetectStackSetDriftOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectStackSetDriftOutputError>
}

public struct DetectStackSetDriftInputQueryItemMiddleware: Middleware {
    public let id: String = "DetectStackSetDriftInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectStackSetDriftInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectStackSetDriftOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectStackSetDriftInput>
    public typealias MOutput = OperationOutput<DetectStackSetDriftOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectStackSetDriftOutputError>
}

public struct DetectStackSetDriftInput: Equatable {
    /// <p>[Service-managed permissions] Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account.</p>
    ///          <p>By default, <code>SELF</code> is specified. Use <code>SELF</code> for stack sets with self-managed permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you are signed in to the management account, specify <code>SELF</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you are signed in to a delegated administrator account, specify <code>DELEGATED_ADMIN</code>.</p>
    ///                <p>Your AWS account must be registered as a delegated administrator in the management account. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-orgs-delegated-admin.html">Register a delegated administrator</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let callAs: CallAs?
    /// <p>
    ///             <i>The ID of the stack set operation.</i>
    ///          </p>
    public var operationId: String?
    /// <p>The user-specified preferences for how AWS CloudFormation performs a stack set
    ///          operation. </p>
    ///          <p>For more information on maximum concurrent accounts and failure tolerance, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-concepts.html#stackset-ops-options">Stack set operation options</a>.</p>
    public let operationPreferences: StackSetOperationPreferences?
    /// <p>The name of the stack set on which to perform the drift detection operation.</p>
    public let stackSetName: String?

    public init (
        callAs: CallAs? = nil,
        operationId: String? = nil,
        operationPreferences: StackSetOperationPreferences? = nil,
        stackSetName: String? = nil
    )
    {
        self.callAs = callAs
        self.operationId = operationId
        self.operationPreferences = operationPreferences
        self.stackSetName = stackSetName
    }
}

extension DetectStackSetDriftOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DetectStackSetDriftOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StackSetNotFoundException" : self = .stackSetNotFoundException(try StackSetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectStackSetDriftOutputError: Equatable {
    case invalidOperationException(InvalidOperationException)
    case operationInProgressException(OperationInProgressException)
    case stackSetNotFoundException(StackSetNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectStackSetDriftOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectStackSetDriftOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension DetectStackSetDriftOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetectStackSetDriftOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct DetectStackSetDriftOutputResponse: Equatable {
    /// <p>The ID of the drift detection stack set operation. </p>
    ///          <p>you can use this operation id with <code>
    ///                <a>DescribeStackSetOperation</a>
    ///             </code> to monitor the progress of the drift detection operation. </p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct DetectStackSetDriftOutputResponseBody: Equatable {
    public let operationId: String?
}

extension DetectStackSetDriftOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DetectStackSetDriftResult"))
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public enum DifferenceType {
    case add
    case notEqual
    case remove
    case sdkUnknown(String)
}

extension DifferenceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DifferenceType] {
        return [
            .add,
            .notEqual,
            .remove,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .add: return "ADD"
        case .notEqual: return "NOT_EQUAL"
        case .remove: return "REMOVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DifferenceType(rawValue: rawValue) ?? DifferenceType.sdkUnknown(rawValue)
    }
}

public struct EstimateTemplateCostInputBodyMiddleware: Middleware {
    public let id: String = "EstimateTemplateCostInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EstimateTemplateCostInput>,
                  next: H) -> Swift.Result<OperationOutput<EstimateTemplateCostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EstimateTemplateCostInput>
    public typealias MOutput = OperationOutput<EstimateTemplateCostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EstimateTemplateCostOutputError>
}

extension EstimateTemplateCostInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EstimateTemplateCostInput(parameters: \(String(describing: parameters)), templateBody: \(String(describing: templateBody)), templateURL: \(String(describing: templateURL)))"}
}

extension EstimateTemplateCostInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let templateBody = templateBody {
            try container.encode(templateBody, forKey: Key("TemplateBody"))
        }
        if let templateURL = templateURL {
            try container.encode(templateURL, forKey: Key("TemplateURL"))
        }
        try container.encode("EstimateTemplateCost", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct EstimateTemplateCostInputHeadersMiddleware: Middleware {
    public let id: String = "EstimateTemplateCostInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EstimateTemplateCostInput>,
                  next: H) -> Swift.Result<OperationOutput<EstimateTemplateCostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EstimateTemplateCostInput>
    public typealias MOutput = OperationOutput<EstimateTemplateCostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EstimateTemplateCostOutputError>
}

public struct EstimateTemplateCostInputQueryItemMiddleware: Middleware {
    public let id: String = "EstimateTemplateCostInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EstimateTemplateCostInput>,
                  next: H) -> Swift.Result<OperationOutput<EstimateTemplateCostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EstimateTemplateCostInput>
    public typealias MOutput = OperationOutput<EstimateTemplateCostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EstimateTemplateCostOutputError>
}

/// <p>The input for an <a>EstimateTemplateCost</a> action.</p>
public struct EstimateTemplateCostInput: Equatable {
    /// <p>A list of <code>Parameter</code> structures that specify input parameters.</p>
    public let parameters: [Parameter]?
    /// <p>Structure containing the template body with a minimum length of 1 byte and a maximum
    ///          length of 51,200 bytes. (For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html">Template Anatomy</a>
    ///          in the AWS CloudFormation User Guide.)</p>
    ///          <p>Conditional: You must pass <code>TemplateBody</code> or <code>TemplateURL</code>. If
    ///          both are passed, only <code>TemplateBody</code> is used.</p>
    public let templateBody: String?
    /// <p>Location of file containing the template body. The URL must point to a template that
    ///          is located in an Amazon S3 bucket or a Systems Manager document. For more information, go to
    ///             <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html">Template Anatomy</a>
    ///          in the AWS CloudFormation User Guide.</p>
    ///          <p>Conditional: You must pass <code>TemplateURL</code> or <code>TemplateBody</code>. If
    ///          both are passed, only <code>TemplateBody</code> is used.</p>
    public let templateURL: String?

    public init (
        parameters: [Parameter]? = nil,
        templateBody: String? = nil,
        templateURL: String? = nil
    )
    {
        self.parameters = parameters
        self.templateBody = templateBody
        self.templateURL = templateURL
    }
}

extension EstimateTemplateCostOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension EstimateTemplateCostOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EstimateTemplateCostOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension EstimateTemplateCostOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EstimateTemplateCostOutputResponse(url: \(String(describing: url)))"}
}

extension EstimateTemplateCostOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EstimateTemplateCostOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.url = output.url
        } else {
            self.url = nil
        }
    }
}

/// <p>The output for a <a>EstimateTemplateCost</a> action.</p>
public struct EstimateTemplateCostOutputResponse: Equatable {
    /// <p>An AWS Simple Monthly Calculator URL with a query string that describes the resources
    ///          required to run the template.</p>
    public let url: String?

    public init (
        url: String? = nil
    )
    {
        self.url = url
    }
}

struct EstimateTemplateCostOutputResponseBody: Equatable {
    public let url: String?
}

extension EstimateTemplateCostOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case url = "Url"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("EstimateTemplateCostResult"))
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

public enum EvaluationType {
    case `dynamic`
    case `static`
    case sdkUnknown(String)
}

extension EvaluationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EvaluationType] {
        return [
            .dynamic,
            .static,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dynamic: return "Dynamic"
        case .static: return "Static"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EvaluationType(rawValue: rawValue) ?? EvaluationType.sdkUnknown(rawValue)
    }
}

public struct ExecuteChangeSetInputBodyMiddleware: Middleware {
    public let id: String = "ExecuteChangeSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteChangeSetInput>
    public typealias MOutput = OperationOutput<ExecuteChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteChangeSetOutputError>
}

extension ExecuteChangeSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteChangeSetInput(changeSetName: \(String(describing: changeSetName)), clientRequestToken: \(String(describing: clientRequestToken)), stackName: \(String(describing: stackName)))"}
}

extension ExecuteChangeSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let changeSetName = changeSetName {
            try container.encode(changeSetName, forKey: Key("ChangeSetName"))
        }
        if let clientRequestToken = clientRequestToken {
            try container.encode(clientRequestToken, forKey: Key("ClientRequestToken"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        try container.encode("ExecuteChangeSet", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct ExecuteChangeSetInputHeadersMiddleware: Middleware {
    public let id: String = "ExecuteChangeSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteChangeSetInput>
    public typealias MOutput = OperationOutput<ExecuteChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteChangeSetOutputError>
}

public struct ExecuteChangeSetInputQueryItemMiddleware: Middleware {
    public let id: String = "ExecuteChangeSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteChangeSetInput>
    public typealias MOutput = OperationOutput<ExecuteChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteChangeSetOutputError>
}

/// <p>The input for the <a>ExecuteChangeSet</a> action.</p>
public struct ExecuteChangeSetInput: Equatable {
    /// <p>The name or ARN of the change set that you want use to update the specified
    ///          stack.</p>
    public let changeSetName: String?
    /// <p>A unique identifier for this <code>ExecuteChangeSet</code> request. Specify this
    ///          token if you plan to retry requests so that AWS CloudFormation knows that you're not
    ///          attempting to execute a change set to update a stack with the same name. You might retry
    ///          <code>ExecuteChangeSet</code> requests to ensure that AWS CloudFormation successfully
    ///          received them.</p>
    public let clientRequestToken: String?
    /// <p>If you specified the name of a change set, specify the stack name or ID (ARN) that is
    ///          associated with the change set you want to execute.</p>
    public let stackName: String?

    public init (
        changeSetName: String? = nil,
        clientRequestToken: String? = nil,
        stackName: String? = nil
    )
    {
        self.changeSetName = changeSetName
        self.clientRequestToken = clientRequestToken
        self.stackName = stackName
    }
}

extension ExecuteChangeSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ExecuteChangeSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ChangeSetNotFoundException" : self = .changeSetNotFoundException(try ChangeSetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientCapabilitiesException" : self = .insufficientCapabilitiesException(try InsufficientCapabilitiesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidChangeSetStatusException" : self = .invalidChangeSetStatusException(try InvalidChangeSetStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TokenAlreadyExistsException" : self = .tokenAlreadyExistsException(try TokenAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExecuteChangeSetOutputError: Equatable {
    case changeSetNotFoundException(ChangeSetNotFoundException)
    case insufficientCapabilitiesException(InsufficientCapabilitiesException)
    case invalidChangeSetStatusException(InvalidChangeSetStatusException)
    case tokenAlreadyExistsException(TokenAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteChangeSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteChangeSetOutputResponse()"}
}

extension ExecuteChangeSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The output for the <a>ExecuteChangeSet</a> action.</p>
public struct ExecuteChangeSetOutputResponse: Equatable {

    public init() {}
}

struct ExecuteChangeSetOutputResponseBody: Equatable {
}

extension ExecuteChangeSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum ExecutionStatus {
    case available
    case executeComplete
    case executeFailed
    case executeInProgress
    case obsolete
    case unavailable
    case sdkUnknown(String)
}

extension ExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExecutionStatus] {
        return [
            .available,
            .executeComplete,
            .executeFailed,
            .executeInProgress,
            .obsolete,
            .unavailable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .executeComplete: return "EXECUTE_COMPLETE"
        case .executeFailed: return "EXECUTE_FAILED"
        case .executeInProgress: return "EXECUTE_IN_PROGRESS"
        case .obsolete: return "OBSOLETE"
        case .unavailable: return "UNAVAILABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExecutionStatus(rawValue: rawValue) ?? ExecutionStatus.sdkUnknown(rawValue)
    }
}

extension Export: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exportingStackId = "ExportingStackId"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let exportingStackId = exportingStackId {
            try container.encode(exportingStackId, forKey: Key("ExportingStackId"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportingStackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportingStackId)
        exportingStackId = exportingStackIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Export: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Export(exportingStackId: \(String(describing: exportingStackId)), name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>The <code>Export</code> structure describes the exported output values for a
///          stack.</p>
public struct Export: Equatable {
    /// <p>The stack that contains the exported output name and value.</p>
    public let exportingStackId: String?
    /// <p>The name of exported output value. Use this name and the <code>Fn::ImportValue</code>
    ///          function to import the associated value into other stacks. The name is defined in the
    ///             <code>Export</code> field in the associated stack's <code>Outputs</code>
    ///          section.</p>
    public let name: String?
    /// <p>The value of the exported output, such as a resource physical ID. This value is
    ///          defined in the <code>Export</code> field in the associated stack's <code>Outputs</code>
    ///          section.</p>
    public let value: String?

    public init (
        exportingStackId: String? = nil,
        name: String? = nil,
        value: String? = nil
    )
    {
        self.exportingStackId = exportingStackId
        self.name = name
        self.value = value
    }
}

public struct GetStackPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetStackPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStackPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStackPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStackPolicyInput>
    public typealias MOutput = OperationOutput<GetStackPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStackPolicyOutputError>
}

extension GetStackPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStackPolicyInput(stackName: \(String(describing: stackName)))"}
}

extension GetStackPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        try container.encode("GetStackPolicy", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct GetStackPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetStackPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStackPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStackPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStackPolicyInput>
    public typealias MOutput = OperationOutput<GetStackPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStackPolicyOutputError>
}

public struct GetStackPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStackPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStackPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStackPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStackPolicyInput>
    public typealias MOutput = OperationOutput<GetStackPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStackPolicyOutputError>
}

/// <p>The input for the <a>GetStackPolicy</a> action.</p>
public struct GetStackPolicyInput: Equatable {
    /// <p>The name or unique stack ID that is associated with the stack whose policy you want
    ///          to get.</p>
    public let stackName: String?

    public init (
        stackName: String? = nil
    )
    {
        self.stackName = stackName
    }
}

extension GetStackPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetStackPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStackPolicyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStackPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStackPolicyOutputResponse(stackPolicyBody: \(String(describing: stackPolicyBody)))"}
}

extension GetStackPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetStackPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stackPolicyBody = output.stackPolicyBody
        } else {
            self.stackPolicyBody = nil
        }
    }
}

/// <p>The output for the <a>GetStackPolicy</a> action.</p>
public struct GetStackPolicyOutputResponse: Equatable {
    /// <p>Structure containing the stack policy body. (For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/protect-stack-resources.html"> Prevent Updates
    ///             to Stack Resources</a> in the AWS CloudFormation User Guide.)</p>
    public let stackPolicyBody: String?

    public init (
        stackPolicyBody: String? = nil
    )
    {
        self.stackPolicyBody = stackPolicyBody
    }
}

struct GetStackPolicyOutputResponseBody: Equatable {
    public let stackPolicyBody: String?
}

extension GetStackPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackPolicyBody = "StackPolicyBody"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetStackPolicyResult"))
        let stackPolicyBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackPolicyBody)
        stackPolicyBody = stackPolicyBodyDecoded
    }
}

public struct GetTemplateInputBodyMiddleware: Middleware {
    public let id: String = "GetTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTemplateInput>
    public typealias MOutput = OperationOutput<GetTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTemplateOutputError>
}

extension GetTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTemplateInput(changeSetName: \(String(describing: changeSetName)), stackName: \(String(describing: stackName)), templateStage: \(String(describing: templateStage)))"}
}

extension GetTemplateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let changeSetName = changeSetName {
            try container.encode(changeSetName, forKey: Key("ChangeSetName"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        if let templateStage = templateStage {
            try container.encode(templateStage, forKey: Key("TemplateStage"))
        }
        try container.encode("GetTemplate", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct GetTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTemplateInput>
    public typealias MOutput = OperationOutput<GetTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTemplateOutputError>
}

public struct GetTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTemplateInput>
    public typealias MOutput = OperationOutput<GetTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTemplateOutputError>
}

/// <p>The input for a <a>GetTemplate</a> action.</p>
public struct GetTemplateInput: Equatable {
    /// <p>The name or Amazon Resource Name (ARN) of a change set for which AWS CloudFormation
    ///          returns the associated template. If you specify a name, you must also specify the
    ///             <code>StackName</code>.</p>
    public let changeSetName: String?
    /// <p>The name or the unique stack ID that is associated with the stack, which are not
    ///          always interchangeable:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Running stacks: You can specify either the stack's name or its unique stack
    ///                ID.</p>
    ///             </li>
    ///             <li>
    ///                <p>Deleted stacks: You must specify the unique stack ID.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Default: There is no default value.</p>
    public let stackName: String?
    /// <p>For templates that include transforms, the stage of the template that AWS
    ///          CloudFormation returns. To get the user-submitted template, specify <code>Original</code>.
    ///          To get the template after AWS CloudFormation has processed all transforms, specify
    ///             <code>Processed</code>. </p>
    ///          <p>If the template doesn't include transforms, <code>Original</code> and
    ///             <code>Processed</code> return the same template. By default, AWS CloudFormation
    ///          specifies <code>Original</code>. </p>
    public let templateStage: TemplateStage?

    public init (
        changeSetName: String? = nil,
        stackName: String? = nil,
        templateStage: TemplateStage? = nil
    )
    {
        self.changeSetName = changeSetName
        self.stackName = stackName
        self.templateStage = templateStage
    }
}

extension GetTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ChangeSetNotFoundException" : self = .changeSetNotFoundException(try ChangeSetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTemplateOutputError: Equatable {
    case changeSetNotFoundException(ChangeSetNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTemplateOutputResponse(stagesAvailable: \(String(describing: stagesAvailable)), templateBody: \(String(describing: templateBody)))"}
}

extension GetTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stagesAvailable = output.stagesAvailable
            self.templateBody = output.templateBody
        } else {
            self.stagesAvailable = nil
            self.templateBody = nil
        }
    }
}

/// <p>The output for <a>GetTemplate</a> action.</p>
public struct GetTemplateOutputResponse: Equatable {
    /// <p>The stage of the template that you can retrieve. For stacks, the
    ///             <code>Original</code> and <code>Processed</code> templates are always available. For
    ///          change sets, the <code>Original</code> template is always available. After AWS
    ///          CloudFormation finishes creating the change set, the <code>Processed</code> template
    ///          becomes available.</p>
    public let stagesAvailable: [TemplateStage]?
    /// <p>Structure containing the template body. (For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html">Template Anatomy</a> in the AWS CloudFormation User Guide.)</p>
    ///          <p>AWS CloudFormation returns the same template that was used when the stack was
    ///          created.</p>
    public let templateBody: String?

    public init (
        stagesAvailable: [TemplateStage]? = nil,
        templateBody: String? = nil
    )
    {
        self.stagesAvailable = stagesAvailable
        self.templateBody = templateBody
    }
}

struct GetTemplateOutputResponseBody: Equatable {
    public let templateBody: String?
    public let stagesAvailable: [TemplateStage]?
}

extension GetTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stagesAvailable = "StagesAvailable"
        case templateBody = "TemplateBody"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetTemplateResult"))
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        if containerValues.contains(.stagesAvailable) {
            struct KeyVal0{struct member{}}
            let stagesAvailableWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .stagesAvailable)
            if let stagesAvailableWrappedContainer = stagesAvailableWrappedContainer {
                let stagesAvailableContainer = try stagesAvailableWrappedContainer.decodeIfPresent([TemplateStage].self, forKey: .member)
                var stagesAvailableBuffer:[TemplateStage]? = nil
                if let stagesAvailableContainer = stagesAvailableContainer {
                    stagesAvailableBuffer = [TemplateStage]()
                    for stringContainer0 in stagesAvailableContainer {
                        stagesAvailableBuffer?.append(stringContainer0)
                    }
                }
                stagesAvailable = stagesAvailableBuffer
            } else {
                stagesAvailable = []
            }
        } else {
            stagesAvailable = nil
        }
    }
}

public struct GetTemplateSummaryInputBodyMiddleware: Middleware {
    public let id: String = "GetTemplateSummaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTemplateSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTemplateSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTemplateSummaryInput>
    public typealias MOutput = OperationOutput<GetTemplateSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTemplateSummaryOutputError>
}

extension GetTemplateSummaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTemplateSummaryInput(callAs: \(String(describing: callAs)), stackName: \(String(describing: stackName)), stackSetName: \(String(describing: stackSetName)), templateBody: \(String(describing: templateBody)), templateURL: \(String(describing: templateURL)))"}
}

extension GetTemplateSummaryInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let callAs = callAs {
            try container.encode(callAs, forKey: Key("CallAs"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        if let templateBody = templateBody {
            try container.encode(templateBody, forKey: Key("TemplateBody"))
        }
        if let templateURL = templateURL {
            try container.encode(templateURL, forKey: Key("TemplateURL"))
        }
        try container.encode("GetTemplateSummary", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct GetTemplateSummaryInputHeadersMiddleware: Middleware {
    public let id: String = "GetTemplateSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTemplateSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTemplateSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTemplateSummaryInput>
    public typealias MOutput = OperationOutput<GetTemplateSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTemplateSummaryOutputError>
}

public struct GetTemplateSummaryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTemplateSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTemplateSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTemplateSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTemplateSummaryInput>
    public typealias MOutput = OperationOutput<GetTemplateSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTemplateSummaryOutputError>
}

/// <p>The input for the <a>GetTemplateSummary</a> action.</p>
public struct GetTemplateSummaryInput: Equatable {
    /// <p>[Service-managed permissions] Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account.</p>
    ///          <p>By default, <code>SELF</code> is specified. Use <code>SELF</code> for stack sets with self-managed permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you are signed in to the management account, specify <code>SELF</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you are signed in to a delegated administrator account, specify <code>DELEGATED_ADMIN</code>.</p>
    ///                <p>Your AWS account must be registered as a delegated administrator in the management account. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-orgs-delegated-admin.html">Register a delegated administrator</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let callAs: CallAs?
    /// <p>The name or the stack ID that is associated with the stack, which are not always
    ///          interchangeable. For running stacks, you can specify either the stack's name or its unique
    ///          stack ID. For deleted stack, you must specify the unique stack ID.</p>
    ///          <p>Conditional: You must specify only one of the following parameters:
    ///             <code>StackName</code>, <code>StackSetName</code>, <code>TemplateBody</code>, or
    ///             <code>TemplateURL</code>.</p>
    public let stackName: String?
    /// <p>The name or unique ID of the stack set from which the stack was created.</p>
    ///          <p>Conditional: You must specify only one of the following parameters:
    ///             <code>StackName</code>, <code>StackSetName</code>, <code>TemplateBody</code>, or
    ///             <code>TemplateURL</code>.</p>
    public let stackSetName: String?
    /// <p>Structure containing the template body with a minimum length of 1 byte and a maximum
    ///          length of 51,200 bytes. For more information about templates, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html">Template Anatomy</a> in the AWS CloudFormation User Guide.</p>
    ///          <p>Conditional: You must specify only one of the following parameters:
    ///             <code>StackName</code>, <code>StackSetName</code>, <code>TemplateBody</code>, or
    ///             <code>TemplateURL</code>.</p>
    public let templateBody: String?
    /// <p>Location of file containing the template body. The URL must point to a template (max
    ///          size: 460,800 bytes) that is located in an Amazon S3 bucket or a Systems Manager document.
    ///          For more information about templates, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html">Template Anatomy</a>
    ///          in the AWS CloudFormation User Guide.</p>
    ///          <p>Conditional: You must specify only one of the following parameters:
    ///             <code>StackName</code>, <code>StackSetName</code>, <code>TemplateBody</code>, or
    ///             <code>TemplateURL</code>.</p>
    public let templateURL: String?

    public init (
        callAs: CallAs? = nil,
        stackName: String? = nil,
        stackSetName: String? = nil,
        templateBody: String? = nil,
        templateURL: String? = nil
    )
    {
        self.callAs = callAs
        self.stackName = stackName
        self.stackSetName = stackSetName
        self.templateBody = templateBody
        self.templateURL = templateURL
    }
}

extension GetTemplateSummaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetTemplateSummaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "StackSetNotFoundException" : self = .stackSetNotFoundException(try StackSetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTemplateSummaryOutputError: Equatable {
    case stackSetNotFoundException(StackSetNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTemplateSummaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTemplateSummaryOutputResponse(capabilities: \(String(describing: capabilities)), capabilitiesReason: \(String(describing: capabilitiesReason)), declaredTransforms: \(String(describing: declaredTransforms)), description: \(String(describing: description)), metadata: \(String(describing: metadata)), parameters: \(String(describing: parameters)), resourceIdentifierSummaries: \(String(describing: resourceIdentifierSummaries)), resourceTypes: \(String(describing: resourceTypes)), version: \(String(describing: version)))"}
}

extension GetTemplateSummaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTemplateSummaryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.capabilities = output.capabilities
            self.capabilitiesReason = output.capabilitiesReason
            self.declaredTransforms = output.declaredTransforms
            self.description = output.description
            self.metadata = output.metadata
            self.parameters = output.parameters
            self.resourceIdentifierSummaries = output.resourceIdentifierSummaries
            self.resourceTypes = output.resourceTypes
            self.version = output.version
        } else {
            self.capabilities = nil
            self.capabilitiesReason = nil
            self.declaredTransforms = nil
            self.description = nil
            self.metadata = nil
            self.parameters = nil
            self.resourceIdentifierSummaries = nil
            self.resourceTypes = nil
            self.version = nil
        }
    }
}

/// <p>The output for the <a>GetTemplateSummary</a> action.</p>
public struct GetTemplateSummaryOutputResponse: Equatable {
    /// <p>The capabilities found within the template. If your template contains IAM resources,
    ///          you must specify the CAPABILITY_IAM or CAPABILITY_NAMED_IAM value for this parameter when
    ///          you use the <a>CreateStack</a> or <a>UpdateStack</a> actions with
    ///          your template; otherwise, those actions return an InsufficientCapabilities error.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#capabilities">Acknowledging IAM Resources in AWS CloudFormation Templates</a>.</p>
    public let capabilities: [Capability]?
    /// <p>The list of resources that generated the values in the <code>Capabilities</code>
    ///          response element.</p>
    public let capabilitiesReason: String?
    /// <p>A list of the transforms that are declared in the template.</p>
    public let declaredTransforms: [String]?
    /// <p>The value that is defined in the <code>Description</code> property of the
    ///          template.</p>
    public let description: String?
    /// <p>The value that is defined for the <code>Metadata</code> property of the
    ///          template.</p>
    public let metadata: String?
    /// <p>A list of parameter declarations that describe various properties for each
    ///          parameter.</p>
    public let parameters: [ParameterDeclaration]?
    /// <p>A list of resource identifier summaries that describe the target resources of an import
    ///          operation and the properties you can provide during the import to identify the target
    ///          resources. For example, <code>BucketName</code> is a possible identifier property for an
    ///             <code>AWS::S3::Bucket</code> resource. </p>
    public let resourceIdentifierSummaries: [ResourceIdentifierSummary]?
    /// <p>A list of all the template resource types that are defined in the template, such as
    ///             <code>AWS::EC2::Instance</code>, <code>AWS::Dynamo::Table</code>, and
    ///             <code>Custom::MyCustomInstance</code>.</p>
    public let resourceTypes: [String]?
    /// <p>The AWS template format version, which identifies the capabilities of the
    ///          template.</p>
    public let version: String?

    public init (
        capabilities: [Capability]? = nil,
        capabilitiesReason: String? = nil,
        declaredTransforms: [String]? = nil,
        description: String? = nil,
        metadata: String? = nil,
        parameters: [ParameterDeclaration]? = nil,
        resourceIdentifierSummaries: [ResourceIdentifierSummary]? = nil,
        resourceTypes: [String]? = nil,
        version: String? = nil
    )
    {
        self.capabilities = capabilities
        self.capabilitiesReason = capabilitiesReason
        self.declaredTransforms = declaredTransforms
        self.description = description
        self.metadata = metadata
        self.parameters = parameters
        self.resourceIdentifierSummaries = resourceIdentifierSummaries
        self.resourceTypes = resourceTypes
        self.version = version
    }
}

struct GetTemplateSummaryOutputResponseBody: Equatable {
    public let parameters: [ParameterDeclaration]?
    public let description: String?
    public let capabilities: [Capability]?
    public let capabilitiesReason: String?
    public let resourceTypes: [String]?
    public let version: String?
    public let metadata: String?
    public let declaredTransforms: [String]?
    public let resourceIdentifierSummaries: [ResourceIdentifierSummary]?
}

extension GetTemplateSummaryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case capabilities = "Capabilities"
        case capabilitiesReason = "CapabilitiesReason"
        case declaredTransforms = "DeclaredTransforms"
        case description = "Description"
        case metadata = "Metadata"
        case parameters = "Parameters"
        case resourceIdentifierSummaries = "ResourceIdentifierSummaries"
        case resourceTypes = "ResourceTypes"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetTemplateSummaryResult"))
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct member{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([ParameterDeclaration].self, forKey: .member)
                var parametersBuffer:[ParameterDeclaration]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [ParameterDeclaration]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        if containerValues.contains(.capabilities) {
            struct KeyVal0{struct member{}}
            let capabilitiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .capabilities)
            if let capabilitiesWrappedContainer = capabilitiesWrappedContainer {
                let capabilitiesContainer = try capabilitiesWrappedContainer.decodeIfPresent([Capability].self, forKey: .member)
                var capabilitiesBuffer:[Capability]? = nil
                if let capabilitiesContainer = capabilitiesContainer {
                    capabilitiesBuffer = [Capability]()
                    for stringContainer0 in capabilitiesContainer {
                        capabilitiesBuffer?.append(stringContainer0)
                    }
                }
                capabilities = capabilitiesBuffer
            } else {
                capabilities = []
            }
        } else {
            capabilities = nil
        }
        let capabilitiesReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .capabilitiesReason)
        capabilitiesReason = capabilitiesReasonDecoded
        if containerValues.contains(.resourceTypes) {
            struct KeyVal0{struct member{}}
            let resourceTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .resourceTypes)
            if let resourceTypesWrappedContainer = resourceTypesWrappedContainer {
                let resourceTypesContainer = try resourceTypesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var resourceTypesBuffer:[String]? = nil
                if let resourceTypesContainer = resourceTypesContainer {
                    resourceTypesBuffer = [String]()
                    for stringContainer0 in resourceTypesContainer {
                        resourceTypesBuffer?.append(stringContainer0)
                    }
                }
                resourceTypes = resourceTypesBuffer
            } else {
                resourceTypes = []
            }
        } else {
            resourceTypes = nil
        }
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metadata)
        metadata = metadataDecoded
        if containerValues.contains(.declaredTransforms) {
            struct KeyVal0{struct member{}}
            let declaredTransformsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .declaredTransforms)
            if let declaredTransformsWrappedContainer = declaredTransformsWrappedContainer {
                let declaredTransformsContainer = try declaredTransformsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var declaredTransformsBuffer:[String]? = nil
                if let declaredTransformsContainer = declaredTransformsContainer {
                    declaredTransformsBuffer = [String]()
                    for stringContainer0 in declaredTransformsContainer {
                        declaredTransformsBuffer?.append(stringContainer0)
                    }
                }
                declaredTransforms = declaredTransformsBuffer
            } else {
                declaredTransforms = []
            }
        } else {
            declaredTransforms = nil
        }
        if containerValues.contains(.resourceIdentifierSummaries) {
            struct KeyVal0{struct member{}}
            let resourceIdentifierSummariesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .resourceIdentifierSummaries)
            if let resourceIdentifierSummariesWrappedContainer = resourceIdentifierSummariesWrappedContainer {
                let resourceIdentifierSummariesContainer = try resourceIdentifierSummariesWrappedContainer.decodeIfPresent([ResourceIdentifierSummary].self, forKey: .member)
                var resourceIdentifierSummariesBuffer:[ResourceIdentifierSummary]? = nil
                if let resourceIdentifierSummariesContainer = resourceIdentifierSummariesContainer {
                    resourceIdentifierSummariesBuffer = [ResourceIdentifierSummary]()
                    for structureContainer0 in resourceIdentifierSummariesContainer {
                        resourceIdentifierSummariesBuffer?.append(structureContainer0)
                    }
                }
                resourceIdentifierSummaries = resourceIdentifierSummariesBuffer
            } else {
                resourceIdentifierSummaries = []
            }
        } else {
            resourceIdentifierSummaries = nil
        }
    }
}

public enum HandlerErrorCode {
    case accessdenied
    case alreadyexists
    case generalserviceexception
    case internalfailure
    case invalidcredentials
    case invalidrequest
    case networkfailure
    case notfound
    case notupdatable
    case resourceconflict
    case serviceinternalerror
    case servicelimitexceeded
    case servicetimeout
    case throttling
    case sdkUnknown(String)
}

extension HandlerErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HandlerErrorCode] {
        return [
            .accessdenied,
            .alreadyexists,
            .generalserviceexception,
            .internalfailure,
            .invalidcredentials,
            .invalidrequest,
            .networkfailure,
            .notfound,
            .notupdatable,
            .resourceconflict,
            .serviceinternalerror,
            .servicelimitexceeded,
            .servicetimeout,
            .throttling,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessdenied: return "AccessDenied"
        case .alreadyexists: return "AlreadyExists"
        case .generalserviceexception: return "GeneralServiceException"
        case .internalfailure: return "InternalFailure"
        case .invalidcredentials: return "InvalidCredentials"
        case .invalidrequest: return "InvalidRequest"
        case .networkfailure: return "NetworkFailure"
        case .notfound: return "NotFound"
        case .notupdatable: return "NotUpdatable"
        case .resourceconflict: return "ResourceConflict"
        case .serviceinternalerror: return "ServiceInternalError"
        case .servicelimitexceeded: return "ServiceLimitExceeded"
        case .servicetimeout: return "NotStabilized"
        case .throttling: return "Throttling"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HandlerErrorCode(rawValue: rawValue) ?? HandlerErrorCode.sdkUnknown(rawValue)
    }
}

extension InsufficientCapabilitiesException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientCapabilitiesException(message: \(String(describing: message)))"}
}

extension InsufficientCapabilitiesException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InsufficientCapabilitiesExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The template contains resources with capabilities that weren't specified in the
///          Capabilities parameter.</p>
public struct InsufficientCapabilitiesException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientCapabilitiesExceptionBody: Equatable {
    public let message: String?
}

extension InsufficientCapabilitiesExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidChangeSetStatusException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidChangeSetStatusException(message: \(String(describing: message)))"}
}

extension InvalidChangeSetStatusException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidChangeSetStatusExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified change set can't be used to update the stack. For example, the change
///          set status might be <code>CREATE_IN_PROGRESS</code>, or the stack status might be
///             <code>UPDATE_IN_PROGRESS</code>.</p>
public struct InvalidChangeSetStatusException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidChangeSetStatusExceptionBody: Equatable {
    public let message: String?
}

extension InvalidChangeSetStatusExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOperationException(message: \(String(describing: message)))"}
}

extension InvalidOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidOperationExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified operation isn't valid.</p>
public struct InvalidOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOperationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateTransitionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidStateTransitionException(message: \(String(describing: message)))"}
}

extension InvalidStateTransitionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidStateTransitionExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Error reserved for use by the <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/what-is-cloudformation-cli.html">CloudFormation CLI</a>. CloudFormation does not return this error to users.</p>
public struct InvalidStateTransitionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateTransitionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidStateTransitionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<LimitExceededExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The quota for the resource has already been reached.</p>
///          <p>For information on resource and stack limitations, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cloudformation-limits.html">Limits</a> in
///          the <i>AWS CloudFormation User Guide</i>.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListChangeSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListChangeSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChangeSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChangeSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChangeSetsInput>
    public typealias MOutput = OperationOutput<ListChangeSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChangeSetsOutputError>
}

extension ListChangeSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListChangeSetsInput(nextToken: \(String(describing: nextToken)), stackName: \(String(describing: stackName)))"}
}

extension ListChangeSetsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        try container.encode("ListChangeSets", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct ListChangeSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListChangeSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChangeSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChangeSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChangeSetsInput>
    public typealias MOutput = OperationOutput<ListChangeSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChangeSetsOutputError>
}

public struct ListChangeSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListChangeSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChangeSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChangeSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChangeSetsInput>
    public typealias MOutput = OperationOutput<ListChangeSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChangeSetsOutputError>
}

/// <p>The input for the <a>ListChangeSets</a> action.</p>
public struct ListChangeSetsInput: Equatable {
    /// <p>A string (provided by the <a>ListChangeSets</a> response output) that
    ///          identifies the next page of change sets that you want to retrieve.</p>
    public let nextToken: String?
    /// <p>The name or the Amazon Resource Name (ARN) of the stack for which you want to list
    ///          change sets.</p>
    public let stackName: String?

    public init (
        nextToken: String? = nil,
        stackName: String? = nil
    )
    {
        self.nextToken = nextToken
        self.stackName = stackName
    }
}

extension ListChangeSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListChangeSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChangeSetsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChangeSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListChangeSetsOutputResponse(nextToken: \(String(describing: nextToken)), summaries: \(String(describing: summaries)))"}
}

extension ListChangeSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListChangeSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

/// <p>The output for the <a>ListChangeSets</a> action.</p>
public struct ListChangeSetsOutputResponse: Equatable {
    /// <p>If the output exceeds 1 MB, a string that identifies the next page of change sets. If
    ///          there is no additional page, this value is null.</p>
    public let nextToken: String?
    /// <p>A list of <code>ChangeSetSummary</code> structures that provides the ID and status of
    ///          each change set for the specified stack.</p>
    public let summaries: [ChangeSetSummary]?

    public init (
        nextToken: String? = nil,
        summaries: [ChangeSetSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListChangeSetsOutputResponseBody: Equatable {
    public let summaries: [ChangeSetSummary]?
    public let nextToken: String?
}

extension ListChangeSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case summaries = "Summaries"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListChangeSetsResult"))
        if containerValues.contains(.summaries) {
            struct KeyVal0{struct member{}}
            let summariesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .summaries)
            if let summariesWrappedContainer = summariesWrappedContainer {
                let summariesContainer = try summariesWrappedContainer.decodeIfPresent([ChangeSetSummary].self, forKey: .member)
                var summariesBuffer:[ChangeSetSummary]? = nil
                if let summariesContainer = summariesContainer {
                    summariesBuffer = [ChangeSetSummary]()
                    for structureContainer0 in summariesContainer {
                        summariesBuffer?.append(structureContainer0)
                    }
                }
                summaries = summariesBuffer
            } else {
                summaries = []
            }
        } else {
            summaries = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListExportsInputBodyMiddleware: Middleware {
    public let id: String = "ListExportsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListExportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListExportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListExportsInput>
    public typealias MOutput = OperationOutput<ListExportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListExportsOutputError>
}

extension ListExportsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListExportsInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListExportsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("ListExports", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct ListExportsInputHeadersMiddleware: Middleware {
    public let id: String = "ListExportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListExportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListExportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListExportsInput>
    public typealias MOutput = OperationOutput<ListExportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListExportsOutputError>
}

public struct ListExportsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListExportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListExportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListExportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListExportsInput>
    public typealias MOutput = OperationOutput<ListExportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListExportsOutputError>
}

public struct ListExportsInput: Equatable {
    /// <p>A string (provided by the <a>ListExports</a> response output) that
    ///          identifies the next page of exported output values that you asked to retrieve.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension ListExportsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListExportsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListExportsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExportsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListExportsOutputResponse(exports: \(String(describing: exports)), nextToken: \(String(describing: nextToken)))"}
}

extension ListExportsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListExportsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exports = output.exports
            self.nextToken = output.nextToken
        } else {
            self.exports = nil
            self.nextToken = nil
        }
    }
}

public struct ListExportsOutputResponse: Equatable {
    /// <p>The output for the <a>ListExports</a> action.</p>
    public let exports: [Export]?
    /// <p>If the output exceeds 100 exported output values, a string that identifies the next
    ///          page of exports. If there is no additional page, this value is null.</p>
    public let nextToken: String?

    public init (
        exports: [Export]? = nil,
        nextToken: String? = nil
    )
    {
        self.exports = exports
        self.nextToken = nextToken
    }
}

struct ListExportsOutputResponseBody: Equatable {
    public let exports: [Export]?
    public let nextToken: String?
}

extension ListExportsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exports = "Exports"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListExportsResult"))
        if containerValues.contains(.exports) {
            struct KeyVal0{struct member{}}
            let exportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exports)
            if let exportsWrappedContainer = exportsWrappedContainer {
                let exportsContainer = try exportsWrappedContainer.decodeIfPresent([Export].self, forKey: .member)
                var exportsBuffer:[Export]? = nil
                if let exportsContainer = exportsContainer {
                    exportsBuffer = [Export]()
                    for structureContainer0 in exportsContainer {
                        exportsBuffer?.append(structureContainer0)
                    }
                }
                exports = exportsBuffer
            } else {
                exports = []
            }
        } else {
            exports = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListImportsInputBodyMiddleware: Middleware {
    public let id: String = "ListImportsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImportsInput>
    public typealias MOutput = OperationOutput<ListImportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImportsOutputError>
}

extension ListImportsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImportsInput(exportName: \(String(describing: exportName)), nextToken: \(String(describing: nextToken)))"}
}

extension ListImportsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let exportName = exportName {
            try container.encode(exportName, forKey: Key("ExportName"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("ListImports", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct ListImportsInputHeadersMiddleware: Middleware {
    public let id: String = "ListImportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImportsInput>
    public typealias MOutput = OperationOutput<ListImportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImportsOutputError>
}

public struct ListImportsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListImportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImportsInput>
    public typealias MOutput = OperationOutput<ListImportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImportsOutputError>
}

public struct ListImportsInput: Equatable {
    /// <p>The name of the exported output value. AWS CloudFormation returns the stack names
    ///          that are importing this value. </p>
    public let exportName: String?
    /// <p>A string (provided by the <a>ListImports</a> response output) that
    ///          identifies the next page of stacks that are importing the specified exported output value.
    ///       </p>
    public let nextToken: String?

    public init (
        exportName: String? = nil,
        nextToken: String? = nil
    )
    {
        self.exportName = exportName
        self.nextToken = nextToken
    }
}

extension ListImportsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListImportsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImportsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImportsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImportsOutputResponse(imports: \(String(describing: imports)), nextToken: \(String(describing: nextToken)))"}
}

extension ListImportsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListImportsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imports = output.imports
            self.nextToken = output.nextToken
        } else {
            self.imports = nil
            self.nextToken = nil
        }
    }
}

public struct ListImportsOutputResponse: Equatable {
    /// <p>A list of stack names that are importing the specified exported output value.
    ///       </p>
    public let imports: [String]?
    /// <p>A string that identifies the next page of exports. If there is no additional page,
    ///          this value is null.</p>
    public let nextToken: String?

    public init (
        imports: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.imports = imports
        self.nextToken = nextToken
    }
}

struct ListImportsOutputResponseBody: Equatable {
    public let imports: [String]?
    public let nextToken: String?
}

extension ListImportsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imports = "Imports"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListImportsResult"))
        if containerValues.contains(.imports) {
            struct KeyVal0{struct member{}}
            let importsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .imports)
            if let importsWrappedContainer = importsWrappedContainer {
                let importsContainer = try importsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var importsBuffer:[String]? = nil
                if let importsContainer = importsContainer {
                    importsBuffer = [String]()
                    for stringContainer0 in importsContainer {
                        importsBuffer?.append(stringContainer0)
                    }
                }
                imports = importsBuffer
            } else {
                imports = []
            }
        } else {
            imports = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStackInstancesInputBodyMiddleware: Middleware {
    public let id: String = "ListStackInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackInstancesInput>
    public typealias MOutput = OperationOutput<ListStackInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackInstancesOutputError>
}

extension ListStackInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStackInstancesInput(callAs: \(String(describing: callAs)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), stackInstanceAccount: \(String(describing: stackInstanceAccount)), stackInstanceRegion: \(String(describing: stackInstanceRegion)), stackSetName: \(String(describing: stackSetName)))"}
}

extension ListStackInstancesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let callAs = callAs {
            try container.encode(callAs, forKey: Key("CallAs"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Filters"))
            for (index0, stackinstancefilter0) in filters.enumerated() {
                try filtersContainer.encode(stackinstancefilter0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let stackInstanceAccount = stackInstanceAccount {
            try container.encode(stackInstanceAccount, forKey: Key("StackInstanceAccount"))
        }
        if let stackInstanceRegion = stackInstanceRegion {
            try container.encode(stackInstanceRegion, forKey: Key("StackInstanceRegion"))
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        try container.encode("ListStackInstances", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct ListStackInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "ListStackInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackInstancesInput>
    public typealias MOutput = OperationOutput<ListStackInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackInstancesOutputError>
}

public struct ListStackInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStackInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackInstancesInput>
    public typealias MOutput = OperationOutput<ListStackInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackInstancesOutputError>
}

public struct ListStackInstancesInput: Equatable {
    /// <p>[Service-managed permissions] Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account.</p>
    ///          <p>By default, <code>SELF</code> is specified. Use <code>SELF</code> for stack sets with self-managed permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you are signed in to the management account, specify <code>SELF</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you are signed in to a delegated administrator account, specify <code>DELEGATED_ADMIN</code>.</p>
    ///                <p>Your AWS account must be registered as a delegated administrator in the management account. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-orgs-delegated-admin.html">Register a delegated administrator</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let callAs: CallAs?
    /// <p>The status that stack instances are filtered by.</p>
    public let filters: [StackInstanceFilter]?
    /// <p>The maximum number of results to be returned with a single call. If the number of
    ///          available results exceeds this maximum, the response includes a <code>NextToken</code>
    ///          value that you can assign to the <code>NextToken</code> request parameter to get the next
    ///          set of results.</p>
    public let maxResults: Int?
    /// <p>If the previous request didn't return all of the remaining results, the response's
    ///             <code>NextToken</code> parameter value is set to a token. To retrieve the next set of
    ///          results, call <code>ListStackInstances</code> again and assign that token to the request
    ///          object's <code>NextToken</code> parameter. If there are no remaining results, the previous
    ///          response object's <code>NextToken</code> parameter is set to <code>null</code>.</p>
    public let nextToken: String?
    /// <p>The name of the AWS account that you want to list stack instances for.</p>
    public let stackInstanceAccount: String?
    /// <p>The name of the Region where you want to list stack instances. </p>
    public let stackInstanceRegion: String?
    /// <p>The name or unique ID of the stack set that you want to list stack instances
    ///          for.</p>
    public let stackSetName: String?

    public init (
        callAs: CallAs? = nil,
        filters: [StackInstanceFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        stackInstanceAccount: String? = nil,
        stackInstanceRegion: String? = nil,
        stackSetName: String? = nil
    )
    {
        self.callAs = callAs
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stackInstanceAccount = stackInstanceAccount
        self.stackInstanceRegion = stackInstanceRegion
        self.stackSetName = stackSetName
    }
}

extension ListStackInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListStackInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "StackSetNotFoundException" : self = .stackSetNotFoundException(try StackSetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStackInstancesOutputError: Equatable {
    case stackSetNotFoundException(StackSetNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStackInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStackInstancesOutputResponse(nextToken: \(String(describing: nextToken)), summaries: \(String(describing: summaries)))"}
}

extension ListStackInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStackInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListStackInstancesOutputResponse: Equatable {
    /// <p>If the request doesn't return all of the remaining results, <code>NextToken</code> is
    ///          set to a token. To retrieve the next set of results, call <code>ListStackInstances</code>
    ///          again and assign that token to the request object's <code>NextToken</code> parameter. If
    ///          the request returns all results, <code>NextToken</code> is set to
    ///          <code>null</code>.</p>
    public let nextToken: String?
    /// <p>A list of <code>StackInstanceSummary</code> structures that contain information about
    ///          the specified stack instances.</p>
    public let summaries: [StackInstanceSummary]?

    public init (
        nextToken: String? = nil,
        summaries: [StackInstanceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListStackInstancesOutputResponseBody: Equatable {
    public let summaries: [StackInstanceSummary]?
    public let nextToken: String?
}

extension ListStackInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case summaries = "Summaries"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListStackInstancesResult"))
        if containerValues.contains(.summaries) {
            struct KeyVal0{struct member{}}
            let summariesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .summaries)
            if let summariesWrappedContainer = summariesWrappedContainer {
                let summariesContainer = try summariesWrappedContainer.decodeIfPresent([StackInstanceSummary].self, forKey: .member)
                var summariesBuffer:[StackInstanceSummary]? = nil
                if let summariesContainer = summariesContainer {
                    summariesBuffer = [StackInstanceSummary]()
                    for structureContainer0 in summariesContainer {
                        summariesBuffer?.append(structureContainer0)
                    }
                }
                summaries = summariesBuffer
            } else {
                summaries = []
            }
        } else {
            summaries = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStackResourcesInputBodyMiddleware: Middleware {
    public let id: String = "ListStackResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackResourcesInput>
    public typealias MOutput = OperationOutput<ListStackResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackResourcesOutputError>
}

extension ListStackResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStackResourcesInput(nextToken: \(String(describing: nextToken)), stackName: \(String(describing: stackName)))"}
}

extension ListStackResourcesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        try container.encode("ListStackResources", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct ListStackResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListStackResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackResourcesInput>
    public typealias MOutput = OperationOutput<ListStackResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackResourcesOutputError>
}

public struct ListStackResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStackResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackResourcesInput>
    public typealias MOutput = OperationOutput<ListStackResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackResourcesOutputError>
}

/// <p>The input for the <a>ListStackResource</a> action.</p>
public struct ListStackResourcesInput: Equatable {
    /// <p>A string that identifies the next page of stack resources that you want to
    ///          retrieve.</p>
    public let nextToken: String?
    /// <p>The name or the unique stack ID that is associated with the stack, which are not
    ///          always interchangeable:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Running stacks: You can specify either the stack's name or its unique stack
    ///                ID.</p>
    ///             </li>
    ///             <li>
    ///                <p>Deleted stacks: You must specify the unique stack ID.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Default: There is no default value.</p>
    public let stackName: String?

    public init (
        nextToken: String? = nil,
        stackName: String? = nil
    )
    {
        self.nextToken = nextToken
        self.stackName = stackName
    }
}

extension ListStackResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListStackResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStackResourcesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStackResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStackResourcesOutputResponse(nextToken: \(String(describing: nextToken)), stackResourceSummaries: \(String(describing: stackResourceSummaries)))"}
}

extension ListStackResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStackResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.stackResourceSummaries = output.stackResourceSummaries
        } else {
            self.nextToken = nil
            self.stackResourceSummaries = nil
        }
    }
}

/// <p>The output for a <a>ListStackResources</a> action.</p>
public struct ListStackResourcesOutputResponse: Equatable {
    /// <p>If the output exceeds 1 MB, a string that identifies the next page of stack
    ///          resources. If no additional page exists, this value is null.</p>
    public let nextToken: String?
    /// <p>A list of <code>StackResourceSummary</code> structures.</p>
    public let stackResourceSummaries: [StackResourceSummary]?

    public init (
        nextToken: String? = nil,
        stackResourceSummaries: [StackResourceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.stackResourceSummaries = stackResourceSummaries
    }
}

struct ListStackResourcesOutputResponseBody: Equatable {
    public let stackResourceSummaries: [StackResourceSummary]?
    public let nextToken: String?
}

extension ListStackResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case stackResourceSummaries = "StackResourceSummaries"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListStackResourcesResult"))
        if containerValues.contains(.stackResourceSummaries) {
            struct KeyVal0{struct member{}}
            let stackResourceSummariesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .stackResourceSummaries)
            if let stackResourceSummariesWrappedContainer = stackResourceSummariesWrappedContainer {
                let stackResourceSummariesContainer = try stackResourceSummariesWrappedContainer.decodeIfPresent([StackResourceSummary].self, forKey: .member)
                var stackResourceSummariesBuffer:[StackResourceSummary]? = nil
                if let stackResourceSummariesContainer = stackResourceSummariesContainer {
                    stackResourceSummariesBuffer = [StackResourceSummary]()
                    for structureContainer0 in stackResourceSummariesContainer {
                        stackResourceSummariesBuffer?.append(structureContainer0)
                    }
                }
                stackResourceSummaries = stackResourceSummariesBuffer
            } else {
                stackResourceSummaries = []
            }
        } else {
            stackResourceSummaries = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStackSetOperationResultsInputBodyMiddleware: Middleware {
    public let id: String = "ListStackSetOperationResultsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackSetOperationResultsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackSetOperationResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackSetOperationResultsInput>
    public typealias MOutput = OperationOutput<ListStackSetOperationResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackSetOperationResultsOutputError>
}

extension ListStackSetOperationResultsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStackSetOperationResultsInput(callAs: \(String(describing: callAs)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), operationId: \(String(describing: operationId)), stackSetName: \(String(describing: stackSetName)))"}
}

extension ListStackSetOperationResultsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let callAs = callAs {
            try container.encode(callAs, forKey: Key("CallAs"))
        }
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let operationId = operationId {
            try container.encode(operationId, forKey: Key("OperationId"))
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        try container.encode("ListStackSetOperationResults", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct ListStackSetOperationResultsInputHeadersMiddleware: Middleware {
    public let id: String = "ListStackSetOperationResultsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackSetOperationResultsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackSetOperationResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackSetOperationResultsInput>
    public typealias MOutput = OperationOutput<ListStackSetOperationResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackSetOperationResultsOutputError>
}

public struct ListStackSetOperationResultsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStackSetOperationResultsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackSetOperationResultsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackSetOperationResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackSetOperationResultsInput>
    public typealias MOutput = OperationOutput<ListStackSetOperationResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackSetOperationResultsOutputError>
}

public struct ListStackSetOperationResultsInput: Equatable {
    /// <p>[Service-managed permissions] Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account.</p>
    ///          <p>By default, <code>SELF</code> is specified. Use <code>SELF</code> for stack sets with self-managed permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you are signed in to the management account, specify <code>SELF</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you are signed in to a delegated administrator account, specify <code>DELEGATED_ADMIN</code>.</p>
    ///                <p>Your AWS account must be registered as a delegated administrator in the management account. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-orgs-delegated-admin.html">Register a delegated administrator</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let callAs: CallAs?
    /// <p>The maximum number of results to be returned with a single call. If the number of
    ///          available results exceeds this maximum, the response includes a <code>NextToken</code>
    ///          value that you can assign to the <code>NextToken</code> request parameter to get the next
    ///          set of results.</p>
    public let maxResults: Int?
    /// <p>If the previous request didn't return all of the remaining results, the response
    ///          object's <code>NextToken</code> parameter value is set to a token. To retrieve the next set
    ///          of results, call <code>ListStackSetOperationResults</code> again and assign that token to
    ///          the request object's <code>NextToken</code> parameter. If there are no remaining results,
    ///          the previous response object's <code>NextToken</code> parameter is set to
    ///          <code>null</code>.</p>
    public let nextToken: String?
    /// <p>The ID of the stack set operation.</p>
    public let operationId: String?
    /// <p>The name or unique ID of the stack set that you want to get operation results
    ///          for.</p>
    public let stackSetName: String?

    public init (
        callAs: CallAs? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        operationId: String? = nil,
        stackSetName: String? = nil
    )
    {
        self.callAs = callAs
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.operationId = operationId
        self.stackSetName = stackSetName
    }
}

extension ListStackSetOperationResultsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListStackSetOperationResultsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OperationNotFoundException" : self = .operationNotFoundException(try OperationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StackSetNotFoundException" : self = .stackSetNotFoundException(try StackSetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStackSetOperationResultsOutputError: Equatable {
    case operationNotFoundException(OperationNotFoundException)
    case stackSetNotFoundException(StackSetNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStackSetOperationResultsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStackSetOperationResultsOutputResponse(nextToken: \(String(describing: nextToken)), summaries: \(String(describing: summaries)))"}
}

extension ListStackSetOperationResultsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStackSetOperationResultsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListStackSetOperationResultsOutputResponse: Equatable {
    /// <p>If the request doesn't return all results, <code>NextToken</code> is set to a token.
    ///          To retrieve the next set of results, call <code>ListOperationResults</code> again and
    ///          assign that token to the request object's <code>NextToken</code> parameter. If there are no
    ///          remaining results, <code>NextToken</code> is set to <code>null</code>.</p>
    public let nextToken: String?
    /// <p>A list of <code>StackSetOperationResultSummary</code> structures that contain
    ///          information about the specified operation results, for accounts and Regions that are
    ///          included in the operation.</p>
    public let summaries: [StackSetOperationResultSummary]?

    public init (
        nextToken: String? = nil,
        summaries: [StackSetOperationResultSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListStackSetOperationResultsOutputResponseBody: Equatable {
    public let summaries: [StackSetOperationResultSummary]?
    public let nextToken: String?
}

extension ListStackSetOperationResultsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case summaries = "Summaries"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListStackSetOperationResultsResult"))
        if containerValues.contains(.summaries) {
            struct KeyVal0{struct member{}}
            let summariesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .summaries)
            if let summariesWrappedContainer = summariesWrappedContainer {
                let summariesContainer = try summariesWrappedContainer.decodeIfPresent([StackSetOperationResultSummary].self, forKey: .member)
                var summariesBuffer:[StackSetOperationResultSummary]? = nil
                if let summariesContainer = summariesContainer {
                    summariesBuffer = [StackSetOperationResultSummary]()
                    for structureContainer0 in summariesContainer {
                        summariesBuffer?.append(structureContainer0)
                    }
                }
                summaries = summariesBuffer
            } else {
                summaries = []
            }
        } else {
            summaries = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStackSetOperationsInputBodyMiddleware: Middleware {
    public let id: String = "ListStackSetOperationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackSetOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackSetOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackSetOperationsInput>
    public typealias MOutput = OperationOutput<ListStackSetOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackSetOperationsOutputError>
}

extension ListStackSetOperationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStackSetOperationsInput(callAs: \(String(describing: callAs)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), stackSetName: \(String(describing: stackSetName)))"}
}

extension ListStackSetOperationsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let callAs = callAs {
            try container.encode(callAs, forKey: Key("CallAs"))
        }
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        try container.encode("ListStackSetOperations", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct ListStackSetOperationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListStackSetOperationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackSetOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackSetOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackSetOperationsInput>
    public typealias MOutput = OperationOutput<ListStackSetOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackSetOperationsOutputError>
}

public struct ListStackSetOperationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStackSetOperationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackSetOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackSetOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackSetOperationsInput>
    public typealias MOutput = OperationOutput<ListStackSetOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackSetOperationsOutputError>
}

public struct ListStackSetOperationsInput: Equatable {
    /// <p>[Service-managed permissions] Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account.</p>
    ///          <p>By default, <code>SELF</code> is specified. Use <code>SELF</code> for stack sets with self-managed permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you are signed in to the management account, specify <code>SELF</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you are signed in to a delegated administrator account, specify <code>DELEGATED_ADMIN</code>.</p>
    ///                <p>Your AWS account must be registered as a delegated administrator in the management account. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-orgs-delegated-admin.html">Register a delegated administrator</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let callAs: CallAs?
    /// <p>The maximum number of results to be returned with a single call. If the number of
    ///          available results exceeds this maximum, the response includes a <code>NextToken</code>
    ///          value that you can assign to the <code>NextToken</code> request parameter to get the next
    ///          set of results.</p>
    public let maxResults: Int?
    /// <p>If the previous paginated request didn't return all of the remaining results, the
    ///          response object's <code>NextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListStackSetOperations</code> again and assign that token
    ///          to the request object's <code>NextToken</code> parameter. If there are no remaining
    ///          results, the previous response object's <code>NextToken</code> parameter is set to
    ///             <code>null</code>.</p>
    public let nextToken: String?
    /// <p>The name or unique ID of the stack set that you want to get operation summaries
    ///          for.</p>
    public let stackSetName: String?

    public init (
        callAs: CallAs? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        stackSetName: String? = nil
    )
    {
        self.callAs = callAs
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stackSetName = stackSetName
    }
}

extension ListStackSetOperationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListStackSetOperationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "StackSetNotFoundException" : self = .stackSetNotFoundException(try StackSetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStackSetOperationsOutputError: Equatable {
    case stackSetNotFoundException(StackSetNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStackSetOperationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStackSetOperationsOutputResponse(nextToken: \(String(describing: nextToken)), summaries: \(String(describing: summaries)))"}
}

extension ListStackSetOperationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStackSetOperationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListStackSetOperationsOutputResponse: Equatable {
    /// <p>If the request doesn't return all results, <code>NextToken</code> is set to a token.
    ///          To retrieve the next set of results, call <code>ListOperationResults</code> again and
    ///          assign that token to the request object's <code>NextToken</code> parameter. If there are no
    ///          remaining results, <code>NextToken</code> is set to <code>null</code>.</p>
    public let nextToken: String?
    /// <p>A list of <code>StackSetOperationSummary</code> structures that contain summary
    ///          information about operations for the specified stack set.</p>
    public let summaries: [StackSetOperationSummary]?

    public init (
        nextToken: String? = nil,
        summaries: [StackSetOperationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListStackSetOperationsOutputResponseBody: Equatable {
    public let summaries: [StackSetOperationSummary]?
    public let nextToken: String?
}

extension ListStackSetOperationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case summaries = "Summaries"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListStackSetOperationsResult"))
        if containerValues.contains(.summaries) {
            struct KeyVal0{struct member{}}
            let summariesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .summaries)
            if let summariesWrappedContainer = summariesWrappedContainer {
                let summariesContainer = try summariesWrappedContainer.decodeIfPresent([StackSetOperationSummary].self, forKey: .member)
                var summariesBuffer:[StackSetOperationSummary]? = nil
                if let summariesContainer = summariesContainer {
                    summariesBuffer = [StackSetOperationSummary]()
                    for structureContainer0 in summariesContainer {
                        summariesBuffer?.append(structureContainer0)
                    }
                }
                summaries = summariesBuffer
            } else {
                summaries = []
            }
        } else {
            summaries = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStackSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListStackSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackSetsInput>
    public typealias MOutput = OperationOutput<ListStackSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackSetsOutputError>
}

extension ListStackSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStackSetsInput(callAs: \(String(describing: callAs)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), status: \(String(describing: status)))"}
}

extension ListStackSetsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let callAs = callAs {
            try container.encode(callAs, forKey: Key("CallAs"))
        }
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        try container.encode("ListStackSets", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct ListStackSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListStackSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackSetsInput>
    public typealias MOutput = OperationOutput<ListStackSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackSetsOutputError>
}

public struct ListStackSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStackSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackSetsInput>
    public typealias MOutput = OperationOutput<ListStackSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackSetsOutputError>
}

public struct ListStackSetsInput: Equatable {
    /// <p>[Service-managed permissions] Specifies whether you are acting as an account administrator in the management account or as a delegated administrator in a member account.</p>
    ///          <p>By default, <code>SELF</code> is specified. Use <code>SELF</code> for stack sets with self-managed permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you are signed in to the management account, specify <code>SELF</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you are signed in to a delegated administrator account, specify <code>DELEGATED_ADMIN</code>.</p>
    ///                <p>Your AWS account must be registered as a delegated administrator in the management account. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-orgs-delegated-admin.html">Register a delegated administrator</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let callAs: CallAs?
    /// <p>The maximum number of results to be returned with a single call. If the number of
    ///          available results exceeds this maximum, the response includes a <code>NextToken</code>
    ///          value that you can assign to the <code>NextToken</code> request parameter to get the next
    ///          set of results.</p>
    public let maxResults: Int?
    /// <p>If the previous paginated request didn't return all of the remaining results, the
    ///          response object's <code>NextToken</code> parameter value is set to a token. To retrieve the
    ///          next set of results, call <code>ListStackSets</code> again and assign that token to the
    ///          request object's <code>NextToken</code> parameter. If there are no remaining results, the
    ///          previous response object's <code>NextToken</code> parameter is set to
    ///          <code>null</code>.</p>
    public let nextToken: String?
    /// <p>The status of the stack sets that you want to get summary information
    ///          about.</p>
    public let status: StackSetStatus?

    public init (
        callAs: CallAs? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: StackSetStatus? = nil
    )
    {
        self.callAs = callAs
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension ListStackSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListStackSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStackSetsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStackSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStackSetsOutputResponse(nextToken: \(String(describing: nextToken)), summaries: \(String(describing: summaries)))"}
}

extension ListStackSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStackSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListStackSetsOutputResponse: Equatable {
    /// <p>If the request doesn't return all of the remaining results, <code>NextToken</code> is
    ///          set to a token. To retrieve the next set of results, call <code>ListStackInstances</code>
    ///          again and assign that token to the request object's <code>NextToken</code> parameter. If
    ///          the request returns all results, <code>NextToken</code> is set to
    ///          <code>null</code>.</p>
    public let nextToken: String?
    /// <p>A list of <code>StackSetSummary</code> structures that contain information about the
    ///          user's stack sets.</p>
    public let summaries: [StackSetSummary]?

    public init (
        nextToken: String? = nil,
        summaries: [StackSetSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListStackSetsOutputResponseBody: Equatable {
    public let summaries: [StackSetSummary]?
    public let nextToken: String?
}

extension ListStackSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case summaries = "Summaries"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListStackSetsResult"))
        if containerValues.contains(.summaries) {
            struct KeyVal0{struct member{}}
            let summariesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .summaries)
            if let summariesWrappedContainer = summariesWrappedContainer {
                let summariesContainer = try summariesWrappedContainer.decodeIfPresent([StackSetSummary].self, forKey: .member)
                var summariesBuffer:[StackSetSummary]? = nil
                if let summariesContainer = summariesContainer {
                    summariesBuffer = [StackSetSummary]()
                    for structureContainer0 in summariesContainer {
                        summariesBuffer?.append(structureContainer0)
                    }
                }
                summaries = summariesBuffer
            } else {
                summaries = []
            }
        } else {
            summaries = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStacksInputBodyMiddleware: Middleware {
    public let id: String = "ListStacksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStacksInput>
    public typealias MOutput = OperationOutput<ListStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStacksOutputError>
}

extension ListStacksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStacksInput(nextToken: \(String(describing: nextToken)), stackStatusFilter: \(String(describing: stackStatusFilter)))"}
}

extension ListStacksInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let stackStatusFilter = stackStatusFilter {
            var stackStatusFilterContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("StackStatusFilter"))
            for (index0, stackstatus0) in stackStatusFilter.enumerated() {
                try stackStatusFilterContainer.encode(stackstatus0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ListStacks", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct ListStacksInputHeadersMiddleware: Middleware {
    public let id: String = "ListStacksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStacksInput>
    public typealias MOutput = OperationOutput<ListStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStacksOutputError>
}

public struct ListStacksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStacksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStacksInput>
    public typealias MOutput = OperationOutput<ListStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStacksOutputError>
}

/// <p>The input for <a>ListStacks</a> action.</p>
public struct ListStacksInput: Equatable {
    /// <p>A string that identifies the next page of stacks that you want to retrieve.</p>
    public let nextToken: String?
    /// <p>Stack status to use as a filter. Specify one or more stack status codes to list only
    ///          stacks with the specified status codes. For a complete list of stack status codes, see the
    ///             <code>StackStatus</code> parameter of the <a>Stack</a> data type.</p>
    public let stackStatusFilter: [StackStatus]?

    public init (
        nextToken: String? = nil,
        stackStatusFilter: [StackStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.stackStatusFilter = stackStatusFilter
    }
}

extension ListStacksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListStacksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStacksOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStacksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStacksOutputResponse(nextToken: \(String(describing: nextToken)), stackSummaries: \(String(describing: stackSummaries)))"}
}

extension ListStacksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStacksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.stackSummaries = output.stackSummaries
        } else {
            self.nextToken = nil
            self.stackSummaries = nil
        }
    }
}

/// <p>The output for <a>ListStacks</a> action.</p>
public struct ListStacksOutputResponse: Equatable {
    /// <p>If the output exceeds 1 MB in size, a string that identifies the next page of stacks.
    ///          If no additional page exists, this value is null.</p>
    public let nextToken: String?
    /// <p>A list of <code>StackSummary</code> structures containing information about the
    ///          specified stacks.</p>
    public let stackSummaries: [StackSummary]?

    public init (
        nextToken: String? = nil,
        stackSummaries: [StackSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.stackSummaries = stackSummaries
    }
}

struct ListStacksOutputResponseBody: Equatable {
    public let stackSummaries: [StackSummary]?
    public let nextToken: String?
}

extension ListStacksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case stackSummaries = "StackSummaries"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListStacksResult"))
        if containerValues.contains(.stackSummaries) {
            struct KeyVal0{struct member{}}
            let stackSummariesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .stackSummaries)
            if let stackSummariesWrappedContainer = stackSummariesWrappedContainer {
                let stackSummariesContainer = try stackSummariesWrappedContainer.decodeIfPresent([StackSummary].self, forKey: .member)
                var stackSummariesBuffer:[StackSummary]? = nil
                if let stackSummariesContainer = stackSummariesContainer {
                    stackSummariesBuffer = [StackSummary]()
                    for structureContainer0 in stackSummariesContainer {
                        stackSummariesBuffer?.append(structureContainer0)
                    }
                }
                stackSummaries = stackSummariesBuffer
            } else {
                stackSummaries = []
            }
        } else {
            stackSummaries = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTypeRegistrationsInputBodyMiddleware: Middleware {
    public let id: String = "ListTypeRegistrationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypeRegistrationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypeRegistrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypeRegistrationsInput>
    public typealias MOutput = OperationOutput<ListTypeRegistrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypeRegistrationsOutputError>
}

extension ListTypeRegistrationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTypeRegistrationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), registrationStatusFilter: \(String(describing: registrationStatusFilter)), type: \(String(describing: type)), typeArn: \(String(describing: typeArn)), typeName: \(String(describing: typeName)))"}
}

extension ListTypeRegistrationsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let registrationStatusFilter = registrationStatusFilter {
            try container.encode(registrationStatusFilter, forKey: Key("RegistrationStatusFilter"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
        if let typeArn = typeArn {
            try container.encode(typeArn, forKey: Key("TypeArn"))
        }
        if let typeName = typeName {
            try container.encode(typeName, forKey: Key("TypeName"))
        }
        try container.encode("ListTypeRegistrations", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct ListTypeRegistrationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTypeRegistrationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypeRegistrationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypeRegistrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypeRegistrationsInput>
    public typealias MOutput = OperationOutput<ListTypeRegistrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypeRegistrationsOutputError>
}

public struct ListTypeRegistrationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTypeRegistrationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypeRegistrationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypeRegistrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypeRegistrationsInput>
    public typealias MOutput = OperationOutput<ListTypeRegistrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypeRegistrationsOutputError>
}

public struct ListTypeRegistrationsInput: Equatable {
    /// <p>The maximum number of results to be returned with a single call. If the number of available results exceeds this maximum, the response includes a <code>NextToken</code> value that you can assign to the <code>NextToken</code> request parameter to get the next set of results.</p>
    public let maxResults: Int?
    /// <p>If the previous paginated request didn't return all of the remaining results, the response object's <code>NextToken</code> parameter value is set to a token. To retrieve the next set of results, call this action again and assign that token to the request object's <code>NextToken</code> parameter. If there are no remaining results, the previous response object's <code>NextToken</code> parameter is set to <code>null</code>.</p>
    public let nextToken: String?
    /// <p>The current status of the extension registration request.</p>
    ///          <p>The default is <code>IN_PROGRESS</code>.</p>
    public let registrationStatusFilter: RegistrationStatus?
    /// <p>The kind of extension.</p>
    ///          <p>Conditional: You must specify either <code>TypeName</code> and <code>Type</code>, or <code>Arn</code>.</p>
    public let type: RegistryType?
    /// <p>The Amazon Resource Name (ARN) of the extension.</p>
    ///          <p>Conditional: You must specify either <code>TypeName</code> and <code>Type</code>, or <code>Arn</code>.</p>
    public let typeArn: String?
    /// <p>The name of the extension.</p>
    ///          <p>Conditional: You must specify either <code>TypeName</code> and <code>Type</code>, or <code>Arn</code>.</p>
    public let typeName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        registrationStatusFilter: RegistrationStatus? = nil,
        type: RegistryType? = nil,
        typeArn: String? = nil,
        typeName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationStatusFilter = registrationStatusFilter
        self.type = type
        self.typeArn = typeArn
        self.typeName = typeName
    }
}

extension ListTypeRegistrationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTypeRegistrationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CFNRegistryException" : self = .cFNRegistryException(try CFNRegistryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTypeRegistrationsOutputError: Equatable {
    case cFNRegistryException(CFNRegistryException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTypeRegistrationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTypeRegistrationsOutputResponse(nextToken: \(String(describing: nextToken)), registrationTokenList: \(String(describing: registrationTokenList)))"}
}

extension ListTypeRegistrationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTypeRegistrationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.registrationTokenList = output.registrationTokenList
        } else {
            self.nextToken = nil
            self.registrationTokenList = nil
        }
    }
}

public struct ListTypeRegistrationsOutputResponse: Equatable {
    /// <p>If the request doesn't return all of the remaining results, <code>NextToken</code> is set to a token. To retrieve the next set of results, call this action again and assign that token to the request object's <code>NextToken</code> parameter. If the request returns all results, <code>NextToken</code> is set to <code>null</code>.</p>
    public let nextToken: String?
    /// <p> A list of extension registration tokens.</p>
    ///          <p>Use <code>
    ///                <a>DescribeTypeRegistration</a>
    ///             </code> to return detailed information about a type registration request.</p>
    public let registrationTokenList: [String]?

    public init (
        nextToken: String? = nil,
        registrationTokenList: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.registrationTokenList = registrationTokenList
    }
}

struct ListTypeRegistrationsOutputResponseBody: Equatable {
    public let registrationTokenList: [String]?
    public let nextToken: String?
}

extension ListTypeRegistrationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case registrationTokenList = "RegistrationTokenList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListTypeRegistrationsResult"))
        if containerValues.contains(.registrationTokenList) {
            struct KeyVal0{struct member{}}
            let registrationTokenListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .registrationTokenList)
            if let registrationTokenListWrappedContainer = registrationTokenListWrappedContainer {
                let registrationTokenListContainer = try registrationTokenListWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var registrationTokenListBuffer:[String]? = nil
                if let registrationTokenListContainer = registrationTokenListContainer {
                    registrationTokenListBuffer = [String]()
                    for stringContainer0 in registrationTokenListContainer {
                        registrationTokenListBuffer?.append(stringContainer0)
                    }
                }
                registrationTokenList = registrationTokenListBuffer
            } else {
                registrationTokenList = []
            }
        } else {
            registrationTokenList = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTypeVersionsInputBodyMiddleware: Middleware {
    public let id: String = "ListTypeVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypeVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypeVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypeVersionsInput>
    public typealias MOutput = OperationOutput<ListTypeVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypeVersionsOutputError>
}

extension ListTypeVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTypeVersionsInput(arn: \(String(describing: arn)), deprecatedStatus: \(String(describing: deprecatedStatus)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), type: \(String(describing: type)), typeName: \(String(describing: typeName)))"}
}

extension ListTypeVersionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let deprecatedStatus = deprecatedStatus {
            try container.encode(deprecatedStatus, forKey: Key("DeprecatedStatus"))
        }
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
        if let typeName = typeName {
            try container.encode(typeName, forKey: Key("TypeName"))
        }
        try container.encode("ListTypeVersions", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct ListTypeVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTypeVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypeVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypeVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypeVersionsInput>
    public typealias MOutput = OperationOutput<ListTypeVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypeVersionsOutputError>
}

public struct ListTypeVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTypeVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypeVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypeVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypeVersionsInput>
    public typealias MOutput = OperationOutput<ListTypeVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypeVersionsOutputError>
}

public struct ListTypeVersionsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the extension for which you want version summary information.</p>
    ///          <p>Conditional: You must specify either <code>TypeName</code> and <code>Type</code>, or <code>Arn</code>.</p>
    public let arn: String?
    /// <p>The deprecation status of the extension versions that you want to get summary information about.</p>
    ///          <p>Valid values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>LIVE</code>: The extension version is registered and can be used in CloudFormation operations, dependent on its provisioning behavior and visibility scope.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DEPRECATED</code>: The extension version has been deregistered and can no longer be used in CloudFormation operations. </p>
    ///             </li>
    ///          </ul>
    ///          <p>The default is <code>LIVE</code>.</p>
    public let deprecatedStatus: DeprecatedStatus?
    /// <p>The maximum number of results to be returned with a single call. If the number of available results exceeds this maximum, the response includes a <code>NextToken</code> value that you can assign to the <code>NextToken</code> request parameter to get the next set of results.</p>
    public let maxResults: Int?
    /// <p>If the previous paginated request didn't return all of the remaining results, the response object's <code>NextToken</code> parameter value is set to a token. To retrieve the next set of results, call this action again and assign that token to the request object's <code>NextToken</code> parameter. If there are no remaining results, the previous response object's <code>NextToken</code> parameter is set to <code>null</code>.</p>
    public let nextToken: String?
    /// <p>The kind of the extension.</p>
    ///          <p>Conditional: You must specify either <code>TypeName</code> and <code>Type</code>, or <code>Arn</code>.</p>
    public let type: RegistryType?
    /// <p>The name of the extension for which you want version summary information.</p>
    ///          <p>Conditional: You must specify either <code>TypeName</code> and <code>Type</code>, or <code>Arn</code>.</p>
    public let typeName: String?

    public init (
        arn: String? = nil,
        deprecatedStatus: DeprecatedStatus? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        type: RegistryType? = nil,
        typeName: String? = nil
    )
    {
        self.arn = arn
        self.deprecatedStatus = deprecatedStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
        self.typeName = typeName
    }
}

extension ListTypeVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTypeVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CFNRegistryException" : self = .cFNRegistryException(try CFNRegistryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTypeVersionsOutputError: Equatable {
    case cFNRegistryException(CFNRegistryException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTypeVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTypeVersionsOutputResponse(nextToken: \(String(describing: nextToken)), typeVersionSummaries: \(String(describing: typeVersionSummaries)))"}
}

extension ListTypeVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTypeVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.typeVersionSummaries = output.typeVersionSummaries
        } else {
            self.nextToken = nil
            self.typeVersionSummaries = nil
        }
    }
}

public struct ListTypeVersionsOutputResponse: Equatable {
    /// <p>If the request doesn't return all of the remaining results, <code>NextToken</code> is set to a token. To retrieve the next set of results, call this action again and assign that token to the request object's <code>NextToken</code> parameter. If the request returns all results, <code>NextToken</code> is set to <code>null</code>.</p>
    public let nextToken: String?
    /// <p>A list of <code>TypeVersionSummary</code> structures that contain information about the specified extension's versions.</p>
    public let typeVersionSummaries: [TypeVersionSummary]?

    public init (
        nextToken: String? = nil,
        typeVersionSummaries: [TypeVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.typeVersionSummaries = typeVersionSummaries
    }
}

struct ListTypeVersionsOutputResponseBody: Equatable {
    public let typeVersionSummaries: [TypeVersionSummary]?
    public let nextToken: String?
}

extension ListTypeVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case typeVersionSummaries = "TypeVersionSummaries"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListTypeVersionsResult"))
        if containerValues.contains(.typeVersionSummaries) {
            struct KeyVal0{struct member{}}
            let typeVersionSummariesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .typeVersionSummaries)
            if let typeVersionSummariesWrappedContainer = typeVersionSummariesWrappedContainer {
                let typeVersionSummariesContainer = try typeVersionSummariesWrappedContainer.decodeIfPresent([TypeVersionSummary].self, forKey: .member)
                var typeVersionSummariesBuffer:[TypeVersionSummary]? = nil
                if let typeVersionSummariesContainer = typeVersionSummariesContainer {
                    typeVersionSummariesBuffer = [TypeVersionSummary]()
                    for structureContainer0 in typeVersionSummariesContainer {
                        typeVersionSummariesBuffer?.append(structureContainer0)
                    }
                }
                typeVersionSummaries = typeVersionSummariesBuffer
            } else {
                typeVersionSummaries = []
            }
        } else {
            typeVersionSummaries = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTypesInputBodyMiddleware: Middleware {
    public let id: String = "ListTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypesInput>
    public typealias MOutput = OperationOutput<ListTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypesOutputError>
}

extension ListTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTypesInput(deprecatedStatus: \(String(describing: deprecatedStatus)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), provisioningType: \(String(describing: provisioningType)), type: \(String(describing: type)), visibility: \(String(describing: visibility)))"}
}

extension ListTypesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let deprecatedStatus = deprecatedStatus {
            try container.encode(deprecatedStatus, forKey: Key("DeprecatedStatus"))
        }
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        if let provisioningType = provisioningType {
            try container.encode(provisioningType, forKey: Key("ProvisioningType"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
        if let visibility = visibility {
            try container.encode(visibility, forKey: Key("Visibility"))
        }
        try container.encode("ListTypes", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct ListTypesInputHeadersMiddleware: Middleware {
    public let id: String = "ListTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypesInput>
    public typealias MOutput = OperationOutput<ListTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypesOutputError>
}

public struct ListTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypesInput>
    public typealias MOutput = OperationOutput<ListTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypesOutputError>
}

public struct ListTypesInput: Equatable {
    /// <p>The deprecation status of the extension that you want to get summary information about.</p>
    ///          <p>Valid values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>LIVE</code>: The extension is registered for use in CloudFormation operations.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DEPRECATED</code>: The extension has been deregistered and can no longer be used in CloudFormation operations. </p>
    ///             </li>
    ///          </ul>
    public let deprecatedStatus: DeprecatedStatus?
    /// <p>The maximum number of results to be returned with a single call. If the number of available results exceeds this maximum, the response includes a <code>NextToken</code> value that you can assign to the <code>NextToken</code> request parameter to get the next set of results.</p>
    public let maxResults: Int?
    /// <p>If the previous paginated request didn't return all of the remaining results, the response object's <code>NextToken</code> parameter value is set to a token. To retrieve the next set of results, call this action again and assign that token to the request object's <code>NextToken</code> parameter. If there are no remaining results, the previous response object's <code>NextToken</code> parameter is set to <code>null</code>.</p>
    public let nextToken: String?
    /// <p>The provisioning behavior of the type. AWS CloudFormation determines the provisioning type during registration, based on the types of handlers in the schema handler package submitted.</p>
    ///          <p>Valid values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>FULLY_MUTABLE</code>: The extension includes an update handler to process updates to the extension during stack update operations.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IMMUTABLE</code>: The extension does not include an update handler, so the extension cannot be updated and must instead be replaced during stack update operations.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NON_PROVISIONABLE</code>: The extension does not include create, read, and delete handlers, and therefore cannot actually be provisioned.</p>
    ///             </li>
    ///          </ul>
    public let provisioningType: ProvisioningType?
    /// <p>The type of extension.</p>
    public let type: RegistryType?
    /// <p>The scope at which the extension is visible and usable in CloudFormation operations.</p>
    ///          <p>Valid values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PRIVATE</code>: The extension is only visible and usable within the account in which it is registered. Currently, AWS CloudFormation marks any extension you create as <code>PRIVATE</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PUBLIC</code>: The extension is publically visible and usable within any Amazon account.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The default is <code>PRIVATE</code>.</p>
    public let visibility: Visibility?

    public init (
        deprecatedStatus: DeprecatedStatus? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        provisioningType: ProvisioningType? = nil,
        type: RegistryType? = nil,
        visibility: Visibility? = nil
    )
    {
        self.deprecatedStatus = deprecatedStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.provisioningType = provisioningType
        self.type = type
        self.visibility = visibility
    }
}

extension ListTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CFNRegistryException" : self = .cFNRegistryException(try CFNRegistryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTypesOutputError: Equatable {
    case cFNRegistryException(CFNRegistryException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTypesOutputResponse(nextToken: \(String(describing: nextToken)), typeSummaries: \(String(describing: typeSummaries)))"}
}

extension ListTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.typeSummaries = output.typeSummaries
        } else {
            self.nextToken = nil
            self.typeSummaries = nil
        }
    }
}

public struct ListTypesOutputResponse: Equatable {
    /// <p>If the request doesn't return all of the remaining results, <code>NextToken</code> is set to a token. To retrieve the next set of results, call this action again and assign that token to the request object's <code>NextToken</code> parameter. If the request returns all results, <code>NextToken</code> is set to <code>null</code>.</p>
    public let nextToken: String?
    /// <p>A list of <code>TypeSummary</code> structures that contain information about the specified extensions.</p>
    public let typeSummaries: [TypeSummary]?

    public init (
        nextToken: String? = nil,
        typeSummaries: [TypeSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.typeSummaries = typeSummaries
    }
}

struct ListTypesOutputResponseBody: Equatable {
    public let typeSummaries: [TypeSummary]?
    public let nextToken: String?
}

extension ListTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case typeSummaries = "TypeSummaries"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListTypesResult"))
        if containerValues.contains(.typeSummaries) {
            struct KeyVal0{struct member{}}
            let typeSummariesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .typeSummaries)
            if let typeSummariesWrappedContainer = typeSummariesWrappedContainer {
                let typeSummariesContainer = try typeSummariesWrappedContainer.decodeIfPresent([TypeSummary].self, forKey: .member)
                var typeSummariesBuffer:[TypeSummary]? = nil
                if let typeSummariesContainer = typeSummariesContainer {
                    typeSummariesBuffer = [TypeSummary]()
                    for structureContainer0 in typeSummariesContainer {
                        typeSummariesBuffer?.append(structureContainer0)
                    }
                }
                typeSummaries = typeSummariesBuffer
            } else {
                typeSummaries = []
            }
        } else {
            typeSummaries = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LoggingConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logGroupName = "LogGroupName"
        case logRoleArn = "LogRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let logGroupName = logGroupName {
            try container.encode(logGroupName, forKey: Key("LogGroupName"))
        }
        if let logRoleArn = logRoleArn {
            try container.encode(logRoleArn, forKey: Key("LogRoleArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logRoleArn)
        logRoleArn = logRoleArnDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension LoggingConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingConfig(logGroupName: \(String(describing: logGroupName)), logRoleArn: \(String(describing: logRoleArn)))"}
}

/// <p>Contains logging configuration information for a type.</p>
public struct LoggingConfig: Equatable {
    /// <p>The Amazon CloudWatch log group to which CloudFormation sends error logging information when invoking the type's handlers.</p>
    public let logGroupName: String?
    /// <p>The ARN of the role that CloudFormation should assume when sending log entries to CloudWatch logs.</p>
    public let logRoleArn: String?

    public init (
        logGroupName: String? = nil,
        logRoleArn: String? = nil
    )
    {
        self.logGroupName = logGroupName
        self.logRoleArn = logRoleArn
    }
}

extension ModuleInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logicalIdHierarchy = "LogicalIdHierarchy"
        case typeHierarchy = "TypeHierarchy"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let logicalIdHierarchy = logicalIdHierarchy {
            try container.encode(logicalIdHierarchy, forKey: Key("LogicalIdHierarchy"))
        }
        if let typeHierarchy = typeHierarchy {
            try container.encode(typeHierarchy, forKey: Key("TypeHierarchy"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeHierarchyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeHierarchy)
        typeHierarchy = typeHierarchyDecoded
        let logicalIdHierarchyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logicalIdHierarchy)
        logicalIdHierarchy = logicalIdHierarchyDecoded
    }
}

extension ModuleInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModuleInfo(logicalIdHierarchy: \(String(describing: logicalIdHierarchy)), typeHierarchy: \(String(describing: typeHierarchy)))"}
}

/// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
///          <p>For more information on modules, see <a href="AWSCloudFormation/latest/UserGuide/modules.html">Using modules to encapsulate and reuse resource configurations</a> in the <i>CloudFormation User Guide</i>.</p>
public struct ModuleInfo: Equatable {
    /// <p>A concantenated list of the logical IDs of the module or modules containing the resource. Modules are listed starting with the inner-most nested module, and separated by  <code>/</code>.</p>
    ///          <p>In the following example, the resource was created from a module, <code>moduleA</code>, that is nested inside a parent module, <code>moduleB</code>.</p>
    ///          <p>
    ///             <code>moduleA/moduleB</code>
    ///          </p>
    ///          <p>For more information, see <a href="AWSCloudFormation/latest/UserGuide/modules.html#module-ref-resources">Referencing resources in a module</a> in the <i>CloudFormation User Guide</i>.</p>
    public let logicalIdHierarchy: String?
    /// <p>A concantenated list of the the module type or types containing the resource. Module types are listed starting with the inner-most nested module, and separated by  <code>/</code>.</p>
    ///          <p>In the following example, the resource was created from a module of type <code>AWS::First::Example::MODULE</code>, that is nested inside a parent module of type <code>AWS::Second::Example::MODULE</code>.</p>
    ///          <p>
    ///             <code>AWS::First::Example::MODULE/AWS::Second::Example::MODULE</code>
    ///          </p>
    public let typeHierarchy: String?

    public init (
        logicalIdHierarchy: String? = nil,
        typeHierarchy: String? = nil
    )
    {
        self.logicalIdHierarchy = logicalIdHierarchy
        self.typeHierarchy = typeHierarchy
    }
}

extension NameAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NameAlreadyExistsException(message: \(String(describing: message)))"}
}

extension NameAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NameAlreadyExistsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified name is already in use.</p>
public struct NameAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NameAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension NameAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum OnFailure {
    case delete
    case doNothing
    case rollback
    case sdkUnknown(String)
}

extension OnFailure : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OnFailure] {
        return [
            .delete,
            .doNothing,
            .rollback,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .delete: return "DELETE"
        case .doNothing: return "DO_NOTHING"
        case .rollback: return "ROLLBACK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OnFailure(rawValue: rawValue) ?? OnFailure.sdkUnknown(rawValue)
    }
}

extension OperationIdAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationIdAlreadyExistsException(message: \(String(describing: message)))"}
}

extension OperationIdAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<OperationIdAlreadyExistsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified operation ID already exists.</p>
public struct OperationIdAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationIdAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension OperationIdAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OperationInProgressException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationInProgressException(message: \(String(describing: message)))"}
}

extension OperationInProgressException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<OperationInProgressExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Another operation is currently in progress for this stack set. Only one operation can
///          be performed for a stack set at a given time.</p>
public struct OperationInProgressException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationInProgressExceptionBody: Equatable {
    public let message: String?
}

extension OperationInProgressExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OperationNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationNotFoundException(message: \(String(describing: message)))"}
}

extension OperationNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<OperationNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified ID refers to an operation that doesn't exist.</p>
public struct OperationNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension OperationNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum OperationStatus {
    case failed
    case inProgress
    case pending
    case success
    case sdkUnknown(String)
}

extension OperationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperationStatus] {
        return [
            .failed,
            .inProgress,
            .pending,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .pending: return "PENDING"
        case .success: return "SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperationStatus(rawValue: rawValue) ?? OperationStatus.sdkUnknown(rawValue)
    }
}

extension OperationStatusCheckFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationStatusCheckFailedException(message: \(String(describing: message)))"}
}

extension OperationStatusCheckFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<OperationStatusCheckFailedExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Error reserved for use by the <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/what-is-cloudformation-cli.html">CloudFormation CLI</a>. CloudFormation does not return this error to users.</p>
public struct OperationStatusCheckFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationStatusCheckFailedExceptionBody: Equatable {
    public let message: String?
}

extension OperationStatusCheckFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Output: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case exportName = "ExportName"
        case outputKey = "OutputKey"
        case outputValue = "OutputValue"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let exportName = exportName {
            try container.encode(exportName, forKey: Key("ExportName"))
        }
        if let outputKey = outputKey {
            try container.encode(outputKey, forKey: Key("OutputKey"))
        }
        if let outputValue = outputValue {
            try container.encode(outputValue, forKey: Key("OutputValue"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputKey)
        outputKey = outputKeyDecoded
        let outputValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputValue)
        outputValue = outputValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let exportNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportName)
        exportName = exportNameDecoded
    }
}

extension Output: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Output(description: \(String(describing: description)), exportName: \(String(describing: exportName)), outputKey: \(String(describing: outputKey)), outputValue: \(String(describing: outputValue)))"}
}

/// <p>The Output data type.</p>
public struct Output: Equatable {
    /// <p>User defined description associated with the output.</p>
    public let description: String?
    /// <p>The name of the export associated with the output.</p>
    public let exportName: String?
    /// <p>The key associated with the output.</p>
    public let outputKey: String?
    /// <p>The value associated with the output.</p>
    public let outputValue: String?

    public init (
        description: String? = nil,
        exportName: String? = nil,
        outputKey: String? = nil,
        outputValue: String? = nil
    )
    {
        self.description = description
        self.exportName = exportName
        self.outputKey = outputKey
        self.outputValue = outputValue
    }
}

extension Parameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameterKey = "ParameterKey"
        case parameterValue = "ParameterValue"
        case resolvedValue = "ResolvedValue"
        case usePreviousValue = "UsePreviousValue"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let parameterKey = parameterKey {
            try container.encode(parameterKey, forKey: Key("ParameterKey"))
        }
        if let parameterValue = parameterValue {
            try container.encode(parameterValue, forKey: Key("ParameterValue"))
        }
        if let resolvedValue = resolvedValue {
            try container.encode(resolvedValue, forKey: Key("ResolvedValue"))
        }
        if let usePreviousValue = usePreviousValue {
            try container.encode(usePreviousValue, forKey: Key("UsePreviousValue"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
        let usePreviousValueDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .usePreviousValue)
        usePreviousValue = usePreviousValueDecoded
        let resolvedValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolvedValue)
        resolvedValue = resolvedValueDecoded
    }
}

extension Parameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Parameter(parameterKey: \(String(describing: parameterKey)), parameterValue: \(String(describing: parameterValue)), resolvedValue: \(String(describing: resolvedValue)), usePreviousValue: \(String(describing: usePreviousValue)))"}
}

/// <p>The Parameter data type.</p>
public struct Parameter: Equatable {
    /// <p>The key associated with the parameter. If you don't specify a key and value for a
    ///          particular parameter, AWS CloudFormation uses the default value that is specified in your
    ///          template.</p>
    public let parameterKey: String?
    /// <p>The input value associated with the parameter.</p>
    public let parameterValue: String?
    /// <p>Read-only. The value that corresponds to a Systems Manager parameter key. This field
    ///          is returned only for <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html#aws-ssm-parameter-types">
    ///                <code>SSM</code> parameter types</a> in the template.</p>
    public let resolvedValue: String?
    /// <p>During a stack update, use the existing parameter value that the stack is using for a
    ///          given parameter key. If you specify <code>true</code>, do not specify a parameter
    ///          value.</p>
    public let usePreviousValue: Bool?

    public init (
        parameterKey: String? = nil,
        parameterValue: String? = nil,
        resolvedValue: String? = nil,
        usePreviousValue: Bool? = nil
    )
    {
        self.parameterKey = parameterKey
        self.parameterValue = parameterValue
        self.resolvedValue = resolvedValue
        self.usePreviousValue = usePreviousValue
    }
}

extension ParameterConstraints: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedValues = "AllowedValues"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AllowedValues"))
            for (index0, allowedvalue0) in allowedValues.enumerated() {
                try allowedValuesContainer.encode(allowedvalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.allowedValues) {
            struct KeyVal0{struct member{}}
            let allowedValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .allowedValues)
            if let allowedValuesWrappedContainer = allowedValuesWrappedContainer {
                let allowedValuesContainer = try allowedValuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var allowedValuesBuffer:[String]? = nil
                if let allowedValuesContainer = allowedValuesContainer {
                    allowedValuesBuffer = [String]()
                    for stringContainer0 in allowedValuesContainer {
                        allowedValuesBuffer?.append(stringContainer0)
                    }
                }
                allowedValues = allowedValuesBuffer
            } else {
                allowedValues = []
            }
        } else {
            allowedValues = nil
        }
    }
}

extension ParameterConstraints: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterConstraints(allowedValues: \(String(describing: allowedValues)))"}
}

/// <p>A set of criteria that AWS CloudFormation uses to validate parameter values. Although
///          other constraints might be defined in the stack template, AWS CloudFormation returns only
///          the <code>AllowedValues</code> property.</p>
public struct ParameterConstraints: Equatable {
    /// <p>A list of values that are permitted for a parameter.</p>
    public let allowedValues: [String]?

    public init (
        allowedValues: [String]? = nil
    )
    {
        self.allowedValues = allowedValues
    }
}

extension ParameterDeclaration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case description = "Description"
        case noEcho = "NoEcho"
        case parameterConstraints = "ParameterConstraints"
        case parameterKey = "ParameterKey"
        case parameterType = "ParameterType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let noEcho = noEcho {
            try container.encode(noEcho, forKey: Key("NoEcho"))
        }
        if let parameterConstraints = parameterConstraints {
            try container.encode(parameterConstraints, forKey: Key("ParameterConstraints"))
        }
        if let parameterKey = parameterKey {
            try container.encode(parameterKey, forKey: Key("ParameterKey"))
        }
        if let parameterType = parameterType {
            try container.encode(parameterType, forKey: Key("ParameterType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let parameterTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterType)
        parameterType = parameterTypeDecoded
        let noEchoDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .noEcho)
        noEcho = noEchoDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parameterConstraintsDecoded = try containerValues.decodeIfPresent(ParameterConstraints.self, forKey: .parameterConstraints)
        parameterConstraints = parameterConstraintsDecoded
    }
}

extension ParameterDeclaration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterDeclaration(defaultValue: \(String(describing: defaultValue)), description: \(String(describing: description)), noEcho: \(String(describing: noEcho)), parameterConstraints: \(String(describing: parameterConstraints)), parameterKey: \(String(describing: parameterKey)), parameterType: \(String(describing: parameterType)))"}
}

/// <p>The ParameterDeclaration data type.</p>
public struct ParameterDeclaration: Equatable {
    /// <p>The default value of the parameter.</p>
    public let defaultValue: String?
    /// <p>The description that is associate with the parameter.</p>
    public let description: String?
    /// <p>Flag that indicates whether the parameter value is shown as plain text in logs and in
    ///          the AWS Management Console.</p>
    public let noEcho: Bool?
    /// <p>The criteria that AWS CloudFormation uses to validate parameter values.</p>
    public let parameterConstraints: ParameterConstraints?
    /// <p>The name that is associated with the parameter.</p>
    public let parameterKey: String?
    /// <p>The type of parameter.</p>
    public let parameterType: String?

    public init (
        defaultValue: String? = nil,
        description: String? = nil,
        noEcho: Bool? = nil,
        parameterConstraints: ParameterConstraints? = nil,
        parameterKey: String? = nil,
        parameterType: String? = nil
    )
    {
        self.defaultValue = defaultValue
        self.description = description
        self.noEcho = noEcho
        self.parameterConstraints = parameterConstraints
        self.parameterKey = parameterKey
        self.parameterType = parameterType
    }
}

public enum PermissionModels {
    case selfManaged
    case serviceManaged
    case sdkUnknown(String)
}

extension PermissionModels : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PermissionModels] {
        return [
            .selfManaged,
            .serviceManaged,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .selfManaged: return "SELF_MANAGED"
        case .serviceManaged: return "SERVICE_MANAGED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PermissionModels(rawValue: rawValue) ?? PermissionModels.sdkUnknown(rawValue)
    }
}

extension PhysicalResourceIdContextKeyValuePair: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let key = key {
            try container.encode(key, forKey: Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PhysicalResourceIdContextKeyValuePair: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PhysicalResourceIdContextKeyValuePair(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Context information that enables AWS CloudFormation to uniquely identify a resource. AWS CloudFormation uses
///          context key-value pairs in cases where a resource's logical and physical IDs are not enough
///          to uniquely identify that resource. Each context key-value pair specifies a resource that
///          contains the targeted resource.</p>
public struct PhysicalResourceIdContextKeyValuePair: Equatable {
    /// <p>The resource context key.</p>
    public let key: String?
    /// <p>The resource context value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension PropertyDifference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actualValue = "ActualValue"
        case differenceType = "DifferenceType"
        case expectedValue = "ExpectedValue"
        case propertyPath = "PropertyPath"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actualValue = actualValue {
            try container.encode(actualValue, forKey: Key("ActualValue"))
        }
        if let differenceType = differenceType {
            try container.encode(differenceType, forKey: Key("DifferenceType"))
        }
        if let expectedValue = expectedValue {
            try container.encode(expectedValue, forKey: Key("ExpectedValue"))
        }
        if let propertyPath = propertyPath {
            try container.encode(propertyPath, forKey: Key("PropertyPath"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .propertyPath)
        propertyPath = propertyPathDecoded
        let expectedValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expectedValue)
        expectedValue = expectedValueDecoded
        let actualValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actualValue)
        actualValue = actualValueDecoded
        let differenceTypeDecoded = try containerValues.decodeIfPresent(DifferenceType.self, forKey: .differenceType)
        differenceType = differenceTypeDecoded
    }
}

extension PropertyDifference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PropertyDifference(actualValue: \(String(describing: actualValue)), differenceType: \(String(describing: differenceType)), expectedValue: \(String(describing: expectedValue)), propertyPath: \(String(describing: propertyPath)))"}
}

/// <p>Information about a resource property whose actual value differs from its expected
///          value, as defined in the stack template and any values specified as template parameters.
///          These will be present only for resources whose <code>StackResourceDriftStatus</code> is
///             <code>MODIFIED</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting
///             Unregulated Configuration Changes to Stacks and Resources</a>.</p>
public struct PropertyDifference: Equatable {
    /// <p>The actual property value of the resource property.</p>
    public let actualValue: String?
    /// <p>The type of property difference.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ADD</code>: A value has been added to a resource property that is an
    ///                array or list data type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>REMOVE</code>: The property has been removed from the current resource
    ///                configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_EQUAL</code>: The current property value differs from its expected
    ///                value (as defined in the stack template and any values specified as template
    ///                parameters).</p>
    ///             </li>
    ///          </ul>
    public let differenceType: DifferenceType?
    /// <p>The expected property value of the resource property, as defined in the stack
    ///          template and any values specified as template parameters.</p>
    public let expectedValue: String?
    /// <p>The fully-qualified path to the resource property.</p>
    public let propertyPath: String?

    public init (
        actualValue: String? = nil,
        differenceType: DifferenceType? = nil,
        expectedValue: String? = nil,
        propertyPath: String? = nil
    )
    {
        self.actualValue = actualValue
        self.differenceType = differenceType
        self.expectedValue = expectedValue
        self.propertyPath = propertyPath
    }
}

public enum ProvisioningType {
    case fullyMutable
    case immutable
    case nonProvisionable
    case sdkUnknown(String)
}

extension ProvisioningType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProvisioningType] {
        return [
            .fullyMutable,
            .immutable,
            .nonProvisionable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fullyMutable: return "FULLY_MUTABLE"
        case .immutable: return "IMMUTABLE"
        case .nonProvisionable: return "NON_PROVISIONABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProvisioningType(rawValue: rawValue) ?? ProvisioningType.sdkUnknown(rawValue)
    }
}

public struct RecordHandlerProgressInputBodyMiddleware: Middleware {
    public let id: String = "RecordHandlerProgressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RecordHandlerProgressInput>,
                  next: H) -> Swift.Result<OperationOutput<RecordHandlerProgressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RecordHandlerProgressInput>
    public typealias MOutput = OperationOutput<RecordHandlerProgressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RecordHandlerProgressOutputError>
}

extension RecordHandlerProgressInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecordHandlerProgressInput(bearerToken: \(String(describing: bearerToken)), clientRequestToken: \(String(describing: clientRequestToken)), currentOperationStatus: \(String(describing: currentOperationStatus)), errorCode: \(String(describing: errorCode)), operationStatus: \(String(describing: operationStatus)), resourceModel: \(String(describing: resourceModel)), statusMessage: \(String(describing: statusMessage)))"}
}

extension RecordHandlerProgressInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let bearerToken = bearerToken {
            try container.encode(bearerToken, forKey: Key("BearerToken"))
        }
        if let clientRequestToken = clientRequestToken {
            try container.encode(clientRequestToken, forKey: Key("ClientRequestToken"))
        }
        if let currentOperationStatus = currentOperationStatus {
            try container.encode(currentOperationStatus, forKey: Key("CurrentOperationStatus"))
        }
        if let errorCode = errorCode {
            try container.encode(errorCode, forKey: Key("ErrorCode"))
        }
        if let operationStatus = operationStatus {
            try container.encode(operationStatus, forKey: Key("OperationStatus"))
        }
        if let resourceModel = resourceModel {
            try container.encode(resourceModel, forKey: Key("ResourceModel"))
        }
        if let statusMessage = statusMessage {
            try container.encode(statusMessage, forKey: Key("StatusMessage"))
        }
        try container.encode("RecordHandlerProgress", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct RecordHandlerProgressInputHeadersMiddleware: Middleware {
    public let id: String = "RecordHandlerProgressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RecordHandlerProgressInput>,
                  next: H) -> Swift.Result<OperationOutput<RecordHandlerProgressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RecordHandlerProgressInput>
    public typealias MOutput = OperationOutput<RecordHandlerProgressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RecordHandlerProgressOutputError>
}

public struct RecordHandlerProgressInputQueryItemMiddleware: Middleware {
    public let id: String = "RecordHandlerProgressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RecordHandlerProgressInput>,
                  next: H) -> Swift.Result<OperationOutput<RecordHandlerProgressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RecordHandlerProgressInput>
    public typealias MOutput = OperationOutput<RecordHandlerProgressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RecordHandlerProgressOutputError>
}

public struct RecordHandlerProgressInput: Equatable {
    /// <p>Reserved for use by the <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/what-is-cloudformation-cli.html">CloudFormation CLI</a>.</p>
    public let bearerToken: String?
    /// <p>Reserved for use by the <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/what-is-cloudformation-cli.html">CloudFormation CLI</a>.</p>
    public let clientRequestToken: String?
    /// <p>Reserved for use by the <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/what-is-cloudformation-cli.html">CloudFormation CLI</a>.</p>
    public let currentOperationStatus: OperationStatus?
    /// <p>Reserved for use by the <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/what-is-cloudformation-cli.html">CloudFormation CLI</a>.</p>
    public let errorCode: HandlerErrorCode?
    /// <p>Reserved for use by the <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/what-is-cloudformation-cli.html">CloudFormation CLI</a>.</p>
    public let operationStatus: OperationStatus?
    /// <p>Reserved for use by the <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/what-is-cloudformation-cli.html">CloudFormation CLI</a>.</p>
    public let resourceModel: String?
    /// <p>Reserved for use by the <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/what-is-cloudformation-cli.html">CloudFormation CLI</a>.</p>
    public let statusMessage: String?

    public init (
        bearerToken: String? = nil,
        clientRequestToken: String? = nil,
        currentOperationStatus: OperationStatus? = nil,
        errorCode: HandlerErrorCode? = nil,
        operationStatus: OperationStatus? = nil,
        resourceModel: String? = nil,
        statusMessage: String? = nil
    )
    {
        self.bearerToken = bearerToken
        self.clientRequestToken = clientRequestToken
        self.currentOperationStatus = currentOperationStatus
        self.errorCode = errorCode
        self.operationStatus = operationStatus
        self.resourceModel = resourceModel
        self.statusMessage = statusMessage
    }
}

extension RecordHandlerProgressOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RecordHandlerProgressOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidStateTransitionException" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationStatusCheckFailedException" : self = .operationStatusCheckFailedException(try OperationStatusCheckFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RecordHandlerProgressOutputError: Equatable {
    case invalidStateTransitionException(InvalidStateTransitionException)
    case operationStatusCheckFailedException(OperationStatusCheckFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RecordHandlerProgressOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecordHandlerProgressOutputResponse()"}
}

extension RecordHandlerProgressOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RecordHandlerProgressOutputResponse: Equatable {

    public init() {}
}

struct RecordHandlerProgressOutputResponseBody: Equatable {
}

extension RecordHandlerProgressOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum RegionConcurrencyType {
    case parallel
    case sequential
    case sdkUnknown(String)
}

extension RegionConcurrencyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RegionConcurrencyType] {
        return [
            .parallel,
            .sequential,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .parallel: return "PARALLEL"
        case .sequential: return "SEQUENTIAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RegionConcurrencyType(rawValue: rawValue) ?? RegionConcurrencyType.sdkUnknown(rawValue)
    }
}

public struct RegisterTypeInputBodyMiddleware: Middleware {
    public let id: String = "RegisterTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTypeInput>
    public typealias MOutput = OperationOutput<RegisterTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTypeOutputError>
}

extension RegisterTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterTypeInput(clientRequestToken: \(String(describing: clientRequestToken)), executionRoleArn: \(String(describing: executionRoleArn)), loggingConfig: \(String(describing: loggingConfig)), schemaHandlerPackage: \(String(describing: schemaHandlerPackage)), type: \(String(describing: type)), typeName: \(String(describing: typeName)))"}
}

extension RegisterTypeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clientRequestToken = clientRequestToken {
            try container.encode(clientRequestToken, forKey: Key("ClientRequestToken"))
        }
        if let executionRoleArn = executionRoleArn {
            try container.encode(executionRoleArn, forKey: Key("ExecutionRoleArn"))
        }
        if let loggingConfig = loggingConfig {
            try container.encode(loggingConfig, forKey: Key("LoggingConfig"))
        }
        if let schemaHandlerPackage = schemaHandlerPackage {
            try container.encode(schemaHandlerPackage, forKey: Key("SchemaHandlerPackage"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
        if let typeName = typeName {
            try container.encode(typeName, forKey: Key("TypeName"))
        }
        try container.encode("RegisterType", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct RegisterTypeInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTypeInput>
    public typealias MOutput = OperationOutput<RegisterTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTypeOutputError>
}

public struct RegisterTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTypeInput>
    public typealias MOutput = OperationOutput<RegisterTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTypeOutputError>
}

public struct RegisterTypeInput: Equatable {
    /// <p>A unique identifier that acts as an idempotency key for this registration request. Specifying a client request token prevents CloudFormation from generating more than one version of an extension from the same registeration request, even if the request is submitted multiple times. </p>
    public let clientRequestToken: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role for CloudFormation to assume when invoking the extension. If your extension calls AWS APIs in any of its handlers, you must create an
    ///          <i>
    ///                <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html">IAM execution
    ///             role</a>
    ///             </i> that includes the necessary permissions to call those
    ///          AWS APIs, and provision that execution role in your account. When CloudFormation needs to invoke the extension handler, CloudFormation assumes this execution role to create a temporary session token, which it then passes to the extension handler, thereby supplying your extension with the appropriate credentials.</p>
    public let executionRoleArn: String?
    /// <p>Specifies logging configuration information for an extension.</p>
    public let loggingConfig: LoggingConfig?
    /// <p>A url to the S3 bucket containing the extension project package that contains the neccessary files for the extension you want to register.</p>
    ///          <p>For information on generating a schema handler package for the extension you want to register, see <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-cli-submit.html">submit</a> in the <i>CloudFormation CLI User Guide</i>.</p>
    ///          <note>
    ///             <p>The
    ///          user registering the extension must be able to access the package in the S3 bucket. That is, the user needs to have <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObject.html">GetObject</a> permissions
    ///          for the schema handler package. For
    ///          more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazons3.html">Actions, Resources, and Condition Keys for Amazon S3</a> in the
    ///          <i>AWS Identity and Access Management User Guide</i>.</p>
    ///          </note>
    public let schemaHandlerPackage: String?
    /// <p>The kind of extension.</p>
    public let type: RegistryType?
    /// <p>The name of the extension being registered.</p>
    ///
    ///          <p>We recommend that extension names adhere to the following pattern: <i>company_or_organization</i>::<i>service</i>::<i>type</i>.</p>
    ///          <note>
    ///             <p>The following organization namespaces are reserved and cannot be used in your extension names:</p>
    ///             <ul>
    ///                <li>
    ///                   <p>
    ///                      <code>Alexa</code>
    ///                   </p>
    ///                </li>
    ///                <li>
    ///                   <p>
    ///                      <code>AMZN</code>
    ///                   </p>
    ///                </li>
    ///                <li>
    ///                   <p>
    ///                      <code>Amazon</code>
    ///                   </p>
    ///                </li>
    ///                <li>
    ///                   <p>
    ///                      <code>AWS</code>
    ///                   </p>
    ///                </li>
    ///                <li>
    ///                   <p>
    ///                      <code>Custom</code>
    ///                   </p>
    ///                </li>
    ///                <li>
    ///                   <p>
    ///                      <code>Dev</code>
    ///                   </p>
    ///                </li>
    ///             </ul>
    ///          </note>
    public let typeName: String?

    public init (
        clientRequestToken: String? = nil,
        executionRoleArn: String? = nil,
        loggingConfig: LoggingConfig? = nil,
        schemaHandlerPackage: String? = nil,
        type: RegistryType? = nil,
        typeName: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.executionRoleArn = executionRoleArn
        self.loggingConfig = loggingConfig
        self.schemaHandlerPackage = schemaHandlerPackage
        self.type = type
        self.typeName = typeName
    }
}

extension RegisterTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RegisterTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CFNRegistryException" : self = .cFNRegistryException(try CFNRegistryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterTypeOutputError: Equatable {
    case cFNRegistryException(CFNRegistryException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterTypeOutputResponse(registrationToken: \(String(describing: registrationToken)))"}
}

extension RegisterTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.registrationToken = output.registrationToken
        } else {
            self.registrationToken = nil
        }
    }
}

public struct RegisterTypeOutputResponse: Equatable {
    /// <p>The identifier for this registration request.</p>
    ///          <p>Use this registration token when calling <code>
    ///                <a>DescribeTypeRegistration</a>
    ///             </code>, which returns information about the status and IDs of the extension registration. </p>
    public let registrationToken: String?

    public init (
        registrationToken: String? = nil
    )
    {
        self.registrationToken = registrationToken
    }
}

struct RegisterTypeOutputResponseBody: Equatable {
    public let registrationToken: String?
}

extension RegisterTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registrationToken = "RegistrationToken"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("RegisterTypeResult"))
        let registrationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registrationToken)
        registrationToken = registrationTokenDecoded
    }
}

public enum RegistrationStatus {
    case complete
    case failed
    case inProgress
    case sdkUnknown(String)
}

extension RegistrationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RegistrationStatus] {
        return [
            .complete,
            .failed,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "COMPLETE"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RegistrationStatus(rawValue: rawValue) ?? RegistrationStatus.sdkUnknown(rawValue)
    }
}

public enum RegistryType {
    case module
    case resource
    case sdkUnknown(String)
}

extension RegistryType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RegistryType] {
        return [
            .module,
            .resource,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .module: return "MODULE"
        case .resource: return "RESOURCE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RegistryType(rawValue: rawValue) ?? RegistryType.sdkUnknown(rawValue)
    }
}

public enum Replacement {
    case conditional
    case `false`
    case `true`
    case sdkUnknown(String)
}

extension Replacement : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Replacement] {
        return [
            .conditional,
            .false,
            .true,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .conditional: return "Conditional"
        case .false: return "False"
        case .true: return "True"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Replacement(rawValue: rawValue) ?? Replacement.sdkUnknown(rawValue)
    }
}

public enum RequiresRecreation {
    case always
    case conditionally
    case never
    case sdkUnknown(String)
}

extension RequiresRecreation : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RequiresRecreation] {
        return [
            .always,
            .conditionally,
            .never,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .always: return "Always"
        case .conditionally: return "Conditionally"
        case .never: return "Never"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RequiresRecreation(rawValue: rawValue) ?? RequiresRecreation.sdkUnknown(rawValue)
    }
}

public enum ResourceAttribute {
    case creationpolicy
    case deletionpolicy
    case metadata
    case properties
    case tags
    case updatepolicy
    case sdkUnknown(String)
}

extension ResourceAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceAttribute] {
        return [
            .creationpolicy,
            .deletionpolicy,
            .metadata,
            .properties,
            .tags,
            .updatepolicy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creationpolicy: return "CreationPolicy"
        case .deletionpolicy: return "DeletionPolicy"
        case .metadata: return "Metadata"
        case .properties: return "Properties"
        case .tags: return "Tags"
        case .updatepolicy: return "UpdatePolicy"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceAttribute(rawValue: rawValue) ?? ResourceAttribute.sdkUnknown(rawValue)
    }
}

extension ResourceChange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case changeSetId = "ChangeSetId"
        case details = "Details"
        case logicalResourceId = "LogicalResourceId"
        case moduleInfo = "ModuleInfo"
        case physicalResourceId = "PhysicalResourceId"
        case replacement = "Replacement"
        case resourceType = "ResourceType"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let action = action {
            try container.encode(action, forKey: Key("Action"))
        }
        if let changeSetId = changeSetId {
            try container.encode(changeSetId, forKey: Key("ChangeSetId"))
        }
        if let details = details {
            var detailsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Details"))
            for (index0, resourcechangedetail0) in details.enumerated() {
                try detailsContainer.encode(resourcechangedetail0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let logicalResourceId = logicalResourceId {
            try container.encode(logicalResourceId, forKey: Key("LogicalResourceId"))
        }
        if let moduleInfo = moduleInfo {
            try container.encode(moduleInfo, forKey: Key("ModuleInfo"))
        }
        if let physicalResourceId = physicalResourceId {
            try container.encode(physicalResourceId, forKey: Key("PhysicalResourceId"))
        }
        if let replacement = replacement {
            try container.encode(replacement, forKey: Key("Replacement"))
        }
        if let resourceType = resourceType {
            try container.encode(resourceType, forKey: Key("ResourceType"))
        }
        if let scope = scope {
            var scopeContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Scope"))
            for (index0, resourceattribute0) in scope.enumerated() {
                try scopeContainer.encode(resourceattribute0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ChangeAction.self, forKey: .action)
        action = actionDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let replacementDecoded = try containerValues.decodeIfPresent(Replacement.self, forKey: .replacement)
        replacement = replacementDecoded
        if containerValues.contains(.scope) {
            struct KeyVal0{struct member{}}
            let scopeWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .scope)
            if let scopeWrappedContainer = scopeWrappedContainer {
                let scopeContainer = try scopeWrappedContainer.decodeIfPresent([ResourceAttribute].self, forKey: .member)
                var scopeBuffer:[ResourceAttribute]? = nil
                if let scopeContainer = scopeContainer {
                    scopeBuffer = [ResourceAttribute]()
                    for stringContainer0 in scopeContainer {
                        scopeBuffer?.append(stringContainer0)
                    }
                }
                scope = scopeBuffer
            } else {
                scope = []
            }
        } else {
            scope = nil
        }
        if containerValues.contains(.details) {
            struct KeyVal0{struct member{}}
            let detailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .details)
            if let detailsWrappedContainer = detailsWrappedContainer {
                let detailsContainer = try detailsWrappedContainer.decodeIfPresent([ResourceChangeDetail].self, forKey: .member)
                var detailsBuffer:[ResourceChangeDetail]? = nil
                if let detailsContainer = detailsContainer {
                    detailsBuffer = [ResourceChangeDetail]()
                    for structureContainer0 in detailsContainer {
                        detailsBuffer?.append(structureContainer0)
                    }
                }
                details = detailsBuffer
            } else {
                details = []
            }
        } else {
            details = nil
        }
        let changeSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let moduleInfoDecoded = try containerValues.decodeIfPresent(ModuleInfo.self, forKey: .moduleInfo)
        moduleInfo = moduleInfoDecoded
    }
}

extension ResourceChange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceChange(action: \(String(describing: action)), changeSetId: \(String(describing: changeSetId)), details: \(String(describing: details)), logicalResourceId: \(String(describing: logicalResourceId)), moduleInfo: \(String(describing: moduleInfo)), physicalResourceId: \(String(describing: physicalResourceId)), replacement: \(String(describing: replacement)), resourceType: \(String(describing: resourceType)), scope: \(String(describing: scope)))"}
}

/// <p>The <code>ResourceChange</code> structure describes the resource and the action that
///          AWS CloudFormation will perform on it if you execute this change set.</p>
public struct ResourceChange: Equatable {
    /// <p>The action that AWS CloudFormation takes on the resource, such as <code>Add</code>
    ///          (adds a new resource), <code>Modify</code> (changes a resource), <code>Remove</code>
    ///          (deletes a resource), <code>Import</code> (imports a resource), or <code>Dynamic</code>
    ///          (exact action for the resource cannot be determined).</p>
    public let action: ChangeAction?
    /// <p>The change set ID of the nested change set.</p>
    public let changeSetId: String?
    /// <p>For the <code>Modify</code> action, a list of <code>ResourceChangeDetail</code>
    ///          structures that describes the changes that AWS CloudFormation will make to the resource.
    ///       </p>
    public let details: [ResourceChangeDetail]?
    /// <p>The resource's logical ID, which is defined in the stack's template.</p>
    public let logicalResourceId: String?
    /// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
    public let moduleInfo: ModuleInfo?
    /// <p>The resource's physical ID (resource name). Resources that you are adding don't have
    ///          physical IDs because they haven't been created.</p>
    public let physicalResourceId: String?
    /// <p>For the <code>Modify</code> action, indicates whether AWS CloudFormation will replace
    ///          the resource by creating a new one and deleting the old one. This value depends on the
    ///          value of the <code>RequiresRecreation</code> property in the
    ///             <code>ResourceTargetDefinition</code> structure. For example, if the
    ///             <code>RequiresRecreation</code> field is <code>Always</code> and the
    ///             <code>Evaluation</code> field is <code>Static</code>, <code>Replacement</code> is
    ///             <code>True</code>. If the <code>RequiresRecreation</code> field is <code>Always</code>
    ///          and the <code>Evaluation</code> field is <code>Dynamic</code>, <code>Replacement</code> is
    ///             <code>Conditionally</code>.</p>
    ///          <p>If you have multiple changes with different <code>RequiresRecreation</code> values,
    ///          the <code>Replacement</code> value depends on the change with the most impact. A
    ///             <code>RequiresRecreation</code> value of <code>Always</code> has the most impact,
    ///          followed by <code>Conditionally</code>, and then <code>Never</code>.</p>
    public let replacement: Replacement?
    /// <p>The type of AWS CloudFormation resource, such as
    ///          <code>AWS::S3::Bucket</code>.</p>
    public let resourceType: String?
    /// <p>For the <code>Modify</code> action, indicates which resource attribute is triggering
    ///          this update, such as a change in the resource attribute's <code>Metadata</code>,
    ///             <code>Properties</code>, or <code>Tags</code>.</p>
    public let scope: [ResourceAttribute]?

    public init (
        action: ChangeAction? = nil,
        changeSetId: String? = nil,
        details: [ResourceChangeDetail]? = nil,
        logicalResourceId: String? = nil,
        moduleInfo: ModuleInfo? = nil,
        physicalResourceId: String? = nil,
        replacement: Replacement? = nil,
        resourceType: String? = nil,
        scope: [ResourceAttribute]? = nil
    )
    {
        self.action = action
        self.changeSetId = changeSetId
        self.details = details
        self.logicalResourceId = logicalResourceId
        self.moduleInfo = moduleInfo
        self.physicalResourceId = physicalResourceId
        self.replacement = replacement
        self.resourceType = resourceType
        self.scope = scope
    }
}

extension ResourceChangeDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case causingEntity = "CausingEntity"
        case changeSource = "ChangeSource"
        case evaluation = "Evaluation"
        case target = "Target"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let causingEntity = causingEntity {
            try container.encode(causingEntity, forKey: Key("CausingEntity"))
        }
        if let changeSource = changeSource {
            try container.encode(changeSource, forKey: Key("ChangeSource"))
        }
        if let evaluation = evaluation {
            try container.encode(evaluation, forKey: Key("Evaluation"))
        }
        if let target = target {
            try container.encode(target, forKey: Key("Target"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(ResourceTargetDefinition.self, forKey: .target)
        target = targetDecoded
        let evaluationDecoded = try containerValues.decodeIfPresent(EvaluationType.self, forKey: .evaluation)
        evaluation = evaluationDecoded
        let changeSourceDecoded = try containerValues.decodeIfPresent(ChangeSource.self, forKey: .changeSource)
        changeSource = changeSourceDecoded
        let causingEntityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .causingEntity)
        causingEntity = causingEntityDecoded
    }
}

extension ResourceChangeDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceChangeDetail(causingEntity: \(String(describing: causingEntity)), changeSource: \(String(describing: changeSource)), evaluation: \(String(describing: evaluation)), target: \(String(describing: target)))"}
}

/// <p>For a resource with <code>Modify</code> as the action, the
///             <code>ResourceChange</code> structure describes the changes AWS CloudFormation will make
///          to that resource.</p>
public struct ResourceChangeDetail: Equatable {
    /// <p>The identity of the entity that triggered this change. This entity is a member of the
    ///          group that is specified by the <code>ChangeSource</code> field. For example, if you
    ///          modified the value of the <code>KeyPairName</code> parameter, the
    ///             <code>CausingEntity</code> is the name of the parameter
    ///          (<code>KeyPairName</code>).</p>
    ///          <p>If the <code>ChangeSource</code> value is <code>DirectModification</code>, no value
    ///          is given for <code>CausingEntity</code>.</p>
    public let causingEntity: String?
    /// <p>The group to which the <code>CausingEntity</code> value belongs. There are five
    ///          entity groups:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ResourceReference</code> entities are <code>Ref</code> intrinsic functions that
    ///                refer to resources in the template, such as <code>{ "Ref" : "MyEC2InstanceResource"
    ///                   }</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ParameterReference</code> entities are <code>Ref</code> intrinsic functions
    ///                that get template parameter values, such as <code>{ "Ref" : "MyPasswordParameter"
    ///                   }</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ResourceAttribute</code> entities are <code>Fn::GetAtt</code> intrinsic
    ///                functions that get resource attribute values, such as <code>{ "Fn::GetAtt" : [
    ///                   "MyEC2InstanceResource", "PublicDnsName" ] }</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DirectModification</code> entities are changes that are made directly to the
    ///                template.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Automatic</code> entities are <code>AWS::CloudFormation::Stack</code> resource
    ///                types, which are also known as nested stacks. If you made no changes to the
    ///                   <code>AWS::CloudFormation::Stack</code> resource, AWS CloudFormation sets the
    ///                   <code>ChangeSource</code> to <code>Automatic</code> because the nested stack's
    ///                template might have changed. Changes to a nested stack's template aren't visible to
    ///                AWS CloudFormation until you run an update on the parent stack.</p>
    ///             </li>
    ///          </ul>
    public let changeSource: ChangeSource?
    /// <p>Indicates whether AWS CloudFormation can determine the target value, and whether the
    ///          target value will change before you execute a change set.</p>
    ///          <p>For <code>Static</code> evaluations, AWS CloudFormation can determine that the target
    ///          value will change, and its value. For example, if you directly modify the
    ///             <code>InstanceType</code> property of an EC2 instance, AWS CloudFormation knows that
    ///          this property value will change, and its value, so this is a <code>Static</code>
    ///          evaluation.</p>
    ///          <p>For <code>Dynamic</code> evaluations, cannot determine the target value because it
    ///          depends on the result of an intrinsic function, such as a <code>Ref</code> or
    ///             <code>Fn::GetAtt</code> intrinsic function, when the stack is updated. For example, if
    ///          your template includes a reference to a resource that is conditionally recreated, the value
    ///          of the reference (the physical ID of the resource) might change, depending on if the
    ///          resource is recreated. If the resource is recreated, it will have a new physical ID, so all
    ///          references to that resource will also be updated.</p>
    public let evaluation: EvaluationType?
    /// <p>A <code>ResourceTargetDefinition</code> structure that describes the field that AWS
    ///          CloudFormation will change and whether the resource will be recreated.</p>
    public let target: ResourceTargetDefinition?

    public init (
        causingEntity: String? = nil,
        changeSource: ChangeSource? = nil,
        evaluation: EvaluationType? = nil,
        target: ResourceTargetDefinition? = nil
    )
    {
        self.causingEntity = causingEntity
        self.changeSource = changeSource
        self.evaluation = evaluation
        self.target = target
    }
}

extension ResourceIdentifierSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logicalResourceIds = "LogicalResourceIds"
        case resourceIdentifiers = "ResourceIdentifiers"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let logicalResourceIds = logicalResourceIds {
            var logicalResourceIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LogicalResourceIds"))
            for (index0, logicalresourceid0) in logicalResourceIds.enumerated() {
                try logicalResourceIdsContainer.encode(logicalresourceid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceIdentifiers = resourceIdentifiers {
            var resourceIdentifiersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ResourceIdentifiers"))
            for (index0, resourceidentifierpropertykey0) in resourceIdentifiers.enumerated() {
                try resourceIdentifiersContainer.encode(resourceidentifierpropertykey0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceType = resourceType {
            try container.encode(resourceType, forKey: Key("ResourceType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        if containerValues.contains(.logicalResourceIds) {
            struct KeyVal0{struct member{}}
            let logicalResourceIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .logicalResourceIds)
            if let logicalResourceIdsWrappedContainer = logicalResourceIdsWrappedContainer {
                let logicalResourceIdsContainer = try logicalResourceIdsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var logicalResourceIdsBuffer:[String]? = nil
                if let logicalResourceIdsContainer = logicalResourceIdsContainer {
                    logicalResourceIdsBuffer = [String]()
                    for stringContainer0 in logicalResourceIdsContainer {
                        logicalResourceIdsBuffer?.append(stringContainer0)
                    }
                }
                logicalResourceIds = logicalResourceIdsBuffer
            } else {
                logicalResourceIds = []
            }
        } else {
            logicalResourceIds = nil
        }
        if containerValues.contains(.resourceIdentifiers) {
            struct KeyVal0{struct member{}}
            let resourceIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .resourceIdentifiers)
            if let resourceIdentifiersWrappedContainer = resourceIdentifiersWrappedContainer {
                let resourceIdentifiersContainer = try resourceIdentifiersWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var resourceIdentifiersBuffer:[String]? = nil
                if let resourceIdentifiersContainer = resourceIdentifiersContainer {
                    resourceIdentifiersBuffer = [String]()
                    for stringContainer0 in resourceIdentifiersContainer {
                        resourceIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                resourceIdentifiers = resourceIdentifiersBuffer
            } else {
                resourceIdentifiers = []
            }
        } else {
            resourceIdentifiers = nil
        }
    }
}

extension ResourceIdentifierSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceIdentifierSummary(logicalResourceIds: \(String(describing: logicalResourceIds)), resourceIdentifiers: \(String(describing: resourceIdentifiers)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Describes the target resources of a specific type in your import template (for example,
///          all <code>AWS::S3::Bucket</code> resources) and the properties you can provide during the
///          import to identify resources of that type.</p>
public struct ResourceIdentifierSummary: Equatable {
    /// <p>The logical IDs of the target resources of the specified <code>ResourceType</code>, as
    ///          defined in the import template.</p>
    public let logicalResourceIds: [String]?
    /// <p>The resource properties you can provide during the import to identify your target
    ///          resources. For example, <code>BucketName</code> is a possible identifier property for
    ///             <code>AWS::S3::Bucket</code> resources.</p>
    public let resourceIdentifiers: [String]?
    /// <p>The template resource type of the target resources, such as
    ///          <code>AWS::S3::Bucket</code>.</p>
    public let resourceType: String?

    public init (
        logicalResourceIds: [String]? = nil,
        resourceIdentifiers: [String]? = nil,
        resourceType: String? = nil
    )
    {
        self.logicalResourceIds = logicalResourceIds
        self.resourceIdentifiers = resourceIdentifiers
        self.resourceType = resourceType
    }
}

public enum ResourceSignalStatus {
    case failure
    case success
    case sdkUnknown(String)
}

extension ResourceSignalStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceSignalStatus] {
        return [
            .failure,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failure: return "FAILURE"
        case .success: return "SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceSignalStatus(rawValue: rawValue) ?? ResourceSignalStatus.sdkUnknown(rawValue)
    }
}

public enum ResourceStatus {
    case createComplete
    case createFailed
    case createInProgress
    case deleteComplete
    case deleteFailed
    case deleteInProgress
    case deleteSkipped
    case importComplete
    case importFailed
    case importInProgress
    case importRollbackComplete
    case importRollbackFailed
    case importRollbackInProgress
    case updateComplete
    case updateFailed
    case updateInProgress
    case sdkUnknown(String)
}

extension ResourceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceStatus] {
        return [
            .createComplete,
            .createFailed,
            .createInProgress,
            .deleteComplete,
            .deleteFailed,
            .deleteInProgress,
            .deleteSkipped,
            .importComplete,
            .importFailed,
            .importInProgress,
            .importRollbackComplete,
            .importRollbackFailed,
            .importRollbackInProgress,
            .updateComplete,
            .updateFailed,
            .updateInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createComplete: return "CREATE_COMPLETE"
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .deleteComplete: return "DELETE_COMPLETE"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .deleteSkipped: return "DELETE_SKIPPED"
        case .importComplete: return "IMPORT_COMPLETE"
        case .importFailed: return "IMPORT_FAILED"
        case .importInProgress: return "IMPORT_IN_PROGRESS"
        case .importRollbackComplete: return "IMPORT_ROLLBACK_COMPLETE"
        case .importRollbackFailed: return "IMPORT_ROLLBACK_FAILED"
        case .importRollbackInProgress: return "IMPORT_ROLLBACK_IN_PROGRESS"
        case .updateComplete: return "UPDATE_COMPLETE"
        case .updateFailed: return "UPDATE_FAILED"
        case .updateInProgress: return "UPDATE_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceStatus(rawValue: rawValue) ?? ResourceStatus.sdkUnknown(rawValue)
    }
}

extension ResourceTargetDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case name = "Name"
        case requiresRecreation = "RequiresRecreation"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attribute = attribute {
            try container.encode(attribute, forKey: Key("Attribute"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let requiresRecreation = requiresRecreation {
            try container.encode(requiresRecreation, forKey: Key("RequiresRecreation"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(ResourceAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let requiresRecreationDecoded = try containerValues.decodeIfPresent(RequiresRecreation.self, forKey: .requiresRecreation)
        requiresRecreation = requiresRecreationDecoded
    }
}

extension ResourceTargetDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceTargetDefinition(attribute: \(String(describing: attribute)), name: \(String(describing: name)), requiresRecreation: \(String(describing: requiresRecreation)))"}
}

/// <p>The field that AWS CloudFormation will change, such as the name of a resource's
///          property, and whether the resource will be recreated.</p>
public struct ResourceTargetDefinition: Equatable {
    /// <p>Indicates which resource attribute is triggering this update, such as a change in the
    ///          resource attribute's <code>Metadata</code>, <code>Properties</code>, or
    ///          <code>Tags</code>.</p>
    public let attribute: ResourceAttribute?
    /// <p>If the <code>Attribute</code> value is <code>Properties</code>, the name of the
    ///          property. For all other attributes, the value is null.</p>
    public let name: String?
    /// <p>If the <code>Attribute</code> value is <code>Properties</code>, indicates whether a
    ///          change to this property causes the resource to be recreated. The value can be
    ///             <code>Never</code>, <code>Always</code>, or <code>Conditionally</code>. To determine the
    ///          conditions for a <code>Conditionally</code> recreation, see the update behavior for that
    ///             <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">property</a> in the AWS CloudFormation User Guide.</p>
    public let requiresRecreation: RequiresRecreation?

    public init (
        attribute: ResourceAttribute? = nil,
        name: String? = nil,
        requiresRecreation: RequiresRecreation? = nil
    )
    {
        self.attribute = attribute
        self.name = name
        self.requiresRecreation = requiresRecreation
    }
}

extension ResourceToImport: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logicalResourceId = "LogicalResourceId"
        case resourceIdentifier = "ResourceIdentifier"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let logicalResourceId = logicalResourceId {
            try container.encode(logicalResourceId, forKey: Key("LogicalResourceId"))
        }
        if let resourceIdentifier = resourceIdentifier {
            var resourceIdentifierContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ResourceIdentifier"))
            for (index0, element0) in resourceIdentifier.sorted(by: { $0.key < $1.key }).enumerated() {
                let resourceidentifierpropertykeyKey0 = element0.key
                let resourceidentifierpropertyvalueValue0 = element0.value
                var entryContainer0 = resourceIdentifierContainer.nestedContainer(keyedBy: Key.self, forKey: Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("key"))
                try keyContainer0.encode(resourceidentifierpropertykeyKey0, forKey: Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("value"))
                try valueContainer0.encode(resourceidentifierpropertyvalueValue0, forKey: Key(""))
            }
        }
        if let resourceType = resourceType {
            try container.encode(resourceType, forKey: Key("ResourceType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        if containerValues.contains(.resourceIdentifier) {
            struct KeyVal0{struct key{}; struct value{}}
            let resourceIdentifierWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .resourceIdentifier)
            if let resourceIdentifierWrappedContainer = resourceIdentifierWrappedContainer {
                let resourceIdentifierContainer = try resourceIdentifierWrappedContainer.decodeIfPresent([MapKeyValue<String, String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var resourceIdentifierBuffer: [String:String]? = nil
                if let resourceIdentifierContainer = resourceIdentifierContainer {
                    resourceIdentifierBuffer = [String:String]()
                    for stringContainer0 in resourceIdentifierContainer {
                        resourceIdentifierBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                resourceIdentifier = resourceIdentifierBuffer
            } else {
                resourceIdentifier = [:]
            }
        } else {
            resourceIdentifier = nil
        }
    }
}

extension ResourceToImport: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceToImport(logicalResourceId: \(String(describing: logicalResourceId)), resourceIdentifier: \(String(describing: resourceIdentifier)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Describes the target resource of an import operation.</p>
public struct ResourceToImport: Equatable {
    /// <p>The logical ID of the target resource as specified in the template.</p>
    public let logicalResourceId: String?
    /// <p>A key-value pair that identifies the target resource. The key is an identifier property
    ///          (for example, <code>BucketName</code> for <code>AWS::S3::Bucket</code> resources) and the
    ///          value is the actual property value (for example, <code>MyS3Bucket</code>).</p>
    public let resourceIdentifier: [String:String]?
    /// <p>The type of resource to import into your stack, such as <code>AWS::S3::Bucket</code>. For a list of supported resource types, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resource-import-supported-resources.html">Resources that support import operations</a> in the AWS CloudFormation User Guide.</p>
    public let resourceType: String?

    public init (
        logicalResourceId: String? = nil,
        resourceIdentifier: [String:String]? = nil,
        resourceType: String? = nil
    )
    {
        self.logicalResourceId = logicalResourceId
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

extension RollbackConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case monitoringTimeInMinutes = "MonitoringTimeInMinutes"
        case rollbackTriggers = "RollbackTriggers"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let monitoringTimeInMinutes = monitoringTimeInMinutes {
            try container.encode(monitoringTimeInMinutes, forKey: Key("MonitoringTimeInMinutes"))
        }
        if let rollbackTriggers = rollbackTriggers {
            var rollbackTriggersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("RollbackTriggers"))
            for (index0, rollbacktrigger0) in rollbackTriggers.enumerated() {
                try rollbackTriggersContainer.encode(rollbacktrigger0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.rollbackTriggers) {
            struct KeyVal0{struct member{}}
            let rollbackTriggersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .rollbackTriggers)
            if let rollbackTriggersWrappedContainer = rollbackTriggersWrappedContainer {
                let rollbackTriggersContainer = try rollbackTriggersWrappedContainer.decodeIfPresent([RollbackTrigger].self, forKey: .member)
                var rollbackTriggersBuffer:[RollbackTrigger]? = nil
                if let rollbackTriggersContainer = rollbackTriggersContainer {
                    rollbackTriggersBuffer = [RollbackTrigger]()
                    for structureContainer0 in rollbackTriggersContainer {
                        rollbackTriggersBuffer?.append(structureContainer0)
                    }
                }
                rollbackTriggers = rollbackTriggersBuffer
            } else {
                rollbackTriggers = []
            }
        } else {
            rollbackTriggers = nil
        }
        let monitoringTimeInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .monitoringTimeInMinutes)
        monitoringTimeInMinutes = monitoringTimeInMinutesDecoded
    }
}

extension RollbackConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RollbackConfiguration(monitoringTimeInMinutes: \(String(describing: monitoringTimeInMinutes)), rollbackTriggers: \(String(describing: rollbackTriggers)))"}
}

/// <p>Structure containing the rollback triggers for AWS CloudFormation to monitor during stack creation
///          and updating operations, and for the specified monitoring period afterwards.</p>
///          <p>Rollback triggers enable you to have AWS CloudFormation monitor the state of your application
///          during stack creation and updating, and to roll back that operation if the application
///          breaches the threshold of any of the alarms you've specified. For more information, see
///             <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-rollback-triggers.html">Monitor and Roll Back Stack
///             Operations</a>.</p>
public struct RollbackConfiguration: Equatable {
    /// <p>The amount of time, in minutes, during which CloudFormation should monitor all the
    ///          rollback triggers after the stack creation or update operation deploys all necessary
    ///          resources.</p>
    ///          <p>The default is 0 minutes.</p>
    ///          <p>If you specify a monitoring period but do not specify any rollback triggers,
    ///          CloudFormation still waits the specified period of time before cleaning up old resources
    ///          after update operations. You can use this monitoring period to perform any manual stack
    ///          validation desired, and manually cancel the stack creation or update (using <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_CancelUpdateStack.html">CancelUpdateStack</a>, for example) as necessary.</p>
    ///          <p>If you specify 0 for this parameter, CloudFormation still monitors the specified
    ///          rollback triggers during stack creation and update operations. Then, for update operations,
    ///          it begins disposing of old resources immediately once the operation completes.</p>
    public let monitoringTimeInMinutes: Int?
    /// <p>The triggers to monitor during stack creation or update actions. </p>
    ///          <p>By default, AWS CloudFormation saves the rollback triggers specified for a stack and applies them
    ///          to any subsequent update operations for the stack, unless you specify otherwise. If you do
    ///          specify rollback triggers for this parameter, those triggers replace any list of triggers
    ///          previously specified for the stack. This means:</p>
    ///          <ul>
    ///             <li>
    ///                <p>To use the rollback triggers previously specified for this stack, if any, don't
    ///                specify this parameter.</p>
    ///             </li>
    ///             <li>
    ///                <p>To specify new or updated rollback triggers, you must specify
    ///                   <i>all</i> the triggers that you want used for this stack, even
    ///                triggers you've specifed before (for example, when creating the stack or during a
    ///                previous stack update). Any triggers that you don't include in the updated list of
    ///                triggers are no longer applied to the stack.</p>
    ///             </li>
    ///             <li>
    ///                <p>To remove all currently specified triggers, specify an empty list for this
    ///                parameter.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If a specified trigger is missing, the entire stack operation fails and is rolled
    ///          back. </p>
    public let rollbackTriggers: [RollbackTrigger]?

    public init (
        monitoringTimeInMinutes: Int? = nil,
        rollbackTriggers: [RollbackTrigger]? = nil
    )
    {
        self.monitoringTimeInMinutes = monitoringTimeInMinutes
        self.rollbackTriggers = rollbackTriggers
    }
}

extension RollbackTrigger: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension RollbackTrigger: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RollbackTrigger(arn: \(String(describing: arn)), type: \(String(describing: type)))"}
}

/// <p>A rollback trigger AWS CloudFormation monitors during creation and updating of stacks. If any of
///          the alarms you specify goes to ALARM state during the stack operation or within the
///          specified monitoring period afterwards, CloudFormation rolls back the entire stack
///          operation. </p>
public struct RollbackTrigger: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the rollback trigger.</p>
    ///          <p>If a specified trigger is missing, the entire stack operation fails and is rolled
    ///          back. </p>
    public let arn: String?
    /// <p>The resource type of the rollback trigger. Currently, <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cw-alarm.html">AWS::CloudWatch::Alarm</a> is the only supported resource type.</p>
    public let type: String?

    public init (
        arn: String? = nil,
        type: String? = nil
    )
    {
        self.arn = arn
        self.type = type
    }
}

public struct SetStackPolicyInputBodyMiddleware: Middleware {
    public let id: String = "SetStackPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetStackPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SetStackPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetStackPolicyInput>
    public typealias MOutput = OperationOutput<SetStackPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetStackPolicyOutputError>
}

extension SetStackPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetStackPolicyInput(stackName: \(String(describing: stackName)), stackPolicyBody: \(String(describing: stackPolicyBody)), stackPolicyURL: \(String(describing: stackPolicyURL)))"}
}

extension SetStackPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        if let stackPolicyBody = stackPolicyBody {
            try container.encode(stackPolicyBody, forKey: Key("StackPolicyBody"))
        }
        if let stackPolicyURL = stackPolicyURL {
            try container.encode(stackPolicyURL, forKey: Key("StackPolicyURL"))
        }
        try container.encode("SetStackPolicy", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct SetStackPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "SetStackPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetStackPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SetStackPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetStackPolicyInput>
    public typealias MOutput = OperationOutput<SetStackPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetStackPolicyOutputError>
}

public struct SetStackPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "SetStackPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetStackPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SetStackPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetStackPolicyInput>
    public typealias MOutput = OperationOutput<SetStackPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetStackPolicyOutputError>
}

/// <p>The input for the <a>SetStackPolicy</a> action.</p>
public struct SetStackPolicyInput: Equatable {
    /// <p>The name or unique stack ID that you want to associate a policy with.</p>
    public let stackName: String?
    /// <p>Structure containing the stack policy body. For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/protect-stack-resources.html"> Prevent Updates
    ///             to Stack Resources</a> in the AWS CloudFormation User Guide. You can specify either
    ///          the <code>StackPolicyBody</code> or the <code>StackPolicyURL</code> parameter, but not
    ///          both.</p>
    public let stackPolicyBody: String?
    /// <p>Location of a file containing the stack policy. The URL must point to a policy
    ///          (maximum size: 16 KB) located in an S3 bucket in the same
    ///          Region as the stack. You can specify either the <code>StackPolicyBody</code> or the
    ///             <code>StackPolicyURL</code> parameter, but not both.</p>
    public let stackPolicyURL: String?

    public init (
        stackName: String? = nil,
        stackPolicyBody: String? = nil,
        stackPolicyURL: String? = nil
    )
    {
        self.stackName = stackName
        self.stackPolicyBody = stackPolicyBody
        self.stackPolicyURL = stackPolicyURL
    }
}

extension SetStackPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetStackPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetStackPolicyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SetStackPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetStackPolicyOutputResponse()"}
}

extension SetStackPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetStackPolicyOutputResponse: Equatable {

    public init() {}
}

struct SetStackPolicyOutputResponseBody: Equatable {
}

extension SetStackPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetTypeDefaultVersionInputBodyMiddleware: Middleware {
    public let id: String = "SetTypeDefaultVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetTypeDefaultVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<SetTypeDefaultVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetTypeDefaultVersionInput>
    public typealias MOutput = OperationOutput<SetTypeDefaultVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetTypeDefaultVersionOutputError>
}

extension SetTypeDefaultVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetTypeDefaultVersionInput(arn: \(String(describing: arn)), type: \(String(describing: type)), typeName: \(String(describing: typeName)), versionId: \(String(describing: versionId)))"}
}

extension SetTypeDefaultVersionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
        if let typeName = typeName {
            try container.encode(typeName, forKey: Key("TypeName"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: Key("VersionId"))
        }
        try container.encode("SetTypeDefaultVersion", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct SetTypeDefaultVersionInputHeadersMiddleware: Middleware {
    public let id: String = "SetTypeDefaultVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetTypeDefaultVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<SetTypeDefaultVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetTypeDefaultVersionInput>
    public typealias MOutput = OperationOutput<SetTypeDefaultVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetTypeDefaultVersionOutputError>
}

public struct SetTypeDefaultVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "SetTypeDefaultVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetTypeDefaultVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<SetTypeDefaultVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetTypeDefaultVersionInput>
    public typealias MOutput = OperationOutput<SetTypeDefaultVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetTypeDefaultVersionOutputError>
}

public struct SetTypeDefaultVersionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the extension for which you want version summary information.</p>
    ///          <p>Conditional: You must specify either <code>TypeName</code> and <code>Type</code>, or <code>Arn</code>.</p>
    public let arn: String?
    /// <p>The kind of extension.</p>
    ///          <p>Conditional: You must specify either <code>TypeName</code> and <code>Type</code>, or <code>Arn</code>.</p>
    public let type: RegistryType?
    /// <p>The name of the extension.</p>
    ///          <p>Conditional: You must specify either <code>TypeName</code> and <code>Type</code>, or <code>Arn</code>.</p>
    public let typeName: String?
    /// <p>The ID of a specific version of the extension. The version ID is the value at the end of the Amazon Resource Name (ARN) assigned to the extension version when it is registered.</p>
    public let versionId: String?

    public init (
        arn: String? = nil,
        type: RegistryType? = nil,
        typeName: String? = nil,
        versionId: String? = nil
    )
    {
        self.arn = arn
        self.type = type
        self.typeName = typeName
        self.versionId = versionId
    }
}

extension SetTypeDefaultVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetTypeDefaultVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CFNRegistryException" : self = .cFNRegistryException(try CFNRegistryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TypeNotFoundException" : self = .typeNotFoundException(try TypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetTypeDefaultVersionOutputError: Equatable {
    case cFNRegistryException(CFNRegistryException)
    case typeNotFoundException(TypeNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetTypeDefaultVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetTypeDefaultVersionOutputResponse()"}
}

extension SetTypeDefaultVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetTypeDefaultVersionOutputResponse: Equatable {

    public init() {}
}

struct SetTypeDefaultVersionOutputResponseBody: Equatable {
}

extension SetTypeDefaultVersionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SignalResourceInputBodyMiddleware: Middleware {
    public let id: String = "SignalResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SignalResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<SignalResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SignalResourceInput>
    public typealias MOutput = OperationOutput<SignalResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SignalResourceOutputError>
}

extension SignalResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SignalResourceInput(logicalResourceId: \(String(describing: logicalResourceId)), stackName: \(String(describing: stackName)), status: \(String(describing: status)), uniqueId: \(String(describing: uniqueId)))"}
}

extension SignalResourceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let logicalResourceId = logicalResourceId {
            try container.encode(logicalResourceId, forKey: Key("LogicalResourceId"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let uniqueId = uniqueId {
            try container.encode(uniqueId, forKey: Key("UniqueId"))
        }
        try container.encode("SignalResource", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct SignalResourceInputHeadersMiddleware: Middleware {
    public let id: String = "SignalResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SignalResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<SignalResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SignalResourceInput>
    public typealias MOutput = OperationOutput<SignalResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SignalResourceOutputError>
}

public struct SignalResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "SignalResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SignalResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<SignalResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SignalResourceInput>
    public typealias MOutput = OperationOutput<SignalResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SignalResourceOutputError>
}

/// <p>The input for the <a>SignalResource</a> action.</p>
public struct SignalResourceInput: Equatable {
    /// <p>The logical ID of the resource that you want to signal. The logical ID is the name of
    ///          the resource that given in the template.</p>
    public let logicalResourceId: String?
    /// <p>The stack name or unique stack ID that includes the resource that you want to
    ///          signal.</p>
    public let stackName: String?
    /// <p>The status of the signal, which is either success or failure. A failure signal causes
    ///          AWS CloudFormation to immediately fail the stack creation or update.</p>
    public let status: ResourceSignalStatus?
    /// <p>A unique ID of the signal. When you signal Amazon EC2 instances or Auto Scaling
    ///          groups, specify the instance ID that you are signaling as the unique ID. If you send
    ///          multiple signals to a single resource (such as signaling a wait condition), each signal
    ///          requires a different unique ID.</p>
    public let uniqueId: String?

    public init (
        logicalResourceId: String? = nil,
        stackName: String? = nil,
        status: ResourceSignalStatus? = nil,
        uniqueId: String? = nil
    )
    {
        self.logicalResourceId = logicalResourceId
        self.stackName = stackName
        self.status = status
        self.uniqueId = uniqueId
    }
}

extension SignalResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SignalResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SignalResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SignalResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SignalResourceOutputResponse()"}
}

extension SignalResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SignalResourceOutputResponse: Equatable {

    public init() {}
}

struct SignalResourceOutputResponseBody: Equatable {
}

extension SignalResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Stack: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case capabilities = "Capabilities"
        case changeSetId = "ChangeSetId"
        case creationTime = "CreationTime"
        case deletionTime = "DeletionTime"
        case description = "Description"
        case disableRollback = "DisableRollback"
        case driftInformation = "DriftInformation"
        case enableTerminationProtection = "EnableTerminationProtection"
        case lastUpdatedTime = "LastUpdatedTime"
        case notificationARNs = "NotificationARNs"
        case outputs = "Outputs"
        case parameters = "Parameters"
        case parentId = "ParentId"
        case roleARN = "RoleARN"
        case rollbackConfiguration = "RollbackConfiguration"
        case rootId = "RootId"
        case stackId = "StackId"
        case stackName = "StackName"
        case stackStatus = "StackStatus"
        case stackStatusReason = "StackStatusReason"
        case tags = "Tags"
        case timeoutInMinutes = "TimeoutInMinutes"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Capabilities"))
            for (index0, capability0) in capabilities.enumerated() {
                try capabilitiesContainer.encode(capability0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let changeSetId = changeSetId {
            try container.encode(changeSetId, forKey: Key("ChangeSetId"))
        }
        if let creationTime = creationTime {
            try container.encode(TimestampWrapper(creationTime, format: .dateTime), forKey: Key("creationTime"))
        }
        if let deletionTime = deletionTime {
            try container.encode(TimestampWrapper(deletionTime, format: .dateTime), forKey: Key("deletionTime"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let disableRollback = disableRollback {
            try container.encode(disableRollback, forKey: Key("DisableRollback"))
        }
        if let driftInformation = driftInformation {
            try container.encode(driftInformation, forKey: Key("DriftInformation"))
        }
        if let enableTerminationProtection = enableTerminationProtection {
            try container.encode(enableTerminationProtection, forKey: Key("EnableTerminationProtection"))
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try container.encode(TimestampWrapper(lastUpdatedTime, format: .dateTime), forKey: Key("lastUpdatedTime"))
        }
        if let notificationARNs = notificationARNs {
            var notificationARNsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("NotificationARNs"))
            for (index0, notificationarn0) in notificationARNs.enumerated() {
                try notificationARNsContainer.encode(notificationarn0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let outputs = outputs {
            var outputsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Outputs"))
            for (index0, output0) in outputs.enumerated() {
                try outputsContainer.encode(output0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let parentId = parentId {
            try container.encode(parentId, forKey: Key("ParentId"))
        }
        if let roleARN = roleARN {
            try container.encode(roleARN, forKey: Key("RoleARN"))
        }
        if let rollbackConfiguration = rollbackConfiguration {
            try container.encode(rollbackConfiguration, forKey: Key("RollbackConfiguration"))
        }
        if let rootId = rootId {
            try container.encode(rootId, forKey: Key("RootId"))
        }
        if let stackId = stackId {
            try container.encode(stackId, forKey: Key("StackId"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        if let stackStatus = stackStatus {
            try container.encode(stackStatus, forKey: Key("StackStatus"))
        }
        if let stackStatusReason = stackStatusReason {
            try container.encode(stackStatusReason, forKey: Key("StackStatusReason"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let timeoutInMinutes = timeoutInMinutes {
            try container.encode(timeoutInMinutes, forKey: Key("TimeoutInMinutes"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let changeSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct member{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([Parameter].self, forKey: .member)
                var parametersBuffer:[Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        var creationTimeBuffer:Date? = nil
        if let creationTimeDecoded = creationTimeDecoded {
            creationTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationTimeDecoded, format: .dateTime)
        }
        creationTime = creationTimeBuffer
        let deletionTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deletionTime)
        var deletionTimeBuffer:Date? = nil
        if let deletionTimeDecoded = deletionTimeDecoded {
            deletionTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(deletionTimeDecoded, format: .dateTime)
        }
        deletionTime = deletionTimeBuffer
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTime)
        var lastUpdatedTimeBuffer:Date? = nil
        if let lastUpdatedTimeDecoded = lastUpdatedTimeDecoded {
            lastUpdatedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastUpdatedTimeDecoded, format: .dateTime)
        }
        lastUpdatedTime = lastUpdatedTimeBuffer
        let rollbackConfigurationDecoded = try containerValues.decodeIfPresent(RollbackConfiguration.self, forKey: .rollbackConfiguration)
        rollbackConfiguration = rollbackConfigurationDecoded
        let stackStatusDecoded = try containerValues.decodeIfPresent(StackStatus.self, forKey: .stackStatus)
        stackStatus = stackStatusDecoded
        let stackStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackStatusReason)
        stackStatusReason = stackStatusReasonDecoded
        let disableRollbackDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disableRollback)
        disableRollback = disableRollbackDecoded
        if containerValues.contains(.notificationARNs) {
            struct KeyVal0{struct member{}}
            let notificationARNsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .notificationARNs)
            if let notificationARNsWrappedContainer = notificationARNsWrappedContainer {
                let notificationARNsContainer = try notificationARNsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var notificationARNsBuffer:[String]? = nil
                if let notificationARNsContainer = notificationARNsContainer {
                    notificationARNsBuffer = [String]()
                    for stringContainer0 in notificationARNsContainer {
                        notificationARNsBuffer?.append(stringContainer0)
                    }
                }
                notificationARNs = notificationARNsBuffer
            } else {
                notificationARNs = []
            }
        } else {
            notificationARNs = nil
        }
        let timeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutInMinutes)
        timeoutInMinutes = timeoutInMinutesDecoded
        if containerValues.contains(.capabilities) {
            struct KeyVal0{struct member{}}
            let capabilitiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .capabilities)
            if let capabilitiesWrappedContainer = capabilitiesWrappedContainer {
                let capabilitiesContainer = try capabilitiesWrappedContainer.decodeIfPresent([Capability].self, forKey: .member)
                var capabilitiesBuffer:[Capability]? = nil
                if let capabilitiesContainer = capabilitiesContainer {
                    capabilitiesBuffer = [Capability]()
                    for stringContainer0 in capabilitiesContainer {
                        capabilitiesBuffer?.append(stringContainer0)
                    }
                }
                capabilities = capabilitiesBuffer
            } else {
                capabilities = []
            }
        } else {
            capabilities = nil
        }
        if containerValues.contains(.outputs) {
            struct KeyVal0{struct member{}}
            let outputsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .outputs)
            if let outputsWrappedContainer = outputsWrappedContainer {
                let outputsContainer = try outputsWrappedContainer.decodeIfPresent([Output].self, forKey: .member)
                var outputsBuffer:[Output]? = nil
                if let outputsContainer = outputsContainer {
                    outputsBuffer = [Output]()
                    for structureContainer0 in outputsContainer {
                        outputsBuffer?.append(structureContainer0)
                    }
                }
                outputs = outputsBuffer
            } else {
                outputs = []
            }
        } else {
            outputs = nil
        }
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let enableTerminationProtectionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableTerminationProtection)
        enableTerminationProtection = enableTerminationProtectionDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let rootIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rootId)
        rootId = rootIdDecoded
        let driftInformationDecoded = try containerValues.decodeIfPresent(StackDriftInformation.self, forKey: .driftInformation)
        driftInformation = driftInformationDecoded
    }
}

extension Stack: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Stack(capabilities: \(String(describing: capabilities)), changeSetId: \(String(describing: changeSetId)), creationTime: \(String(describing: creationTime)), deletionTime: \(String(describing: deletionTime)), description: \(String(describing: description)), disableRollback: \(String(describing: disableRollback)), driftInformation: \(String(describing: driftInformation)), enableTerminationProtection: \(String(describing: enableTerminationProtection)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), notificationARNs: \(String(describing: notificationARNs)), outputs: \(String(describing: outputs)), parameters: \(String(describing: parameters)), parentId: \(String(describing: parentId)), roleARN: \(String(describing: roleARN)), rollbackConfiguration: \(String(describing: rollbackConfiguration)), rootId: \(String(describing: rootId)), stackId: \(String(describing: stackId)), stackName: \(String(describing: stackName)), stackStatus: \(String(describing: stackStatus)), stackStatusReason: \(String(describing: stackStatusReason)), tags: \(String(describing: tags)), timeoutInMinutes: \(String(describing: timeoutInMinutes)))"}
}

/// <p>The Stack data type.</p>
public struct Stack: Equatable {
    /// <p>The capabilities allowed in the stack.</p>
    public let capabilities: [Capability]?
    /// <p>The unique ID of the change set.</p>
    public let changeSetId: String?
    /// <p>The time at which the stack was created.</p>
    public let creationTime: Date?
    /// <p>The time the stack was deleted.</p>
    public let deletionTime: Date?
    /// <p>A user-defined description associated with the stack.</p>
    public let description: String?
    /// <p>Boolean to enable or disable rollback on stack creation failures:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>true</code>: disable rollback</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>false</code>: enable rollback</p>
    ///             </li>
    ///          </ul>
    public let disableRollback: Bool?
    /// <p>Information on whether a stack's actual configuration differs, or has
    ///             <i>drifted</i>, from it's expected configuration, as defined in the stack
    ///          template and any values specified as template parameters. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting Unregulated Configuration
    ///             Changes to Stacks and Resources</a>.</p>
    public let driftInformation: StackDriftInformation?
    /// <p>Whether termination protection is enabled for the stack.</p>
    ///          <p> For <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">nested stacks</a>,
    ///          termination protection is set on the root stack and cannot be changed directly on the
    ///          nested stack. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-protect-stacks.html">Protecting a Stack From Being
    ///             Deleted</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    public let enableTerminationProtection: Bool?
    /// <p>The time the stack was last updated. This field will only be returned if the stack
    ///          has been updated at least once.</p>
    public let lastUpdatedTime: Date?
    /// <p>SNS topic ARNs to which stack related events are published.</p>
    public let notificationARNs: [String]?
    /// <p>A list of output structures.</p>
    public let outputs: [Output]?
    /// <p>A list of <code>Parameter</code> structures.</p>
    public let parameters: [Parameter]?
    /// <p>For nested stacks--stacks created as resources for another stack--the stack ID of the
    ///          direct parent of this stack. For the first level of nested stacks, the root stack is also
    ///          the parent stack.</p>
    ///          <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">Working with Nested Stacks</a> in the
    ///          <i>AWS CloudFormation User Guide</i>.</p>
    public let parentId: String?
    /// <p>The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role
    ///          that is associated with the stack. During a stack operation, AWS CloudFormation uses this
    ///          role's credentials to make calls on your behalf.</p>
    public let roleARN: String?
    /// <p>The rollback triggers for AWS CloudFormation to monitor during stack creation and
    ///          updating operations, and for the specified monitoring period afterwards.</p>
    public let rollbackConfiguration: RollbackConfiguration?
    /// <p>For nested stacks--stacks created as resources for another stack--the stack ID of the
    ///          top-level stack to which the nested stack ultimately belongs.</p>
    ///          <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">Working with Nested Stacks</a> in the
    ///          <i>AWS CloudFormation User Guide</i>.</p>
    public let rootId: String?
    /// <p>Unique identifier of the stack.</p>
    public let stackId: String?
    /// <p>The name associated with the stack.</p>
    public let stackName: String?
    /// <p>Current status of the stack.</p>
    public let stackStatus: StackStatus?
    /// <p>Success/failure message associated with the stack status.</p>
    public let stackStatusReason: String?
    /// <p>A list of <code>Tag</code>s that specify information about the stack.</p>
    public let tags: [Tag]?
    /// <p>The amount of time within which stack creation should complete.</p>
    public let timeoutInMinutes: Int?

    public init (
        capabilities: [Capability]? = nil,
        changeSetId: String? = nil,
        creationTime: Date? = nil,
        deletionTime: Date? = nil,
        description: String? = nil,
        disableRollback: Bool? = nil,
        driftInformation: StackDriftInformation? = nil,
        enableTerminationProtection: Bool? = nil,
        lastUpdatedTime: Date? = nil,
        notificationARNs: [String]? = nil,
        outputs: [Output]? = nil,
        parameters: [Parameter]? = nil,
        parentId: String? = nil,
        roleARN: String? = nil,
        rollbackConfiguration: RollbackConfiguration? = nil,
        rootId: String? = nil,
        stackId: String? = nil,
        stackName: String? = nil,
        stackStatus: StackStatus? = nil,
        stackStatusReason: String? = nil,
        tags: [Tag]? = nil,
        timeoutInMinutes: Int? = nil
    )
    {
        self.capabilities = capabilities
        self.changeSetId = changeSetId
        self.creationTime = creationTime
        self.deletionTime = deletionTime
        self.description = description
        self.disableRollback = disableRollback
        self.driftInformation = driftInformation
        self.enableTerminationProtection = enableTerminationProtection
        self.lastUpdatedTime = lastUpdatedTime
        self.notificationARNs = notificationARNs
        self.outputs = outputs
        self.parameters = parameters
        self.parentId = parentId
        self.roleARN = roleARN
        self.rollbackConfiguration = rollbackConfiguration
        self.rootId = rootId
        self.stackId = stackId
        self.stackName = stackName
        self.stackStatus = stackStatus
        self.stackStatusReason = stackStatusReason
        self.tags = tags
        self.timeoutInMinutes = timeoutInMinutes
    }
}

public enum StackDriftDetectionStatus {
    case detectionComplete
    case detectionFailed
    case detectionInProgress
    case sdkUnknown(String)
}

extension StackDriftDetectionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackDriftDetectionStatus] {
        return [
            .detectionComplete,
            .detectionFailed,
            .detectionInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .detectionComplete: return "DETECTION_COMPLETE"
        case .detectionFailed: return "DETECTION_FAILED"
        case .detectionInProgress: return "DETECTION_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackDriftDetectionStatus(rawValue: rawValue) ?? StackDriftDetectionStatus.sdkUnknown(rawValue)
    }
}

extension StackDriftInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastCheckTimestamp = "LastCheckTimestamp"
        case stackDriftStatus = "StackDriftStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let lastCheckTimestamp = lastCheckTimestamp {
            try container.encode(TimestampWrapper(lastCheckTimestamp, format: .dateTime), forKey: Key("lastCheckTimestamp"))
        }
        if let stackDriftStatus = stackDriftStatus {
            try container.encode(stackDriftStatus, forKey: Key("StackDriftStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackDriftStatusDecoded = try containerValues.decodeIfPresent(StackDriftStatus.self, forKey: .stackDriftStatus)
        stackDriftStatus = stackDriftStatusDecoded
        let lastCheckTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastCheckTimestamp)
        var lastCheckTimestampBuffer:Date? = nil
        if let lastCheckTimestampDecoded = lastCheckTimestampDecoded {
            lastCheckTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastCheckTimestampDecoded, format: .dateTime)
        }
        lastCheckTimestamp = lastCheckTimestampBuffer
    }
}

extension StackDriftInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackDriftInformation(lastCheckTimestamp: \(String(describing: lastCheckTimestamp)), stackDriftStatus: \(String(describing: stackDriftStatus)))"}
}

/// <p>Contains information about whether the stack's actual configuration differs, or has
///             <i>drifted</i>, from its expected configuration, as defined in the stack
///          template and any values specified as template parameters. A stack is considered to have
///          drifted if one or more of its resources have drifted.</p>
public struct StackDriftInformation: Equatable {
    /// <p>Most recent time when a drift detection operation was initiated on the stack, or any
    ///          of its individual resources that support drift detection.</p>
    public let lastCheckTimestamp: Date?
    /// <p>Status of the stack's actual configuration compared to its expected template
    ///          configuration. </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DRIFTED</code>: The stack differs from its expected template
    ///                configuration. A stack is considered to have drifted if one or more of its resources
    ///                have drifted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the stack differs from its
    ///                expected template configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_SYNC</code>: The stack's actual configuration matches its expected
    ///                template configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UNKNOWN</code>: This value is reserved for future use.</p>
    ///             </li>
    ///          </ul>
    public let stackDriftStatus: StackDriftStatus?

    public init (
        lastCheckTimestamp: Date? = nil,
        stackDriftStatus: StackDriftStatus? = nil
    )
    {
        self.lastCheckTimestamp = lastCheckTimestamp
        self.stackDriftStatus = stackDriftStatus
    }
}

extension StackDriftInformationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastCheckTimestamp = "LastCheckTimestamp"
        case stackDriftStatus = "StackDriftStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let lastCheckTimestamp = lastCheckTimestamp {
            try container.encode(TimestampWrapper(lastCheckTimestamp, format: .dateTime), forKey: Key("lastCheckTimestamp"))
        }
        if let stackDriftStatus = stackDriftStatus {
            try container.encode(stackDriftStatus, forKey: Key("StackDriftStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackDriftStatusDecoded = try containerValues.decodeIfPresent(StackDriftStatus.self, forKey: .stackDriftStatus)
        stackDriftStatus = stackDriftStatusDecoded
        let lastCheckTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastCheckTimestamp)
        var lastCheckTimestampBuffer:Date? = nil
        if let lastCheckTimestampDecoded = lastCheckTimestampDecoded {
            lastCheckTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastCheckTimestampDecoded, format: .dateTime)
        }
        lastCheckTimestamp = lastCheckTimestampBuffer
    }
}

extension StackDriftInformationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackDriftInformationSummary(lastCheckTimestamp: \(String(describing: lastCheckTimestamp)), stackDriftStatus: \(String(describing: stackDriftStatus)))"}
}

/// <p>Contains information about whether the stack's actual configuration differs, or has
///             <i>drifted</i>, from its expected configuration, as defined in the stack
///          template and any values specified as template parameters. A stack is considered to have
///          drifted if one or more of its resources have drifted.</p>
public struct StackDriftInformationSummary: Equatable {
    /// <p>Most recent time when a drift detection operation was initiated on the stack, or any
    ///          of its individual resources that support drift detection.</p>
    public let lastCheckTimestamp: Date?
    /// <p>Status of the stack's actual configuration compared to its expected template
    ///          configuration. </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DRIFTED</code>: The stack differs from its expected template
    ///                configuration. A stack is considered to have drifted if one or more of its resources
    ///                have drifted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the stack differs from its
    ///                expected template configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_SYNC</code>: The stack's actual configuration matches its expected
    ///                template configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UNKNOWN</code>: This value is reserved for future use.</p>
    ///             </li>
    ///          </ul>
    public let stackDriftStatus: StackDriftStatus?

    public init (
        lastCheckTimestamp: Date? = nil,
        stackDriftStatus: StackDriftStatus? = nil
    )
    {
        self.lastCheckTimestamp = lastCheckTimestamp
        self.stackDriftStatus = stackDriftStatus
    }
}

public enum StackDriftStatus {
    case drifted
    case inSync
    case notChecked
    case unknown
    case sdkUnknown(String)
}

extension StackDriftStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackDriftStatus] {
        return [
            .drifted,
            .inSync,
            .notChecked,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .drifted: return "DRIFTED"
        case .inSync: return "IN_SYNC"
        case .notChecked: return "NOT_CHECKED"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackDriftStatus(rawValue: rawValue) ?? StackDriftStatus.sdkUnknown(rawValue)
    }
}

extension StackEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case eventId = "EventId"
        case logicalResourceId = "LogicalResourceId"
        case physicalResourceId = "PhysicalResourceId"
        case resourceProperties = "ResourceProperties"
        case resourceStatus = "ResourceStatus"
        case resourceStatusReason = "ResourceStatusReason"
        case resourceType = "ResourceType"
        case stackId = "StackId"
        case stackName = "StackName"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let clientRequestToken = clientRequestToken {
            try container.encode(clientRequestToken, forKey: Key("ClientRequestToken"))
        }
        if let eventId = eventId {
            try container.encode(eventId, forKey: Key("EventId"))
        }
        if let logicalResourceId = logicalResourceId {
            try container.encode(logicalResourceId, forKey: Key("LogicalResourceId"))
        }
        if let physicalResourceId = physicalResourceId {
            try container.encode(physicalResourceId, forKey: Key("PhysicalResourceId"))
        }
        if let resourceProperties = resourceProperties {
            try container.encode(resourceProperties, forKey: Key("ResourceProperties"))
        }
        if let resourceStatus = resourceStatus {
            try container.encode(resourceStatus, forKey: Key("ResourceStatus"))
        }
        if let resourceStatusReason = resourceStatusReason {
            try container.encode(resourceStatusReason, forKey: Key("ResourceStatusReason"))
        }
        if let resourceType = resourceType {
            try container.encode(resourceType, forKey: Key("ResourceType"))
        }
        if let stackId = stackId {
            try container.encode(stackId, forKey: Key("StackId"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        if let timestamp = timestamp {
            try container.encode(TimestampWrapper(timestamp, format: .dateTime), forKey: Key("timestamp"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestamp)
        var timestampBuffer:Date? = nil
        if let timestampDecoded = timestampDecoded {
            timestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(timestampDecoded, format: .dateTime)
        }
        timestamp = timestampBuffer
        let resourceStatusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .resourceStatus)
        resourceStatus = resourceStatusDecoded
        let resourceStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceStatusReason)
        resourceStatusReason = resourceStatusReasonDecoded
        let resourcePropertiesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceProperties)
        resourceProperties = resourcePropertiesDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StackEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackEvent(clientRequestToken: \(String(describing: clientRequestToken)), eventId: \(String(describing: eventId)), logicalResourceId: \(String(describing: logicalResourceId)), physicalResourceId: \(String(describing: physicalResourceId)), resourceProperties: \(String(describing: resourceProperties)), resourceStatus: \(String(describing: resourceStatus)), resourceStatusReason: \(String(describing: resourceStatusReason)), resourceType: \(String(describing: resourceType)), stackId: \(String(describing: stackId)), stackName: \(String(describing: stackName)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>The StackEvent data type.</p>
public struct StackEvent: Equatable {
    /// <p>The token passed to the operation that generated this event.</p>
    ///          <p>All events triggered by a given stack operation are assigned the same client request
    ///          token, which you can use to track operations. For example, if you execute a
    ///          <code>CreateStack</code> operation with the token <code>token1</code>, then all the
    ///          <code>StackEvents</code> generated by that operation will have
    ///          <code>ClientRequestToken</code> set as <code>token1</code>.</p>
    ///          <p>In the console, stack operations display the client request token on the Events tab.
    ///          Stack operations that are initiated from the console use the token format
    ///          <i>Console-StackOperation-ID</i>, which helps you easily identify the
    ///          stack operation . For example, if you create a stack using the console, each stack event
    ///          would be assigned the same token in the following format:
    ///          <code>Console-CreateStack-7f59c3cf-00d2-40c7-b2ff-e75db0987002</code>. </p>
    public let clientRequestToken: String?
    /// <p>The unique ID of this event.</p>
    public let eventId: String?
    /// <p>The logical name of the resource specified in the template.</p>
    public let logicalResourceId: String?
    /// <p>The name or unique identifier associated with the physical instance of the
    ///          resource.</p>
    public let physicalResourceId: String?
    /// <p>BLOB of the properties used to create the resource.</p>
    public let resourceProperties: String?
    /// <p>Current status of the resource.</p>
    public let resourceStatus: ResourceStatus?
    /// <p>Success/failure message associated with the resource.</p>
    public let resourceStatusReason: String?
    /// <p>Type of resource. (For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html"> AWS
    ///             Resource Types Reference</a> in the AWS CloudFormation User Guide.)</p>
    public let resourceType: String?
    /// <p>The unique ID name of the instance of the stack.</p>
    public let stackId: String?
    /// <p>The name associated with a stack.</p>
    public let stackName: String?
    /// <p>Time the status was updated.</p>
    public let timestamp: Date?

    public init (
        clientRequestToken: String? = nil,
        eventId: String? = nil,
        logicalResourceId: String? = nil,
        physicalResourceId: String? = nil,
        resourceProperties: String? = nil,
        resourceStatus: ResourceStatus? = nil,
        resourceStatusReason: String? = nil,
        resourceType: String? = nil,
        stackId: String? = nil,
        stackName: String? = nil,
        timestamp: Date? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.eventId = eventId
        self.logicalResourceId = logicalResourceId
        self.physicalResourceId = physicalResourceId
        self.resourceProperties = resourceProperties
        self.resourceStatus = resourceStatus
        self.resourceStatusReason = resourceStatusReason
        self.resourceType = resourceType
        self.stackId = stackId
        self.stackName = stackName
        self.timestamp = timestamp
    }
}

extension StackInstance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case account = "Account"
        case driftStatus = "DriftStatus"
        case lastDriftCheckTimestamp = "LastDriftCheckTimestamp"
        case organizationalUnitId = "OrganizationalUnitId"
        case parameterOverrides = "ParameterOverrides"
        case region = "Region"
        case stackId = "StackId"
        case stackInstanceStatus = "StackInstanceStatus"
        case stackSetId = "StackSetId"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let account = account {
            try container.encode(account, forKey: Key("Account"))
        }
        if let driftStatus = driftStatus {
            try container.encode(driftStatus, forKey: Key("DriftStatus"))
        }
        if let lastDriftCheckTimestamp = lastDriftCheckTimestamp {
            try container.encode(TimestampWrapper(lastDriftCheckTimestamp, format: .dateTime), forKey: Key("lastDriftCheckTimestamp"))
        }
        if let organizationalUnitId = organizationalUnitId {
            try container.encode(organizationalUnitId, forKey: Key("OrganizationalUnitId"))
        }
        if let parameterOverrides = parameterOverrides {
            var parameterOverridesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ParameterOverrides"))
            for (index0, parameter0) in parameterOverrides.enumerated() {
                try parameterOverridesContainer.encode(parameter0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let region = region {
            try container.encode(region, forKey: Key("Region"))
        }
        if let stackId = stackId {
            try container.encode(stackId, forKey: Key("StackId"))
        }
        if let stackInstanceStatus = stackInstanceStatus {
            try container.encode(stackInstanceStatus, forKey: Key("StackInstanceStatus"))
        }
        if let stackSetId = stackSetId {
            try container.encode(stackSetId, forKey: Key("StackSetId"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let statusReason = statusReason {
            try container.encode(statusReason, forKey: Key("StatusReason"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackSetId)
        stackSetId = stackSetIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let accountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .account)
        account = accountDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        if containerValues.contains(.parameterOverrides) {
            struct KeyVal0{struct member{}}
            let parameterOverridesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .parameterOverrides)
            if let parameterOverridesWrappedContainer = parameterOverridesWrappedContainer {
                let parameterOverridesContainer = try parameterOverridesWrappedContainer.decodeIfPresent([Parameter].self, forKey: .member)
                var parameterOverridesBuffer:[Parameter]? = nil
                if let parameterOverridesContainer = parameterOverridesContainer {
                    parameterOverridesBuffer = [Parameter]()
                    for structureContainer0 in parameterOverridesContainer {
                        parameterOverridesBuffer?.append(structureContainer0)
                    }
                }
                parameterOverrides = parameterOverridesBuffer
            } else {
                parameterOverrides = []
            }
        } else {
            parameterOverrides = nil
        }
        let statusDecoded = try containerValues.decodeIfPresent(StackInstanceStatus.self, forKey: .status)
        status = statusDecoded
        let stackInstanceStatusDecoded = try containerValues.decodeIfPresent(StackInstanceComprehensiveStatus.self, forKey: .stackInstanceStatus)
        stackInstanceStatus = stackInstanceStatusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let organizationalUnitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationalUnitId)
        organizationalUnitId = organizationalUnitIdDecoded
        let driftStatusDecoded = try containerValues.decodeIfPresent(StackDriftStatus.self, forKey: .driftStatus)
        driftStatus = driftStatusDecoded
        let lastDriftCheckTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastDriftCheckTimestamp)
        var lastDriftCheckTimestampBuffer:Date? = nil
        if let lastDriftCheckTimestampDecoded = lastDriftCheckTimestampDecoded {
            lastDriftCheckTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastDriftCheckTimestampDecoded, format: .dateTime)
        }
        lastDriftCheckTimestamp = lastDriftCheckTimestampBuffer
    }
}

extension StackInstance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackInstance(account: \(String(describing: account)), driftStatus: \(String(describing: driftStatus)), lastDriftCheckTimestamp: \(String(describing: lastDriftCheckTimestamp)), organizationalUnitId: \(String(describing: organizationalUnitId)), parameterOverrides: \(String(describing: parameterOverrides)), region: \(String(describing: region)), stackId: \(String(describing: stackId)), stackInstanceStatus: \(String(describing: stackInstanceStatus)), stackSetId: \(String(describing: stackSetId)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)))"}
}

/// <p>An AWS CloudFormation stack, in a specific account and Region, that's part of a stack
///          set operation. A stack instance is a reference to an attempted or actual stack in a given
///          account within a given Region. A stack instance can exist without a stack—for example, if
///          the stack couldn't be created for some reason. A stack instance is associated with only one
///          stack set. Each stack instance contains the ID of its associated stack set, as well as the
///          ID of the actual stack and the stack status.</p>
public struct StackInstance: Equatable {
    /// <p>[Self-managed permissions] The name of the AWS account that the stack instance is associated with.</p>
    public let account: String?
    /// <p>Status of the stack instance's actual configuration compared to the expected template
    ///          and parameter configuration of the stack set to which it belongs. </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DRIFTED</code>: The stack differs from the expected template and parameter
    ///                configuration of the stack set to which it belongs. A stack instance is considered to
    ///                have drifted if one or more of the resources in the associated stack have
    ///                drifted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the stack instance differs from
    ///                its expected stack set configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_SYNC</code>: The stack instance's actual configuration matches its
    ///                expected stack set configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UNKNOWN</code>: This value is reserved for future use.</p>
    ///             </li>
    ///          </ul>
    public let driftStatus: StackDriftStatus?
    /// <p>Most recent time when CloudFormation performed a drift detection operation on the stack
    ///          instance. This value will be <code>NULL</code> for any stack instance on which drift
    ///          detection has not yet been performed.</p>
    public let lastDriftCheckTimestamp: Date?
    /// <p>[Service-managed permissions] The organization root ID or organizational unit (OU) IDs that you specified for <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_DeploymentTargets.html">DeploymentTargets</a>.</p>
    public let organizationalUnitId: String?
    /// <p>A list of parameters from the stack set template whose values have been overridden in
    ///          this stack instance.</p>
    public let parameterOverrides: [Parameter]?
    /// <p>The name of the AWS Region that the stack instance is associated with.</p>
    public let region: String?
    /// <p>The ID of the stack instance.</p>
    public let stackId: String?
    /// <p>The detailed status of the stack instance.</p>
    public let stackInstanceStatus: StackInstanceComprehensiveStatus?
    /// <p>The name or unique ID of the stack set that the stack instance is associated
    ///          with.</p>
    public let stackSetId: String?
    /// <p>The status of the stack instance, in terms of its synchronization with its associated
    ///          stack set.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>INOPERABLE</code>: A <code>DeleteStackInstances</code> operation has
    ///                failed and left the stack in an unstable state. Stacks in this state are excluded
    ///                from further <code>UpdateStackSet</code> operations. You might need to perform a
    ///                   <code>DeleteStackInstances</code> operation, with <code>RetainStacks</code> set to
    ///                   <code>true</code>, to delete the stack instance, and then delete the stack
    ///                manually.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OUTDATED</code>: The stack isn't currently up to date with the stack set
    ///                because:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>The associated stack failed during a <code>CreateStackSet</code> or
    ///                         <code>UpdateStackSet</code> operation. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>The stack was part of a <code>CreateStackSet</code> or
    ///                         <code>UpdateStackSet</code> operation that failed or was stopped before the
    ///                      stack was created or updated. </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CURRENT</code>: The stack is currently up to date with the stack
    ///                set.</p>
    ///             </li>
    ///          </ul>
    public let status: StackInstanceStatus?
    /// <p>The explanation for the specific status code that is assigned to this stack
    ///          instance.</p>
    public let statusReason: String?

    public init (
        account: String? = nil,
        driftStatus: StackDriftStatus? = nil,
        lastDriftCheckTimestamp: Date? = nil,
        organizationalUnitId: String? = nil,
        parameterOverrides: [Parameter]? = nil,
        region: String? = nil,
        stackId: String? = nil,
        stackInstanceStatus: StackInstanceComprehensiveStatus? = nil,
        stackSetId: String? = nil,
        status: StackInstanceStatus? = nil,
        statusReason: String? = nil
    )
    {
        self.account = account
        self.driftStatus = driftStatus
        self.lastDriftCheckTimestamp = lastDriftCheckTimestamp
        self.organizationalUnitId = organizationalUnitId
        self.parameterOverrides = parameterOverrides
        self.region = region
        self.stackId = stackId
        self.stackInstanceStatus = stackInstanceStatus
        self.stackSetId = stackSetId
        self.status = status
        self.statusReason = statusReason
    }
}

extension StackInstanceComprehensiveStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detailedStatus = "DetailedStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let detailedStatus = detailedStatus {
            try container.encode(detailedStatus, forKey: Key("DetailedStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedStatusDecoded = try containerValues.decodeIfPresent(StackInstanceDetailedStatus.self, forKey: .detailedStatus)
        detailedStatus = detailedStatusDecoded
    }
}

extension StackInstanceComprehensiveStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackInstanceComprehensiveStatus(detailedStatus: \(String(describing: detailedStatus)))"}
}

/// <p>The detailed status of the stack instance.</p>
public struct StackInstanceComprehensiveStatus: Equatable {
    /// <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CANCELLED</code>: The operation in the specified account and Region has been cancelled. This is either because a user has stopped the stack set operation, or because the failure tolerance of the stack set operation has been exceeded.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code>: The operation in the specified account and Region failed. If
    ///                the stack set operation fails in enough accounts within a Region, the failure
    ///                tolerance for the stack set operation as a whole might be exceeded.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INOPERABLE</code>: A <code>DeleteStackInstances</code> operation has failed and left the stack in an unstable state. Stacks in this state are excluded from further <code>UpdateStackSet</code> operations. You might need to perform a <code>DeleteStackInstances</code> operation, with <code>RetainStacks</code> set to <code>true</code>, to delete the stack instance, and then delete the stack manually.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PENDING</code>: The operation in the specified account and Region has yet to start.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RUNNING</code>: The operation in the specified account and Region is currently in progress.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SUCCEEDED</code>: The operation in the specified account and Region completed successfully.</p>
    ///             </li>
    ///          </ul>
    public let detailedStatus: StackInstanceDetailedStatus?

    public init (
        detailedStatus: StackInstanceDetailedStatus? = nil
    )
    {
        self.detailedStatus = detailedStatus
    }
}

public enum StackInstanceDetailedStatus {
    case cancelled
    case failed
    case inoperable
    case pending
    case running
    case succeeded
    case sdkUnknown(String)
}

extension StackInstanceDetailedStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackInstanceDetailedStatus] {
        return [
            .cancelled,
            .failed,
            .inoperable,
            .pending,
            .running,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .failed: return "FAILED"
        case .inoperable: return "INOPERABLE"
        case .pending: return "PENDING"
        case .running: return "RUNNING"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackInstanceDetailedStatus(rawValue: rawValue) ?? StackInstanceDetailedStatus.sdkUnknown(rawValue)
    }
}

extension StackInstanceFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let values = values {
            try container.encode(values, forKey: Key("Values"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(StackInstanceFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .values)
        values = valuesDecoded
    }
}

extension StackInstanceFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackInstanceFilter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>The status that stack instances are filtered by.</p>
public struct StackInstanceFilter: Equatable {
    /// <p>The type of filter to apply.</p>
    public let name: StackInstanceFilterName?
    /// <p>The status to filter by.</p>
    public let values: String?

    public init (
        name: StackInstanceFilterName? = nil,
        values: String? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

public enum StackInstanceFilterName {
    case detailedStatus
    case sdkUnknown(String)
}

extension StackInstanceFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackInstanceFilterName] {
        return [
            .detailedStatus,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .detailedStatus: return "DETAILED_STATUS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackInstanceFilterName(rawValue: rawValue) ?? StackInstanceFilterName.sdkUnknown(rawValue)
    }
}

extension StackInstanceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackInstanceNotFoundException(message: \(String(describing: message)))"}
}

extension StackInstanceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<StackInstanceNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified stack instance doesn't exist.</p>
public struct StackInstanceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StackInstanceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension StackInstanceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum StackInstanceStatus {
    case current
    case inoperable
    case outdated
    case sdkUnknown(String)
}

extension StackInstanceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackInstanceStatus] {
        return [
            .current,
            .inoperable,
            .outdated,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .current: return "CURRENT"
        case .inoperable: return "INOPERABLE"
        case .outdated: return "OUTDATED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackInstanceStatus(rawValue: rawValue) ?? StackInstanceStatus.sdkUnknown(rawValue)
    }
}

extension StackInstanceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case account = "Account"
        case driftStatus = "DriftStatus"
        case lastDriftCheckTimestamp = "LastDriftCheckTimestamp"
        case organizationalUnitId = "OrganizationalUnitId"
        case region = "Region"
        case stackId = "StackId"
        case stackInstanceStatus = "StackInstanceStatus"
        case stackSetId = "StackSetId"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let account = account {
            try container.encode(account, forKey: Key("Account"))
        }
        if let driftStatus = driftStatus {
            try container.encode(driftStatus, forKey: Key("DriftStatus"))
        }
        if let lastDriftCheckTimestamp = lastDriftCheckTimestamp {
            try container.encode(TimestampWrapper(lastDriftCheckTimestamp, format: .dateTime), forKey: Key("lastDriftCheckTimestamp"))
        }
        if let organizationalUnitId = organizationalUnitId {
            try container.encode(organizationalUnitId, forKey: Key("OrganizationalUnitId"))
        }
        if let region = region {
            try container.encode(region, forKey: Key("Region"))
        }
        if let stackId = stackId {
            try container.encode(stackId, forKey: Key("StackId"))
        }
        if let stackInstanceStatus = stackInstanceStatus {
            try container.encode(stackInstanceStatus, forKey: Key("StackInstanceStatus"))
        }
        if let stackSetId = stackSetId {
            try container.encode(stackSetId, forKey: Key("StackSetId"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let statusReason = statusReason {
            try container.encode(statusReason, forKey: Key("StatusReason"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackSetId)
        stackSetId = stackSetIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let accountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .account)
        account = accountDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StackInstanceStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let stackInstanceStatusDecoded = try containerValues.decodeIfPresent(StackInstanceComprehensiveStatus.self, forKey: .stackInstanceStatus)
        stackInstanceStatus = stackInstanceStatusDecoded
        let organizationalUnitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationalUnitId)
        organizationalUnitId = organizationalUnitIdDecoded
        let driftStatusDecoded = try containerValues.decodeIfPresent(StackDriftStatus.self, forKey: .driftStatus)
        driftStatus = driftStatusDecoded
        let lastDriftCheckTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastDriftCheckTimestamp)
        var lastDriftCheckTimestampBuffer:Date? = nil
        if let lastDriftCheckTimestampDecoded = lastDriftCheckTimestampDecoded {
            lastDriftCheckTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastDriftCheckTimestampDecoded, format: .dateTime)
        }
        lastDriftCheckTimestamp = lastDriftCheckTimestampBuffer
    }
}

extension StackInstanceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackInstanceSummary(account: \(String(describing: account)), driftStatus: \(String(describing: driftStatus)), lastDriftCheckTimestamp: \(String(describing: lastDriftCheckTimestamp)), organizationalUnitId: \(String(describing: organizationalUnitId)), region: \(String(describing: region)), stackId: \(String(describing: stackId)), stackInstanceStatus: \(String(describing: stackInstanceStatus)), stackSetId: \(String(describing: stackSetId)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)))"}
}

/// <p>The structure that contains summary information about a stack instance.</p>
public struct StackInstanceSummary: Equatable {
    /// <p>[Self-managed permissions] The name of the AWS account that the stack instance is associated with.</p>
    public let account: String?
    /// <p>Status of the stack instance's actual configuration compared to the expected template
    ///          and parameter configuration of the stack set to which it belongs. </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DRIFTED</code>: The stack differs from the expected template and parameter
    ///                configuration of the stack set to which it belongs. A stack instance is considered to
    ///                have drifted if one or more of the resources in the associated stack have
    ///                drifted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the stack instance differs from
    ///                its expected stack set configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_SYNC</code>: The stack instance's actual configuration matches its
    ///                expected stack set configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UNKNOWN</code>: This value is reserved for future use.</p>
    ///             </li>
    ///          </ul>
    public let driftStatus: StackDriftStatus?
    /// <p>Most recent time when CloudFormation performed a drift detection operation on the stack
    ///          instance. This value will be <code>NULL</code> for any stack instance on which drift
    ///          detection has not yet been performed.</p>
    public let lastDriftCheckTimestamp: Date?
    /// <p>[Service-managed permissions] The organization root ID or organizational unit (OU) IDs that you specified for <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_DeploymentTargets.html">DeploymentTargets</a>.</p>
    public let organizationalUnitId: String?
    /// <p>The name of the AWS Region that the stack instance is associated with.</p>
    public let region: String?
    /// <p>The ID of the stack instance.</p>
    public let stackId: String?
    /// <p>The detailed status of the stack instance.</p>
    public let stackInstanceStatus: StackInstanceComprehensiveStatus?
    /// <p>The name or unique ID of the stack set that the stack instance is associated
    ///          with.</p>
    public let stackSetId: String?
    /// <p>The status of the stack instance, in terms of its synchronization with its associated
    ///          stack set.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>INOPERABLE</code>: A <code>DeleteStackInstances</code> operation has
    ///                failed and left the stack in an unstable state. Stacks in this state are excluded
    ///                from further <code>UpdateStackSet</code> operations. You might need to perform a
    ///                   <code>DeleteStackInstances</code> operation, with <code>RetainStacks</code> set to
    ///                   <code>true</code>, to delete the stack instance, and then delete the stack
    ///                manually.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OUTDATED</code>: The stack isn't currently up to date with the stack set
    ///                because:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>The associated stack failed during a <code>CreateStackSet</code> or
    ///                         <code>UpdateStackSet</code> operation. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>The stack was part of a <code>CreateStackSet</code> or
    ///                         <code>UpdateStackSet</code> operation that failed or was stopped before the
    ///                      stack was created or updated. </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CURRENT</code>: The stack is currently up to date with the stack
    ///                set.</p>
    ///             </li>
    ///          </ul>
    public let status: StackInstanceStatus?
    /// <p>The explanation for the specific status code assigned to this stack
    ///          instance.</p>
    public let statusReason: String?

    public init (
        account: String? = nil,
        driftStatus: StackDriftStatus? = nil,
        lastDriftCheckTimestamp: Date? = nil,
        organizationalUnitId: String? = nil,
        region: String? = nil,
        stackId: String? = nil,
        stackInstanceStatus: StackInstanceComprehensiveStatus? = nil,
        stackSetId: String? = nil,
        status: StackInstanceStatus? = nil,
        statusReason: String? = nil
    )
    {
        self.account = account
        self.driftStatus = driftStatus
        self.lastDriftCheckTimestamp = lastDriftCheckTimestamp
        self.organizationalUnitId = organizationalUnitId
        self.region = region
        self.stackId = stackId
        self.stackInstanceStatus = stackInstanceStatus
        self.stackSetId = stackSetId
        self.status = status
        self.statusReason = statusReason
    }
}

extension StackResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case driftInformation = "DriftInformation"
        case logicalResourceId = "LogicalResourceId"
        case moduleInfo = "ModuleInfo"
        case physicalResourceId = "PhysicalResourceId"
        case resourceStatus = "ResourceStatus"
        case resourceStatusReason = "ResourceStatusReason"
        case resourceType = "ResourceType"
        case stackId = "StackId"
        case stackName = "StackName"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let driftInformation = driftInformation {
            try container.encode(driftInformation, forKey: Key("DriftInformation"))
        }
        if let logicalResourceId = logicalResourceId {
            try container.encode(logicalResourceId, forKey: Key("LogicalResourceId"))
        }
        if let moduleInfo = moduleInfo {
            try container.encode(moduleInfo, forKey: Key("ModuleInfo"))
        }
        if let physicalResourceId = physicalResourceId {
            try container.encode(physicalResourceId, forKey: Key("PhysicalResourceId"))
        }
        if let resourceStatus = resourceStatus {
            try container.encode(resourceStatus, forKey: Key("ResourceStatus"))
        }
        if let resourceStatusReason = resourceStatusReason {
            try container.encode(resourceStatusReason, forKey: Key("ResourceStatusReason"))
        }
        if let resourceType = resourceType {
            try container.encode(resourceType, forKey: Key("ResourceType"))
        }
        if let stackId = stackId {
            try container.encode(stackId, forKey: Key("StackId"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        if let timestamp = timestamp {
            try container.encode(TimestampWrapper(timestamp, format: .dateTime), forKey: Key("timestamp"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestamp)
        var timestampBuffer:Date? = nil
        if let timestampDecoded = timestampDecoded {
            timestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(timestampDecoded, format: .dateTime)
        }
        timestamp = timestampBuffer
        let resourceStatusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .resourceStatus)
        resourceStatus = resourceStatusDecoded
        let resourceStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceStatusReason)
        resourceStatusReason = resourceStatusReasonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let driftInformationDecoded = try containerValues.decodeIfPresent(StackResourceDriftInformation.self, forKey: .driftInformation)
        driftInformation = driftInformationDecoded
        let moduleInfoDecoded = try containerValues.decodeIfPresent(ModuleInfo.self, forKey: .moduleInfo)
        moduleInfo = moduleInfoDecoded
    }
}

extension StackResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackResource(description: \(String(describing: description)), driftInformation: \(String(describing: driftInformation)), logicalResourceId: \(String(describing: logicalResourceId)), moduleInfo: \(String(describing: moduleInfo)), physicalResourceId: \(String(describing: physicalResourceId)), resourceStatus: \(String(describing: resourceStatus)), resourceStatusReason: \(String(describing: resourceStatusReason)), resourceType: \(String(describing: resourceType)), stackId: \(String(describing: stackId)), stackName: \(String(describing: stackName)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>The StackResource data type.</p>
public struct StackResource: Equatable {
    /// <p>User defined description associated with the resource.</p>
    public let description: String?
    /// <p>Information about whether the resource's actual configuration differs, or has
    ///             <i>drifted</i>, from its expected configuration, as defined in the stack
    ///          template and any values specified as template parameters. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting Unregulated Configuration
    ///             Changes to Stacks and Resources</a>.</p>
    public let driftInformation: StackResourceDriftInformation?
    /// <p>The logical name of the resource specified in the template.</p>
    public let logicalResourceId: String?
    /// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
    public let moduleInfo: ModuleInfo?
    /// <p>The name or unique identifier that corresponds to a physical instance ID of a
    ///          resource supported by AWS CloudFormation.</p>
    public let physicalResourceId: String?
    /// <p>Current status of the resource.</p>
    public let resourceStatus: ResourceStatus?
    /// <p>Success/failure message associated with the resource.</p>
    public let resourceStatusReason: String?
    /// <p>Type of resource. (For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html"> AWS
    ///             Resource Types Reference</a> in the AWS CloudFormation User Guide.)</p>
    public let resourceType: String?
    /// <p>Unique identifier of the stack.</p>
    public let stackId: String?
    /// <p>The name associated with the stack.</p>
    public let stackName: String?
    /// <p>Time the status was updated.</p>
    public let timestamp: Date?

    public init (
        description: String? = nil,
        driftInformation: StackResourceDriftInformation? = nil,
        logicalResourceId: String? = nil,
        moduleInfo: ModuleInfo? = nil,
        physicalResourceId: String? = nil,
        resourceStatus: ResourceStatus? = nil,
        resourceStatusReason: String? = nil,
        resourceType: String? = nil,
        stackId: String? = nil,
        stackName: String? = nil,
        timestamp: Date? = nil
    )
    {
        self.description = description
        self.driftInformation = driftInformation
        self.logicalResourceId = logicalResourceId
        self.moduleInfo = moduleInfo
        self.physicalResourceId = physicalResourceId
        self.resourceStatus = resourceStatus
        self.resourceStatusReason = resourceStatusReason
        self.resourceType = resourceType
        self.stackId = stackId
        self.stackName = stackName
        self.timestamp = timestamp
    }
}

extension StackResourceDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case driftInformation = "DriftInformation"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case logicalResourceId = "LogicalResourceId"
        case metadata = "Metadata"
        case moduleInfo = "ModuleInfo"
        case physicalResourceId = "PhysicalResourceId"
        case resourceStatus = "ResourceStatus"
        case resourceStatusReason = "ResourceStatusReason"
        case resourceType = "ResourceType"
        case stackId = "StackId"
        case stackName = "StackName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let driftInformation = driftInformation {
            try container.encode(driftInformation, forKey: Key("DriftInformation"))
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try container.encode(TimestampWrapper(lastUpdatedTimestamp, format: .dateTime), forKey: Key("lastUpdatedTimestamp"))
        }
        if let logicalResourceId = logicalResourceId {
            try container.encode(logicalResourceId, forKey: Key("LogicalResourceId"))
        }
        if let metadata = metadata {
            try container.encode(metadata, forKey: Key("Metadata"))
        }
        if let moduleInfo = moduleInfo {
            try container.encode(moduleInfo, forKey: Key("ModuleInfo"))
        }
        if let physicalResourceId = physicalResourceId {
            try container.encode(physicalResourceId, forKey: Key("PhysicalResourceId"))
        }
        if let resourceStatus = resourceStatus {
            try container.encode(resourceStatus, forKey: Key("ResourceStatus"))
        }
        if let resourceStatusReason = resourceStatusReason {
            try container.encode(resourceStatusReason, forKey: Key("ResourceStatusReason"))
        }
        if let resourceType = resourceType {
            try container.encode(resourceType, forKey: Key("ResourceType"))
        }
        if let stackId = stackId {
            try container.encode(stackId, forKey: Key("StackId"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        var lastUpdatedTimestampBuffer:Date? = nil
        if let lastUpdatedTimestampDecoded = lastUpdatedTimestampDecoded {
            lastUpdatedTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastUpdatedTimestampDecoded, format: .dateTime)
        }
        lastUpdatedTimestamp = lastUpdatedTimestampBuffer
        let resourceStatusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .resourceStatus)
        resourceStatus = resourceStatusDecoded
        let resourceStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceStatusReason)
        resourceStatusReason = resourceStatusReasonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metadata)
        metadata = metadataDecoded
        let driftInformationDecoded = try containerValues.decodeIfPresent(StackResourceDriftInformation.self, forKey: .driftInformation)
        driftInformation = driftInformationDecoded
        let moduleInfoDecoded = try containerValues.decodeIfPresent(ModuleInfo.self, forKey: .moduleInfo)
        moduleInfo = moduleInfoDecoded
    }
}

extension StackResourceDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackResourceDetail(description: \(String(describing: description)), driftInformation: \(String(describing: driftInformation)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), logicalResourceId: \(String(describing: logicalResourceId)), metadata: \(String(describing: metadata)), moduleInfo: \(String(describing: moduleInfo)), physicalResourceId: \(String(describing: physicalResourceId)), resourceStatus: \(String(describing: resourceStatus)), resourceStatusReason: \(String(describing: resourceStatusReason)), resourceType: \(String(describing: resourceType)), stackId: \(String(describing: stackId)), stackName: \(String(describing: stackName)))"}
}

/// <p>Contains detailed information about the specified stack resource.</p>
public struct StackResourceDetail: Equatable {
    /// <p>User defined description associated with the resource.</p>
    public let description: String?
    /// <p>Information about whether the resource's actual configuration differs, or has
    ///             <i>drifted</i>, from its expected configuration, as defined in the stack
    ///          template and any values specified as template parameters. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting Unregulated Configuration
    ///             Changes to Stacks and Resources</a>.</p>
    public let driftInformation: StackResourceDriftInformation?
    /// <p>Time the status was updated.</p>
    public let lastUpdatedTimestamp: Date?
    /// <p>The logical name of the resource specified in the template.</p>
    public let logicalResourceId: String?
    /// <p>The content of the <code>Metadata</code> attribute declared for the resource. For
    ///          more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-metadata.html">Metadata
    ///             Attribute</a> in the AWS CloudFormation User Guide.</p>
    public let metadata: String?
    /// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
    public let moduleInfo: ModuleInfo?
    /// <p>The name or unique identifier that corresponds to a physical instance ID of a
    ///          resource supported by AWS CloudFormation.</p>
    public let physicalResourceId: String?
    /// <p>Current status of the resource.</p>
    public let resourceStatus: ResourceStatus?
    /// <p>Success/failure message associated with the resource.</p>
    public let resourceStatusReason: String?
    /// <p>Type of resource. ((For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html"> AWS
    ///             Resource Types Reference</a> in the AWS CloudFormation User Guide.)</p>
    public let resourceType: String?
    /// <p>Unique identifier of the stack.</p>
    public let stackId: String?
    /// <p>The name associated with the stack.</p>
    public let stackName: String?

    public init (
        description: String? = nil,
        driftInformation: StackResourceDriftInformation? = nil,
        lastUpdatedTimestamp: Date? = nil,
        logicalResourceId: String? = nil,
        metadata: String? = nil,
        moduleInfo: ModuleInfo? = nil,
        physicalResourceId: String? = nil,
        resourceStatus: ResourceStatus? = nil,
        resourceStatusReason: String? = nil,
        resourceType: String? = nil,
        stackId: String? = nil,
        stackName: String? = nil
    )
    {
        self.description = description
        self.driftInformation = driftInformation
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.logicalResourceId = logicalResourceId
        self.metadata = metadata
        self.moduleInfo = moduleInfo
        self.physicalResourceId = physicalResourceId
        self.resourceStatus = resourceStatus
        self.resourceStatusReason = resourceStatusReason
        self.resourceType = resourceType
        self.stackId = stackId
        self.stackName = stackName
    }
}

extension StackResourceDrift: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actualProperties = "ActualProperties"
        case expectedProperties = "ExpectedProperties"
        case logicalResourceId = "LogicalResourceId"
        case moduleInfo = "ModuleInfo"
        case physicalResourceId = "PhysicalResourceId"
        case physicalResourceIdContext = "PhysicalResourceIdContext"
        case propertyDifferences = "PropertyDifferences"
        case resourceType = "ResourceType"
        case stackId = "StackId"
        case stackResourceDriftStatus = "StackResourceDriftStatus"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actualProperties = actualProperties {
            try container.encode(actualProperties, forKey: Key("ActualProperties"))
        }
        if let expectedProperties = expectedProperties {
            try container.encode(expectedProperties, forKey: Key("ExpectedProperties"))
        }
        if let logicalResourceId = logicalResourceId {
            try container.encode(logicalResourceId, forKey: Key("LogicalResourceId"))
        }
        if let moduleInfo = moduleInfo {
            try container.encode(moduleInfo, forKey: Key("ModuleInfo"))
        }
        if let physicalResourceId = physicalResourceId {
            try container.encode(physicalResourceId, forKey: Key("PhysicalResourceId"))
        }
        if let physicalResourceIdContext = physicalResourceIdContext {
            var physicalResourceIdContextContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PhysicalResourceIdContext"))
            for (index0, physicalresourceidcontextkeyvaluepair0) in physicalResourceIdContext.enumerated() {
                try physicalResourceIdContextContainer.encode(physicalresourceidcontextkeyvaluepair0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let propertyDifferences = propertyDifferences {
            var propertyDifferencesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PropertyDifferences"))
            for (index0, propertydifference0) in propertyDifferences.enumerated() {
                try propertyDifferencesContainer.encode(propertydifference0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceType = resourceType {
            try container.encode(resourceType, forKey: Key("ResourceType"))
        }
        if let stackId = stackId {
            try container.encode(stackId, forKey: Key("StackId"))
        }
        if let stackResourceDriftStatus = stackResourceDriftStatus {
            try container.encode(stackResourceDriftStatus, forKey: Key("StackResourceDriftStatus"))
        }
        if let timestamp = timestamp {
            try container.encode(TimestampWrapper(timestamp, format: .dateTime), forKey: Key("timestamp"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        if containerValues.contains(.physicalResourceIdContext) {
            struct KeyVal0{struct member{}}
            let physicalResourceIdContextWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .physicalResourceIdContext)
            if let physicalResourceIdContextWrappedContainer = physicalResourceIdContextWrappedContainer {
                let physicalResourceIdContextContainer = try physicalResourceIdContextWrappedContainer.decodeIfPresent([PhysicalResourceIdContextKeyValuePair].self, forKey: .member)
                var physicalResourceIdContextBuffer:[PhysicalResourceIdContextKeyValuePair]? = nil
                if let physicalResourceIdContextContainer = physicalResourceIdContextContainer {
                    physicalResourceIdContextBuffer = [PhysicalResourceIdContextKeyValuePair]()
                    for structureContainer0 in physicalResourceIdContextContainer {
                        physicalResourceIdContextBuffer?.append(structureContainer0)
                    }
                }
                physicalResourceIdContext = physicalResourceIdContextBuffer
            } else {
                physicalResourceIdContext = []
            }
        } else {
            physicalResourceIdContext = nil
        }
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let expectedPropertiesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expectedProperties)
        expectedProperties = expectedPropertiesDecoded
        let actualPropertiesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actualProperties)
        actualProperties = actualPropertiesDecoded
        if containerValues.contains(.propertyDifferences) {
            struct KeyVal0{struct member{}}
            let propertyDifferencesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .propertyDifferences)
            if let propertyDifferencesWrappedContainer = propertyDifferencesWrappedContainer {
                let propertyDifferencesContainer = try propertyDifferencesWrappedContainer.decodeIfPresent([PropertyDifference].self, forKey: .member)
                var propertyDifferencesBuffer:[PropertyDifference]? = nil
                if let propertyDifferencesContainer = propertyDifferencesContainer {
                    propertyDifferencesBuffer = [PropertyDifference]()
                    for structureContainer0 in propertyDifferencesContainer {
                        propertyDifferencesBuffer?.append(structureContainer0)
                    }
                }
                propertyDifferences = propertyDifferencesBuffer
            } else {
                propertyDifferences = []
            }
        } else {
            propertyDifferences = nil
        }
        let stackResourceDriftStatusDecoded = try containerValues.decodeIfPresent(StackResourceDriftStatus.self, forKey: .stackResourceDriftStatus)
        stackResourceDriftStatus = stackResourceDriftStatusDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestamp)
        var timestampBuffer:Date? = nil
        if let timestampDecoded = timestampDecoded {
            timestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(timestampDecoded, format: .dateTime)
        }
        timestamp = timestampBuffer
        let moduleInfoDecoded = try containerValues.decodeIfPresent(ModuleInfo.self, forKey: .moduleInfo)
        moduleInfo = moduleInfoDecoded
    }
}

extension StackResourceDrift: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackResourceDrift(actualProperties: \(String(describing: actualProperties)), expectedProperties: \(String(describing: expectedProperties)), logicalResourceId: \(String(describing: logicalResourceId)), moduleInfo: \(String(describing: moduleInfo)), physicalResourceId: \(String(describing: physicalResourceId)), physicalResourceIdContext: \(String(describing: physicalResourceIdContext)), propertyDifferences: \(String(describing: propertyDifferences)), resourceType: \(String(describing: resourceType)), stackId: \(String(describing: stackId)), stackResourceDriftStatus: \(String(describing: stackResourceDriftStatus)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>Contains the drift information for a resource that has been checked for drift. This
///          includes actual and expected property values for resources in which AWS CloudFormation has detected
///          drift. Only resource properties explicitly defined in the stack template are checked for
///          drift. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting
///             Unregulated Configuration Changes to Stacks and Resources</a>.</p>
///          <p>Resources that do not currently support drift detection cannot be checked. For a list
///          of resources that support drift detection, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift-resource-list.html">Resources that Support
///             Drift Detection</a>.</p>
///          <p>Use <a>DetectStackResourceDrift</a> to detect drift on individual
///          resources, or <a>DetectStackDrift</a> to detect drift on all resources in a
///          given stack that support drift detection.</p>
public struct StackResourceDrift: Equatable {
    /// <p>A JSON structure containing the actual property values of the stack
    ///          resource.</p>
    ///          <p>For resources whose <code>StackResourceDriftStatus</code> is <code>DELETED</code>,
    ///          this structure will not be present. </p>
    public let actualProperties: String?
    /// <p>A JSON structure containing the expected property values of the stack resource, as
    ///          defined in the stack template and any values specified as template parameters. </p>
    ///          <p>For resources whose <code>StackResourceDriftStatus</code> is <code>DELETED</code>,
    ///          this structure will not be present. </p>
    public let expectedProperties: String?
    /// <p>The logical name of the resource specified in the template.</p>
    public let logicalResourceId: String?
    /// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
    public let moduleInfo: ModuleInfo?
    /// <p>The name or unique identifier that corresponds to a physical instance ID of a
    ///          resource supported by AWS CloudFormation. </p>
    public let physicalResourceId: String?
    /// <p>Context information that enables AWS CloudFormation to uniquely identify a resource. AWS CloudFormation uses
    ///          context key-value pairs in cases where a resource's logical and physical IDs are not enough
    ///          to uniquely identify that resource. Each context key-value pair specifies a unique resource
    ///          that contains the targeted resource.</p>
    public let physicalResourceIdContext: [PhysicalResourceIdContextKeyValuePair]?
    /// <p>A collection of the resource properties whose actual values differ from their
    ///          expected values. These will be present only for resources whose
    ///             <code>StackResourceDriftStatus</code> is <code>MODIFIED</code>.
    ///          </p>
    public let propertyDifferences: [PropertyDifference]?
    /// <p>The type of the resource.</p>
    public let resourceType: String?
    /// <p>The ID of the stack.</p>
    public let stackId: String?
    /// <p>Status of the resource's actual configuration compared to its expected
    ///          configuration</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DELETED</code>: The resource differs from its expected template
    ///                configuration because the resource has been deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MODIFIED</code>: One or more resource properties differ from their
    ///                expected values (as defined in the stack template and any values specified as
    ///                template parameters).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_SYNC</code>: The resources's actual configuration matches its expected
    ///                template configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_CHECKED</code>: AWS CloudFormation does not currently return this value.</p>
    ///             </li>
    ///          </ul>
    public let stackResourceDriftStatus: StackResourceDriftStatus?
    /// <p>Time at which AWS CloudFormation performed drift detection on the stack resource.</p>
    public let timestamp: Date?

    public init (
        actualProperties: String? = nil,
        expectedProperties: String? = nil,
        logicalResourceId: String? = nil,
        moduleInfo: ModuleInfo? = nil,
        physicalResourceId: String? = nil,
        physicalResourceIdContext: [PhysicalResourceIdContextKeyValuePair]? = nil,
        propertyDifferences: [PropertyDifference]? = nil,
        resourceType: String? = nil,
        stackId: String? = nil,
        stackResourceDriftStatus: StackResourceDriftStatus? = nil,
        timestamp: Date? = nil
    )
    {
        self.actualProperties = actualProperties
        self.expectedProperties = expectedProperties
        self.logicalResourceId = logicalResourceId
        self.moduleInfo = moduleInfo
        self.physicalResourceId = physicalResourceId
        self.physicalResourceIdContext = physicalResourceIdContext
        self.propertyDifferences = propertyDifferences
        self.resourceType = resourceType
        self.stackId = stackId
        self.stackResourceDriftStatus = stackResourceDriftStatus
        self.timestamp = timestamp
    }
}

extension StackResourceDriftInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastCheckTimestamp = "LastCheckTimestamp"
        case stackResourceDriftStatus = "StackResourceDriftStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let lastCheckTimestamp = lastCheckTimestamp {
            try container.encode(TimestampWrapper(lastCheckTimestamp, format: .dateTime), forKey: Key("lastCheckTimestamp"))
        }
        if let stackResourceDriftStatus = stackResourceDriftStatus {
            try container.encode(stackResourceDriftStatus, forKey: Key("StackResourceDriftStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackResourceDriftStatusDecoded = try containerValues.decodeIfPresent(StackResourceDriftStatus.self, forKey: .stackResourceDriftStatus)
        stackResourceDriftStatus = stackResourceDriftStatusDecoded
        let lastCheckTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastCheckTimestamp)
        var lastCheckTimestampBuffer:Date? = nil
        if let lastCheckTimestampDecoded = lastCheckTimestampDecoded {
            lastCheckTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastCheckTimestampDecoded, format: .dateTime)
        }
        lastCheckTimestamp = lastCheckTimestampBuffer
    }
}

extension StackResourceDriftInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackResourceDriftInformation(lastCheckTimestamp: \(String(describing: lastCheckTimestamp)), stackResourceDriftStatus: \(String(describing: stackResourceDriftStatus)))"}
}

/// <p>Contains information about whether the resource's actual configuration differs, or
///          has <i>drifted</i>, from its expected configuration.</p>
public struct StackResourceDriftInformation: Equatable {
    /// <p>When AWS CloudFormation last checked if the resource had drifted from its expected
    ///          configuration.</p>
    public let lastCheckTimestamp: Date?
    /// <p>Status of the resource's actual configuration compared to its expected
    ///          configuration</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DELETED</code>: The resource differs from its expected configuration in
    ///                that it has been deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MODIFIED</code>: The resource differs from its expected
    ///                configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the resource differs from
    ///                its expected configuration.</p>
    ///                <p>Any resources that do not currently support drift detection have a status of
    ///                   <code>NOT_CHECKED</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift-resource-list.html">Resources that Support Drift Detection</a>. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_SYNC</code>: The resources's actual configuration matches its expected
    ///                configuration.</p>
    ///             </li>
    ///          </ul>
    public let stackResourceDriftStatus: StackResourceDriftStatus?

    public init (
        lastCheckTimestamp: Date? = nil,
        stackResourceDriftStatus: StackResourceDriftStatus? = nil
    )
    {
        self.lastCheckTimestamp = lastCheckTimestamp
        self.stackResourceDriftStatus = stackResourceDriftStatus
    }
}

extension StackResourceDriftInformationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastCheckTimestamp = "LastCheckTimestamp"
        case stackResourceDriftStatus = "StackResourceDriftStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let lastCheckTimestamp = lastCheckTimestamp {
            try container.encode(TimestampWrapper(lastCheckTimestamp, format: .dateTime), forKey: Key("lastCheckTimestamp"))
        }
        if let stackResourceDriftStatus = stackResourceDriftStatus {
            try container.encode(stackResourceDriftStatus, forKey: Key("StackResourceDriftStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackResourceDriftStatusDecoded = try containerValues.decodeIfPresent(StackResourceDriftStatus.self, forKey: .stackResourceDriftStatus)
        stackResourceDriftStatus = stackResourceDriftStatusDecoded
        let lastCheckTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastCheckTimestamp)
        var lastCheckTimestampBuffer:Date? = nil
        if let lastCheckTimestampDecoded = lastCheckTimestampDecoded {
            lastCheckTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastCheckTimestampDecoded, format: .dateTime)
        }
        lastCheckTimestamp = lastCheckTimestampBuffer
    }
}

extension StackResourceDriftInformationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackResourceDriftInformationSummary(lastCheckTimestamp: \(String(describing: lastCheckTimestamp)), stackResourceDriftStatus: \(String(describing: stackResourceDriftStatus)))"}
}

/// <p>Summarizes information about whether the resource's actual configuration differs, or
///          has <i>drifted</i>, from its expected configuration.</p>
public struct StackResourceDriftInformationSummary: Equatable {
    /// <p>When AWS CloudFormation last checked if the resource had drifted from its expected
    ///          configuration.</p>
    public let lastCheckTimestamp: Date?
    /// <p>Status of the resource's actual configuration compared to its expected
    ///          configuration</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DELETED</code>: The resource differs from its expected configuration in
    ///                that it has been deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MODIFIED</code>: The resource differs from its expected
    ///                configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the resource differs from
    ///                its expected configuration.</p>
    ///                <p>Any resources that do not currently support drift detection have a status of
    ///                   <code>NOT_CHECKED</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift-resource-list.html">Resources that Support Drift Detection</a>. If you performed an <a>ContinueUpdateRollback</a> operation on a stack, any resources included in
    ///                   <code>ResourcesToSkip</code> will also have a status of <code>NOT_CHECKED</code>.
    ///                For more information on skipping resources during rollback operations, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-continueupdaterollback.html">Continue Rolling Back an Update</a> in the AWS CloudFormation User Guide.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_SYNC</code>: The resources's actual configuration matches its expected
    ///                configuration.</p>
    ///             </li>
    ///          </ul>
    public let stackResourceDriftStatus: StackResourceDriftStatus?

    public init (
        lastCheckTimestamp: Date? = nil,
        stackResourceDriftStatus: StackResourceDriftStatus? = nil
    )
    {
        self.lastCheckTimestamp = lastCheckTimestamp
        self.stackResourceDriftStatus = stackResourceDriftStatus
    }
}

public enum StackResourceDriftStatus {
    case deleted
    case inSync
    case modified
    case notChecked
    case sdkUnknown(String)
}

extension StackResourceDriftStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackResourceDriftStatus] {
        return [
            .deleted,
            .inSync,
            .modified,
            .notChecked,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleted: return "DELETED"
        case .inSync: return "IN_SYNC"
        case .modified: return "MODIFIED"
        case .notChecked: return "NOT_CHECKED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackResourceDriftStatus(rawValue: rawValue) ?? StackResourceDriftStatus.sdkUnknown(rawValue)
    }
}

extension StackResourceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case driftInformation = "DriftInformation"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case logicalResourceId = "LogicalResourceId"
        case moduleInfo = "ModuleInfo"
        case physicalResourceId = "PhysicalResourceId"
        case resourceStatus = "ResourceStatus"
        case resourceStatusReason = "ResourceStatusReason"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let driftInformation = driftInformation {
            try container.encode(driftInformation, forKey: Key("DriftInformation"))
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try container.encode(TimestampWrapper(lastUpdatedTimestamp, format: .dateTime), forKey: Key("lastUpdatedTimestamp"))
        }
        if let logicalResourceId = logicalResourceId {
            try container.encode(logicalResourceId, forKey: Key("LogicalResourceId"))
        }
        if let moduleInfo = moduleInfo {
            try container.encode(moduleInfo, forKey: Key("ModuleInfo"))
        }
        if let physicalResourceId = physicalResourceId {
            try container.encode(physicalResourceId, forKey: Key("PhysicalResourceId"))
        }
        if let resourceStatus = resourceStatus {
            try container.encode(resourceStatus, forKey: Key("ResourceStatus"))
        }
        if let resourceStatusReason = resourceStatusReason {
            try container.encode(resourceStatusReason, forKey: Key("ResourceStatusReason"))
        }
        if let resourceType = resourceType {
            try container.encode(resourceType, forKey: Key("ResourceType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTimestamp)
        var lastUpdatedTimestampBuffer:Date? = nil
        if let lastUpdatedTimestampDecoded = lastUpdatedTimestampDecoded {
            lastUpdatedTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastUpdatedTimestampDecoded, format: .dateTime)
        }
        lastUpdatedTimestamp = lastUpdatedTimestampBuffer
        let resourceStatusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .resourceStatus)
        resourceStatus = resourceStatusDecoded
        let resourceStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceStatusReason)
        resourceStatusReason = resourceStatusReasonDecoded
        let driftInformationDecoded = try containerValues.decodeIfPresent(StackResourceDriftInformationSummary.self, forKey: .driftInformation)
        driftInformation = driftInformationDecoded
        let moduleInfoDecoded = try containerValues.decodeIfPresent(ModuleInfo.self, forKey: .moduleInfo)
        moduleInfo = moduleInfoDecoded
    }
}

extension StackResourceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackResourceSummary(driftInformation: \(String(describing: driftInformation)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), logicalResourceId: \(String(describing: logicalResourceId)), moduleInfo: \(String(describing: moduleInfo)), physicalResourceId: \(String(describing: physicalResourceId)), resourceStatus: \(String(describing: resourceStatus)), resourceStatusReason: \(String(describing: resourceStatusReason)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Contains high-level information about the specified stack resource.</p>
public struct StackResourceSummary: Equatable {
    /// <p>Information about whether the resource's actual configuration differs, or has
    ///             <i>drifted</i>, from its expected configuration, as defined in the stack
    ///          template and any values specified as template parameters. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting Unregulated Configuration
    ///             Changes to Stacks and Resources</a>.</p>
    public let driftInformation: StackResourceDriftInformationSummary?
    /// <p>Time the status was updated.</p>
    public let lastUpdatedTimestamp: Date?
    /// <p>The logical name of the resource specified in the template.</p>
    public let logicalResourceId: String?
    /// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
    public let moduleInfo: ModuleInfo?
    /// <p>The name or unique identifier that corresponds to a physical instance ID of the
    ///          resource.</p>
    public let physicalResourceId: String?
    /// <p>Current status of the resource.</p>
    public let resourceStatus: ResourceStatus?
    /// <p>Success/failure message associated with the resource.</p>
    public let resourceStatusReason: String?
    /// <p>Type of resource. (For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html"> AWS
    ///             Resource Types Reference</a> in the AWS CloudFormation User Guide.)</p>
    public let resourceType: String?

    public init (
        driftInformation: StackResourceDriftInformationSummary? = nil,
        lastUpdatedTimestamp: Date? = nil,
        logicalResourceId: String? = nil,
        moduleInfo: ModuleInfo? = nil,
        physicalResourceId: String? = nil,
        resourceStatus: ResourceStatus? = nil,
        resourceStatusReason: String? = nil,
        resourceType: String? = nil
    )
    {
        self.driftInformation = driftInformation
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.logicalResourceId = logicalResourceId
        self.moduleInfo = moduleInfo
        self.physicalResourceId = physicalResourceId
        self.resourceStatus = resourceStatus
        self.resourceStatusReason = resourceStatusReason
        self.resourceType = resourceType
    }
}

extension StackSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case administrationRoleARN = "AdministrationRoleARN"
        case autoDeployment = "AutoDeployment"
        case capabilities = "Capabilities"
        case description = "Description"
        case executionRoleName = "ExecutionRoleName"
        case organizationalUnitIds = "OrganizationalUnitIds"
        case parameters = "Parameters"
        case permissionModel = "PermissionModel"
        case stackSetARN = "StackSetARN"
        case stackSetDriftDetectionDetails = "StackSetDriftDetectionDetails"
        case stackSetId = "StackSetId"
        case stackSetName = "StackSetName"
        case status = "Status"
        case tags = "Tags"
        case templateBody = "TemplateBody"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let administrationRoleARN = administrationRoleARN {
            try container.encode(administrationRoleARN, forKey: Key("AdministrationRoleARN"))
        }
        if let autoDeployment = autoDeployment {
            try container.encode(autoDeployment, forKey: Key("AutoDeployment"))
        }
        if let capabilities = capabilities {
            var capabilitiesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Capabilities"))
            for (index0, capability0) in capabilities.enumerated() {
                try capabilitiesContainer.encode(capability0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let executionRoleName = executionRoleName {
            try container.encode(executionRoleName, forKey: Key("ExecutionRoleName"))
        }
        if let organizationalUnitIds = organizationalUnitIds {
            var organizationalUnitIdsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OrganizationalUnitIds"))
            for (index0, organizationalunitid0) in organizationalUnitIds.enumerated() {
                try organizationalUnitIdsContainer.encode(organizationalunitid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let permissionModel = permissionModel {
            try container.encode(permissionModel, forKey: Key("PermissionModel"))
        }
        if let stackSetARN = stackSetARN {
            try container.encode(stackSetARN, forKey: Key("StackSetARN"))
        }
        if let stackSetDriftDetectionDetails = stackSetDriftDetectionDetails {
            try container.encode(stackSetDriftDetectionDetails, forKey: Key("StackSetDriftDetectionDetails"))
        }
        if let stackSetId = stackSetId {
            try container.encode(stackSetId, forKey: Key("StackSetId"))
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let templateBody = templateBody {
            try container.encode(templateBody, forKey: Key("TemplateBody"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackSetName)
        stackSetName = stackSetNameDecoded
        let stackSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackSetId)
        stackSetId = stackSetIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StackSetStatus.self, forKey: .status)
        status = statusDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct member{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([Parameter].self, forKey: .member)
                var parametersBuffer:[Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        if containerValues.contains(.capabilities) {
            struct KeyVal0{struct member{}}
            let capabilitiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .capabilities)
            if let capabilitiesWrappedContainer = capabilitiesWrappedContainer {
                let capabilitiesContainer = try capabilitiesWrappedContainer.decodeIfPresent([Capability].self, forKey: .member)
                var capabilitiesBuffer:[Capability]? = nil
                if let capabilitiesContainer = capabilitiesContainer {
                    capabilitiesBuffer = [Capability]()
                    for stringContainer0 in capabilitiesContainer {
                        capabilitiesBuffer?.append(stringContainer0)
                    }
                }
                capabilities = capabilitiesBuffer
            } else {
                capabilities = []
            }
        } else {
            capabilities = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let stackSetARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackSetARN)
        stackSetARN = stackSetARNDecoded
        let administrationRoleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .administrationRoleARN)
        administrationRoleARN = administrationRoleARNDecoded
        let executionRoleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleName)
        executionRoleName = executionRoleNameDecoded
        let stackSetDriftDetectionDetailsDecoded = try containerValues.decodeIfPresent(StackSetDriftDetectionDetails.self, forKey: .stackSetDriftDetectionDetails)
        stackSetDriftDetectionDetails = stackSetDriftDetectionDetailsDecoded
        let autoDeploymentDecoded = try containerValues.decodeIfPresent(AutoDeployment.self, forKey: .autoDeployment)
        autoDeployment = autoDeploymentDecoded
        let permissionModelDecoded = try containerValues.decodeIfPresent(PermissionModels.self, forKey: .permissionModel)
        permissionModel = permissionModelDecoded
        if containerValues.contains(.organizationalUnitIds) {
            struct KeyVal0{struct member{}}
            let organizationalUnitIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .organizationalUnitIds)
            if let organizationalUnitIdsWrappedContainer = organizationalUnitIdsWrappedContainer {
                let organizationalUnitIdsContainer = try organizationalUnitIdsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var organizationalUnitIdsBuffer:[String]? = nil
                if let organizationalUnitIdsContainer = organizationalUnitIdsContainer {
                    organizationalUnitIdsBuffer = [String]()
                    for stringContainer0 in organizationalUnitIdsContainer {
                        organizationalUnitIdsBuffer?.append(stringContainer0)
                    }
                }
                organizationalUnitIds = organizationalUnitIdsBuffer
            } else {
                organizationalUnitIds = []
            }
        } else {
            organizationalUnitIds = nil
        }
    }
}

extension StackSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackSet(administrationRoleARN: \(String(describing: administrationRoleARN)), autoDeployment: \(String(describing: autoDeployment)), capabilities: \(String(describing: capabilities)), description: \(String(describing: description)), executionRoleName: \(String(describing: executionRoleName)), organizationalUnitIds: \(String(describing: organizationalUnitIds)), parameters: \(String(describing: parameters)), permissionModel: \(String(describing: permissionModel)), stackSetARN: \(String(describing: stackSetARN)), stackSetDriftDetectionDetails: \(String(describing: stackSetDriftDetectionDetails)), stackSetId: \(String(describing: stackSetId)), stackSetName: \(String(describing: stackSetName)), status: \(String(describing: status)), tags: \(String(describing: tags)), templateBody: \(String(describing: templateBody)))"}
}

/// <p>A structure that contains information about a stack set. A stack set enables you to
///          provision stacks into AWS accounts and across Regions by using a single CloudFormation
///          template. In the stack set, you specify the template to use, as well as any parameters and
///          capabilities that the template requires. </p>
public struct StackSet: Equatable {
    /// <p>The Amazon Resource Number (ARN) of the IAM role used to create or update the stack
    ///          set.</p>
    ///          <p>Use customized administrator roles to control which users or groups can manage specific
    ///          stack sets within the same administrator account. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs.html">Prerequisites: Granting Permissions for Stack
    ///             Set Operations</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    public let administrationRoleARN: String?
    /// <p>[Service-managed permissions] Describes whether StackSets automatically deploys to AWS Organizations accounts that are added to a target organization or organizational unit (OU).</p>
    public let autoDeployment: AutoDeployment?
    /// <p>The capabilities that are allowed in the stack set. Some stack set templates might
    ///          include resources that can affect permissions in your AWS account—for example, by creating
    ///          new AWS Identity and Access Management (IAM) users. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#capabilities">Acknowledging IAM Resources in AWS CloudFormation Templates.</a>
    ///          </p>
    public let capabilities: [Capability]?
    /// <p>A description of the stack set that you specify when the stack set is created or
    ///          updated.</p>
    public let description: String?
    /// <p>The name of the IAM execution role used to create or update the stack set. </p>
    ///          <p>Use customized execution roles to control which stack resources users and groups can
    ///          include in their stack sets.
    ///       </p>
    public let executionRoleName: String?
    /// <p>[Service-managed permissions] The organization root ID or organizational unit (OU) IDs that you specified for <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_DeploymentTargets.html">DeploymentTargets</a>.</p>
    public let organizationalUnitIds: [String]?
    /// <p>A list of input parameters for a stack set.</p>
    public let parameters: [Parameter]?
    /// <p>Describes how the IAM roles required for stack set operations are created.</p>
    ///          <ul>
    ///             <li>
    ///                <p>With <code>self-managed</code> permissions, you must create the administrator and execution roles required to deploy to target accounts. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-self-managed.html">Grant Self-Managed Stack Set Permissions</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>With <code>service-managed</code> permissions, StackSets automatically creates the IAM roles required to deploy to accounts managed by AWS Organizations. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-service-managed.html">Grant Service-Managed Stack Set Permissions</a>.</p>
    ///             </li>
    ///          </ul>
    public let permissionModel: PermissionModels?
    /// <p>The Amazon Resource Number (ARN) of the stack set.</p>
    public let stackSetARN: String?
    /// <p>Detailed information about the drift status of the stack set.</p>
    ///          <p>For stack sets, contains information about the last <i>completed</i> drift
    ///          operation performed on the stack set. Information about drift operations currently in
    ///          progress is not included.</p>
    public let stackSetDriftDetectionDetails: StackSetDriftDetectionDetails?
    /// <p>The ID of the stack set.</p>
    public let stackSetId: String?
    /// <p>The name that's associated with the stack set.</p>
    public let stackSetName: String?
    /// <p>The status of the stack set.</p>
    public let status: StackSetStatus?
    /// <p>A list of tags that specify information about the stack set. A maximum number of 50
    ///          tags can be specified.</p>
    public let tags: [Tag]?
    /// <p>The structure that contains the body of the template that was used to create or
    ///          update the stack set.</p>
    public let templateBody: String?

    public init (
        administrationRoleARN: String? = nil,
        autoDeployment: AutoDeployment? = nil,
        capabilities: [Capability]? = nil,
        description: String? = nil,
        executionRoleName: String? = nil,
        organizationalUnitIds: [String]? = nil,
        parameters: [Parameter]? = nil,
        permissionModel: PermissionModels? = nil,
        stackSetARN: String? = nil,
        stackSetDriftDetectionDetails: StackSetDriftDetectionDetails? = nil,
        stackSetId: String? = nil,
        stackSetName: String? = nil,
        status: StackSetStatus? = nil,
        tags: [Tag]? = nil,
        templateBody: String? = nil
    )
    {
        self.administrationRoleARN = administrationRoleARN
        self.autoDeployment = autoDeployment
        self.capabilities = capabilities
        self.description = description
        self.executionRoleName = executionRoleName
        self.organizationalUnitIds = organizationalUnitIds
        self.parameters = parameters
        self.permissionModel = permissionModel
        self.stackSetARN = stackSetARN
        self.stackSetDriftDetectionDetails = stackSetDriftDetectionDetails
        self.stackSetId = stackSetId
        self.stackSetName = stackSetName
        self.status = status
        self.tags = tags
        self.templateBody = templateBody
    }
}

extension StackSetDriftDetectionDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case driftDetectionStatus = "DriftDetectionStatus"
        case driftStatus = "DriftStatus"
        case driftedStackInstancesCount = "DriftedStackInstancesCount"
        case failedStackInstancesCount = "FailedStackInstancesCount"
        case inProgressStackInstancesCount = "InProgressStackInstancesCount"
        case inSyncStackInstancesCount = "InSyncStackInstancesCount"
        case lastDriftCheckTimestamp = "LastDriftCheckTimestamp"
        case totalStackInstancesCount = "TotalStackInstancesCount"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let driftDetectionStatus = driftDetectionStatus {
            try container.encode(driftDetectionStatus, forKey: Key("DriftDetectionStatus"))
        }
        if let driftStatus = driftStatus {
            try container.encode(driftStatus, forKey: Key("DriftStatus"))
        }
        if driftedStackInstancesCount != 0 {
            try container.encode(driftedStackInstancesCount, forKey: Key("DriftedStackInstancesCount"))
        }
        if failedStackInstancesCount != 0 {
            try container.encode(failedStackInstancesCount, forKey: Key("FailedStackInstancesCount"))
        }
        if inProgressStackInstancesCount != 0 {
            try container.encode(inProgressStackInstancesCount, forKey: Key("InProgressStackInstancesCount"))
        }
        if inSyncStackInstancesCount != 0 {
            try container.encode(inSyncStackInstancesCount, forKey: Key("InSyncStackInstancesCount"))
        }
        if let lastDriftCheckTimestamp = lastDriftCheckTimestamp {
            try container.encode(TimestampWrapper(lastDriftCheckTimestamp, format: .dateTime), forKey: Key("lastDriftCheckTimestamp"))
        }
        if totalStackInstancesCount != 0 {
            try container.encode(totalStackInstancesCount, forKey: Key("TotalStackInstancesCount"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let driftStatusDecoded = try containerValues.decodeIfPresent(StackSetDriftStatus.self, forKey: .driftStatus)
        driftStatus = driftStatusDecoded
        let driftDetectionStatusDecoded = try containerValues.decodeIfPresent(StackSetDriftDetectionStatus.self, forKey: .driftDetectionStatus)
        driftDetectionStatus = driftDetectionStatusDecoded
        let lastDriftCheckTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastDriftCheckTimestamp)
        var lastDriftCheckTimestampBuffer:Date? = nil
        if let lastDriftCheckTimestampDecoded = lastDriftCheckTimestampDecoded {
            lastDriftCheckTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastDriftCheckTimestampDecoded, format: .dateTime)
        }
        lastDriftCheckTimestamp = lastDriftCheckTimestampBuffer
        let totalStackInstancesCountDecoded = try containerValues.decode(Int.self, forKey: .totalStackInstancesCount)
        totalStackInstancesCount = totalStackInstancesCountDecoded
        let driftedStackInstancesCountDecoded = try containerValues.decode(Int.self, forKey: .driftedStackInstancesCount)
        driftedStackInstancesCount = driftedStackInstancesCountDecoded
        let inSyncStackInstancesCountDecoded = try containerValues.decode(Int.self, forKey: .inSyncStackInstancesCount)
        inSyncStackInstancesCount = inSyncStackInstancesCountDecoded
        let inProgressStackInstancesCountDecoded = try containerValues.decode(Int.self, forKey: .inProgressStackInstancesCount)
        inProgressStackInstancesCount = inProgressStackInstancesCountDecoded
        let failedStackInstancesCountDecoded = try containerValues.decode(Int.self, forKey: .failedStackInstancesCount)
        failedStackInstancesCount = failedStackInstancesCountDecoded
    }
}

extension StackSetDriftDetectionDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackSetDriftDetectionDetails(driftDetectionStatus: \(String(describing: driftDetectionStatus)), driftStatus: \(String(describing: driftStatus)), driftedStackInstancesCount: \(String(describing: driftedStackInstancesCount)), failedStackInstancesCount: \(String(describing: failedStackInstancesCount)), inProgressStackInstancesCount: \(String(describing: inProgressStackInstancesCount)), inSyncStackInstancesCount: \(String(describing: inSyncStackInstancesCount)), lastDriftCheckTimestamp: \(String(describing: lastDriftCheckTimestamp)), totalStackInstancesCount: \(String(describing: totalStackInstancesCount)))"}
}

/// <p>Detailed information about the drift status of the stack set.</p>
///          <p>For stack sets, contains information about the last <i>completed</i> drift
///          operation performed on the stack set. Information about drift operations in-progress is not
///          included. </p>
///          <p>For stack set operations, includes information about drift operations currently being
///          performed on the stack set.</p>
///          <p>For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-drift.html">Detecting Unmanaged
///          Changes in Stack Sets</a> in the <i>AWS CloudFormation User Guide</i>.</p>
public struct StackSetDriftDetectionDetails: Equatable {
    /// <p>The status of the stack set drift detection operation.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>COMPLETED</code>: The drift detection operation completed without failing on
    ///                any stack instances.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code>: The drift detection operation exceeded the specified failure
    ///                tolerance. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PARTIAL_SUCCESS</code>: The drift detection operation completed without
    ///                exceeding the failure tolerance for the operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_PROGRESS</code>: The drift detection operation is currently being
    ///                performed.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>STOPPED</code>: The user has cancelled the drift detection operation.</p>
    ///             </li>
    ///          </ul>
    public let driftDetectionStatus: StackSetDriftDetectionStatus?
    /// <p>Status of the stack set's actual configuration compared to its expected template and
    ///          parameter configuration. A stack set is considered to have drifted if one or more of its
    ///          stack instances have drifted from their expected template and parameter
    ///          configuration.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DRIFTED</code>: One or more of the stack instances belonging to the stack
    ///                set stack differs from the expected template and parameter configuration. A stack
    ///                instance is considered to have drifted if one or more of the resources in the
    ///                associated stack have drifted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_CHECKED</code>: AWS CloudFormation has not checked the stack set for drift.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_SYNC</code>: All of the stack instances belonging to the stack set stack
    ///                match from the expected template and parameter configuration.</p>
    ///             </li>
    ///          </ul>
    public let driftStatus: StackSetDriftStatus?
    /// <p>The number of stack instances that have drifted from the expected template and parameter
    ///          configuration of the stack set. A stack instance is considered to have drifted if one or
    ///          more of the resources in the associated stack do not match their expected
    ///          configuration.</p>
    public let driftedStackInstancesCount: Int
    /// <p>The number of stack instances for which the drift detection operation failed.</p>
    public let failedStackInstancesCount: Int
    /// <p>The number of stack instances that are currently being checked for drift.</p>
    public let inProgressStackInstancesCount: Int
    /// <p>The number of stack instances which match the expected template and parameter
    ///          configuration of the stack set.</p>
    public let inSyncStackInstancesCount: Int
    /// <p>Most recent time when CloudFormation performed a drift detection operation on the stack
    ///          set. This value will be <code>NULL</code> for any stack set on which drift detection has
    ///          not yet been performed.</p>
    public let lastDriftCheckTimestamp: Date?
    /// <p>The total number of stack instances belonging to this stack set. </p>
    ///          <p>The total number of stack instances is equal to the total of:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Stack instances that match the stack set configuration. </p>
    ///             </li>
    ///             <li>
    ///                <p>Stack instances that have drifted from the stack set configuration. </p>
    ///             </li>
    ///             <li>
    ///                <p>Stack instances where the drift detection operation has failed.</p>
    ///             </li>
    ///             <li>
    ///                <p>Stack instances currently being checked for drift.</p>
    ///             </li>
    ///          </ul>
    public let totalStackInstancesCount: Int

    public init (
        driftDetectionStatus: StackSetDriftDetectionStatus? = nil,
        driftStatus: StackSetDriftStatus? = nil,
        driftedStackInstancesCount: Int = 0,
        failedStackInstancesCount: Int = 0,
        inProgressStackInstancesCount: Int = 0,
        inSyncStackInstancesCount: Int = 0,
        lastDriftCheckTimestamp: Date? = nil,
        totalStackInstancesCount: Int = 0
    )
    {
        self.driftDetectionStatus = driftDetectionStatus
        self.driftStatus = driftStatus
        self.driftedStackInstancesCount = driftedStackInstancesCount
        self.failedStackInstancesCount = failedStackInstancesCount
        self.inProgressStackInstancesCount = inProgressStackInstancesCount
        self.inSyncStackInstancesCount = inSyncStackInstancesCount
        self.lastDriftCheckTimestamp = lastDriftCheckTimestamp
        self.totalStackInstancesCount = totalStackInstancesCount
    }
}

public enum StackSetDriftDetectionStatus {
    case completed
    case failed
    case inProgress
    case partialSuccess
    case stopped
    case sdkUnknown(String)
}

extension StackSetDriftDetectionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackSetDriftDetectionStatus] {
        return [
            .completed,
            .failed,
            .inProgress,
            .partialSuccess,
            .stopped,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .partialSuccess: return "PARTIAL_SUCCESS"
        case .stopped: return "STOPPED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackSetDriftDetectionStatus(rawValue: rawValue) ?? StackSetDriftDetectionStatus.sdkUnknown(rawValue)
    }
}

public enum StackSetDriftStatus {
    case drifted
    case inSync
    case notChecked
    case sdkUnknown(String)
}

extension StackSetDriftStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackSetDriftStatus] {
        return [
            .drifted,
            .inSync,
            .notChecked,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .drifted: return "DRIFTED"
        case .inSync: return "IN_SYNC"
        case .notChecked: return "NOT_CHECKED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackSetDriftStatus(rawValue: rawValue) ?? StackSetDriftStatus.sdkUnknown(rawValue)
    }
}

extension StackSetNotEmptyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackSetNotEmptyException(message: \(String(describing: message)))"}
}

extension StackSetNotEmptyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<StackSetNotEmptyExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't yet delete this stack set, because it still contains one or more stack
///          instances. Delete all stack instances from the stack set before deleting the stack
///          set.</p>
public struct StackSetNotEmptyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StackSetNotEmptyExceptionBody: Equatable {
    public let message: String?
}

extension StackSetNotEmptyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StackSetNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackSetNotFoundException(message: \(String(describing: message)))"}
}

extension StackSetNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<StackSetNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified stack set doesn't exist.</p>
public struct StackSetNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StackSetNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension StackSetNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StackSetOperation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case administrationRoleARN = "AdministrationRoleARN"
        case creationTimestamp = "CreationTimestamp"
        case deploymentTargets = "DeploymentTargets"
        case endTimestamp = "EndTimestamp"
        case executionRoleName = "ExecutionRoleName"
        case operationId = "OperationId"
        case operationPreferences = "OperationPreferences"
        case retainStacks = "RetainStacks"
        case stackSetDriftDetectionDetails = "StackSetDriftDetectionDetails"
        case stackSetId = "StackSetId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let action = action {
            try container.encode(action, forKey: Key("Action"))
        }
        if let administrationRoleARN = administrationRoleARN {
            try container.encode(administrationRoleARN, forKey: Key("AdministrationRoleARN"))
        }
        if let creationTimestamp = creationTimestamp {
            try container.encode(TimestampWrapper(creationTimestamp, format: .dateTime), forKey: Key("creationTimestamp"))
        }
        if let deploymentTargets = deploymentTargets {
            try container.encode(deploymentTargets, forKey: Key("DeploymentTargets"))
        }
        if let endTimestamp = endTimestamp {
            try container.encode(TimestampWrapper(endTimestamp, format: .dateTime), forKey: Key("endTimestamp"))
        }
        if let executionRoleName = executionRoleName {
            try container.encode(executionRoleName, forKey: Key("ExecutionRoleName"))
        }
        if let operationId = operationId {
            try container.encode(operationId, forKey: Key("OperationId"))
        }
        if let operationPreferences = operationPreferences {
            try container.encode(operationPreferences, forKey: Key("OperationPreferences"))
        }
        if let retainStacks = retainStacks {
            try container.encode(retainStacks, forKey: Key("RetainStacks"))
        }
        if let stackSetDriftDetectionDetails = stackSetDriftDetectionDetails {
            try container.encode(stackSetDriftDetectionDetails, forKey: Key("StackSetDriftDetectionDetails"))
        }
        if let stackSetId = stackSetId {
            try container.encode(stackSetId, forKey: Key("StackSetId"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
        let stackSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackSetId)
        stackSetId = stackSetIdDecoded
        let actionDecoded = try containerValues.decodeIfPresent(StackSetOperationAction.self, forKey: .action)
        action = actionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StackSetOperationStatus.self, forKey: .status)
        status = statusDecoded
        let operationPreferencesDecoded = try containerValues.decodeIfPresent(StackSetOperationPreferences.self, forKey: .operationPreferences)
        operationPreferences = operationPreferencesDecoded
        let retainStacksDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .retainStacks)
        retainStacks = retainStacksDecoded
        let administrationRoleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .administrationRoleARN)
        administrationRoleARN = administrationRoleARNDecoded
        let executionRoleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleName)
        executionRoleName = executionRoleNameDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        var creationTimestampBuffer:Date? = nil
        if let creationTimestampDecoded = creationTimestampDecoded {
            creationTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationTimestampDecoded, format: .dateTime)
        }
        creationTimestamp = creationTimestampBuffer
        let endTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTimestamp)
        var endTimestampBuffer:Date? = nil
        if let endTimestampDecoded = endTimestampDecoded {
            endTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(endTimestampDecoded, format: .dateTime)
        }
        endTimestamp = endTimestampBuffer
        let deploymentTargetsDecoded = try containerValues.decodeIfPresent(DeploymentTargets.self, forKey: .deploymentTargets)
        deploymentTargets = deploymentTargetsDecoded
        let stackSetDriftDetectionDetailsDecoded = try containerValues.decodeIfPresent(StackSetDriftDetectionDetails.self, forKey: .stackSetDriftDetectionDetails)
        stackSetDriftDetectionDetails = stackSetDriftDetectionDetailsDecoded
    }
}

extension StackSetOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackSetOperation(action: \(String(describing: action)), administrationRoleARN: \(String(describing: administrationRoleARN)), creationTimestamp: \(String(describing: creationTimestamp)), deploymentTargets: \(String(describing: deploymentTargets)), endTimestamp: \(String(describing: endTimestamp)), executionRoleName: \(String(describing: executionRoleName)), operationId: \(String(describing: operationId)), operationPreferences: \(String(describing: operationPreferences)), retainStacks: \(String(describing: retainStacks)), stackSetDriftDetectionDetails: \(String(describing: stackSetDriftDetectionDetails)), stackSetId: \(String(describing: stackSetId)), status: \(String(describing: status)))"}
}

/// <p>The structure that contains information about a stack set operation. </p>
public struct StackSetOperation: Equatable {
    /// <p>The type of stack set operation: <code>CREATE</code>, <code>UPDATE</code>, or
    ///             <code>DELETE</code>. Create and delete operations affect only the specified stack set
    ///          instances that are associated with the specified stack set. Update operations affect both
    ///          the stack set itself, as well as <i>all</i> associated stack set
    ///          instances.</p>
    public let action: StackSetOperationAction?
    /// <p>The Amazon Resource Number (ARN) of the IAM role used to perform this stack set
    ///          operation. </p>
    ///          <p>Use customized administrator roles to control which users or groups can manage specific
    ///          stack sets within the same administrator account. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs.html">Define Permissions for Multiple
    ///             Administrators</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    public let administrationRoleARN: String?
    /// <p>The time at which the operation was initiated. Note that the creation times for the
    ///          stack set operation might differ from the creation time of the individual stacks
    ///          themselves. This is because AWS CloudFormation needs to perform preparatory work for the
    ///          operation, such as dispatching the work to the requested Regions, before actually creating
    ///          the first stacks.</p>
    public let creationTimestamp: Date?
    /// <p>[Service-managed permissions] The AWS Organizations accounts affected by the stack operation.</p>
    public let deploymentTargets: DeploymentTargets?
    /// <p>The time at which the stack set operation ended, across all accounts and Regions
    ///          specified. Note that this doesn't necessarily mean that the stack set operation was
    ///          successful, or even attempted, in each account or Region.</p>
    public let endTimestamp: Date?
    /// <p>The name of the IAM execution role used to create or update the stack set.</p>
    ///          <p>Use customized execution roles to control which stack resources users and groups can
    ///          include in their stack sets.
    ///       </p>
    public let executionRoleName: String?
    /// <p>The unique ID of a stack set operation.</p>
    public let operationId: String?
    /// <p>The preferences for how AWS CloudFormation performs this stack set
    ///          operation.</p>
    public let operationPreferences: StackSetOperationPreferences?
    /// <p>For stack set operations of action type <code>DELETE</code>, specifies whether to
    ///          remove the stack instances from the specified stack set, but doesn't delete the stacks. You
    ///          can't reassociate a retained stack, or add an existing, saved stack to a new stack
    ///          set.</p>
    public let retainStacks: Bool?
    /// <p>Detailed information about the drift status of the stack set. This includes information
    ///          about drift operations currently being performed on the stack set.</p>
    ///          <p>this information will only be present for stack set operations whose <code>Action</code>
    ///          type is <code>DETECT_DRIFT</code>.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-drift.html">Detecting Unmanaged
    ///          Changes in Stack Sets</a> in the AWS CloudFormation User Guide.</p>
    public let stackSetDriftDetectionDetails: StackSetDriftDetectionDetails?
    /// <p>The ID of the stack set.</p>
    public let stackSetId: String?
    /// <p>The status of the operation. </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code>: The operation exceeded the specified failure tolerance.
    ///                The failure tolerance value that you've set for an operation is applied for each
    ///                Region during stack create and update operations. If the number of failed stacks
    ///                within a Region exceeds the failure tolerance, the status of the operation in the
    ///                Region is set to <code>FAILED</code>. This in turn sets the status of the operation
    ///                as a whole to <code>FAILED</code>, and AWS CloudFormation cancels the operation in
    ///                any remaining Regions.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>QUEUED</code>: [Service-managed permissions] For automatic deployments that
    ///                require a sequence of operations, the operation is queued to be performed. For more information, see the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-concepts.html#stackset-status-codes">stack set operation status codes</a> in the AWS CloudFormation User Guide.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RUNNING</code>: The operation is currently being performed.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>STOPPED</code>: The user has cancelled the operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>STOPPING</code>: The operation is in the process of stopping, at user
    ///                request. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SUCCEEDED</code>: The operation completed creating or updating all the
    ///                specified stacks without exceeding the failure tolerance for the operation.</p>
    ///             </li>
    ///          </ul>
    public let status: StackSetOperationStatus?

    public init (
        action: StackSetOperationAction? = nil,
        administrationRoleARN: String? = nil,
        creationTimestamp: Date? = nil,
        deploymentTargets: DeploymentTargets? = nil,
        endTimestamp: Date? = nil,
        executionRoleName: String? = nil,
        operationId: String? = nil,
        operationPreferences: StackSetOperationPreferences? = nil,
        retainStacks: Bool? = nil,
        stackSetDriftDetectionDetails: StackSetDriftDetectionDetails? = nil,
        stackSetId: String? = nil,
        status: StackSetOperationStatus? = nil
    )
    {
        self.action = action
        self.administrationRoleARN = administrationRoleARN
        self.creationTimestamp = creationTimestamp
        self.deploymentTargets = deploymentTargets
        self.endTimestamp = endTimestamp
        self.executionRoleName = executionRoleName
        self.operationId = operationId
        self.operationPreferences = operationPreferences
        self.retainStacks = retainStacks
        self.stackSetDriftDetectionDetails = stackSetDriftDetectionDetails
        self.stackSetId = stackSetId
        self.status = status
    }
}

public enum StackSetOperationAction {
    case create
    case delete
    case detectDrift
    case update
    case sdkUnknown(String)
}

extension StackSetOperationAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackSetOperationAction] {
        return [
            .create,
            .delete,
            .detectDrift,
            .update,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .create: return "CREATE"
        case .delete: return "DELETE"
        case .detectDrift: return "DETECT_DRIFT"
        case .update: return "UPDATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackSetOperationAction(rawValue: rawValue) ?? StackSetOperationAction.sdkUnknown(rawValue)
    }
}

extension StackSetOperationPreferences: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureToleranceCount = "FailureToleranceCount"
        case failureTolerancePercentage = "FailureTolerancePercentage"
        case maxConcurrentCount = "MaxConcurrentCount"
        case maxConcurrentPercentage = "MaxConcurrentPercentage"
        case regionConcurrencyType = "RegionConcurrencyType"
        case regionOrder = "RegionOrder"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let failureToleranceCount = failureToleranceCount {
            try container.encode(failureToleranceCount, forKey: Key("FailureToleranceCount"))
        }
        if let failureTolerancePercentage = failureTolerancePercentage {
            try container.encode(failureTolerancePercentage, forKey: Key("FailureTolerancePercentage"))
        }
        if let maxConcurrentCount = maxConcurrentCount {
            try container.encode(maxConcurrentCount, forKey: Key("MaxConcurrentCount"))
        }
        if let maxConcurrentPercentage = maxConcurrentPercentage {
            try container.encode(maxConcurrentPercentage, forKey: Key("MaxConcurrentPercentage"))
        }
        if let regionConcurrencyType = regionConcurrencyType {
            try container.encode(regionConcurrencyType, forKey: Key("RegionConcurrencyType"))
        }
        if let regionOrder = regionOrder {
            var regionOrderContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("RegionOrder"))
            for (index0, region0) in regionOrder.enumerated() {
                try regionOrderContainer.encode(region0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionConcurrencyTypeDecoded = try containerValues.decodeIfPresent(RegionConcurrencyType.self, forKey: .regionConcurrencyType)
        regionConcurrencyType = regionConcurrencyTypeDecoded
        if containerValues.contains(.regionOrder) {
            struct KeyVal0{struct member{}}
            let regionOrderWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .regionOrder)
            if let regionOrderWrappedContainer = regionOrderWrappedContainer {
                let regionOrderContainer = try regionOrderWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var regionOrderBuffer:[String]? = nil
                if let regionOrderContainer = regionOrderContainer {
                    regionOrderBuffer = [String]()
                    for stringContainer0 in regionOrderContainer {
                        regionOrderBuffer?.append(stringContainer0)
                    }
                }
                regionOrder = regionOrderBuffer
            } else {
                regionOrder = []
            }
        } else {
            regionOrder = nil
        }
        let failureToleranceCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .failureToleranceCount)
        failureToleranceCount = failureToleranceCountDecoded
        let failureTolerancePercentageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .failureTolerancePercentage)
        failureTolerancePercentage = failureTolerancePercentageDecoded
        let maxConcurrentCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxConcurrentCount)
        maxConcurrentCount = maxConcurrentCountDecoded
        let maxConcurrentPercentageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxConcurrentPercentage)
        maxConcurrentPercentage = maxConcurrentPercentageDecoded
    }
}

extension StackSetOperationPreferences: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackSetOperationPreferences(failureToleranceCount: \(String(describing: failureToleranceCount)), failureTolerancePercentage: \(String(describing: failureTolerancePercentage)), maxConcurrentCount: \(String(describing: maxConcurrentCount)), maxConcurrentPercentage: \(String(describing: maxConcurrentPercentage)), regionConcurrencyType: \(String(describing: regionConcurrencyType)), regionOrder: \(String(describing: regionOrder)))"}
}

/// <p>The user-specified preferences for how AWS CloudFormation performs a stack set
///          operation. </p>
///          <p>For more information on maximum concurrent accounts and failure tolerance, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-concepts.html#stackset-ops-options">Stack set operation options</a>.</p>
public struct StackSetOperationPreferences: Equatable {
    /// <p>The number of accounts, per Region, for which this operation can fail before AWS
    ///          CloudFormation stops the operation in that Region. If the operation is stopped in a Region,
    ///          AWS CloudFormation doesn't attempt the operation in any subsequent Regions.</p>
    ///          <p>Conditional: You must specify either <code>FailureToleranceCount</code> or
    ///             <code>FailureTolerancePercentage</code> (but not both).</p>
    public let failureToleranceCount: Int?
    /// <p>The percentage of accounts, per Region, for which this stack operation can fail
    ///          before AWS CloudFormation stops the operation in that Region. If the operation is stopped
    ///          in a Region, AWS CloudFormation doesn't attempt the operation in any subsequent
    ///          Regions.</p>
    ///          <p>When calculating the number of accounts based on the specified percentage, AWS
    ///          CloudFormation rounds <i>down</i> to the next whole number.</p>
    ///          <p>Conditional: You must specify either <code>FailureToleranceCount</code> or
    ///             <code>FailureTolerancePercentage</code>, but not both.</p>
    public let failureTolerancePercentage: Int?
    /// <p>The maximum number of accounts in which to perform this operation at one time. This
    ///          is dependent on the value of
    ///             <code>FailureToleranceCount</code>. <code>MaxConcurrentCount</code> is at most one more
    ///          than the <code>FailureToleranceCount</code>.</p>
    ///          <p>Note that this setting lets you specify the <i>maximum</i> for
    ///          operations. For large deployments, under certain circumstances the actual number of
    ///          accounts acted upon concurrently may be lower due to service throttling.</p>
    ///          <p>Conditional: You must specify either <code>MaxConcurrentCount</code> or
    ///             <code>MaxConcurrentPercentage</code>, but not both.</p>
    public let maxConcurrentCount: Int?
    /// <p>The maximum percentage of accounts in which to perform this operation at one
    ///          time.</p>
    ///          <p>When calculating the number of accounts based on the specified percentage, AWS
    ///          CloudFormation rounds down to the next whole number. This is true except in cases where
    ///          rounding down would result is zero. In this case, CloudFormation sets the number as one
    ///          instead.</p>
    ///          <p>Note that this setting lets you specify the <i>maximum</i> for
    ///          operations. For large deployments, under certain circumstances the actual number of
    ///          accounts acted upon concurrently may be lower due to service throttling.</p>
    ///          <p>Conditional: You must specify either <code>MaxConcurrentCount</code> or
    ///             <code>MaxConcurrentPercentage</code>, but not both.</p>
    public let maxConcurrentPercentage: Int?
    /// <p>The concurrency type of deploying StackSets operations in regions, could be in parallel or one region at a time.</p>
    public let regionConcurrencyType: RegionConcurrencyType?
    /// <p>The order of the Regions in where you want to perform the stack operation.</p>
    public let regionOrder: [String]?

    public init (
        failureToleranceCount: Int? = nil,
        failureTolerancePercentage: Int? = nil,
        maxConcurrentCount: Int? = nil,
        maxConcurrentPercentage: Int? = nil,
        regionConcurrencyType: RegionConcurrencyType? = nil,
        regionOrder: [String]? = nil
    )
    {
        self.failureToleranceCount = failureToleranceCount
        self.failureTolerancePercentage = failureTolerancePercentage
        self.maxConcurrentCount = maxConcurrentCount
        self.maxConcurrentPercentage = maxConcurrentPercentage
        self.regionConcurrencyType = regionConcurrencyType
        self.regionOrder = regionOrder
    }
}

public enum StackSetOperationResultStatus {
    case cancelled
    case failed
    case pending
    case running
    case succeeded
    case sdkUnknown(String)
}

extension StackSetOperationResultStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackSetOperationResultStatus] {
        return [
            .cancelled,
            .failed,
            .pending,
            .running,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case .running: return "RUNNING"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackSetOperationResultStatus(rawValue: rawValue) ?? StackSetOperationResultStatus.sdkUnknown(rawValue)
    }
}

extension StackSetOperationResultSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case account = "Account"
        case accountGateResult = "AccountGateResult"
        case organizationalUnitId = "OrganizationalUnitId"
        case region = "Region"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let account = account {
            try container.encode(account, forKey: Key("Account"))
        }
        if let accountGateResult = accountGateResult {
            try container.encode(accountGateResult, forKey: Key("AccountGateResult"))
        }
        if let organizationalUnitId = organizationalUnitId {
            try container.encode(organizationalUnitId, forKey: Key("OrganizationalUnitId"))
        }
        if let region = region {
            try container.encode(region, forKey: Key("Region"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
        if let statusReason = statusReason {
            try container.encode(statusReason, forKey: Key("StatusReason"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .account)
        account = accountDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StackSetOperationResultStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let accountGateResultDecoded = try containerValues.decodeIfPresent(AccountGateResult.self, forKey: .accountGateResult)
        accountGateResult = accountGateResultDecoded
        let organizationalUnitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationalUnitId)
        organizationalUnitId = organizationalUnitIdDecoded
    }
}

extension StackSetOperationResultSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackSetOperationResultSummary(account: \(String(describing: account)), accountGateResult: \(String(describing: accountGateResult)), organizationalUnitId: \(String(describing: organizationalUnitId)), region: \(String(describing: region)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)))"}
}

/// <p>The structure that contains information about a specified operation's results for a
///          given account in a given Region.</p>
public struct StackSetOperationResultSummary: Equatable {
    /// <p>[Self-managed permissions] The name of the AWS account for this operation result.</p>
    public let account: String?
    /// <p>The results of the account gate function AWS CloudFormation invokes, if present,
    ///          before proceeding with stack set operations in an account</p>
    public let accountGateResult: AccountGateResult?
    /// <p>[Service-managed permissions] The organization root ID or organizational unit (OU) IDs that you specified for <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_DeploymentTargets.html">DeploymentTargets</a>.</p>
    public let organizationalUnitId: String?
    /// <p>The name of the AWS Region for this operation result.</p>
    public let region: String?
    /// <p>The result status of the stack set operation for the given account in the given
    ///          Region.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CANCELLED</code>: The operation in the specified account and Region has
    ///                been cancelled. This is either because a user has stopped the stack set operation, or
    ///                because the failure tolerance of the stack set operation has been exceeded.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code>: The operation in the specified account and Region failed. </p>
    ///                <p>If the stack set operation fails in enough accounts within a Region, the
    ///                failure tolerance for the stack set operation as a whole might be exceeded.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RUNNING</code>: The operation in the specified account and Region is
    ///                currently in progress.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PENDING</code>: The operation in the specified account and Region has yet
    ///                to start. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SUCCEEDED</code>: The operation in the specified account and Region
    ///                completed successfully.</p>
    ///             </li>
    ///          </ul>
    public let status: StackSetOperationResultStatus?
    /// <p>The reason for the assigned result status.</p>
    public let statusReason: String?

    public init (
        account: String? = nil,
        accountGateResult: AccountGateResult? = nil,
        organizationalUnitId: String? = nil,
        region: String? = nil,
        status: StackSetOperationResultStatus? = nil,
        statusReason: String? = nil
    )
    {
        self.account = account
        self.accountGateResult = accountGateResult
        self.organizationalUnitId = organizationalUnitId
        self.region = region
        self.status = status
        self.statusReason = statusReason
    }
}

public enum StackSetOperationStatus {
    case failed
    case queued
    case running
    case stopped
    case stopping
    case succeeded
    case sdkUnknown(String)
}

extension StackSetOperationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackSetOperationStatus] {
        return [
            .failed,
            .queued,
            .running,
            .stopped,
            .stopping,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .queued: return "QUEUED"
        case .running: return "RUNNING"
        case .stopped: return "STOPPED"
        case .stopping: return "STOPPING"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackSetOperationStatus(rawValue: rawValue) ?? StackSetOperationStatus.sdkUnknown(rawValue)
    }
}

extension StackSetOperationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case creationTimestamp = "CreationTimestamp"
        case endTimestamp = "EndTimestamp"
        case operationId = "OperationId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let action = action {
            try container.encode(action, forKey: Key("Action"))
        }
        if let creationTimestamp = creationTimestamp {
            try container.encode(TimestampWrapper(creationTimestamp, format: .dateTime), forKey: Key("creationTimestamp"))
        }
        if let endTimestamp = endTimestamp {
            try container.encode(TimestampWrapper(endTimestamp, format: .dateTime), forKey: Key("endTimestamp"))
        }
        if let operationId = operationId {
            try container.encode(operationId, forKey: Key("OperationId"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
        let actionDecoded = try containerValues.decodeIfPresent(StackSetOperationAction.self, forKey: .action)
        action = actionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StackSetOperationStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTimestamp)
        var creationTimestampBuffer:Date? = nil
        if let creationTimestampDecoded = creationTimestampDecoded {
            creationTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationTimestampDecoded, format: .dateTime)
        }
        creationTimestamp = creationTimestampBuffer
        let endTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTimestamp)
        var endTimestampBuffer:Date? = nil
        if let endTimestampDecoded = endTimestampDecoded {
            endTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(endTimestampDecoded, format: .dateTime)
        }
        endTimestamp = endTimestampBuffer
    }
}

extension StackSetOperationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackSetOperationSummary(action: \(String(describing: action)), creationTimestamp: \(String(describing: creationTimestamp)), endTimestamp: \(String(describing: endTimestamp)), operationId: \(String(describing: operationId)), status: \(String(describing: status)))"}
}

/// <p>The structures that contain summary information about the specified
///          operation.</p>
public struct StackSetOperationSummary: Equatable {
    /// <p>The type of operation: <code>CREATE</code>, <code>UPDATE</code>, or
    ///             <code>DELETE</code>. Create and delete operations affect only the specified stack
    ///          instances that are associated with the specified stack set. Update operations affect both
    ///          the stack set itself as well as <i>all</i> associated stack set
    ///          instances.</p>
    public let action: StackSetOperationAction?
    /// <p>The time at which the operation was initiated. Note that the creation times for the
    ///          stack set operation might differ from the creation time of the individual stacks
    ///          themselves. This is because AWS CloudFormation needs to perform preparatory work for the
    ///          operation, such as dispatching the work to the requested Regions, before actually creating
    ///          the first stacks.</p>
    public let creationTimestamp: Date?
    /// <p>The time at which the stack set operation ended, across all accounts and Regions
    ///          specified. Note that this doesn't necessarily mean that the stack set operation was
    ///          successful, or even attempted, in each account or Region.</p>
    public let endTimestamp: Date?
    /// <p>The unique ID of the stack set operation.</p>
    public let operationId: String?
    /// <p>The overall status of the operation.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code>: The operation exceeded the specified failure tolerance.
    ///                The failure tolerance value that you've set for an operation is applied for each
    ///                Region during stack create and update operations. If the number of failed stacks
    ///                within a Region exceeds the failure tolerance, the status of the operation in the
    ///                Region is set to <code>FAILED</code>. This in turn sets the status of the operation
    ///                as a whole to <code>FAILED</code>, and AWS CloudFormation cancels the operation in
    ///                any remaining Regions.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>QUEUED</code>: [Service-managed permissions] For automatic deployments that
    ///                require a sequence of operations, the operation is queued to be performed. For more information, see the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-concepts.html#stackset-status-codes">stack set operation status codes</a> in the AWS CloudFormation User Guide.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RUNNING</code>: The operation is currently being performed.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>STOPPED</code>: The user has cancelled the operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>STOPPING</code>: The operation is in the process of stopping, at user
    ///                request. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SUCCEEDED</code>: The operation completed creating or updating all the
    ///                specified stacks without exceeding the failure tolerance for the operation.</p>
    ///             </li>
    ///          </ul>
    public let status: StackSetOperationStatus?

    public init (
        action: StackSetOperationAction? = nil,
        creationTimestamp: Date? = nil,
        endTimestamp: Date? = nil,
        operationId: String? = nil,
        status: StackSetOperationStatus? = nil
    )
    {
        self.action = action
        self.creationTimestamp = creationTimestamp
        self.endTimestamp = endTimestamp
        self.operationId = operationId
        self.status = status
    }
}

public enum StackSetStatus {
    case active
    case deleted
    case sdkUnknown(String)
}

extension StackSetStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackSetStatus] {
        return [
            .active,
            .deleted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleted: return "DELETED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackSetStatus(rawValue: rawValue) ?? StackSetStatus.sdkUnknown(rawValue)
    }
}

extension StackSetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoDeployment = "AutoDeployment"
        case description = "Description"
        case driftStatus = "DriftStatus"
        case lastDriftCheckTimestamp = "LastDriftCheckTimestamp"
        case permissionModel = "PermissionModel"
        case stackSetId = "StackSetId"
        case stackSetName = "StackSetName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let autoDeployment = autoDeployment {
            try container.encode(autoDeployment, forKey: Key("AutoDeployment"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let driftStatus = driftStatus {
            try container.encode(driftStatus, forKey: Key("DriftStatus"))
        }
        if let lastDriftCheckTimestamp = lastDriftCheckTimestamp {
            try container.encode(TimestampWrapper(lastDriftCheckTimestamp, format: .dateTime), forKey: Key("lastDriftCheckTimestamp"))
        }
        if let permissionModel = permissionModel {
            try container.encode(permissionModel, forKey: Key("PermissionModel"))
        }
        if let stackSetId = stackSetId {
            try container.encode(stackSetId, forKey: Key("StackSetId"))
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackSetName)
        stackSetName = stackSetNameDecoded
        let stackSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackSetId)
        stackSetId = stackSetIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StackSetStatus.self, forKey: .status)
        status = statusDecoded
        let autoDeploymentDecoded = try containerValues.decodeIfPresent(AutoDeployment.self, forKey: .autoDeployment)
        autoDeployment = autoDeploymentDecoded
        let permissionModelDecoded = try containerValues.decodeIfPresent(PermissionModels.self, forKey: .permissionModel)
        permissionModel = permissionModelDecoded
        let driftStatusDecoded = try containerValues.decodeIfPresent(StackDriftStatus.self, forKey: .driftStatus)
        driftStatus = driftStatusDecoded
        let lastDriftCheckTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastDriftCheckTimestamp)
        var lastDriftCheckTimestampBuffer:Date? = nil
        if let lastDriftCheckTimestampDecoded = lastDriftCheckTimestampDecoded {
            lastDriftCheckTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastDriftCheckTimestampDecoded, format: .dateTime)
        }
        lastDriftCheckTimestamp = lastDriftCheckTimestampBuffer
    }
}

extension StackSetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackSetSummary(autoDeployment: \(String(describing: autoDeployment)), description: \(String(describing: description)), driftStatus: \(String(describing: driftStatus)), lastDriftCheckTimestamp: \(String(describing: lastDriftCheckTimestamp)), permissionModel: \(String(describing: permissionModel)), stackSetId: \(String(describing: stackSetId)), stackSetName: \(String(describing: stackSetName)), status: \(String(describing: status)))"}
}

/// <p>The structures that contain summary information about the specified stack
///          set.</p>
public struct StackSetSummary: Equatable {
    /// <p>[Service-managed permissions] Describes whether StackSets automatically deploys to AWS Organizations accounts that are added to a target organizational unit (OU).</p>
    public let autoDeployment: AutoDeployment?
    /// <p>A description of the stack set that you specify when the stack set is created or
    ///          updated.</p>
    public let description: String?
    /// <p>Status of the stack set's actual configuration compared to its expected template and
    ///          parameter configuration. A stack set is considered to have drifted if one or more of its
    ///          stack instances have drifted from their expected template and parameter
    ///          configuration.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DRIFTED</code>: One or more of the stack instances belonging to the stack
    ///                set stack differs from the expected template and parameter configuration. A stack
    ///                instance is considered to have drifted if one or more of the resources in the
    ///                associated stack have drifted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOT_CHECKED</code>: AWS CloudFormation has not checked the stack set for drift.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_SYNC</code>: All of the stack instances belonging to the stack set stack
    ///                match from the expected template and parameter configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UNKNOWN</code>: This value is reserved for future use.</p>
    ///             </li>
    ///          </ul>
    public let driftStatus: StackDriftStatus?
    /// <p>Most recent time when CloudFormation performed a drift detection operation on the stack
    ///          set. This value will be <code>NULL</code> for any stack set on which drift detection has
    ///          not yet been performed.</p>
    public let lastDriftCheckTimestamp: Date?
    /// <p>Describes how the IAM roles required for stack set operations are created.</p>
    ///          <ul>
    ///             <li>
    ///                <p>With <code>self-managed</code> permissions, you must create the administrator and execution roles required to deploy to target accounts. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-self-managed.html">Grant Self-Managed Stack Set Permissions</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>With <code>service-managed</code> permissions, StackSets automatically creates the IAM roles required to deploy to accounts managed by AWS Organizations. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-service-managed.html">Grant Service-Managed Stack Set Permissions</a>.</p>
    ///             </li>
    ///          </ul>
    public let permissionModel: PermissionModels?
    /// <p>The ID of the stack set.</p>
    public let stackSetId: String?
    /// <p>The name of the stack set.</p>
    public let stackSetName: String?
    /// <p>The status of the stack set.</p>
    public let status: StackSetStatus?

    public init (
        autoDeployment: AutoDeployment? = nil,
        description: String? = nil,
        driftStatus: StackDriftStatus? = nil,
        lastDriftCheckTimestamp: Date? = nil,
        permissionModel: PermissionModels? = nil,
        stackSetId: String? = nil,
        stackSetName: String? = nil,
        status: StackSetStatus? = nil
    )
    {
        self.autoDeployment = autoDeployment
        self.description = description
        self.driftStatus = driftStatus
        self.lastDriftCheckTimestamp = lastDriftCheckTimestamp
        self.permissionModel = permissionModel
        self.stackSetId = stackSetId
        self.stackSetName = stackSetName
        self.status = status
    }
}

public enum StackStatus {
    case createComplete
    case createFailed
    case createInProgress
    case deleteComplete
    case deleteFailed
    case deleteInProgress
    case importComplete
    case importInProgress
    case importRollbackComplete
    case importRollbackFailed
    case importRollbackInProgress
    case reviewInProgress
    case rollbackComplete
    case rollbackFailed
    case rollbackInProgress
    case updateComplete
    case updateCompleteCleanupInProgress
    case updateInProgress
    case updateRollbackComplete
    case updateRollbackCompleteCleanupInProgress
    case updateRollbackFailed
    case updateRollbackInProgress
    case sdkUnknown(String)
}

extension StackStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackStatus] {
        return [
            .createComplete,
            .createFailed,
            .createInProgress,
            .deleteComplete,
            .deleteFailed,
            .deleteInProgress,
            .importComplete,
            .importInProgress,
            .importRollbackComplete,
            .importRollbackFailed,
            .importRollbackInProgress,
            .reviewInProgress,
            .rollbackComplete,
            .rollbackFailed,
            .rollbackInProgress,
            .updateComplete,
            .updateCompleteCleanupInProgress,
            .updateInProgress,
            .updateRollbackComplete,
            .updateRollbackCompleteCleanupInProgress,
            .updateRollbackFailed,
            .updateRollbackInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createComplete: return "CREATE_COMPLETE"
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .deleteComplete: return "DELETE_COMPLETE"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .importComplete: return "IMPORT_COMPLETE"
        case .importInProgress: return "IMPORT_IN_PROGRESS"
        case .importRollbackComplete: return "IMPORT_ROLLBACK_COMPLETE"
        case .importRollbackFailed: return "IMPORT_ROLLBACK_FAILED"
        case .importRollbackInProgress: return "IMPORT_ROLLBACK_IN_PROGRESS"
        case .reviewInProgress: return "REVIEW_IN_PROGRESS"
        case .rollbackComplete: return "ROLLBACK_COMPLETE"
        case .rollbackFailed: return "ROLLBACK_FAILED"
        case .rollbackInProgress: return "ROLLBACK_IN_PROGRESS"
        case .updateComplete: return "UPDATE_COMPLETE"
        case .updateCompleteCleanupInProgress: return "UPDATE_COMPLETE_CLEANUP_IN_PROGRESS"
        case .updateInProgress: return "UPDATE_IN_PROGRESS"
        case .updateRollbackComplete: return "UPDATE_ROLLBACK_COMPLETE"
        case .updateRollbackCompleteCleanupInProgress: return "UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS"
        case .updateRollbackFailed: return "UPDATE_ROLLBACK_FAILED"
        case .updateRollbackInProgress: return "UPDATE_ROLLBACK_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackStatus(rawValue: rawValue) ?? StackStatus.sdkUnknown(rawValue)
    }
}

extension StackSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case deletionTime = "DeletionTime"
        case driftInformation = "DriftInformation"
        case lastUpdatedTime = "LastUpdatedTime"
        case parentId = "ParentId"
        case rootId = "RootId"
        case stackId = "StackId"
        case stackName = "StackName"
        case stackStatus = "StackStatus"
        case stackStatusReason = "StackStatusReason"
        case templateDescription = "TemplateDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let creationTime = creationTime {
            try container.encode(TimestampWrapper(creationTime, format: .dateTime), forKey: Key("creationTime"))
        }
        if let deletionTime = deletionTime {
            try container.encode(TimestampWrapper(deletionTime, format: .dateTime), forKey: Key("deletionTime"))
        }
        if let driftInformation = driftInformation {
            try container.encode(driftInformation, forKey: Key("DriftInformation"))
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try container.encode(TimestampWrapper(lastUpdatedTime, format: .dateTime), forKey: Key("lastUpdatedTime"))
        }
        if let parentId = parentId {
            try container.encode(parentId, forKey: Key("ParentId"))
        }
        if let rootId = rootId {
            try container.encode(rootId, forKey: Key("RootId"))
        }
        if let stackId = stackId {
            try container.encode(stackId, forKey: Key("StackId"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        if let stackStatus = stackStatus {
            try container.encode(stackStatus, forKey: Key("StackStatus"))
        }
        if let stackStatusReason = stackStatusReason {
            try container.encode(stackStatusReason, forKey: Key("StackStatusReason"))
        }
        if let templateDescription = templateDescription {
            try container.encode(templateDescription, forKey: Key("TemplateDescription"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let templateDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateDescription)
        templateDescription = templateDescriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationTime)
        var creationTimeBuffer:Date? = nil
        if let creationTimeDecoded = creationTimeDecoded {
            creationTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(creationTimeDecoded, format: .dateTime)
        }
        creationTime = creationTimeBuffer
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedTime)
        var lastUpdatedTimeBuffer:Date? = nil
        if let lastUpdatedTimeDecoded = lastUpdatedTimeDecoded {
            lastUpdatedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastUpdatedTimeDecoded, format: .dateTime)
        }
        lastUpdatedTime = lastUpdatedTimeBuffer
        let deletionTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deletionTime)
        var deletionTimeBuffer:Date? = nil
        if let deletionTimeDecoded = deletionTimeDecoded {
            deletionTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(deletionTimeDecoded, format: .dateTime)
        }
        deletionTime = deletionTimeBuffer
        let stackStatusDecoded = try containerValues.decodeIfPresent(StackStatus.self, forKey: .stackStatus)
        stackStatus = stackStatusDecoded
        let stackStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackStatusReason)
        stackStatusReason = stackStatusReasonDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let rootIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rootId)
        rootId = rootIdDecoded
        let driftInformationDecoded = try containerValues.decodeIfPresent(StackDriftInformationSummary.self, forKey: .driftInformation)
        driftInformation = driftInformationDecoded
    }
}

extension StackSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackSummary(creationTime: \(String(describing: creationTime)), deletionTime: \(String(describing: deletionTime)), driftInformation: \(String(describing: driftInformation)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), parentId: \(String(describing: parentId)), rootId: \(String(describing: rootId)), stackId: \(String(describing: stackId)), stackName: \(String(describing: stackName)), stackStatus: \(String(describing: stackStatus)), stackStatusReason: \(String(describing: stackStatusReason)), templateDescription: \(String(describing: templateDescription)))"}
}

/// <p>The StackSummary Data Type</p>
public struct StackSummary: Equatable {
    /// <p>The time the stack was created.</p>
    public let creationTime: Date?
    /// <p>The time the stack was deleted.</p>
    public let deletionTime: Date?
    /// <p>Summarizes information on whether a stack's actual configuration differs, or has
    ///             <i>drifted</i>, from it's expected configuration, as defined in the stack
    ///          template and any values specified as template parameters. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting Unregulated Configuration
    ///             Changes to Stacks and Resources</a>.</p>
    public let driftInformation: StackDriftInformationSummary?
    /// <p>The time the stack was last updated. This field will only be returned if the stack
    ///          has been updated at least once.</p>
    public let lastUpdatedTime: Date?
    /// <p>For nested stacks--stacks created as resources for another stack--the stack ID of the
    ///          direct parent of this stack. For the first level of nested stacks, the root stack is also
    ///          the parent stack.</p>
    ///          <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">Working with Nested Stacks</a> in the
    ///          <i>AWS CloudFormation User Guide</i>.</p>
    public let parentId: String?
    /// <p>For nested stacks--stacks created as resources for another stack--the stack ID of the
    ///          top-level stack to which the nested stack ultimately belongs.</p>
    ///          <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">Working with Nested Stacks</a> in the
    ///          <i>AWS CloudFormation User Guide</i>.</p>
    public let rootId: String?
    /// <p>Unique stack identifier.</p>
    public let stackId: String?
    /// <p>The name associated with the stack.</p>
    public let stackName: String?
    /// <p>The current status of the stack.</p>
    public let stackStatus: StackStatus?
    /// <p>Success/Failure message associated with the stack status.</p>
    public let stackStatusReason: String?
    /// <p>The template description of the template used to create the stack.</p>
    public let templateDescription: String?

    public init (
        creationTime: Date? = nil,
        deletionTime: Date? = nil,
        driftInformation: StackDriftInformationSummary? = nil,
        lastUpdatedTime: Date? = nil,
        parentId: String? = nil,
        rootId: String? = nil,
        stackId: String? = nil,
        stackName: String? = nil,
        stackStatus: StackStatus? = nil,
        stackStatusReason: String? = nil,
        templateDescription: String? = nil
    )
    {
        self.creationTime = creationTime
        self.deletionTime = deletionTime
        self.driftInformation = driftInformation
        self.lastUpdatedTime = lastUpdatedTime
        self.parentId = parentId
        self.rootId = rootId
        self.stackId = stackId
        self.stackName = stackName
        self.stackStatus = stackStatus
        self.stackStatusReason = stackStatusReason
        self.templateDescription = templateDescription
    }
}

extension StaleRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StaleRequestException(message: \(String(describing: message)))"}
}

extension StaleRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<StaleRequestExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Another operation has been performed on this stack set since the specified operation
///          was performed. </p>
public struct StaleRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StaleRequestExceptionBody: Equatable {
    public let message: String?
}

extension StaleRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StopStackSetOperationInputBodyMiddleware: Middleware {
    public let id: String = "StopStackSetOperationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopStackSetOperationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopStackSetOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopStackSetOperationInput>
    public typealias MOutput = OperationOutput<StopStackSetOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopStackSetOperationOutputError>
}

extension StopStackSetOperationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopStackSetOperationInput(callAs: \(String(describing: callAs)), operationId: \(String(describing: operationId)), stackSetName: \(String(describing: stackSetName)))"}
}

extension StopStackSetOperationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let callAs = callAs {
            try container.encode(callAs, forKey: Key("CallAs"))
        }
        if let operationId = operationId {
            try container.encode(operationId, forKey: Key("OperationId"))
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        try container.encode("StopStackSetOperation", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct StopStackSetOperationInputHeadersMiddleware: Middleware {
    public let id: String = "StopStackSetOperationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopStackSetOperationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopStackSetOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopStackSetOperationInput>
    public typealias MOutput = OperationOutput<StopStackSetOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopStackSetOperationOutputError>
}

public struct StopStackSetOperationInputQueryItemMiddleware: Middleware {
    public let id: String = "StopStackSetOperationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopStackSetOperationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopStackSetOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopStackSetOperationInput>
    public typealias MOutput = OperationOutput<StopStackSetOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopStackSetOperationOutputError>
}

public struct StopStackSetOperationInput: Equatable {
    /// <p>[Service-managed permissions] Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account.</p>
    ///          <p>By default, <code>SELF</code> is specified. Use <code>SELF</code> for stack sets with self-managed permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you are signed in to the management account, specify <code>SELF</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you are signed in to a delegated administrator account, specify <code>DELEGATED_ADMIN</code>.</p>
    ///                <p>Your AWS account must be registered as a delegated administrator in the management account. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-orgs-delegated-admin.html">Register a delegated administrator</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let callAs: CallAs?
    /// <p>The ID of the stack operation. </p>
    public let operationId: String?
    /// <p>The name or unique ID of the stack set that you want to stop the operation
    ///          for.</p>
    public let stackSetName: String?

    public init (
        callAs: CallAs? = nil,
        operationId: String? = nil,
        stackSetName: String? = nil
    )
    {
        self.callAs = callAs
        self.operationId = operationId
        self.stackSetName = stackSetName
    }
}

extension StopStackSetOperationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StopStackSetOperationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotFoundException" : self = .operationNotFoundException(try OperationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StackSetNotFoundException" : self = .stackSetNotFoundException(try StackSetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopStackSetOperationOutputError: Equatable {
    case invalidOperationException(InvalidOperationException)
    case operationNotFoundException(OperationNotFoundException)
    case stackSetNotFoundException(StackSetNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopStackSetOperationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopStackSetOperationOutputResponse()"}
}

extension StopStackSetOperationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopStackSetOperationOutputResponse: Equatable {

    public init() {}
}

struct StopStackSetOperationOutputResponseBody: Equatable {
}

extension StopStackSetOperationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let key = key {
            try container.encode(key, forKey: Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>The Tag type enables you to specify a key-value pair that can be used to store
///          information about an AWS CloudFormation stack.</p>
public struct Tag: Equatable {
    /// <p>
    ///             <i>Required</i>. A string used to identify this tag. You can specify a
    ///          maximum of 128 characters for a tag key. Tags owned by Amazon Web Services (AWS) have the
    ///          reserved prefix: <code>aws:</code>.</p>
    public let key: String?
    /// <p>
    ///             <i>Required</i>. A string containing the value for this tag. You can specify
    ///          a maximum of 256 characters for a tag value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TemplateParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case description = "Description"
        case noEcho = "NoEcho"
        case parameterKey = "ParameterKey"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: Key("DefaultValue"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let noEcho = noEcho {
            try container.encode(noEcho, forKey: Key("NoEcho"))
        }
        if let parameterKey = parameterKey {
            try container.encode(parameterKey, forKey: Key("ParameterKey"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let noEchoDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .noEcho)
        noEcho = noEchoDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension TemplateParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateParameter(defaultValue: \(String(describing: defaultValue)), description: \(String(describing: description)), noEcho: \(String(describing: noEcho)), parameterKey: \(String(describing: parameterKey)))"}
}

/// <p>The TemplateParameter data type.</p>
public struct TemplateParameter: Equatable {
    /// <p>The default value associated with the parameter.</p>
    public let defaultValue: String?
    /// <p>User defined description associated with the parameter.</p>
    public let description: String?
    /// <p>Flag indicating whether the parameter should be displayed as plain text in logs and
    ///          UIs.</p>
    public let noEcho: Bool?
    /// <p>The name associated with the parameter.</p>
    public let parameterKey: String?

    public init (
        defaultValue: String? = nil,
        description: String? = nil,
        noEcho: Bool? = nil,
        parameterKey: String? = nil
    )
    {
        self.defaultValue = defaultValue
        self.description = description
        self.noEcho = noEcho
        self.parameterKey = parameterKey
    }
}

public enum TemplateStage {
    case original
    case processed
    case sdkUnknown(String)
}

extension TemplateStage : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TemplateStage] {
        return [
            .original,
            .processed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .original: return "Original"
        case .processed: return "Processed"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TemplateStage(rawValue: rawValue) ?? TemplateStage.sdkUnknown(rawValue)
    }
}

extension TokenAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TokenAlreadyExistsException(message: \(String(describing: message)))"}
}

extension TokenAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TokenAlreadyExistsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A client request token already exists.</p>
public struct TokenAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TokenAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension TokenAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TypeNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TypeNotFoundException(message: \(String(describing: message)))"}
}

extension TypeNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TypeNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified type does not exist in the CloudFormation registry.</p>
public struct TypeNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TypeNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension TypeNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TypeSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultVersionId = "DefaultVersionId"
        case description = "Description"
        case lastUpdated = "LastUpdated"
        case type = "Type"
        case typeArn = "TypeArn"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let defaultVersionId = defaultVersionId {
            try container.encode(defaultVersionId, forKey: Key("DefaultVersionId"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let lastUpdated = lastUpdated {
            try container.encode(TimestampWrapper(lastUpdated, format: .dateTime), forKey: Key("lastUpdated"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
        if let typeArn = typeArn {
            try container.encode(typeArn, forKey: Key("TypeArn"))
        }
        if let typeName = typeName {
            try container.encode(typeName, forKey: Key("TypeName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(RegistryType.self, forKey: .type)
        type = typeDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
        let typeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeArn)
        typeArn = typeArnDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdated)
        var lastUpdatedBuffer:Date? = nil
        if let lastUpdatedDecoded = lastUpdatedDecoded {
            lastUpdatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastUpdatedDecoded, format: .dateTime)
        }
        lastUpdated = lastUpdatedBuffer
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension TypeSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TypeSummary(defaultVersionId: \(String(describing: defaultVersionId)), description: \(String(describing: description)), lastUpdated: \(String(describing: lastUpdated)), type: \(String(describing: type)), typeArn: \(String(describing: typeArn)), typeName: \(String(describing: typeName)))"}
}

/// <p>Contains summary information about the specified CloudFormation type.</p>
public struct TypeSummary: Equatable {
    /// <p>The ID of the default version of the type. The default version is used when the type version is not specified.</p>
    ///          <p>To set the default version of a type, use <code>
    ///                <a>SetTypeDefaultVersion</a>
    ///             </code>. </p>
    public let defaultVersionId: String?
    /// <p>The description of the type.</p>
    public let description: String?
    /// <p>When the current default version of the type was registered.</p>
    public let lastUpdated: Date?
    /// <p>The kind of type.</p>
    public let type: RegistryType?
    /// <p>The Amazon Resource Name (ARN) of the type.</p>
    public let typeArn: String?
    /// <p>The name of the type.</p>
    public let typeName: String?

    public init (
        defaultVersionId: String? = nil,
        description: String? = nil,
        lastUpdated: Date? = nil,
        type: RegistryType? = nil,
        typeArn: String? = nil,
        typeName: String? = nil
    )
    {
        self.defaultVersionId = defaultVersionId
        self.description = description
        self.lastUpdated = lastUpdated
        self.type = type
        self.typeArn = typeArn
        self.typeName = typeName
    }
}

extension TypeVersionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case description = "Description"
        case isDefaultVersion = "IsDefaultVersion"
        case timeCreated = "TimeCreated"
        case type = "Type"
        case typeName = "TypeName"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let isDefaultVersion = isDefaultVersion {
            try container.encode(isDefaultVersion, forKey: Key("IsDefaultVersion"))
        }
        if let timeCreated = timeCreated {
            try container.encode(TimestampWrapper(timeCreated, format: .dateTime), forKey: Key("timeCreated"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
        if let typeName = typeName {
            try container.encode(typeName, forKey: Key("TypeName"))
        }
        if let versionId = versionId {
            try container.encode(versionId, forKey: Key("VersionId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(RegistryType.self, forKey: .type)
        type = typeDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let isDefaultVersionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isDefaultVersion)
        isDefaultVersion = isDefaultVersionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let timeCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeCreated)
        var timeCreatedBuffer:Date? = nil
        if let timeCreatedDecoded = timeCreatedDecoded {
            timeCreatedBuffer = try TimestampWrapperDecoder.parseDateStringValue(timeCreatedDecoded, format: .dateTime)
        }
        timeCreated = timeCreatedBuffer
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension TypeVersionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TypeVersionSummary(arn: \(String(describing: arn)), description: \(String(describing: description)), isDefaultVersion: \(String(describing: isDefaultVersion)), timeCreated: \(String(describing: timeCreated)), type: \(String(describing: type)), typeName: \(String(describing: typeName)), versionId: \(String(describing: versionId)))"}
}

/// <p>Contains summary information about a specific version of a CloudFormation type.</p>
public struct TypeVersionSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the type version.</p>
    public let arn: String?
    /// <p>The description of the type version.</p>
    public let description: String?
    /// <p>Whether the specified type version is set as the default version.</p>
    public let isDefaultVersion: Bool?
    /// <p>When the version was registered.</p>
    public let timeCreated: Date?
    /// <p>The kind of type.</p>
    public let type: RegistryType?
    /// <p>The name of the type.</p>
    public let typeName: String?
    /// <p>The ID of a specific version of the type. The version ID is the value at the end of the Amazon Resource Name (ARN) assigned to the type version when it is registered.</p>
    public let versionId: String?

    public init (
        arn: String? = nil,
        description: String? = nil,
        isDefaultVersion: Bool? = nil,
        timeCreated: Date? = nil,
        type: RegistryType? = nil,
        typeName: String? = nil,
        versionId: String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.isDefaultVersion = isDefaultVersion
        self.timeCreated = timeCreated
        self.type = type
        self.typeName = typeName
        self.versionId = versionId
    }
}

public struct UpdateStackInputBodyMiddleware: Middleware {
    public let id: String = "UpdateStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStackInput>
    public typealias MOutput = OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStackOutputError>
}

extension UpdateStackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStackInput(capabilities: \(String(describing: capabilities)), clientRequestToken: \(String(describing: clientRequestToken)), notificationARNs: \(String(describing: notificationARNs)), parameters: \(String(describing: parameters)), resourceTypes: \(String(describing: resourceTypes)), roleARN: \(String(describing: roleARN)), rollbackConfiguration: \(String(describing: rollbackConfiguration)), stackName: \(String(describing: stackName)), stackPolicyBody: \(String(describing: stackPolicyBody)), stackPolicyDuringUpdateBody: \(String(describing: stackPolicyDuringUpdateBody)), stackPolicyDuringUpdateURL: \(String(describing: stackPolicyDuringUpdateURL)), stackPolicyURL: \(String(describing: stackPolicyURL)), tags: \(String(describing: tags)), templateBody: \(String(describing: templateBody)), templateURL: \(String(describing: templateURL)), usePreviousTemplate: \(String(describing: usePreviousTemplate)))"}
}

extension UpdateStackInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Capabilities"))
            for (index0, capability0) in capabilities.enumerated() {
                try capabilitiesContainer.encode(capability0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let clientRequestToken = clientRequestToken {
            try container.encode(clientRequestToken, forKey: Key("ClientRequestToken"))
        }
        if let notificationARNs = notificationARNs {
            var notificationARNsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("NotificationARNs"))
            for (index0, notificationarn0) in notificationARNs.enumerated() {
                try notificationARNsContainer.encode(notificationarn0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ResourceTypes"))
            for (index0, resourcetype0) in resourceTypes.enumerated() {
                try resourceTypesContainer.encode(resourcetype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let roleARN = roleARN {
            try container.encode(roleARN, forKey: Key("RoleARN"))
        }
        if let rollbackConfiguration = rollbackConfiguration {
            try container.encode(rollbackConfiguration, forKey: Key("RollbackConfiguration"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        if let stackPolicyBody = stackPolicyBody {
            try container.encode(stackPolicyBody, forKey: Key("StackPolicyBody"))
        }
        if let stackPolicyDuringUpdateBody = stackPolicyDuringUpdateBody {
            try container.encode(stackPolicyDuringUpdateBody, forKey: Key("StackPolicyDuringUpdateBody"))
        }
        if let stackPolicyDuringUpdateURL = stackPolicyDuringUpdateURL {
            try container.encode(stackPolicyDuringUpdateURL, forKey: Key("StackPolicyDuringUpdateURL"))
        }
        if let stackPolicyURL = stackPolicyURL {
            try container.encode(stackPolicyURL, forKey: Key("StackPolicyURL"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let templateBody = templateBody {
            try container.encode(templateBody, forKey: Key("TemplateBody"))
        }
        if let templateURL = templateURL {
            try container.encode(templateURL, forKey: Key("TemplateURL"))
        }
        if let usePreviousTemplate = usePreviousTemplate {
            try container.encode(usePreviousTemplate, forKey: Key("UsePreviousTemplate"))
        }
        try container.encode("UpdateStack", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct UpdateStackInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStackInput>
    public typealias MOutput = OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStackOutputError>
}

public struct UpdateStackInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStackInput>
    public typealias MOutput = OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStackOutputError>
}

/// <p>The input for an <a>UpdateStack</a> action.</p>
public struct UpdateStackInput: Equatable {
    /// <p>In some cases, you must explicitly acknowledge that your stack template contains certain
    ///          capabilities in order for AWS CloudFormation to update the stack.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CAPABILITY_IAM</code> and <code>CAPABILITY_NAMED_IAM</code>
    ///                </p>
    ///                <p>Some stack templates might include resources that can affect permissions in
    ///                your AWS account; for example, by creating new AWS Identity and Access Management
    ///                (IAM) users. For those stacks, you must explicitly acknowledge this by specifying one
    ///                of these capabilities.</p>
    ///                <p>The following IAM resources require you to specify either the
    ///                   <code>CAPABILITY_IAM</code> or <code>CAPABILITY_NAMED_IAM</code>
    ///                capability.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>If you have IAM resources, you can specify either capability. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If you have IAM resources with custom names, you <i>must</i>
    ///                      specify <code>CAPABILITY_NAMED_IAM</code>. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If you don't specify either of these capabilities, AWS CloudFormation returns an
    ///                         <code>InsufficientCapabilities</code> error.</p>
    ///                   </li>
    ///                </ul>
    ///                <p>If your stack template contains these resources, we recommend that you review
    ///                all permissions associated with them and edit their permissions if
    ///                necessary.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-accesskey.html">
    ///                         AWS::IAM::AccessKey</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html">
    ///                         AWS::IAM::Group</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html"> AWS::IAM::InstanceProfile</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-policy.html">
    ///                         AWS::IAM::Policy</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html">
    ///                         AWS::IAM::Role</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-user.html">
    ///                         AWS::IAM::User</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-addusertogroup.html"> AWS::IAM::UserToGroupAddition</a>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///                <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#capabilities">Acknowledging IAM
    ///                   Resources in AWS CloudFormation Templates</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CAPABILITY_AUTO_EXPAND</code>
    ///                </p>
    ///                <p>Some template contain macros. Macros perform custom processing on templates; this
    ///                can include simple actions like find-and-replace operations, all the way to extensive
    ///                transformations of entire templates. Because of this, users typically create a change
    ///                set from the processed template, so that they can review the changes resulting from
    ///                the macros before actually updating the stack. If your stack template contains one or
    ///                more macros, and you choose to update a stack directly from the processed template,
    ///                without first reviewing the resulting changes in a change set, you must acknowledge
    ///                this capability. This includes the <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/create-reusable-transform-function-snippets-and-add-to-your-template-with-aws-include-transform.html">AWS::Include</a> and <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/transform-aws-serverless.html">AWS::Serverless</a> transforms, which are macros hosted by AWS CloudFormation.</p>
    ///                <p>If you want to update a stack
    ///                from a stack template that contains macros <i>and</i> nested stacks,
    ///                you must update the stack directly from the template using this capability.</p>
    ///                <important>
    ///                   <p>You should only update stacks directly from a stack template that contains
    ///                   macros if you know what processing the macro performs.</p>
    ///                   <p>Each macro relies on an underlying Lambda service function for processing stack
    ///                   templates. Be aware that the Lambda function owner can update the function
    ///                   operation without AWS CloudFormation being notified.</p>
    ///                </important>
    ///                <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-macros.html">Using
    ///                   AWS CloudFormation Macros to Perform Custom Processing on
    ///                Templates</a>.</p>
    ///             </li>
    ///          </ul>
    public let capabilities: [Capability]?
    /// <p>A unique identifier for this <code>UpdateStack</code> request. Specify this token if
    ///          you plan to retry requests so that AWS CloudFormation knows that you're not attempting to
    ///          update a stack with the same name. You might retry <code>UpdateStack</code> requests to
    ///          ensure that AWS CloudFormation successfully received them.</p>
    ///          <p>All events triggered by a given stack operation are assigned the same client request
    ///          token, which you can use to track operations. For example, if you execute a
    ///          <code>CreateStack</code> operation with the token <code>token1</code>, then all the
    ///          <code>StackEvents</code> generated by that operation will have
    ///          <code>ClientRequestToken</code> set as <code>token1</code>.</p>
    ///          <p>In the console, stack operations display the client request token on the Events tab.
    ///          Stack operations that are initiated from the console use the token format
    ///          <i>Console-StackOperation-ID</i>, which helps you easily identify the
    ///          stack operation . For example, if you create a stack using the console, each stack event
    ///          would be assigned the same token in the following format:
    ///          <code>Console-CreateStack-7f59c3cf-00d2-40c7-b2ff-e75db0987002</code>. </p>
    public let clientRequestToken: String?
    /// <p>Amazon Simple Notification Service topic Amazon Resource Names (ARNs) that AWS
    ///          CloudFormation associates with the stack. Specify an empty list to remove all notification
    ///          topics.</p>
    public let notificationARNs: [String]?
    /// <p>A list of <code>Parameter</code> structures that specify input parameters for the
    ///          stack. For more information, see the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_Parameter.html">Parameter</a> data
    ///          type.</p>
    public let parameters: [Parameter]?
    /// <p>The template resource types that you have permissions to work with for this update
    ///          stack action, such as <code>AWS::EC2::Instance</code>, <code>AWS::EC2::*</code>, or
    ///             <code>Custom::MyCustomInstance</code>.</p>
    ///          <p>If the list of resource types doesn't include a resource that you're updating, the
    ///          stack update fails. By default, AWS CloudFormation grants permissions to all resource
    ///          types. AWS Identity and Access Management (IAM) uses this parameter for AWS
    ///          CloudFormation-specific condition keys in IAM policies. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html">Controlling Access with AWS Identity and Access Management</a>.</p>
    public let resourceTypes: [String]?
    /// <p>The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role
    ///          that AWS CloudFormation assumes to update the stack. AWS CloudFormation uses the role's
    ///          credentials to make calls on your behalf. AWS CloudFormation always uses this role for all
    ///          future operations on the stack. As long as users have permission to operate on the stack,
    ///          AWS CloudFormation uses this role even if the users don't have permission to pass it.
    ///          Ensure that the role grants least privilege.</p>
    ///          <p>If you don't specify a value, AWS CloudFormation uses the role that was previously
    ///          associated with the stack. If no role is available, AWS CloudFormation uses a temporary
    ///          session that is generated from your user credentials.</p>
    public let roleARN: String?
    /// <p>The rollback triggers for AWS CloudFormation to monitor during stack creation and
    ///          updating operations, and for the specified monitoring period afterwards.</p>
    public let rollbackConfiguration: RollbackConfiguration?
    /// <p>The name or unique stack ID of the stack to update.</p>
    public let stackName: String?
    /// <p>Structure containing a new stack policy body. You can specify either the
    ///             <code>StackPolicyBody</code> or the <code>StackPolicyURL</code> parameter, but not
    ///          both.</p>
    ///          <p>You might update the stack policy, for example, in order to protect a new resource
    ///          that you created during a stack update. If you do not specify a stack policy, the current
    ///          policy that is associated with the stack is unchanged.</p>
    public let stackPolicyBody: String?
    /// <p>Structure containing the temporary overriding stack policy body. You can specify
    ///          either the <code>StackPolicyDuringUpdateBody</code> or the
    ///             <code>StackPolicyDuringUpdateURL</code> parameter, but not both.</p>
    ///          <p>If you want to update protected resources, specify a temporary overriding stack
    ///          policy during this update. If you do not specify a stack policy, the current policy that is
    ///          associated with the stack will be used.</p>
    public let stackPolicyDuringUpdateBody: String?
    /// <p>Location of a file containing the temporary overriding stack policy. The URL must
    ///          point to a policy (max size: 16KB) located in an S3 bucket in
    ///          the same Region as the stack. You can specify either the
    ///             <code>StackPolicyDuringUpdateBody</code> or the <code>StackPolicyDuringUpdateURL</code>
    ///          parameter, but not both.</p>
    ///          <p>If you want to update protected resources, specify a temporary overriding stack
    ///          policy during this update. If you do not specify a stack policy, the current policy that is
    ///          associated with the stack will be used.</p>
    public let stackPolicyDuringUpdateURL: String?
    /// <p>Location of a file containing the updated stack policy. The URL must point to a
    ///          policy (max size: 16KB) located in an S3 bucket in the same
    ///          Region as the stack. You can specify either the <code>StackPolicyBody</code> or the
    ///             <code>StackPolicyURL</code> parameter, but not both.</p>
    ///          <p>You might update the stack policy, for example, in order to protect a new resource
    ///          that you created during a stack update. If you do not specify a stack policy, the current
    ///          policy that is associated with the stack is unchanged.</p>
    public let stackPolicyURL: String?
    /// <p>Key-value pairs to associate with this stack. AWS CloudFormation also propagates
    ///          these tags to supported resources in the stack. You can specify a maximum number of 50
    ///          tags.</p>
    ///          <p>If you don't specify this parameter, AWS CloudFormation doesn't modify the stack's
    ///          tags. If you specify an empty value, AWS CloudFormation removes all associated
    ///          tags.</p>
    public let tags: [Tag]?
    /// <p>Structure containing the template body with a minimum length of 1 byte and a maximum
    ///          length of 51,200 bytes. (For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html">Template Anatomy</a>
    ///          in the AWS CloudFormation User Guide.)</p>
    ///          <p>Conditional: You must specify only one of the following parameters:
    ///             <code>TemplateBody</code>, <code>TemplateURL</code>, or set the
    ///             <code>UsePreviousTemplate</code> to <code>true</code>.</p>
    public let templateBody: String?
    /// <p>Location of file containing the template body. The URL must point to a template that
    ///          is located in an Amazon S3 bucket or a Systems Manager document. For more information, go to
    ///             <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html">Template Anatomy</a>
    ///          in the AWS CloudFormation User Guide.</p>
    ///          <p>Conditional: You must specify only one of the following parameters:
    ///             <code>TemplateBody</code>, <code>TemplateURL</code>, or set the
    ///             <code>UsePreviousTemplate</code> to <code>true</code>.</p>
    public let templateURL: String?
    /// <p>Reuse the existing template that is associated with the stack that you are
    ///          updating.</p>
    ///          <p>Conditional: You must specify only one of the following parameters:
    ///             <code>TemplateBody</code>, <code>TemplateURL</code>, or set the
    ///             <code>UsePreviousTemplate</code> to <code>true</code>.</p>
    public let usePreviousTemplate: Bool?

    public init (
        capabilities: [Capability]? = nil,
        clientRequestToken: String? = nil,
        notificationARNs: [String]? = nil,
        parameters: [Parameter]? = nil,
        resourceTypes: [String]? = nil,
        roleARN: String? = nil,
        rollbackConfiguration: RollbackConfiguration? = nil,
        stackName: String? = nil,
        stackPolicyBody: String? = nil,
        stackPolicyDuringUpdateBody: String? = nil,
        stackPolicyDuringUpdateURL: String? = nil,
        stackPolicyURL: String? = nil,
        tags: [Tag]? = nil,
        templateBody: String? = nil,
        templateURL: String? = nil,
        usePreviousTemplate: Bool? = nil
    )
    {
        self.capabilities = capabilities
        self.clientRequestToken = clientRequestToken
        self.notificationARNs = notificationARNs
        self.parameters = parameters
        self.resourceTypes = resourceTypes
        self.roleARN = roleARN
        self.rollbackConfiguration = rollbackConfiguration
        self.stackName = stackName
        self.stackPolicyBody = stackPolicyBody
        self.stackPolicyDuringUpdateBody = stackPolicyDuringUpdateBody
        self.stackPolicyDuringUpdateURL = stackPolicyDuringUpdateURL
        self.stackPolicyURL = stackPolicyURL
        self.tags = tags
        self.templateBody = templateBody
        self.templateURL = templateURL
        self.usePreviousTemplate = usePreviousTemplate
    }
}

public struct UpdateStackInstancesInputBodyMiddleware: Middleware {
    public let id: String = "UpdateStackInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStackInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStackInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStackInstancesInput>
    public typealias MOutput = OperationOutput<UpdateStackInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStackInstancesOutputError>
}

extension UpdateStackInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStackInstancesInput(accounts: \(String(describing: accounts)), callAs: \(String(describing: callAs)), deploymentTargets: \(String(describing: deploymentTargets)), operationId: \(String(describing: operationId)), operationPreferences: \(String(describing: operationPreferences)), parameterOverrides: \(String(describing: parameterOverrides)), regions: \(String(describing: regions)), stackSetName: \(String(describing: stackSetName)))"}
}

extension UpdateStackInstancesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accounts = accounts {
            var accountsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Accounts"))
            for (index0, account0) in accounts.enumerated() {
                try accountsContainer.encode(account0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let callAs = callAs {
            try container.encode(callAs, forKey: Key("CallAs"))
        }
        if let deploymentTargets = deploymentTargets {
            try container.encode(deploymentTargets, forKey: Key("DeploymentTargets"))
        }
        if let operationId = operationId {
            try container.encode(operationId, forKey: Key("OperationId"))
        }
        if let operationPreferences = operationPreferences {
            try container.encode(operationPreferences, forKey: Key("OperationPreferences"))
        }
        if let parameterOverrides = parameterOverrides {
            var parameterOverridesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ParameterOverrides"))
            for (index0, parameter0) in parameterOverrides.enumerated() {
                try parameterOverridesContainer.encode(parameter0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let regions = regions {
            var regionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Regions"))
            for (index0, region0) in regions.enumerated() {
                try regionsContainer.encode(region0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        try container.encode("UpdateStackInstances", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct UpdateStackInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateStackInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStackInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStackInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStackInstancesInput>
    public typealias MOutput = OperationOutput<UpdateStackInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStackInstancesOutputError>
}

public struct UpdateStackInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateStackInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStackInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStackInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStackInstancesInput>
    public typealias MOutput = OperationOutput<UpdateStackInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStackInstancesOutputError>
}

public struct UpdateStackInstancesInput: Equatable {
    /// <p>[Self-managed permissions] The names of one or more AWS accounts for which you want to update parameter values
    ///          for stack instances. The overridden parameter values will be applied to all stack instances
    ///          in the specified accounts and Regions.</p>
    ///          <p>You can specify <code>Accounts</code> or <code>DeploymentTargets</code>, but not both.</p>
    public let accounts: [String]?
    /// <p>[Service-managed permissions] Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account.</p>
    ///          <p>By default, <code>SELF</code> is specified. Use <code>SELF</code> for stack sets with self-managed permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you are signed in to the management account, specify <code>SELF</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you are signed in to a delegated administrator account, specify <code>DELEGATED_ADMIN</code>.</p>
    ///                <p>Your AWS account must be registered as a delegated administrator in the management account. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-orgs-delegated-admin.html">Register a delegated administrator</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let callAs: CallAs?
    /// <p>[Service-managed permissions] The AWS Organizations accounts for which you want to update parameter values for stack instances. If your update targets OUs, the overridden parameter values only apply to the accounts that are currently in the target OUs and their child OUs. Accounts added to the target OUs and their child OUs in the future won't use the overridden values.</p>
    ///          <p>You can specify <code>Accounts</code> or <code>DeploymentTargets</code>, but not both.</p>
    public let deploymentTargets: DeploymentTargets?
    /// <p>The unique identifier for this stack set operation. </p>
    ///          <p>The operation ID also functions as an idempotency token, to ensure that AWS
    ///          CloudFormation performs the stack set operation only once, even if you retry the request
    ///          multiple times. You might retry stack set operation requests to ensure that AWS
    ///          CloudFormation successfully received them.</p>
    ///          <p>If you don't specify an operation ID, the SDK generates one automatically.
    ///       </p>
    public var operationId: String?
    /// <p>Preferences for how AWS CloudFormation performs this stack set operation.</p>
    public let operationPreferences: StackSetOperationPreferences?
    /// <p> A list of input parameters whose values you want to update for the specified stack
    ///          instances. </p>
    ///          <p>Any overridden parameter values will be applied to all stack instances in the
    ///          specified accounts and Regions. When specifying parameters and their values, be aware of
    ///          how AWS CloudFormation sets parameter values during stack instance update
    ///          operations:</p>
    ///          <ul>
    ///             <li>
    ///                <p>To override the current value for a parameter, include the parameter and
    ///                specify its value.</p>
    ///             </li>
    ///             <li>
    ///                <p>To leave a parameter set to its present value, you can do one of the
    ///                following:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>Do not include the parameter in the list.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Include the parameter and specify <code>UsePreviousValue</code> as
    ///                         <code>true</code>. (You cannot specify both a value and set
    ///                         <code>UsePreviousValue</code> to <code>true</code>.)</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>To set all overridden parameter back to the values specified in the stack set,
    ///                specify a parameter list but do not include any parameters.</p>
    ///             </li>
    ///             <li>
    ///                <p>To leave all parameters set to their present values, do not specify this
    ///                property at all.</p>
    ///             </li>
    ///          </ul>
    ///          <p>During stack set updates, any parameter values overridden for a stack instance are
    ///          not updated, but retain their overridden value.</p>
    ///          <p>You can only override the parameter <i>values</i> that are specified in
    ///          the stack set; to add or delete a parameter itself, use <code>UpdateStackSet</code> to
    ///          update the stack set template. If you add a parameter to a template, before you can
    ///          override the parameter value specified in the stack set you must first use <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_UpdateStackSet.html">UpdateStackSet</a> to update all stack instances with the updated template and
    ///          parameter value specified in the stack set. Once a stack instance has been updated with the
    ///          new parameter, you can then override the parameter value using
    ///             <code>UpdateStackInstances</code>.</p>
    public let parameterOverrides: [Parameter]?
    /// <p>The names of one or more Regions in which you want to update parameter values for
    ///          stack instances. The overridden parameter values will be applied to all stack instances in
    ///          the specified accounts and Regions.</p>
    public let regions: [String]?
    /// <p>The name or unique ID of the stack set associated with the stack instances.</p>
    public let stackSetName: String?

    public init (
        accounts: [String]? = nil,
        callAs: CallAs? = nil,
        deploymentTargets: DeploymentTargets? = nil,
        operationId: String? = nil,
        operationPreferences: StackSetOperationPreferences? = nil,
        parameterOverrides: [Parameter]? = nil,
        regions: [String]? = nil,
        stackSetName: String? = nil
    )
    {
        self.accounts = accounts
        self.callAs = callAs
        self.deploymentTargets = deploymentTargets
        self.operationId = operationId
        self.operationPreferences = operationPreferences
        self.parameterOverrides = parameterOverrides
        self.regions = regions
        self.stackSetName = stackSetName
    }
}

extension UpdateStackInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateStackInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationIdAlreadyExistsException" : self = .operationIdAlreadyExistsException(try OperationIdAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StackInstanceNotFoundException" : self = .stackInstanceNotFoundException(try StackInstanceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StackSetNotFoundException" : self = .stackSetNotFoundException(try StackSetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StaleRequestException" : self = .staleRequestException(try StaleRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStackInstancesOutputError: Equatable {
    case invalidOperationException(InvalidOperationException)
    case operationIdAlreadyExistsException(OperationIdAlreadyExistsException)
    case operationInProgressException(OperationInProgressException)
    case stackInstanceNotFoundException(StackInstanceNotFoundException)
    case stackSetNotFoundException(StackSetNotFoundException)
    case staleRequestException(StaleRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStackInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStackInstancesOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension UpdateStackInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateStackInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct UpdateStackInstancesOutputResponse: Equatable {
    /// <p>The unique identifier for this stack set operation. </p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdateStackInstancesOutputResponseBody: Equatable {
    public let operationId: String?
}

extension UpdateStackInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UpdateStackInstancesResult"))
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension UpdateStackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateStackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientCapabilitiesException" : self = .insufficientCapabilitiesException(try InsufficientCapabilitiesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TokenAlreadyExistsException" : self = .tokenAlreadyExistsException(try TokenAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStackOutputError: Equatable {
    case insufficientCapabilitiesException(InsufficientCapabilitiesException)
    case tokenAlreadyExistsException(TokenAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStackOutputResponse(stackId: \(String(describing: stackId)))"}
}

extension UpdateStackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateStackOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stackId = output.stackId
        } else {
            self.stackId = nil
        }
    }
}

/// <p>The output for an <a>UpdateStack</a> action.</p>
public struct UpdateStackOutputResponse: Equatable {
    /// <p>Unique identifier of the stack.</p>
    public let stackId: String?

    public init (
        stackId: String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct UpdateStackOutputResponseBody: Equatable {
    public let stackId: String?
}

extension UpdateStackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UpdateStackResult"))
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

public struct UpdateStackSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateStackSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStackSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStackSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStackSetInput>
    public typealias MOutput = OperationOutput<UpdateStackSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStackSetOutputError>
}

extension UpdateStackSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStackSetInput(accounts: \(String(describing: accounts)), administrationRoleARN: \(String(describing: administrationRoleARN)), autoDeployment: \(String(describing: autoDeployment)), callAs: \(String(describing: callAs)), capabilities: \(String(describing: capabilities)), deploymentTargets: \(String(describing: deploymentTargets)), description: \(String(describing: description)), executionRoleName: \(String(describing: executionRoleName)), operationId: \(String(describing: operationId)), operationPreferences: \(String(describing: operationPreferences)), parameters: \(String(describing: parameters)), permissionModel: \(String(describing: permissionModel)), regions: \(String(describing: regions)), stackSetName: \(String(describing: stackSetName)), tags: \(String(describing: tags)), templateBody: \(String(describing: templateBody)), templateURL: \(String(describing: templateURL)), usePreviousTemplate: \(String(describing: usePreviousTemplate)))"}
}

extension UpdateStackSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accounts = accounts {
            var accountsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Accounts"))
            for (index0, account0) in accounts.enumerated() {
                try accountsContainer.encode(account0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let administrationRoleARN = administrationRoleARN {
            try container.encode(administrationRoleARN, forKey: Key("AdministrationRoleARN"))
        }
        if let autoDeployment = autoDeployment {
            try container.encode(autoDeployment, forKey: Key("AutoDeployment"))
        }
        if let callAs = callAs {
            try container.encode(callAs, forKey: Key("CallAs"))
        }
        if let capabilities = capabilities {
            var capabilitiesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Capabilities"))
            for (index0, capability0) in capabilities.enumerated() {
                try capabilitiesContainer.encode(capability0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let deploymentTargets = deploymentTargets {
            try container.encode(deploymentTargets, forKey: Key("DeploymentTargets"))
        }
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let executionRoleName = executionRoleName {
            try container.encode(executionRoleName, forKey: Key("ExecutionRoleName"))
        }
        if let operationId = operationId {
            try container.encode(operationId, forKey: Key("OperationId"))
        }
        if let operationPreferences = operationPreferences {
            try container.encode(operationPreferences, forKey: Key("OperationPreferences"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let permissionModel = permissionModel {
            try container.encode(permissionModel, forKey: Key("PermissionModel"))
        }
        if let regions = regions {
            var regionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Regions"))
            for (index0, region0) in regions.enumerated() {
                try regionsContainer.encode(region0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let stackSetName = stackSetName {
            try container.encode(stackSetName, forKey: Key("StackSetName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let templateBody = templateBody {
            try container.encode(templateBody, forKey: Key("TemplateBody"))
        }
        if let templateURL = templateURL {
            try container.encode(templateURL, forKey: Key("TemplateURL"))
        }
        if let usePreviousTemplate = usePreviousTemplate {
            try container.encode(usePreviousTemplate, forKey: Key("UsePreviousTemplate"))
        }
        try container.encode("UpdateStackSet", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct UpdateStackSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateStackSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStackSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStackSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStackSetInput>
    public typealias MOutput = OperationOutput<UpdateStackSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStackSetOutputError>
}

public struct UpdateStackSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateStackSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStackSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStackSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStackSetInput>
    public typealias MOutput = OperationOutput<UpdateStackSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStackSetOutputError>
}

public struct UpdateStackSetInput: Equatable {
    /// <p>[Self-managed permissions] The accounts in which to update associated stack instances. If you specify accounts, you
    ///          must also specify the Regions in which to update stack set instances.</p>
    ///          <p>To update <i>all</i> the stack instances associated with this stack set,
    ///          do not specify the <code>Accounts</code> or <code>Regions</code> properties.</p>
    ///          <p>If the stack set update includes changes to the template (that is, if the
    ///             <code>TemplateBody</code> or <code>TemplateURL</code> properties are specified), or the
    ///             <code>Parameters</code> property, AWS CloudFormation marks all stack instances with a status of
    ///             <code>OUTDATED</code> prior to updating the stack instances in the specified accounts
    ///          and Regions. If the stack set update does not include changes to the template or
    ///          parameters, AWS CloudFormation updates the stack instances in the specified accounts and Regions, while
    ///          leaving all other stack instances with their existing stack instance status. </p>
    public let accounts: [String]?
    /// <p>The Amazon Resource Number (ARN) of the IAM role to use to update this stack set.</p>
    ///          <p>Specify an IAM role only if you are using customized administrator roles to control
    ///          which users or groups can manage specific stack sets within the same administrator account.
    ///          For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs.html">Granting
    ///             Permissions for Stack Set Operations</a> in the
    ///             <i>AWS CloudFormation User Guide</i>.</p>
    ///          <p>If you specified a customized administrator role when you created the stack set, you
    ///          must specify a customized administrator role, even if it is the same customized
    ///          administrator role used with this stack set previously.</p>
    public let administrationRoleARN: String?
    /// <p>[Service-managed permissions] Describes whether StackSets automatically deploys to AWS Organizations accounts that are added to a target organization or organizational unit (OU).</p>
    ///          <p>If you specify <code>AutoDeployment</code>, do not specify <code>DeploymentTargets</code> or <code>Regions</code>.</p>
    public let autoDeployment: AutoDeployment?
    /// <p>[Service-managed permissions] Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account.</p>
    ///          <p>By default, <code>SELF</code> is specified. Use <code>SELF</code> for stack sets with self-managed permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you are signed in to the management account, specify <code>SELF</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you are signed in to a delegated administrator account, specify <code>DELEGATED_ADMIN</code>.</p>
    ///                <p>Your AWS account must be registered as a delegated administrator in the management account. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-orgs-delegated-admin.html">Register a delegated administrator</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    ///             </li>
    ///          </ul>
    public let callAs: CallAs?
    /// <p>In some cases, you must explicitly acknowledge that your stack template contains certain
    ///          capabilities in order for AWS CloudFormation to update the stack set and its associated stack
    ///          instances.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CAPABILITY_IAM</code> and <code>CAPABILITY_NAMED_IAM</code>
    ///                </p>
    ///                <p>Some stack templates might include resources that can affect permissions in
    ///                your AWS account; for example, by creating new AWS Identity and Access Management
    ///                (IAM) users. For those stacks sets, you must explicitly acknowledge this by
    ///                specifying one of these capabilities.</p>
    ///                <p>The following IAM resources require you to specify either the
    ///                   <code>CAPABILITY_IAM</code> or <code>CAPABILITY_NAMED_IAM</code>
    ///                capability.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>If you have IAM resources, you can specify either capability. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If you have IAM resources with custom names, you <i>must</i>
    ///                      specify <code>CAPABILITY_NAMED_IAM</code>. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If you don't specify either of these capabilities, AWS CloudFormation returns an
    ///                         <code>InsufficientCapabilities</code> error.</p>
    ///                   </li>
    ///                </ul>
    ///                <p>If your stack template contains these resources, we recommend that you review
    ///                all permissions associated with them and edit their permissions if
    ///                necessary.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-accesskey.html">
    ///                         AWS::IAM::AccessKey</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html">
    ///                         AWS::IAM::Group</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html"> AWS::IAM::InstanceProfile</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-policy.html">
    ///                         AWS::IAM::Policy</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html">
    ///                         AWS::IAM::Role</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-user.html">
    ///                         AWS::IAM::User</a>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-addusertogroup.html"> AWS::IAM::UserToGroupAddition</a>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///                <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#capabilities">Acknowledging IAM
    ///                   Resources in AWS CloudFormation Templates</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CAPABILITY_AUTO_EXPAND</code>
    ///                </p>
    ///                <p>Some templates reference macros. If your stack set template references one or more macros,
    ///                you must update the stack set directly from the processed template, without first
    ///                reviewing the resulting changes in a change set. To update the stack set directly, you must acknowledge this
    ///                capability. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-macros.html">Using AWS CloudFormation Macros to Perform Custom Processing on
    ///                   Templates</a>.</p>
    ///                <important>
    ///                   <p>Stack sets with service-managed permissions
    ///                   do not currently support the use of macros in templates. (This includes
    ///                   the <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/create-reusable-transform-function-snippets-and-add-to-your-template-with-aws-include-transform.html">AWS::Include</a> and <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/transform-aws-serverless.html">AWS::Serverless</a>
    ///                   transforms, which are macros hosted by AWS CloudFormation.) Even if you specify this
    ///                   capability for a stack set with service-managed permissions, if you reference a macro in your template the stack set operation will
    ///                   fail.</p>
    ///                </important>
    ///             </li>
    ///          </ul>
    public let capabilities: [Capability]?
    /// <p>[Service-managed permissions] The AWS Organizations accounts in which to update associated stack instances.</p>
    ///          <p>To update all the stack instances associated with this stack set, do not specify <code>DeploymentTargets</code> or <code>Regions</code>.</p>
    ///          <p>If the stack set update includes changes to the template (that is, if <code>TemplateBody</code> or <code>TemplateURL</code> is specified), or the <code>Parameters</code>, AWS CloudFormation marks all stack instances with a status of <code>OUTDATED</code> prior to updating the stack instances in the specified accounts and Regions. If the stack set update does not include changes to the template or parameters, AWS CloudFormation updates the stack instances in the specified accounts and Regions, while leaving all other stack instances with their existing stack instance status.</p>
    public let deploymentTargets: DeploymentTargets?
    /// <p>A brief description of updates that you are making.</p>
    public let description: String?
    /// <p>The name of the IAM execution role to use to update the stack set. If you do not specify
    ///          an execution role, AWS CloudFormation uses the <code>AWSCloudFormationStackSetExecutionRole</code> role
    ///          for the stack set operation.</p>
    ///          <p>Specify an IAM role only if you are using customized execution roles to control which
    ///          stack resources users and groups can include in their stack sets.
    ///       </p>
    ///          <p> If you specify a customized execution role, AWS CloudFormation uses that role to update the stack.
    ///          If you do not specify a customized execution role, AWS CloudFormation performs the update using the role
    ///          previously associated with the stack set, so long as you have permissions to perform
    ///          operations on the stack set.</p>
    public let executionRoleName: String?
    /// <p>The unique ID for this stack set operation. </p>
    ///          <p>The operation ID also functions as an idempotency token, to ensure that AWS
    ///          CloudFormation performs the stack set operation only once, even if you retry the request
    ///          multiple times. You might retry stack set operation requests to ensure that AWS
    ///          CloudFormation successfully received them.</p>
    ///          <p>If you don't specify an operation ID, AWS CloudFormation generates one
    ///          automatically.</p>
    ///          <p>Repeating this stack set operation with a new operation ID retries all stack
    ///          instances whose status is <code>OUTDATED</code>. </p>
    public var operationId: String?
    /// <p>Preferences for how AWS CloudFormation performs this stack set operation.</p>
    public let operationPreferences: StackSetOperationPreferences?
    /// <p>A list of input parameters for the stack set template. </p>
    public let parameters: [Parameter]?
    /// <p>Describes how the IAM roles required for stack set operations are created. You cannot modify <code>PermissionModel</code> if there are stack instances associated with your stack set.</p>
    ///          <ul>
    ///             <li>
    ///                <p>With <code>self-managed</code> permissions, you must create the administrator and execution roles required to deploy to target accounts. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-self-managed.html">Grant Self-Managed Stack Set Permissions</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>With <code>service-managed</code> permissions, StackSets automatically creates the IAM roles required to deploy to accounts managed by AWS Organizations. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-service-managed.html">Grant Service-Managed Stack Set Permissions</a>.</p>
    ///             </li>
    ///          </ul>
    public let permissionModel: PermissionModels?
    /// <p>The Regions in which to update associated stack instances. If you specify Regions, you
    ///          must also specify accounts in which to update stack set instances.</p>
    ///          <p>To update <i>all</i> the stack instances associated with this stack set,
    ///          do not specify the <code>Accounts</code> or <code>Regions</code> properties.</p>
    ///          <p>If the stack set update includes changes to the template (that is, if the
    ///             <code>TemplateBody</code> or <code>TemplateURL</code> properties are specified), or the
    ///             <code>Parameters</code> property, AWS CloudFormation marks all stack instances with a status of
    ///             <code>OUTDATED</code> prior to updating the stack instances in the specified accounts
    ///          and Regions. If the stack set update does not include changes to the template or
    ///          parameters, AWS CloudFormation updates the stack instances in the specified accounts and Regions, while
    ///          leaving all other stack instances with their existing stack instance status. </p>
    public let regions: [String]?
    /// <p>The name or unique ID of the stack set that you want to update.</p>
    public let stackSetName: String?
    /// <p>The key-value pairs to associate with this stack set and the stacks created from it.
    ///          AWS CloudFormation also propagates these tags to supported resources that are created in
    ///          the stacks. You can specify a maximum number of 50 tags.</p>
    ///          <p>If you specify tags for this parameter, those tags replace any list of tags that are
    ///          currently associated with this stack set. This means:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If you don't specify this parameter, AWS CloudFormation doesn't modify the
    ///                stack's tags. </p>
    ///             </li>
    ///             <li>
    ///                <p>If you specify <i>any</i> tags using this parameter, you must
    ///                specify <i>all</i> the tags that you want associated with this stack
    ///                set, even tags you've specifed before (for example, when creating the stack set or
    ///                during a previous update of the stack set.). Any tags that you don't include in the
    ///                updated list of tags are removed from the stack set, and therefore from the stacks
    ///                and resources as well. </p>
    ///             </li>
    ///             <li>
    ///                <p>If you specify an empty value, AWS CloudFormation removes all currently
    ///                associated tags.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you specify new tags as part of an <code>UpdateStackSet</code> action, AWS
    ///          CloudFormation checks to see if you have the required IAM permission to tag resources. If
    ///          you omit tags that are currently associated with the stack set from the list of tags you
    ///          specify, AWS CloudFormation assumes that you want to remove those tags from the stack set,
    ///          and checks to see if you have permission to untag resources. If you don't have the
    ///          necessary permission(s), the entire <code>UpdateStackSet</code> action fails with an
    ///             <code>access denied</code> error, and the stack set is not updated.</p>
    public let tags: [Tag]?
    /// <p>The structure that contains the template body, with a minimum length of 1 byte and a
    ///          maximum length of 51,200 bytes. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html">Template Anatomy</a>
    ///          in the AWS CloudFormation User Guide.</p>
    ///          <p>Conditional: You must specify only one of the following parameters:
    ///             <code>TemplateBody</code> or <code>TemplateURL</code>—or set
    ///             <code>UsePreviousTemplate</code> to true.</p>
    public let templateBody: String?
    /// <p>The location of the file that contains the template body. The URL must point to a
    ///          template (maximum size: 460,800 bytes) that is located in an Amazon S3 bucket or a Systems
    ///          Manager document. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html">Template Anatomy</a>
    ///          in the AWS CloudFormation User Guide.</p>
    ///          <p>Conditional: You must specify only one of the following parameters:
    ///             <code>TemplateBody</code> or <code>TemplateURL</code>—or set
    ///             <code>UsePreviousTemplate</code> to true. </p>
    public let templateURL: String?
    /// <p>Use the existing template that's associated with the stack set that you're
    ///          updating.</p>
    ///          <p>Conditional: You must specify only one of the following parameters:
    ///             <code>TemplateBody</code> or <code>TemplateURL</code>—or set
    ///             <code>UsePreviousTemplate</code> to true. </p>
    public let usePreviousTemplate: Bool?

    public init (
        accounts: [String]? = nil,
        administrationRoleARN: String? = nil,
        autoDeployment: AutoDeployment? = nil,
        callAs: CallAs? = nil,
        capabilities: [Capability]? = nil,
        deploymentTargets: DeploymentTargets? = nil,
        description: String? = nil,
        executionRoleName: String? = nil,
        operationId: String? = nil,
        operationPreferences: StackSetOperationPreferences? = nil,
        parameters: [Parameter]? = nil,
        permissionModel: PermissionModels? = nil,
        regions: [String]? = nil,
        stackSetName: String? = nil,
        tags: [Tag]? = nil,
        templateBody: String? = nil,
        templateURL: String? = nil,
        usePreviousTemplate: Bool? = nil
    )
    {
        self.accounts = accounts
        self.administrationRoleARN = administrationRoleARN
        self.autoDeployment = autoDeployment
        self.callAs = callAs
        self.capabilities = capabilities
        self.deploymentTargets = deploymentTargets
        self.description = description
        self.executionRoleName = executionRoleName
        self.operationId = operationId
        self.operationPreferences = operationPreferences
        self.parameters = parameters
        self.permissionModel = permissionModel
        self.regions = regions
        self.stackSetName = stackSetName
        self.tags = tags
        self.templateBody = templateBody
        self.templateURL = templateURL
        self.usePreviousTemplate = usePreviousTemplate
    }
}

extension UpdateStackSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateStackSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationIdAlreadyExistsException" : self = .operationIdAlreadyExistsException(try OperationIdAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StackInstanceNotFoundException" : self = .stackInstanceNotFoundException(try StackInstanceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StackSetNotFoundException" : self = .stackSetNotFoundException(try StackSetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StaleRequestException" : self = .staleRequestException(try StaleRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStackSetOutputError: Equatable {
    case invalidOperationException(InvalidOperationException)
    case operationIdAlreadyExistsException(OperationIdAlreadyExistsException)
    case operationInProgressException(OperationInProgressException)
    case stackInstanceNotFoundException(StackInstanceNotFoundException)
    case stackSetNotFoundException(StackSetNotFoundException)
    case staleRequestException(StaleRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStackSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStackSetOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension UpdateStackSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateStackSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct UpdateStackSetOutputResponse: Equatable {
    /// <p>The unique ID for this stack set operation.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdateStackSetOutputResponseBody: Equatable {
    public let operationId: String?
}

extension UpdateStackSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UpdateStackSetResult"))
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct UpdateTerminationProtectionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTerminationProtectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTerminationProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTerminationProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTerminationProtectionInput>
    public typealias MOutput = OperationOutput<UpdateTerminationProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTerminationProtectionOutputError>
}

extension UpdateTerminationProtectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTerminationProtectionInput(enableTerminationProtection: \(String(describing: enableTerminationProtection)), stackName: \(String(describing: stackName)))"}
}

extension UpdateTerminationProtectionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let enableTerminationProtection = enableTerminationProtection {
            try container.encode(enableTerminationProtection, forKey: Key("EnableTerminationProtection"))
        }
        if let stackName = stackName {
            try container.encode(stackName, forKey: Key("StackName"))
        }
        try container.encode("UpdateTerminationProtection", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct UpdateTerminationProtectionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTerminationProtectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTerminationProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTerminationProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTerminationProtectionInput>
    public typealias MOutput = OperationOutput<UpdateTerminationProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTerminationProtectionOutputError>
}

public struct UpdateTerminationProtectionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTerminationProtectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTerminationProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTerminationProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTerminationProtectionInput>
    public typealias MOutput = OperationOutput<UpdateTerminationProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTerminationProtectionOutputError>
}

public struct UpdateTerminationProtectionInput: Equatable {
    /// <p>Whether to enable termination protection on the specified stack.</p>
    public let enableTerminationProtection: Bool?
    /// <p>The name or unique ID of the stack for which you want to set termination
    ///          protection.</p>
    public let stackName: String?

    public init (
        enableTerminationProtection: Bool? = nil,
        stackName: String? = nil
    )
    {
        self.enableTerminationProtection = enableTerminationProtection
        self.stackName = stackName
    }
}

extension UpdateTerminationProtectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateTerminationProtectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTerminationProtectionOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTerminationProtectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTerminationProtectionOutputResponse(stackId: \(String(describing: stackId)))"}
}

extension UpdateTerminationProtectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateTerminationProtectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stackId = output.stackId
        } else {
            self.stackId = nil
        }
    }
}

public struct UpdateTerminationProtectionOutputResponse: Equatable {
    /// <p>The unique ID of the stack.</p>
    public let stackId: String?

    public init (
        stackId: String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct UpdateTerminationProtectionOutputResponseBody: Equatable {
    public let stackId: String?
}

extension UpdateTerminationProtectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("UpdateTerminationProtectionResult"))
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

public struct ValidateTemplateInputBodyMiddleware: Middleware {
    public let id: String = "ValidateTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateTemplateInput>
    public typealias MOutput = OperationOutput<ValidateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateTemplateOutputError>
}

extension ValidateTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidateTemplateInput(templateBody: \(String(describing: templateBody)), templateURL: \(String(describing: templateURL)))"}
}

extension ValidateTemplateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let templateBody = templateBody {
            try container.encode(templateBody, forKey: Key("TemplateBody"))
        }
        if let templateURL = templateURL {
            try container.encode(templateURL, forKey: Key("TemplateURL"))
        }
        try container.encode("ValidateTemplate", forKey:Key("Action"))
        try container.encode("2010-05-15", forKey:Key("Version"))
    }
}

public struct ValidateTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "ValidateTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateTemplateInput>
    public typealias MOutput = OperationOutput<ValidateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateTemplateOutputError>
}

public struct ValidateTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "ValidateTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateTemplateInput>
    public typealias MOutput = OperationOutput<ValidateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateTemplateOutputError>
}

/// <p>The input for <a>ValidateTemplate</a> action.</p>
public struct ValidateTemplateInput: Equatable {
    /// <p>Structure containing the template body with a minimum length of 1 byte and a maximum
    ///          length of 51,200 bytes. For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html">Template Anatomy</a>
    ///          in the AWS CloudFormation User Guide.</p>
    ///          <p>Conditional: You must pass <code>TemplateURL</code> or <code>TemplateBody</code>. If
    ///          both are passed, only <code>TemplateBody</code> is used.</p>
    public let templateBody: String?
    /// <p>Location of file containing the template body. The URL must point to a template (max
    ///          size: 460,800 bytes) that is located in an Amazon S3 bucket or a Systems Manager document.
    ///          For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html">Template Anatomy</a>
    ///          in the AWS CloudFormation User Guide.</p>
    ///          <p>Conditional: You must pass <code>TemplateURL</code> or <code>TemplateBody</code>. If
    ///          both are passed, only <code>TemplateBody</code> is used.</p>
    public let templateURL: String?

    public init (
        templateBody: String? = nil,
        templateURL: String? = nil
    )
    {
        self.templateBody = templateBody
        self.templateURL = templateURL
    }
}

extension ValidateTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ValidateTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ValidateTemplateOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidateTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidateTemplateOutputResponse(capabilities: \(String(describing: capabilities)), capabilitiesReason: \(String(describing: capabilitiesReason)), declaredTransforms: \(String(describing: declaredTransforms)), description: \(String(describing: description)), parameters: \(String(describing: parameters)))"}
}

extension ValidateTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidateTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.capabilities = output.capabilities
            self.capabilitiesReason = output.capabilitiesReason
            self.declaredTransforms = output.declaredTransforms
            self.description = output.description
            self.parameters = output.parameters
        } else {
            self.capabilities = nil
            self.capabilitiesReason = nil
            self.declaredTransforms = nil
            self.description = nil
            self.parameters = nil
        }
    }
}

/// <p>The output for <a>ValidateTemplate</a> action.</p>
public struct ValidateTemplateOutputResponse: Equatable {
    /// <p>The capabilities found within the template. If your template contains IAM resources,
    ///          you must specify the CAPABILITY_IAM or CAPABILITY_NAMED_IAM value for this parameter when
    ///          you use the <a>CreateStack</a> or <a>UpdateStack</a> actions with
    ///          your template; otherwise, those actions return an InsufficientCapabilities error.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#capabilities">Acknowledging IAM Resources in AWS CloudFormation Templates</a>.</p>
    public let capabilities: [Capability]?
    /// <p>The list of resources that generated the values in the <code>Capabilities</code>
    ///          response element.</p>
    public let capabilitiesReason: String?
    /// <p>A list of the transforms that are declared in the template.</p>
    public let declaredTransforms: [String]?
    /// <p>The description found within the template.</p>
    public let description: String?
    /// <p>A list of <code>TemplateParameter</code> structures.</p>
    public let parameters: [TemplateParameter]?

    public init (
        capabilities: [Capability]? = nil,
        capabilitiesReason: String? = nil,
        declaredTransforms: [String]? = nil,
        description: String? = nil,
        parameters: [TemplateParameter]? = nil
    )
    {
        self.capabilities = capabilities
        self.capabilitiesReason = capabilitiesReason
        self.declaredTransforms = declaredTransforms
        self.description = description
        self.parameters = parameters
    }
}

struct ValidateTemplateOutputResponseBody: Equatable {
    public let parameters: [TemplateParameter]?
    public let description: String?
    public let capabilities: [Capability]?
    public let capabilitiesReason: String?
    public let declaredTransforms: [String]?
}

extension ValidateTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case capabilities = "Capabilities"
        case capabilitiesReason = "CapabilitiesReason"
        case declaredTransforms = "DeclaredTransforms"
        case description = "Description"
        case parameters = "Parameters"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ValidateTemplateResult"))
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct member{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([TemplateParameter].self, forKey: .member)
                var parametersBuffer:[TemplateParameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [TemplateParameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        if containerValues.contains(.capabilities) {
            struct KeyVal0{struct member{}}
            let capabilitiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .capabilities)
            if let capabilitiesWrappedContainer = capabilitiesWrappedContainer {
                let capabilitiesContainer = try capabilitiesWrappedContainer.decodeIfPresent([Capability].self, forKey: .member)
                var capabilitiesBuffer:[Capability]? = nil
                if let capabilitiesContainer = capabilitiesContainer {
                    capabilitiesBuffer = [Capability]()
                    for stringContainer0 in capabilitiesContainer {
                        capabilitiesBuffer?.append(stringContainer0)
                    }
                }
                capabilities = capabilitiesBuffer
            } else {
                capabilities = []
            }
        } else {
            capabilities = nil
        }
        let capabilitiesReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .capabilitiesReason)
        capabilitiesReason = capabilitiesReasonDecoded
        if containerValues.contains(.declaredTransforms) {
            struct KeyVal0{struct member{}}
            let declaredTransformsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .declaredTransforms)
            if let declaredTransformsWrappedContainer = declaredTransformsWrappedContainer {
                let declaredTransformsContainer = try declaredTransformsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var declaredTransformsBuffer:[String]? = nil
                if let declaredTransformsContainer = declaredTransformsContainer {
                    declaredTransformsBuffer = [String]()
                    for stringContainer0 in declaredTransformsContainer {
                        declaredTransformsBuffer?.append(stringContainer0)
                    }
                }
                declaredTransforms = declaredTransformsBuffer
            } else {
                declaredTransforms = []
            }
        } else {
            declaredTransforms = nil
        }
    }
}

public enum Visibility {
    case `private`
    case `public`
    case sdkUnknown(String)
}

extension Visibility : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Visibility] {
        return [
            .private,
            .public,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .private: return "PRIVATE"
        case .public: return "PUBLIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Visibility(rawValue: rawValue) ?? Visibility.sdkUnknown(rawValue)
    }
}
